{"mappings":"AwJ2qBA,SAAS,EAAyB,CAAC,EAAK,EAAsD,EAC1F,MAAO,CAAG,EAAA,EAAO,CAAA,EAAA,AApBrB,SAAS,EAAY,CAAwB,SACrC,AAAA,MAAM,OAAQ,CAAA,GAEP,MADsB,EAAM,GAAI,CAAA,GAAa,IAAA,CAAK,UACC,MACnD,AAAiB,UAAjB,OAAO,EACP,CAAA,EAAG,EAAK,CAAA,CAAA,CAER,mBACH,OACI,AAAS,MAAT,GAAiB,AAAiC,OAAjC,OAAO,cAAA,CAAe,GAGjC,CAAE,GAAI,CAAiB,AAHqB,EAI5C,GAItB,EAGiC,GAAM,CAAA,AACvC,CGnmBa,IwB9CT,EACA,EhB6DQiT,EmD5EAnB,EnNGApD,ECAAC,EIOAQ,EMDAoC,ECoFAC,EAwBAC,E4IzDC,EAAN,cAAgF,MAO1E,MAA8E,IAAK,CAAA,KAAA,AAPH,AAWhF,CAAA,OAJmF,AAK5F,aACO,GAAA,CAAC,EAAM,EAGZ,CAAA,CACM,IAAA,EACA,CACA,CAAA,GACO,OAAA,OAAA,CAAQ,OAAO,yBAAA,CAA0B,IAAyB,OAAA,CAAQ,CAAC,CAAC,EAAM,EAAgB,IAEjG,AAAS,UAAT,EACe,EAAA,CAAE,MAAO,EAAW,KAAM,AAAA,GAErC,AAAY,KAAA,IAAZ,GACA,CAAA,EAAU,CAAA,CAAA,EAEP,OAAA,cAAA,CAAe,EAAS,EAAM,GACzC,GAIR,KAAA,CADgB,ADpBjB,SACH,CAAA,CACA,EAAmC,CAAA,CAC7B,EAGC,CACH,IAAI,EAAwB,CAAA,cAAA,EAAiB,EAAI,8DAAA,EAAiE,EAAI,CAAA,CAStH,OARI,OAAO,IAAA,CAAK,GAAS,MAAQ,EAMJ,CAAA,GAAA,CAAA,EAAA,EF6kBgD,KADtD,OAAO,OAAQ,CE5kBgB,GF4kBP,GAAI,CAAA,GAA0B,IAAA,CAAK,ME5kBpB,CAAA,CAAA,AAAA,EAEvD,CAAA,EAAG,EAAqB,EAAA,CAAA,AAAA,CAEvC,ECEwC,EAAM,GACvB,GACf,IAAA,CAAK,OAAW,CAAA,AAAY,KAAA,IAAZ,EAAwB,CAAA,EAAK,EAC7C,IAAA,CAAK,OAAA,CAAQ,MAAS,CAAA,EAGtB,IAAA,CAAK,IAAO,CAAA,aAAA,CAEpB,EjBuXO,SAAS,EACZ,CACc,EACd,OAAO,OAAO,MAAO,CAAA,CACjB,GAAG,CAAA,CACH,OAAQ,AAAS,IACb,IAAM,EAAQ,IAAI,WApGnB,cAoGoD,EApG3B,AAoG2B,EApGnB,SAAY,CAAA,AAoGO,EApGC,gBAAA,CAoGR,IAErC,OADC,EAAA,KAAA,CAAM,EAAO,EAAO,GACrB,CAAA,CACX,EAER,CA4FO,SAAS,EACZ,CACY,EACZ,OAAO,OAAO,MAAO,CAAA,CACjB,GAAG,CAAA,CACH,OAAQ,CAAC,EAAO,EAAS,CAAA,GAAM,EAAQ,IAAK,CAAA,EAAO,EAAM,CAAE,EADxD,AACyD,EAEpE,CAoLO,SAAS,EAAY,CAAqF,EAC7G,MAAO,cAAe,GAAS,AAA2B,UAA3B,OAAO,EAAM,SAAc,AAC9D,CyBnrBY,IAAA,GACRwB,CADQA,EAAA,GAAA,CAAA,EACR,CAAA,EAAA,MAAA,CAAA,EAAA,CAAA,SACAA,CAAA,CAAA,EAAA,GAAA,CAAA,EAAA,CAAA,MAFQA,GwBwEZ,SAAS,EACL,CAAA,CACA,CACqD,EAC/C,GAAA,CAAC,EAAc,EAAa,CAAA,EAAM,KAAM,CAAA,AAAI,OAAO,CAAA,IAAA,EAAO,EAAa,IAAA,CAAM,GAC5E,MAAA,CAAC,EAAc,EAAS,AACnC,CAEA,SAAS,EAAmB,CAAA,CAAe/N,CAA0B,EAC3D,IAAA,EAAO,OAAOA,EAAS,MAAM,EAC/B,EAAM,CAAA,AAAA,CAAA,CACV,IAAA,IAAW,KAAQ,EACR,GAAA,EACP,GAAO,OAAOA,EAAS,OAAQ,CAAA,IAE5B,OAAA,CACX,CGhLA,IAAMA,EAAW,6DX6BjB,SAAS,IAEE,OADH,AAAC,GAAuB,CAAA,EQCrB,AAAA,EAAc,CACjB,iBAAkB,AAAC,IACT,GAAA,CAAC,EAAe,EAAS,CAAI,EAAuB,EAAOA,AGZvBA,CHYuBA,CAAS,EAAE,EACxE,GAAA,CAAC,EAAW,OAAO,EAAM,MAAA,CAEvB,IAAA,EAAe,EAAmB,EGfEA,GHgBnC,OAAA,EAAc,MAAA,CAAS,KAAK,IAAA,CAAK,EAAa,QAAS,CAAA,IAAI,MAAA,CAAS,EAAC,EAEhF,MAAM,CAAe,CAAA,CAAA,CAAO,CAAQ,EAG5B,IADJ,ADrBL,SAA+BA,CAAAA,CAAkB,CAAmB,CAAA,EAAa,CAAW,EAC3F,GAAA,CAAC,EAAU,KAAM,CAAA,AAAI,OAAO,CAAKA,EAAAA,EAAAA,EAAa,GAAA,CAAA,GACxC,MAAA,IAAI,EnCiQ2C,QmCjQgB,CACjE,SAAAA,EACA,KAAMA,EAAS,MAAA,CACf,MAAO,CAAA,EAGnB,EIPsDA,EHoBV,GAC5B,AAAU,KAAV,EAAqB,OAAA,EAGnB,GAAA,CAAC,EAAe,EAAS,CAAI,EAAuB,EAAOA,AGxBvBA,CHwBuBA,CAAS,EAAE,EAC5E,GAAI,CAAC,EAED,OADM,EAAA,GAAA,CAAI,IAAI,WAAW,EAAc,MAAM,EAAE,IAAA,CAAK,GAAI,GACjD,EAAS,EAAc,MAAA,CAI9B,IAAA,EAAe,EAAmB,EG/BIA,GHkCpC,EAAsB,EAAC,CAC7B,KAAO,EAAe,CAAI,AAAJ,CAAI,EACtB,EAAU,OAAQ,CAAA,OAAO,EAAe,GAAI,AAAJ,CAAI,GAC5B,GAAA,GAAA,AAAA,CAAA,CAGd,IAAA,EAAa,IAAI,MAAM,EAAc,MAAM,EAAE,IAAK,CAAA,MAAO,EAAS,CAExE,OADM,EAAA,GAAA,CAAI,EAAY,GACf,EAAS,EAAW,MAAA,AAAA,CAC/B,ERlCA,EACG,CACX,CAmHO,SAAS,EAA0C,CAA8C,EA5CpG,GAEI,AA2CY,EA3CI,MAAS,CAAA,IAEzB,AAyCY,EAzCI,MAAS,CAAA,GAEnB,MAAA,IAAI,E5B1CiD,Q4B0CgB,CACvE,aAAc,AAsCN,EAtCsB,MADyC,AACzC,GAMtC,IAAM,EAAW,AADH,AADQ,IACM,MAAA,CAiCZ,GAhCO,UAAA,CACvB,GAAI,AAAa,KAAb,EACM,MAAA,IAAI,E5BpD0C,K4BoDgB,CAChE,aAAc,CAAA,GA8Bf,OAAA,CACX,CAoBO,SAAS,QnC7HZ,EKUA,GLVA,EmC8HuC,InC3HhC,EAAc,CACjB,UmC0H+D,GnCzH/D,MAAO,CAAC,EAAc,EAAmB,KAI/B,IAAA,EAAoB,EAAQ,MAAA,CAAO,GACnC,EACF,EAAkB,MAAS,CmCmH4B,GnCnHf,EAAkB,KAAM,CAAA,EmCmHT,InCnH0B,EAErF,OADM,EAAA,GAAA,CAAI,EAAgB,GACnB,EmCiHoD,EnCjH3C,CACpB,IKHJ,E8BmHwE,AAAA,GACpE,EAAQ,G9BlHZ,OAAO,EAAc,CACjB,GAAI,AX4yBD,CAAC,EW5yBe,GACb,CAAE,GAAG,CAAS,CAAA,iBAAkB,AAAC,GAAoB,EAAQ,gBAAiB,CAAA,EAAM,GAAM,EAC1F,CAAA,CACN,MAAO,CAAC,EAAiB,EAAO,IAAW,EAAQ,KAAA,CAAM,EAAM,GAAQ,EAAO,EAAM,E8BgH5F,CClJA,SAAS,EAAI,CAAmB,EAC5B,IAAM,EAAI,EALJ,kEAAA,AAAA,CAAA,CAMC,OAAA,GAAK,CAAK,AAAL,CAAK,CAAA,EAAI,AANf,kEAAA,AAAA,CAAA,CAMmB,CAC7B,CACA,SAAS,EAAK,CAAA,CAAW,CAAuB,EAE5C,IAAI,EAAI,EACR,KAAO,KAAU,CAAI,AAAJ,CAAI,EACZ,GAAA,EACA,GAbH,kEAAA,AAAA,CAAA,CAeC,OAAA,CACX,CGoDA,IAAM,EAAmB,CAErB,GAAI,IAAK,IAAK,IAAK,IAAK,GAAI,IAAK,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IACpG,CAEA,eAAe,EAA4B,CAAA,eAAE,CAAgB,CAAA,MAAA,CAAA,CAAuD,MAQ5G,Ee/Fe,GAAA,CAAC,WAAW,eAAiB,CACtC,MAAA,IAAIyN,E/C8EyD,O+C/CnE,GAAA,AAA6B,KAAA,IAAtB,WAAW,MAAW,EAAe,AAA4C,YAA5C,OAAO,WAAW,MAAA,CAAO,MAAQ,EAAA,OACvE,MAAA,IAAIA,E/C+C+C,SgCSzD,GAAA,EAAM,MAAA,CARI,GASJ,MAAA,IAAIA,EhC5BuD,QgC4BgB,CAC7E,OAAQ,EAAM,MAAA,CACd,SAXM,EAWI,GAIlB,IAAM,EAAY,EAAM,MAAA,CAAO,CAAC,EAAK,EAAM,KACjC,IAAA,EAAQ,AAAgB,UAAhB,OAAO,EAAqB,AAAA,CAAA,IAAgB,IAAI,WAAA,EAAe,MAAO,CAAA,GAAQ,EACxF,GAAA,EAAM,UAAA,CAlBM,GAmBN,MAAA,IAAIA,EhCpC+C,QgCoCoB,CACzE,OAAQ,EAAM,UAAA,CACd,MAAO,EACP,cAtBQ,EAsBO,GAIhB,OADH,EAAA,IAAA,IAAQ,GACL,CAAA,EACR,EAAc,EACX,EAA4B,AJsF/B,enC/GH,ELQA,EwCwGoB,IxCvGpB,GwCnEI,AAAC,GAAuB,CAAA,EQuDrB,AAAA,EAAc,CACjB,KAAK,CAAA,CAAU,CAA0B,EACrC,IAAM,EAAQ,AAAW,IAAX,EAAe,EAAW,EAAS,KAAA,CAAM,GACvD,GAAI,AAAiB,IAAjB,EAAM,MAAW,CAAU,MAAA,CAAC,GAAI,EAAC,CAGrC,IAAI,EAAa,EAAM,SAAU,CAAA,AAAA,GAAK,AAAM,IAAN,GACzB,EAAA,AAAe,KAAf,EAAoB,EAAM,MAAS,CAAA,EAChD,IAAM,EAAgBzN,AGzDoBA,CHyDpBA,CAAS,EAAC,CAAE,MAAA,CAAO,UACzC,AAAI,IAAe,EAAM,MAAA,CAAe,CAAC,EAAe,EAAS,MAAM,CAAA,CAQhE,CAAC,EAFU,AAyE9B,SAA4B,CAAA,CAAeA,CAA0B,EAC3D,IAAA,EAAO,OAAOA,EAAS,MAAM,EAC7B,EAAY,EAAC,CACnB,KAAO,EAAQ,CAAI,AAAJ,CAAI,EACf,EAAU,OAAA,CAAQA,CAAS,CAAA,OAAO,EAAQ,GAAM,EACvC,GAAA,EAEN,OAAA,EAAU,IAAA,CAAK,GAC1B,EApFiC,EAAM,KAAM,CAAA,GAAY,MAAO,CAAA,CAAC,EAAK,IAAS,AAAM,GAAA,AAAA,CAAA,CAAN,EAAa,OAAO,GAAO,CAAE,AAAF,CAAE,EG7DtDA,GHkEP,EAAS,MAAM,CAAA,AAAA,CACtD,ERzEA,EnC0DJ,EmCzDO,EnC4DA,EAAc,CACjB,UmCkG8C,GnCjG9C,KAAM,CAAC,EAAO,SPCG,EAAwC,GOAf,AHzC3C,SACH,CAAA,CACA,CACA,CAAA,CAAA,CACA,EAAS,CACX,EACQ,IAAA,EAAc,EAAM,MAAS,CAAA,EACnC,GAAI,EsCkI8C,GtCjIxC,MAAA,IAAIyN,EU0MuC,QV1MgB,CAC7D,YAAA,EACA,iBAAA,EACA,SAAA,CAAA,EAGZ,EG2BkD,emCgGI,GnChGwB,EAAO,GAErE,CAAA,EAAS,GAAK,EAAM,MAAA,CmC8FkB,EnC9FT,GAC7B,CAAA,EAAQ,EAAM,KAAA,CAAM,EAAQ,EmC6FU,GnC9F1C,EAII,EAAY,KPNH,EOOQ,EPPgC,EOOzB,EAAQ,SAAS,CAAjC,EPNpB,AAxCG,SAAkB,CAAA,CAA2B,CAAoC,EAChF,GAAA,EAAM,MAAU,EAAA,EAAe,OAAA,EACnC,IAAM,EAAc,IAAI,WAAW,GAAQ,IAAA,CAAK,GAEzC,OADP,EAAY,GAAA,CAAI,GACT,CACX,EAmCa,EAAM,MAAA,EAAU,EAAS,EAAQ,EAAM,KAAA,CAAM,EAAG,GAAS,IOS1D,GAAM,CAAC,EAAK,CAAI,EAAQ,IAAA,CAAK,EAAO,GAC7B,MAAA,CAAC,EAAO,EmCqF2B,GnCrFR,AAAA,CACtC,ILPJ,GAAI,EAAY,KAAa,EAAY,GAC/B,MAAA,IAAIA,EYsK+D,SZnKzE,GAAA,EAAY,IAAY,EAAY,IAAY,EAAQ,SAAc,GAAA,EAAQ,SAAW,CACnF,MAAA,IAAIA,EYmKuD,QZnKgB,CAC7E,iBAAkB,EAAQ,SAAA,CAC1B,iBAAkB,EAAQ,SADA,AACA,GAI9B,GAAA,CAAC,EAAY,IAAY,CAAC,EAAY,IAAY,EAAQ,OAAY,GAAA,EAAQ,OAAS,CACjF,MAAA,IAAIA,EY6JqD,QZ7JgB,CAC3E,eAAgB,EAAQ,OAAA,CACxB,eAAgB,EAAQ,OADA,AACA,GAIzB,MAAA,CACH,GAAG,CAAA,CACH,GAAG,CAAA,CACH,OAAQ,EAAQ,MAAA,CAChB,OAAQ,EAAQ,MAAA,CAChB,KAAM,EAAQ,IAAA,CACd,MAAO,EAAQ,KADD,AACC,CwC8EvB,IIvFU,EAAsB,EAA0B,MAAA,CAAO,GACvD,EAAqB,MAAM,OAAO,MAAO,CAAA,MAAA,CAC3C,UACA,IAAI,WAAW,IAAI,KAAc,KAAwB,EAAiB,GAExE,EAAe,IAAI,WAAW,GAChC,GF3GA,AAAqB,KAArB,AE2G+B,EF3GzB,UAAA,EAIH,ADwDJ,SAAwB,CAAA,CAAW,CAA2B,EAC3D,IAAA,EAAK,EAAI,EAAI,GAGb,EAAI,AAzBd,SAAiB,CAAA,CAAW,CAA0B,EAElD,IAAM,EAAK,EAAI,EAAI,EAAI,GAEjB,EAAM,AApBhB,SAAqB,CAAmB,EAG9B,IAAA,EAAM,AADA,EAAI,EAnBV,kEAAA,AAAA,CAAA,CAoBW,EApBX,kEAAA,AAAA,CAAA,CAqBA,EAAM,EAAK,EAAI,CAAE,AAAF,CAAE,EAAI,EArBrB,kEAAA,AAAA,CAAA,CAsBA,EAAM,EAAK,EAAI,CAAE,AAAF,CAAE,EAAI,EAtBrB,kEAAA,AAAA,CAAA,CAuBA,EAAO,EAAK,EAAI,CAAE,AAAF,CAAE,EAAI,EAvBtB,kEAAA,AAAA,CAAA,CAwBA,EAAO,EAAK,EAAK,EAAG,AAAH,CAAG,EAAI,EAxBxB,kEAAA,AAAA,CAAA,CAyBA,EAAO,EAAK,EAAK,EAAG,AAAH,CAAG,EAAI,EAzBxB,kEAAA,AAAA,CAAA,CA0BA,EAAO,EAAK,EAAK,EAAG,AAAH,CAAG,EAAI,EA1BxB,kEAAA,AAAA,CAAA,CA2BA,EAAQ,EAAK,EAAK,EAAG,AAAH,CAAG,EAAI,EA3BzB,kEAAA,AAAA,CAAA,CA4BA,EAAQ,EAAK,EAAM,EAAG,AAAH,CAAG,EAAI,EA5B1B,kEAAA,AAAA,CAAA,CA6BA,EAAQ,EAAK,EAAM,EAAG,AAAH,CAAG,EAAI,EA7B1B,kEAAA,AAAA,CAAA,CA+BC,OADY,EAAK,EAAM,CAAE,AAAF,CAAE,EAAI,EA9B9B,kEAAA,AAAA,CAAA,AAgCV,EAK4B,EADb,EAAI,EAAK,EAAK,IAErB,EAAI,EAAI,EAAI,EAAK,GACf,EAAM,EAAI,EAAI,EAAI,GAClB,EAAQ,EACR,EAAQ,EAAI,AAxCV,kEAAA,AAAA,CAAA,CAwCU,GACZ,EAAW,IAAQ,EACnB,EAAW,IAAQ,EAAI,CAAC,GACxB,EAAS,IAAQ,EAAI,CAAA,CAAA,AA3CnB,kEAAA,AAAA,CAAA,CA2CoB,CAA5B,SAII,CAHA,GAAc,CAAA,EAAA,CAAlB,EACI,CAAA,GAAY,CAAA,GAAY,CAAA,EAAA,CAAxB,EACC,AAAA,CAAA,AAAS,CAAA,AAAA,CAAA,CAAT,EAAI,EAAK,IAAQ,CAAA,AAAA,CAAA,EAAQ,CAAA,EAAA,EAAI,CAAC,EAA9B,EACD,AAAC,GAAa,GAGX,EAFI,IAGf,EAIc,EAAI,EAAK,CAAE,AAAF,CAAE,EACX,EAAI,AA1DR,kEAAA,AAAA,CAAA,CA0DY,EAAK,CAAE,AAAF,CAAE,UAEzB,AAAU,OAAN,GAIA,CAAA,AAAM,CAAA,AAAA,CAAA,GAAN,GADE,AAAiB,CAAA,AAAW,IAAX,CAAW,GAAU,CAC5B,CAIpB,ECtEc,AAVd,SAA8B,CAAmC,EAC7D,IAAM,EAAY,EAAM,MAAA,CAAO,CAAC,EAAK,EAAM,IAAO,CAAG,EAAA,AAVzD,SAAmB,CAAsB,EAC/B,IAAA,EAAY,EAAK,QAAA,CAAS,WAC5B,AAAA,AAAqB,IAArB,EAAU,MAAA,CACH,CAAA,CAAA,EAAI,EAAS,CAAA,CAEb,CAEf,EAGmE,AAAO,KAAP,EAAY,AAAO,KAAP,EAAe,GAAQ,EAAA,EAAG,CAAA,CAAI,IAEzG,OAAO,OADsB,CAAA,EAAA,EAAK,EAAS,CAAA,CAE/C,EE8GuC,GFvGV,AEuGU,CFvGJ,CAAA,GAAG,EEwGxB,MAAA,IAAIA,EhCpDmD,SgCsD1D,OAAA,EAA0B,MAAA,CAAO,EAC5C,CAwBA,eAAsB,EAAyB,CAAA,eAC3C,CAAA,CAAA,MACA,CADA,CAE2D,EAC3D,IAAI,EAAW,IACf,KAAO,EAAW,GACV,GAAA,CAKO,MAAA,CAJS,MAAM,EAA4B,CAC9C,eAAA,EACA,MAAO,IAAI,EAAO,IAAI,WAAW,CAAC,EAAS,EAD3C,AAC4C,GAE/B,EAAqC,AAAA,CAAA,MACjD,EAAG,K5BxHhB,E4ByHY,G5BjHZ,AADsB,CAPtB,E4ByH0B,a5BlHS,OAAS,AAAW,gBAAX,EAAE,IAAS,CAGvC,AJmBiD,UInBjD,EAA8B,OAAA,CAAQ,MAAW,CAI1D,E4B8GW,MAAA,CAFN,CAAA,GAGJ,CAGF,MAAA,IAAIA,EhClG8D,QgCmG5E,C+BlKY,IAAA,GAERb,CAFQA,EAAA,GAAA,CAAA,EAER,CAAA,EAAA,eAAA,CAA0B,EAA1B,CAAA,kBACAA,CAAA,CAAA,EAAA,eAAA,CAA0B,EAA1B,CAAA,kBACAA,CAAA,CAAA,EAAA,QAAA,CAA0B,EAA1B,CAAA,WACAA,CAAA,CAAA,EAAA,QAAA,CAA0B,EAA1B,CAAA,WALQA,GoBXR,OAAO,MAAA,CAAO,CAAE,KAAM,SAAA,G0BmDb,OAAO,0BjQrCR,IAAA,GACVpD,CADUA,EAAA,GAAA,CAAA,EACV,CAAA,EAAA,aAAA,CAAA,EAAA,CAAA,gBACAA,CAAA,CAAA,EAAA,WAAA,CAAA,EAAA,CAAA,cACAA,CAAA,CAAA,EAAA,MAAA,CAAA,EAAA,CAAA,SAHUA,GCAA,GACVC,CADUA,EAAA,GAAA,CAAA,EACV,CAAA,EAAA,UAAA,CAAA,EAAA,CAAA,aACAA,CAAA,CAAA,EAAA,aAAA,CAAA,EAAA,CAAA,gBACAA,CAAA,CAAA,EAAA,YAAA,CAAA,EAAA,CAAA,eACAA,CAAA,CAAA,EAAA,YAAA,CAAA,EAAA,CAAA,eACAA,CAAA,CAAA,EAAA,iBAAA,CAAA,EAAA,CAAA,oBACAA,CAAA,CAAA,EAAA,gBAAA,CAAA,EAAA,CAAA,mBACAA,CAAA,CAAA,EAAA,SAAA,CAAA,EAAA,CAAA,YACAA,CAAA,CAAA,EAAA,YAAA,CAAA,EAAA,CAAA,eACAA,CAAA,CAAA,EAAA,iBAAA,CAAA,EAAA,CAAA,oBACAA,CAAA,CAAA,EAAA,wBAAA,CAAA,EAAA,CAAA,2BACAA,CAAA,CAAA,EAAA,qBAAA,CAAA,GAAA,CAAA,wBACAA,CAAA,CAAA,EAAA,6BAAA,CAAA,GAAA,CAAA,gCACAA,CAAA,CAAA,EAAA,eAAA,CAAA,GAAA,CAAA,kBACAA,CAAA,CAAA,EAAA,YAAA,CAAA,GAAA,CAAA,eACAA,CAAA,CAAA,EAAA,kBAAA,CAAA,GAAA,CAAA,qBACAA,CAAA,CAAA,EAAA,cAAA,CAAA,GAAA,CAAA,iBACAA,CAAA,CAAA,EAAA,KAAA,CAAA,GAAA,CAAA,QAjBUA,GIOA,GACVQ,CADUA,EAAA,GAAA,CAAA,EACV,CAAA,EAAA,aAAA,CAAA,EAAA,CAAA,gBACAA,CAAA,CAAA,EAAA,iBAAA,CAAA,EAAA,CAAA,oBACAA,CAAA,CAAA,EAAA,iBAAA,CAAA,EAAA,CAAA,oBACAA,CAAA,CAAA,EAAA,kBAAA,CAAA,EAAA,CAAA,qBACAA,CAAA,CAAA,EAAA,wBAAA,CAAA,EAAA,CAAA,2BACAA,CAAA,CAAA,EAAA,2BAAA,CAAA,EAAA,CAAA,8BACAA,CAAA,CAAA,EAAA,mBAAA,CAAA,EAAA,CAAA,sBACAA,CAAA,CAAA,EAAA,cAAA,CAAA,EAAA,CAAA,iBACAA,CAAA,CAAA,EAAA,YAAA,CAAA,EAAA,CAAA,eACAA,CAAA,CAAA,EAAA,eAAA,CAAA,EAAA,CAAA,kBACAA,CAAA,CAAA,EAAA,qBAAA,CAAA,GAAA,CAAA,wBACAA,CAAA,CAAA,EAAA,QAAA,CAAA,GAAA,CAAA,WACAA,CAAA,CAAA,EAAA,iBAAA,CAAA,GAAA,CAAA,oBACAA,CAAA,CAAA,EAAA,sBAAA,CAAA,GAAA,CAAA,yBACAA,CAAA,CAAA,EAAA,YAAA,CAAA,GAAA,CAAA,eACAA,CAAA,CAAA,EAAA,mBAAA,CAAA,GAAA,CAAA,sBACAA,CAAA,CAAA,EAAA,uBAAA,CAAA,GAAA,CAAA,0BACAA,CAAA,CAAA,EAAA,6BAAA,CAAA,GAAA,CAAA,gCACAA,CAAA,CAAA,EAAA,oBAAA,CAAA,GAAA,CAAA,uBACAA,CAAA,CAAA,EAAA,cAAA,CAAA,GAAA,CAAA,iBACAA,CAAA,CAAA,EAAA,eAAA,CAAA,GAAA,CAAA,kBACAA,CAAA,CAAA,EAAA,eAAA,CAAA,GAAA,CAAA,kBACAA,CAAA,CAAA,EAAA,aAAA,CAAA,GAAA,CAAA,gBACAA,CAAA,CAAA,EAAA,YAAA,CAAA,GAAA,CAAA,eACAA,CAAA,CAAA,EAAA,UAAA,CAAA,GAAA,CAAA,aACAA,CAAA,CAAA,EAAA,kBAAA,CAAA,GAAA,CAAA,qBACAA,CAAA,CAAA,EAAA,gBAAA,CAAA,GAAA,CAAA,mBA3BUA,GMDA,GACVoC,CADUA,EAAA,GAAA,CAAA,EACV,CAAA,EAAA,qBAAA,CAAA,EAAA,CAAA,wBACAA,CAAA,CAAA,EAAA,+BAAA,CAAA,EAAA,CAAA,kCACAA,CAAA,CAAA,EAAA,4BAAA,CAAA,EAAA,CAAA,+BAHUA,GCoFA,GACVC,CADUA,EAAA,GAAA,CAAA,EACV,CAAA,EAAA,IAAA,CAAA,EAAA,CAAA,OACAA,CAAA,CAAA,EAAA,KAAA,CAAA,EAAA,CAAA,QACAA,CAAA,CAAA,EAAA,QAAA,CAAA,EAAA,CAAA,WAHUA,GAwBA,GACVC,CADUA,EAAA,GAAA,CAAA,EACV,CAAA,EAAA,cAAA,CAAA,EAAA,CAAA,iBACAA,CAAA,CAAA,EAAA,iBAAA,CAAA,EAAA,CAAA,oBACAA,CAAA,CAAA,EAAA,kBAAA,CAAA,EAAA,CAAA,qBACAA,CAAA,CAAA,EAAA,QAAA,CAAA,EAAA,CAAA,WACAA,CAAA,CAAA,EAAA,OAAA,CAAA,EAAA,CAAA,UACAA,CAAA,CAAA,EAAA,MAAA,CAAA,EAAA,CAAA,SACAA,CAAA,CAAA,EAAA,YAAA,CAAA,EAAA,CAAA,eACAA,CAAA,CAAA,EAAA,MAAA,CAAA,EAAA,CAAA,SACAA,CAAA,CAAA,EAAA,IAAA,CAAA,EAAA,CAAA,OACAA,CAAA,CAAA,EAAA,YAAA,CAAA,EAAA,CAAA,eACAA,CAAA,CAAA,EAAA,aAAA,CAAA,GAAA,CAAA,gBACAA,CAAA,CAAA,EAAA,WAAA,CAAA,GAAA,CAAA,cACAA,CAAA,CAAA,EAAA,eAAA,CAAA,GAAA,CAAA,kBACAA,CAAA,CAAA,EAAA,cAAA,CAAA,GAAA,CAAA,iBACAA,CAAA,CAAA,EAAA,aAAA,CAAA,GAAA,CAAA,gBACAA,CAAA,CAAA,EAAA,WAAA,CAAA,GAAA,CAAA,cACAA,CAAA,CAAA,EAAA,kBAAA,CAAA,GAAA,CAAA,qBACAA,CAAA,CAAA,EAAA,UAAA,CAAA,GAAA,CAAA,aACAA,CAAA,CAAA,EAAA,kBAAA,CAAA,GAAA,CAAA,qBACAA,CAAA,CAAA,EAAA,mBAAA,CAAA,GAAA,CAAA,sBACAA,CAAA,CAAA,EAAA,eAAA,CAAA,GAAA,CAAA,kBACAA,CAAA,CAAA,EAAA,kBAAA,CAAA,GAAA,CAAA,qBACAA,CAAA,CAAA,EAAA,wBAAA,CAAA,GAAA,CAAA,2BACAA,CAAA,CAAA,EAAA,gBAAA,CAAA,GAAA,CAAA,mBACAA,CAAA,CAAA,EAAA,gBAAA,CAAA,GAAA,CAAA,mBACAA,CAAA,CAAA,EAAA,4BAAA,CAAA,GAAA,CAAA,+BACAA,CAAA,CAAA,EAAA,2BAAA,CAAA,GAAA,CAAA,8BACAA,CAAA,CAAA,EAAA,sBAAA,CAAA,GAAA,CAAA,yBACAA,CAAA,CAAA,EAAA,8BAAA,CAAA,GAAA,CAAA,iCACAA,CAAA,CAAA,EAAA,kCAAA,CAAA,GAAA,CAAA,qCACAA,CAAA,CAAA,EAAA,2BAAA,CAAA,GAAA,CAAA,8BACAA,CAAA,CAAA,EAAA,cAAA,CAAA,GAAA,CAAA,iBACAA,CAAA,CAAA,EAAA,kCAAA,CAAA,GAAA,CAAA,qCACAA,CAAA,CAAA,EAAA,8BAAA,CAAA,GAAA,CAAA,iCACAA,CAAA,CAAA,EAAA,oCAAA,CAAA,GAAA,CAAA,uCACAA,CAAA,CAAA,EAAA,kCAAA,CAAA,GAAA,CAAA,qCACAA,CAAA,CAAA,EAAA,gCAAA,CAAA,GAAA,CAAA,mCACAA,CAAA,CAAA,EAAA,mBAAA,CAAA,GAAA,CAAA,sBACAA,CAAA,CAAA,EAAA,oBAAA,CAAA,GAAA,CAAA,uBACAA,CAAA,CAAA,EAAA,oBAAA,CAAA,GAAA,CAAA,uBACAA,CAAA,CAAA,EAAA,+BAAA,CAAA,GAAA,CAAA,kCACAA,CAAA,CAAA,EAAA,yBAAA,CAAA,GAAA,CAAA,4BACAA,CAAA,CAAA,EAAA,0BAAA,CAAA,GAAA,CAAA,6BACAA,CAAA,CAAA,EAAA,4BAAA,CAAA,GAAA,CAAA,+BACAA,CAAA,CAAA,EAAA,6BAAA,CAAA,GAAA,CAAA,gCACAA,CAAA,CAAA,EAAA,2BAAA,CAAA,GAAA,CAAA,8BACAA,CAAA,CAAA,EAAA,6BAAA,CAAA,GAAA,CAAA,gCACAA,CAAA,CAAA,EAAA,yBAAA,CAAA,GAAA,CAAA,4BACAA,CAAA,CAAA,EAAA,UAAA,CAAA,GAAA,CAAA,aACAA,CAAA,CAAA,EAAA,mBAAA,CAAA,GAAA,CAAA,sBACAA,CAAA,CAAA,EAAA,oBAAA,CAAA,GAAA,CAAA,uBACAA,CAAA,CAAA,EAAA,gBAAA,CAAA,GAAA,CAAA,mBACAA,CAAA,CAAA,EAAA,6BAAA,CAAA,GAAA,CAAA,gCACAA,CAAA,CAAA,EAAA,6BAAA,CAAA,GAAA,CAAA,gCACAA,CAAA,CAAA,EAAA,6BAAA,CAAA,GAAA,CAAA,gCACAA,CAAA,CAAA,EAAA,cAAA,CAAA,GAAA,CAAA,iBACAA,CAAA,CAAA,EAAA,eAAA,CAAA,GAAA,CAAA,kBACAA,CAAA,CAAA,EAAA,2BAAA,CAAA,GAAA,CAAA,8BACAA,CAAA,CAAA,EAAA,sBAAA,CAAA,GAAA,CAAA,yBACAA,CAAA,CAAA,EAAA,kBAAA,CAAA,GAAA,CAAA,qBACAA,CAAA,CAAA,EAAA,iCAAA,CAAA,GAAA,CAAA,oCACAA,CAAA,CAAA,EAAA,wDAAA,CAAA,GAAA,CAAA,2DACAA,CAAA,CAAA,EAAA,4DAAA,CAAA,GAAA,CAAA,+DACAA,CAAA,CAAA,EAAA,qDAAA,CAAA,GAAA,CAAA,wDACAA,CAAA,CAAA,EAAA,mBAAA,CAAA,GAAA,CAAA,sBACAA,CAAA,CAAA,EAAA,oBAAA,CAAA,GAAA,CAAA,uBACAA,CAAA,CAAA,EAAA,sBAAA,CAAA,GAAA,CAAA,yBACAA,CAAA,CAAA,EAAA,yBAAA,CAAA,GAAA,CAAA,4BACAA,CAAA,CAAA,EAAA,qBAAA,CAAA,GAAA,CAAA,wBACAA,CAAA,CAAA,EAAA,sBAAA,CAAA,GAAA,CAAA,yBACAA,CAAA,CAAA,EAAA,kBAAA,CAAA,GAAA,CAAA,qBACAA,CAAA,CAAA,EAAA,4BAAA,CAAA,GAAA,CAAA,+BACAA,CAAA,CAAA,EAAA,wBAAA,CAAA,GAAA,CAAA,2BACAA,CAAA,CAAA,EAAA,4BAAA,CAAA,GAAA,CAAA,+BACAA,CAAA,CAAA,EAAA,4BAAA,CAAA,GAAA,CAAA,+BACAA,CAAA,CAAA,EAAA,wBAAA,CAAA,GAAA,CAAA,2BACAA,CAAA,CAAA,EAAA,KAAA,CAAA,GAAA,CAAA,QACAA,CAAA,CAAA,EAAA,MAAA,CAAA,GAAA,CAAA,SACAA,CAAA,CAAA,EAAA,uBAAA,CAAA,GAAA,CAAA,0BACAA,CAAA,CAAA,EAAA,wBAAA,CAAA,GAAA,CAAA,2BACAA,CAAA,CAAA,EAAA,sBAAA,CAAA,GAAA,CAAA,yBACAA,CAAA,CAAA,EAAA,kCAAA,CAAA,GAAA,CAAA,qCACAA,CAAA,CAAA,EAAA,iBAAA,CAAA,GAAA,CAAA,oBACAA,CAAA,CAAA,EAAA,oBAAA,CAAA,GAAA,CAAA,uBACAA,CAAA,CAAA,EAAA,uBAAA,CAAA,GAAA,CAAA,0BACAA,CAAA,CAAA,EAAA,+BAAA,CAAA,GAAA,CAAA,kCACAA,CAAA,CAAA,EAAA,0BAAA,CAAA,GAAA,CAAA,6BAvFUA,GiB3GZ,eAAsB,EACpB,CAAA,CACA,EAAmD,CAAA,CACnB,EAC1B,GAAA,CAAA,eACJ,EAAiB,8CAAA,CACf,CAAA,EACJ,OAAO,MAAM,AAAA,EAAyB,CACpC,eAAA,EACA,MAAO,CACLpB,AAAAA,IAAoB,MAAO,CAAA,EAAM,KAAK,EACtCA,AAAAA,IAAoB,MAAO,CAAA,EAAM,YAAY,EAC7CA,AAAAA,IAAoB,MAAO,CAAA,EAAM,IAAI,EAAA,AACvC,EAEJ,CSHiD,IAAI,WAAW,CAC9D,IAAK,IAAK,IAAK,IAAK,GAAI,GAAI,IAAK,GAClC,E+BGmD,IAAI,WAAW,CACjE,IAAK,IAAK,IAAK,GAAI,GAAI,GAAI,EAAG,EAC/B,ECV0D,IAAI,WAAW,CACxE,IAAK,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IACnC,ECIsD,IAAI,WAAW,CACpE,IAAK,IAAK,GAAI,IAAK,GAAI,IAAK,GAAI,IACjC,EQDsD,IAAI,WAAW,CACpE,IAAK,GAAI,GAAI,GAAI,GAAI,IAAK,GAAI,IAC/B,EkBRwD,IAAI,WAAW,CACtE,IAAK,GAAI,IAAK,IAAK,IAAK,GAAI,GAAI,IACjC,ECEgE,IAAI,WACnE,CAAC,IAAK,IAAK,GAAI,EAAG,IAAK,IAAK,IAAK,IADkC,ECMZ,IAAI,WAAW,CACtE,IAAK,IAAK,GAAI,GAAI,IAAK,IAAK,IAAK,IAClC,ECPC,IAAI,WAAW,CAAC,IAAK,IAAK,IAAK,IAAK,GAAI,IAAK,GAAI,IAAI,EtGjCvD,SAAS,gBAAgB,CAAC,mBAAoB,KAC5C,IAAM,EAAoB,SAAS,cAAc,CAC/C,gBAEI,EAAc,SAAS,cAAc,CAAC,UACtC,EAAa,SAAS,cAAc,CAAC,WACrC,EAAW,SAAS,cAAc,CAAC,SACnC,EAAc,SAAS,cAAc,CAAC,YACtC,EAAkB,SAAS,cAAc,CAC7C,gBAEI,EAAY,SAAS,aAAa,CAAC,cAEzC,QAAQ,GAAG,CAAC,yBAGZ,IAAM,EAAgB,UACpB,IAAM,EAAe,EAAkB,KAAK,CAAC,IAAI,GAC3C,EAAS,EAAY,KAAK,CAAC,IAAI,GAOrC,GAJA,EAAW,KAAK,CAAC,OAAO,CAAG,OAC3B,EAAS,KAAK,CAAC,OAAO,CAAG,OAGrB,AAAC,GAAiB,EAItB,GAAI,CAEF,EAAU,SAAS,CAAC,GAAG,CAAC,WAGxB,IAAM,EAAS,MAAM,EAAc,EAAc,EAG7C,CAAA,EAAO,sBAAsB,EAAE,SAAW,YAC5C,EAAY,WAAW,CAAG,EAAO,sBAAsB,CAAC,KAAK,CAAC,EAAE,CAEhE,EAAY,WAAW,CAAG,CAAC,OAAO,EAAE,EAAO,sBAAsB,EAAE,OAAO,CAAC,CAGzE,EAAO,0BAA0B,EAAE,SAAW,YAChD,EAAgB,WAAW,CACzB,EAAO,0BAA0B,CAAC,KAAK,CAAC,EAAE,CAE5C,EAAgB,WAAW,CAAG,CAAC,OAAO,EAAE,EAAO,0BAA0B,EAAE,OAAO,CAAC,CAGrF,EAAW,KAAK,CAAC,OAAO,CAAG,QAE3B,QAAQ,GAAG,CAAC,WAAY,EAC1B,CAAE,MAAO,EAAO,CAEd,EAAS,WAAW,CAAG,CAAC,OAAO,EAC7B,aAAiB,MAAQ,EAAM,OAAO,CAAG,OAAO,GACjD,CAAC,CACF,EAAS,KAAK,CAAC,OAAO,CAAG,QACzB,QAAQ,KAAK,CAAC,wBAAyB,EACzC,QAAU,CAER,EAAU,SAAS,CAAC,MAAM,CAAC,UAC7B,CACF,EAGA,EAAkB,gBAAgB,CAAC,QAAS,GAC5C,EAAY,gBAAgB,CAAC,QAAS,EACxC,GAEA,MAAM,EAAgB,MAAO,EAAsB,KACjD,GAAI,CACF,GAAM,CAAC,EAAwB,EAA2B,CACxD,MAAM,QAAQ,UAAU,CAAC,CACvB,AAAA,EAAuB,CACrB,KAAM,AAAA,EAAQ,GACd,MAAO,AAAA,EAAQ,GACf,aAAc,AAAA,EAAQ,EACxB,GACA,AAAA,EAAuB,CACrB,KAAM,AAAA,EAAQ,GACd,MAAO,AAAA,EAAQ,GACf,aAAc,AAAA,EAAQ,EACxB,GAMD,EACH,MAAO,CAAE,uBAAA,EAAwB,2BAAA,CAA2B,CAC9D,CAAE,MAAO,EAAO,CAEd,OADA,QAAQ,KAAK,CAAC,wBAAyB,GAChC,CAAE,uBAAwB,KAAM,2BAA4B,IAAK,CAC1E,CACF,EAGM,EAAmB,8CAGnB,EAAwB","sources":["<anon>","src/index.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/dist/src/index.mjs","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/types/accountState.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/types/authorityType.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/types/decryptableBalance.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/types/encryptedBalance.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/types/extension.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/types/extensionType.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/types/tokenMetadataField.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/types/transferFee.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/accounts/mint.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/accounts/multisig.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/accounts/token.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/programs/associatedToken.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/programs/token2022.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/errors/associatedToken.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/errors/token2022.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/shared/index.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/amountToUiAmount.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/applyConfidentialPendingBalance.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/approve.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/approveChecked.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/approveConfidentialTransferAccount.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/burn.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/burnChecked.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/closeAccount.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/confidentialDeposit.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/confidentialTransfer.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/confidentialTransferWithFee.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/confidentialWithdraw.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/configureConfidentialTransferAccount.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/pdas/associatedToken.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/createAssociatedToken.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/createAssociatedTokenIdempotent.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/createNativeMint.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/disableConfidentialCredits.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/disableCpiGuard.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/disableHarvestToMint.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/disableMemoTransfers.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/disableNonConfidentialCredits.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/emitTokenMetadata.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/emptyConfidentialTransferAccount.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/enableConfidentialCredits.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/enableCpiGuard.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/enableHarvestToMint.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/enableMemoTransfers.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/enableNonConfidentialCredits.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/freezeAccount.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/getAccountDataSize.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/harvestWithheldTokensToMint.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/harvestWithheldTokensToMintForConfidentialTransferFee.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializeAccount.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializeAccount2.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializeAccount3.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializeConfidentialTransferFee.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializeConfidentialTransferMint.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializeDefaultAccountState.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializeGroupMemberPointer.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializeGroupPointer.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializeImmutableOwner.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializeInterestBearingMint.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializeMetadataPointer.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializeMint.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializeMint2.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializeMintCloseAuthority.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializeMultisig.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializeMultisig2.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializeNonTransferableMint.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializePausableConfig.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializePermanentDelegate.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializeScaledUiAmountMint.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializeTokenGroup.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializeTokenGroupMember.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializeTokenMetadata.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializeTransferFeeConfig.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/initializeTransferHook.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/mintTo.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/mintToChecked.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/pause.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/reallocate.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/recoverNestedAssociatedToken.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/removeTokenMetadataKey.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/resume.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/revoke.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/setAuthority.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/setTransferFee.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/syncNative.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/thawAccount.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/transfer.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/transferChecked.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/transferCheckedWithFee.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/uiAmountToAmount.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/updateConfidentialTransferMint.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/updateDefaultAccountState.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/updateGroupMemberPointer.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/updateGroupPointer.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/updateMetadataPointer.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/updateMultiplierScaledUiMint.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/updateRateInterestBearingMint.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/updateTokenGroupMaxSize.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/updateTokenGroupUpdateAuthority.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/updateTokenMetadataField.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/updateTokenMetadataUpdateAuthority.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/updateTransferHook.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/withdrawExcessLamports.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/withdrawWithheldTokensFromAccounts.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/withdrawWithheldTokensFromAccountsForConfidentialTransferFee.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/withdrawWithheldTokensFromMint.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/generated/instructions/withdrawWithheldTokensFromMintForConfidentialTransferFee.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/amountToUiAmount.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/getInitializeInstructionsForExtensions.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/getTokenSize.ts","node_modules/.pnpm/@solana-program+token-2022@0.6.0_@solana+kit@4.0.0_@solana+sysvars@4.0.0/node_modules/@solana-program/token-2022/src/getMintSize.ts","node_modules/.pnpm/@solana+codecs-data-structures@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-data-structures/dist/index.browser.mjs","node_modules/.pnpm/@solana+codecs-data-structures@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-data-structures/src/assertions.ts","node_modules/.pnpm/@solana+codecs-data-structures@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-data-structures/src/utils.ts","node_modules/.pnpm/@solana+codecs-data-structures@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-data-structures/src/array.ts","node_modules/.pnpm/@solana+codecs-data-structures@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-data-structures/src/bit-array.ts","node_modules/.pnpm/@solana+codecs-data-structures@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-data-structures/src/boolean.ts","node_modules/.pnpm/@solana+codecs-data-structures@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-data-structures/src/bytes.ts","node_modules/.pnpm/@solana+codecs-data-structures@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-strings/src/base16.ts","node_modules/.pnpm/@solana+codecs-data-structures@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-data-structures/src/constant.ts","node_modules/.pnpm/@solana+codecs-data-structures@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-data-structures/src/tuple.ts","node_modules/.pnpm/@solana+codecs-data-structures@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-data-structures/src/union.ts","node_modules/.pnpm/@solana+codecs-data-structures@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-data-structures/src/discriminated-union.ts","node_modules/.pnpm/@solana+codecs-data-structures@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-data-structures/src/enum-helpers.ts","node_modules/.pnpm/@solana+codecs-data-structures@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-data-structures/src/enum.ts","node_modules/.pnpm/@solana+codecs-data-structures@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-data-structures/src/hidden-prefix.ts","node_modules/.pnpm/@solana+codecs-data-structures@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-data-structures/src/hidden-suffix.ts","node_modules/.pnpm/@solana+codecs-data-structures@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-data-structures/src/literal-union.ts","node_modules/.pnpm/@solana+codecs-data-structures@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-data-structures/src/map.ts","node_modules/.pnpm/@solana+codecs-data-structures@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-data-structures/src/unit.ts","node_modules/.pnpm/@solana+codecs-data-structures@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-data-structures/src/nullable.ts","node_modules/.pnpm/@solana+codecs-data-structures@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-data-structures/src/set.ts","node_modules/.pnpm/@solana+codecs-data-structures@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-data-structures/src/struct.ts","node_modules/.pnpm/@solana+codecs-core@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-core/dist/index.browser.mjs","node_modules/.pnpm/@solana+codecs-core@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-core/src/bytes.ts","node_modules/.pnpm/@solana+codecs-core@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-core/src/codec.ts","node_modules/.pnpm/@solana+codecs-core@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-core/src/combine-codec.ts","node_modules/.pnpm/@solana+codecs-core@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-core/src/add-codec-sentinel.ts","node_modules/.pnpm/@solana+codecs-core@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-core/src/assertions.ts","node_modules/.pnpm/@solana+codecs-core@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-core/src/add-codec-size-prefix.ts","node_modules/.pnpm/@solana+codecs-core@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-core/src/decoder-entire-byte-array.ts","node_modules/.pnpm/@solana+codecs-core@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-core/src/fix-codec-size.ts","node_modules/.pnpm/@solana+codecs-core@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-core/src/offset-codec.ts","node_modules/.pnpm/@solana+codecs-core@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-core/src/resize-codec.ts","node_modules/.pnpm/@solana+codecs-core@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-core/src/pad-codec.ts","node_modules/.pnpm/@solana+codecs-core@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-core/src/reverse-codec.ts","node_modules/.pnpm/@solana+codecs-core@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-core/src/transform-codec.ts","node_modules/.pnpm/@solana+errors@4.0.0_typescript@5.9.3/node_modules/@solana/errors/dist/index.browser.mjs","node_modules/.pnpm/@solana+errors@4.0.0_typescript@5.9.3/node_modules/@solana/errors/src/codes.ts","node_modules/.pnpm/@solana+errors@4.0.0_typescript@5.9.3/node_modules/@solana/errors/src/context.ts","node_modules/.pnpm/@solana+errors@4.0.0_typescript@5.9.3/node_modules/@solana/errors/src/messages.ts","node_modules/.pnpm/@solana+errors@4.0.0_typescript@5.9.3/node_modules/@solana/errors/src/message-formatter.ts","node_modules/.pnpm/@solana+errors@4.0.0_typescript@5.9.3/node_modules/@solana/errors/src/error.ts","node_modules/.pnpm/@solana+errors@4.0.0_typescript@5.9.3/node_modules/@solana/errors/src/stack-trace.ts","node_modules/.pnpm/@solana+errors@4.0.0_typescript@5.9.3/node_modules/@solana/errors/src/rpc-enum-errors.ts","node_modules/.pnpm/@solana+errors@4.0.0_typescript@5.9.3/node_modules/@solana/errors/src/instruction-error.ts","node_modules/.pnpm/@solana+errors@4.0.0_typescript@5.9.3/node_modules/@solana/errors/src/transaction-error.ts","node_modules/.pnpm/@solana+errors@4.0.0_typescript@5.9.3/node_modules/@solana/errors/src/json-rpc-error.ts","node_modules/.pnpm/@solana+codecs-numbers@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-numbers/dist/index.browser.mjs","node_modules/.pnpm/@solana+codecs-numbers@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-numbers/src/assertions.ts","node_modules/.pnpm/@solana+codecs-numbers@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-numbers/src/common.ts","node_modules/.pnpm/@solana+codecs-numbers@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-numbers/src/utils.ts","node_modules/.pnpm/@solana+codecs-numbers@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-numbers/src/f32.ts","node_modules/.pnpm/@solana+codecs-numbers@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-numbers/src/f64.ts","node_modules/.pnpm/@solana+codecs-numbers@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-numbers/src/i128.ts","node_modules/.pnpm/@solana+codecs-numbers@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-numbers/src/i16.ts","node_modules/.pnpm/@solana+codecs-numbers@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-numbers/src/i32.ts","node_modules/.pnpm/@solana+codecs-numbers@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-numbers/src/i64.ts","node_modules/.pnpm/@solana+codecs-numbers@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-numbers/src/i8.ts","node_modules/.pnpm/@solana+codecs-numbers@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-numbers/src/short-u16.ts","node_modules/.pnpm/@solana+codecs-numbers@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-numbers/src/u128.ts","node_modules/.pnpm/@solana+codecs-numbers@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-numbers/src/u16.ts","node_modules/.pnpm/@solana+codecs-numbers@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-numbers/src/u32.ts","node_modules/.pnpm/@solana+codecs-numbers@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-numbers/src/u64.ts","node_modules/.pnpm/@solana+codecs-numbers@4.0.0_typescript@5.9.3/node_modules/@solana/codecs-numbers/src/u8.ts","node_modules/.pnpm/@solana+addresses@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/addresses/dist/index.browser.mjs","node_modules/.pnpm/@solana+addresses@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/addresses/src/address.ts","node_modules/.pnpm/@solana+addresses@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/addresses/src/vendor/noble/ed25519.ts","node_modules/.pnpm/@solana+addresses@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/addresses/src/curve-internal.ts","node_modules/.pnpm/@solana+addresses@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/addresses/src/curve.ts","node_modules/.pnpm/@solana+addresses@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/addresses/src/program-derived-address.ts","node_modules/.pnpm/@solana+addresses@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/addresses/src/public-key.ts","node_modules/.pnpm/@solana+codecs-strings@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/codecs-strings/dist/index.browser.mjs","node_modules/.pnpm/@solana+codecs-strings@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/codecs-strings/src/assertions.ts","node_modules/.pnpm/@solana+codecs-strings@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/codecs-strings/src/baseX.ts","node_modules/.pnpm/@solana+codecs-strings@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/codecs-strings/src/base10.ts","node_modules/.pnpm/@solana+codecs-strings@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/codecs-strings/src/base16.ts","node_modules/.pnpm/@solana+codecs-strings@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/codecs-strings/src/base58.ts","node_modules/.pnpm/@solana+codecs-strings@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/codecs-strings/src/baseX-reslice.ts","node_modules/.pnpm/@solana+codecs-strings@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/codecs-strings/src/base64.ts","node_modules/.pnpm/@solana+codecs-strings@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/codecs-strings/src/null-characters.ts","node_modules/.pnpm/@solana+codecs-strings@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/text-encoding-impl/src/index.browser.ts","node_modules/.pnpm/@solana+codecs-strings@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/codecs-strings/src/utf8.ts","node_modules/.pnpm/@solana+assertions@4.0.0_typescript@5.9.3/node_modules/@solana/assertions/dist/index.browser.mjs","node_modules/.pnpm/@solana+assertions@4.0.0_typescript@5.9.3/node_modules/@solana/assertions/src/crypto.ts","node_modules/.pnpm/@solana+assertions@4.0.0_typescript@5.9.3/node_modules/@solana/assertions/src/subtle-crypto.ts","node_modules/.pnpm/@solana+options@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/options/dist/index.browser.mjs","node_modules/.pnpm/@solana+options@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/options/src/option.ts","node_modules/.pnpm/@solana+options@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/options/src/unwrap-option.ts","node_modules/.pnpm/@solana+options@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/options/src/option-codec.ts","node_modules/.pnpm/@solana+options@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/options/src/unwrap-option-recursively.ts","node_modules/.pnpm/@solana+accounts@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/accounts/dist/index.browser.mjs","node_modules/.pnpm/@solana+accounts@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/accounts/src/account.ts","node_modules/.pnpm/@solana+accounts@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/accounts/src/decode-account.ts","node_modules/.pnpm/@solana+accounts@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/accounts/src/parse-account.ts","node_modules/.pnpm/@solana+accounts@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/accounts/src/fetch-account.ts","node_modules/.pnpm/@solana+accounts@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/accounts/src/maybe-account.ts","node_modules/.pnpm/@solana+programs@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/programs/dist/index.browser.mjs","node_modules/.pnpm/@solana+programs@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/programs/src/program-error.ts","node_modules/.pnpm/@solana+instructions@4.0.0_typescript@5.9.3/node_modules/@solana/instructions/dist/index.browser.mjs","node_modules/.pnpm/@solana+instructions@4.0.0_typescript@5.9.3/node_modules/@solana/instructions/src/instruction.ts","node_modules/.pnpm/@solana+instructions@4.0.0_typescript@5.9.3/node_modules/@solana/instructions/src/roles.ts","node_modules/.pnpm/@solana+signers@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/signers/dist/index.browser.mjs","node_modules/.pnpm/@solana+signers@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/signers/src/deduplicate-signers.ts","node_modules/.pnpm/@solana+signers@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/signers/src/transaction-modifying-signer.ts","node_modules/.pnpm/@solana+signers@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/signers/src/transaction-partial-signer.ts","node_modules/.pnpm/@solana+signers@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/signers/src/transaction-sending-signer.ts","node_modules/.pnpm/@solana+signers@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/signers/src/transaction-signer.ts","node_modules/.pnpm/@solana+signers@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/signers/src/account-signer-meta.ts","node_modules/.pnpm/@solana+signers@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/signers/src/add-signers.ts","node_modules/.pnpm/@solana+signers@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/signers/src/fee-payer-signer.ts","node_modules/.pnpm/@solana+signers@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/signers/src/message-partial-signer.ts","node_modules/.pnpm/@solana+signers@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/signers/src/keypair-signer.ts","node_modules/.pnpm/@solana+signers@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/signers/src/message-modifying-signer.ts","node_modules/.pnpm/@solana+signers@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/signers/src/message-signer.ts","node_modules/.pnpm/@solana+signers@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/signers/src/noop-signer.ts","node_modules/.pnpm/@solana+signers@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/signers/src/transaction-with-single-sending-signer.ts","node_modules/.pnpm/@solana+signers@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/signers/src/sign-transaction.ts","node_modules/.pnpm/@solana+signers@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/text-encoding-impl/src/index.browser.ts","node_modules/.pnpm/@solana+signers@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/signers/src/signable-message.ts","node_modules/.pnpm/@solana+keys@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/keys/dist/index.browser.mjs","node_modules/.pnpm/@solana+keys@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/keys/src/algorithm.ts","node_modules/.pnpm/@solana+keys@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/keys/src/private-key.ts","node_modules/.pnpm/@solana+keys@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/keys/src/public-key.ts","node_modules/.pnpm/@solana+keys@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/keys/src/signatures.ts","node_modules/.pnpm/@solana+keys@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/keys/src/key-pair.ts","node_modules/.pnpm/@solana+transactions@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transactions/dist/index.browser.mjs","node_modules/.pnpm/@solana+transactions@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transactions/src/codecs/signatures-encoder.ts","node_modules/.pnpm/@solana+transactions@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transactions/src/codecs/transaction-codec.ts","node_modules/.pnpm/@solana+transactions@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transactions/src/lifetime.ts","node_modules/.pnpm/@solana+transactions@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transactions/src/compile-transaction.ts","node_modules/.pnpm/@solana+transactions@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transactions/src/signatures.ts","node_modules/.pnpm/@solana+transactions@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transactions/src/wire-transaction.ts","node_modules/.pnpm/@solana+transactions@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transactions/src/transaction-size.ts","node_modules/.pnpm/@solana+transactions@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transactions/src/sendable-transaction.ts","node_modules/.pnpm/@solana+transactions@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transactions/src/transaction-message-size.ts","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transaction-messages/dist/index.browser.mjs","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transaction-messages/src/blockhash.ts","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/codecs-strings/src/assertions.ts","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/codecs-strings/src/baseX.ts","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/codecs-strings/src/base58.ts","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transaction-messages/src/codecs/address-table-lookup.ts","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transaction-messages/src/codecs/header.ts","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transaction-messages/src/codecs/instruction.ts","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transaction-messages/src/transaction-message.ts","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transaction-messages/src/codecs/transaction-version.ts","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transaction-messages/src/codecs/message.ts","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transaction-messages/src/compile/accounts.ts","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transaction-messages/src/compile/address-table-lookups.ts","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transaction-messages/src/compile/header.ts","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transaction-messages/src/compile/instructions.ts","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transaction-messages/src/compile/lifetime-token.ts","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transaction-messages/src/compile/static-accounts.ts","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transaction-messages/src/compile/message.ts","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transaction-messages/src/compress-transaction-message.ts","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transaction-messages/src/create-transaction-message.ts","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transaction-messages/src/durable-nonce-instruction.ts","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transaction-messages/src/durable-nonce.ts","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transaction-messages/src/fee-payer.ts","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transaction-messages/src/instructions.ts","node_modules/.pnpm/@solana+transaction-messages@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/transaction-messages/src/decompile-message.ts","node_modules/.pnpm/@solana+rpc-types@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/rpc-types/dist/index.browser.mjs","node_modules/.pnpm/@solana+rpc-types@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/rpc-types/src/blockhash.ts","node_modules/.pnpm/@solana+rpc-types@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/rpc-types/src/cluster-url.ts","node_modules/.pnpm/@solana+rpc-types@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/rpc-types/src/commitment.ts","node_modules/.pnpm/@solana+rpc-types@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/rpc-types/src/lamports.ts","node_modules/.pnpm/@solana+rpc-types@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/rpc-types/src/stringified-bigint.ts","node_modules/.pnpm/@solana+rpc-types@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/rpc-types/src/stringified-number.ts","node_modules/.pnpm/@solana+rpc-types@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/rpc-types/src/unix-timestamp.ts","node_modules/.pnpm/@solana+functional@4.0.0_typescript@5.9.3/node_modules/@solana/functional/dist/index.browser.mjs","node_modules/.pnpm/@solana+functional@4.0.0_typescript@5.9.3/node_modules/@solana/functional/src/pipe.ts","node_modules/.pnpm/@solana+sysvars@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/sysvars/dist/index.browser.mjs","node_modules/.pnpm/@solana+sysvars@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/sysvars/src/sysvar.ts","node_modules/.pnpm/@solana+sysvars@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/sysvars/src/clock.ts","node_modules/.pnpm/@solana+sysvars@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/sysvars/src/epoch-rewards.ts","node_modules/.pnpm/@solana+sysvars@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/sysvars/src/epoch-schedule.ts","node_modules/.pnpm/@solana+sysvars@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/sysvars/src/last-restart-slot.ts","node_modules/.pnpm/@solana+sysvars@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/sysvars/src/recent-blockhashes.ts","node_modules/.pnpm/@solana+sysvars@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/sysvars/src/rent.ts","node_modules/.pnpm/@solana+sysvars@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/sysvars/src/slot-hashes.ts","node_modules/.pnpm/@solana+sysvars@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/sysvars/src/slot-history.ts","node_modules/.pnpm/@solana+sysvars@4.0.0_fastestsmallesttextencoderdecoder@1.0.22_typescript@5.9.3/node_modules/@solana/sysvars/src/stake-history.ts"],"sourcesContent":["// Entry point for the application\n// Logic will be added here later\n// src/codes.ts\nvar $0bb11e8e9f3a1c4e$export$637a712014b81b9c = 1;\nvar $0bb11e8e9f3a1c4e$export$2b45309b0547a9c4 = 2;\nvar $0bb11e8e9f3a1c4e$export$7cf14cde1226b7cb = 3;\nvar $0bb11e8e9f3a1c4e$export$6ad19ea5e363a944 = 4;\nvar $0bb11e8e9f3a1c4e$export$c37fe345cc9b38e7 = 5;\nvar $0bb11e8e9f3a1c4e$export$cf7b28c4ea07497b = 6;\nvar $0bb11e8e9f3a1c4e$export$e8ff0c73a3d6800d = 7;\nvar $0bb11e8e9f3a1c4e$export$7dd7d17f1f93a166 = 8;\nvar $0bb11e8e9f3a1c4e$export$8b23617676679e2d = 9;\nvar $0bb11e8e9f3a1c4e$export$1cf7bba40d7d2361 = 10;\nvar $0bb11e8e9f3a1c4e$export$e09e3905081e44fe = -32700;\nvar $0bb11e8e9f3a1c4e$export$afa40fd3fc01204 = -32603;\nvar $0bb11e8e9f3a1c4e$export$2981978a530b1a7c = -32602;\nvar $0bb11e8e9f3a1c4e$export$5ec955cc8b7e8cf9 = -32601;\nvar $0bb11e8e9f3a1c4e$export$23cb4efd59427895 = -32600;\nvar $0bb11e8e9f3a1c4e$export$35d837f314929752 = -32019;\nvar $0bb11e8e9f3a1c4e$export$86fc15c41ff3dc9c = -32018;\nvar $0bb11e8e9f3a1c4e$export$1e95c50f9776ce34 = -32017;\nvar $0bb11e8e9f3a1c4e$export$4f93db3d1b48599e = -32016;\nvar $0bb11e8e9f3a1c4e$export$f7685139153f9191 = -32015;\nvar $0bb11e8e9f3a1c4e$export$65235469ebe9845e = -32014;\nvar $0bb11e8e9f3a1c4e$export$bdeebdca616ef1f3 = -32013;\nvar $0bb11e8e9f3a1c4e$export$1b90c411626421b1 = -32012;\nvar $0bb11e8e9f3a1c4e$export$8e678bf9b4e5cb64 = -32011;\nvar $0bb11e8e9f3a1c4e$export$54dea2286c43ec1e = -32010;\nvar $0bb11e8e9f3a1c4e$export$e71fbee92648fc61 = -32009;\nvar $0bb11e8e9f3a1c4e$export$eb4f7515ff6aa19d = -32008;\nvar $0bb11e8e9f3a1c4e$export$d21075fd06730e = -32007;\nvar $0bb11e8e9f3a1c4e$export$d964b43bb02eacdf = -32006;\nvar $0bb11e8e9f3a1c4e$export$6bad0f4fb625ae6e = -32005;\nvar $0bb11e8e9f3a1c4e$export$bfbf8b75e865efa0 = -32004;\nvar $0bb11e8e9f3a1c4e$export$83dce8c0aef70463 = -32003;\nvar $0bb11e8e9f3a1c4e$export$426cc73f5ad00f38 = -32002;\nvar $0bb11e8e9f3a1c4e$export$6ae475e85fe02aad = -32001;\nvar $0bb11e8e9f3a1c4e$export$fe284a92110eab86 = 28e5;\nvar $0bb11e8e9f3a1c4e$export$8aae3518bf4ea38c = 2800001;\nvar $0bb11e8e9f3a1c4e$export$e31a90a3bf6aebaa = 2800002;\nvar $0bb11e8e9f3a1c4e$export$adaec66b544981e7 = 2800003;\nvar $0bb11e8e9f3a1c4e$export$523a769cce7318bf = 2800004;\nvar $0bb11e8e9f3a1c4e$export$68473acf744cabf5 = 2800005;\nvar $0bb11e8e9f3a1c4e$export$940d17d3b63dba7c = 2800006;\nvar $0bb11e8e9f3a1c4e$export$a1cf857da540ee2e = 2800007;\nvar $0bb11e8e9f3a1c4e$export$30501b98da9564bb = 2800008;\nvar $0bb11e8e9f3a1c4e$export$123d01dd469dc2ef = 2800009;\nvar $0bb11e8e9f3a1c4e$export$2a7684440f52314e = 2800010;\nvar $0bb11e8e9f3a1c4e$export$7ada2ae349acb674 = 2800011;\nvar $0bb11e8e9f3a1c4e$export$8f39956700e64760 = 323e4;\nvar $0bb11e8e9f3a1c4e$export$1239089c4564c858 = 32300001;\nvar $0bb11e8e9f3a1c4e$export$afc08ee11abbc257 = 3230002;\nvar $0bb11e8e9f3a1c4e$export$57836d13a84f54b0 = 3230003;\nvar $0bb11e8e9f3a1c4e$export$f080cd056a56cd54 = 3230004;\nvar $0bb11e8e9f3a1c4e$export$f2bbb3c14e29977e = 361e4;\nvar $0bb11e8e9f3a1c4e$export$f18173f573d8bb21 = 3610001;\nvar $0bb11e8e9f3a1c4e$export$7ad09900bd645a86 = 3610002;\nvar $0bb11e8e9f3a1c4e$export$69c08c51e1841f29 = 3610003;\nvar $0bb11e8e9f3a1c4e$export$325dad4e0a6bd514 = 3610004;\nvar $0bb11e8e9f3a1c4e$export$242c341c7c464bee = 3610005;\nvar $0bb11e8e9f3a1c4e$export$a73c064bb32a7c36 = 3610006;\nvar $0bb11e8e9f3a1c4e$export$b6497aaa1c3cb4a7 = 3610007;\nvar $0bb11e8e9f3a1c4e$export$bc2b26beee0f9a0b = 3611e3;\nvar $0bb11e8e9f3a1c4e$export$bc1242deaa4d848d = 3704e3;\nvar $0bb11e8e9f3a1c4e$export$44352af09ecae39f = 3704001;\nvar $0bb11e8e9f3a1c4e$export$d2a0e93e506be463 = 3704002;\nvar $0bb11e8e9f3a1c4e$export$bbe4ed5687bc7f55 = 3704003;\nvar $0bb11e8e9f3a1c4e$export$436df06ce5af77b3 = 3704004;\nvar $0bb11e8e9f3a1c4e$export$552eeff1216c4a1e = 4128e3;\nvar $0bb11e8e9f3a1c4e$export$b260fc8c8d3cde52 = 4128001;\nvar $0bb11e8e9f3a1c4e$export$b81e507604713b9b = 4128002;\nvar $0bb11e8e9f3a1c4e$export$d308cb6df5c28ff6 = 4615e3;\nvar $0bb11e8e9f3a1c4e$export$ab2273c84ffc5d61 = 4615001;\nvar $0bb11e8e9f3a1c4e$export$23cc359156888c7f = 4615002;\nvar $0bb11e8e9f3a1c4e$export$a4193356408e9ff0 = 4615003;\nvar $0bb11e8e9f3a1c4e$export$f9ae264f831e3bcf = 4615004;\nvar $0bb11e8e9f3a1c4e$export$e170b44d99a3d17c = 4615005;\nvar $0bb11e8e9f3a1c4e$export$84ec8e94b54ae7d2 = 4615006;\nvar $0bb11e8e9f3a1c4e$export$4063fe8d5aed84a5 = 4615007;\nvar $0bb11e8e9f3a1c4e$export$ecdd3388f6a493b1 = 4615008;\nvar $0bb11e8e9f3a1c4e$export$df0a6d6cbb0d96a1 = 4615009;\nvar $0bb11e8e9f3a1c4e$export$e45bdcd5a97f01d1 = 4615010;\nvar $0bb11e8e9f3a1c4e$export$c2bfe7e903a0febb = 4615011;\nvar $0bb11e8e9f3a1c4e$export$fa2d8ac69bd6117e = 4615012;\nvar $0bb11e8e9f3a1c4e$export$2b7e7e6bd3d5b8c4 = 4615013;\nvar $0bb11e8e9f3a1c4e$export$72e64aed285de589 = 4615014;\nvar $0bb11e8e9f3a1c4e$export$95d7c72146ee65c6 = 4615015;\nvar $0bb11e8e9f3a1c4e$export$aa03f185732dc00b = 4615016;\nvar $0bb11e8e9f3a1c4e$export$c390f45549d7336b = 4615017;\nvar $0bb11e8e9f3a1c4e$export$2ea2f2f9a9e26449 = 4615018;\nvar $0bb11e8e9f3a1c4e$export$c9ece88629d0d2d8 = 4615019;\nvar $0bb11e8e9f3a1c4e$export$2f331454431511bf = 4615020;\nvar $0bb11e8e9f3a1c4e$export$3c4b9377ed4116a0 = 4615021;\nvar $0bb11e8e9f3a1c4e$export$211b990ef3bd19ce = 4615022;\nvar $0bb11e8e9f3a1c4e$export$ef486e0fcc8262b = 4615023;\nvar $0bb11e8e9f3a1c4e$export$afcb9eeb4bf056b5 = 4615024;\nvar $0bb11e8e9f3a1c4e$export$4db39a3a67e51db2 = 4615025;\nvar $0bb11e8e9f3a1c4e$export$5abe2d1d040bf6cf = 4615026;\nvar $0bb11e8e9f3a1c4e$export$35a7a209cf9aaee8 = 4615027;\nvar $0bb11e8e9f3a1c4e$export$203fce7ce63eb278 = 4615028;\nvar $0bb11e8e9f3a1c4e$export$c65d87b69a4b86e5 = 4615029;\nvar $0bb11e8e9f3a1c4e$export$d13686e596713674 = 4615030;\nvar $0bb11e8e9f3a1c4e$export$a070310f29fe959b = 4615031;\nvar $0bb11e8e9f3a1c4e$export$8eb8ce58a8afa4d8 = 4615032;\nvar $0bb11e8e9f3a1c4e$export$1224afa7bd705d3d = 4615033;\nvar $0bb11e8e9f3a1c4e$export$547fdb4fff65c547 = 4615034;\nvar $0bb11e8e9f3a1c4e$export$cbeea52e947eb081 = 4615035;\nvar $0bb11e8e9f3a1c4e$export$fd7a98f0746b6c8a = 4615036;\nvar $0bb11e8e9f3a1c4e$export$8e6d399c8fb88eaa = 4615037;\nvar $0bb11e8e9f3a1c4e$export$2c001ce75e66180d = 4615038;\nvar $0bb11e8e9f3a1c4e$export$ec7d592dad68aa12 = 4615039;\nvar $0bb11e8e9f3a1c4e$export$8815da3ec592d05a = 4615040;\nvar $0bb11e8e9f3a1c4e$export$b1b9bf899899a525 = 4615041;\nvar $0bb11e8e9f3a1c4e$export$67715a67add5645f = 4615042;\nvar $0bb11e8e9f3a1c4e$export$e343a153899b82e9 = 4615043;\nvar $0bb11e8e9f3a1c4e$export$2199fb95c7d85b85 = 4615044;\nvar $0bb11e8e9f3a1c4e$export$57c1675a0c20931f = 4615045;\nvar $0bb11e8e9f3a1c4e$export$9e62f446da191370 = 4615046;\nvar $0bb11e8e9f3a1c4e$export$b5ccaf975fe486a0 = 4615047;\nvar $0bb11e8e9f3a1c4e$export$4d39d4c2f04b41a8 = 4615048;\nvar $0bb11e8e9f3a1c4e$export$1997554dc67e9c4e = 4615049;\nvar $0bb11e8e9f3a1c4e$export$8a65209e9cece2cd = 4615050;\nvar $0bb11e8e9f3a1c4e$export$6b675123aa59300c = 4615051;\nvar $0bb11e8e9f3a1c4e$export$70b4e2dd1496c5a3 = 4615052;\nvar $0bb11e8e9f3a1c4e$export$43d5111034db211a = 4615053;\nvar $0bb11e8e9f3a1c4e$export$8aebe3e76f515046 = 4615054;\nvar $0bb11e8e9f3a1c4e$export$ee84b29a9985e516 = 5508e3;\nvar $0bb11e8e9f3a1c4e$export$9998b265c986beaa = 5508001;\nvar $0bb11e8e9f3a1c4e$export$dd792e9d67cd031b = 5508002;\nvar $0bb11e8e9f3a1c4e$export$14d32fbdad2233cd = 5508003;\nvar $0bb11e8e9f3a1c4e$export$8c6fc1cfcec8440c = 5508004;\nvar $0bb11e8e9f3a1c4e$export$dcec7171cff295d1 = 5508005;\nvar $0bb11e8e9f3a1c4e$export$200acbfc722e322b = 5508006;\nvar $0bb11e8e9f3a1c4e$export$4c96d9a95880ae4b = 5508007;\nvar $0bb11e8e9f3a1c4e$export$bba76b21ada319a5 = 5508008;\nvar $0bb11e8e9f3a1c4e$export$3cb3b480d2bfdacc = 5508009;\nvar $0bb11e8e9f3a1c4e$export$1f5fbaa83776feec = 5508010;\nvar $0bb11e8e9f3a1c4e$export$1d51c4c8b2c49e09 = 5508011;\nvar $0bb11e8e9f3a1c4e$export$694fd435994bcca = 5663e3;\nvar $0bb11e8e9f3a1c4e$export$707576ec00ca24d6 = 5663001;\nvar $0bb11e8e9f3a1c4e$export$e33d07a7526bded0 = 5663002;\nvar $0bb11e8e9f3a1c4e$export$a20747f749dd4515 = 5663003;\nvar $0bb11e8e9f3a1c4e$export$3963d9bca4091810 = 5663004;\nvar $0bb11e8e9f3a1c4e$export$b34a16b8adbffdc1 = 5663005;\nvar $0bb11e8e9f3a1c4e$export$3764bbcfb0679211 = 5663006;\nvar $0bb11e8e9f3a1c4e$export$ed2bdee7953e467f = 5663007;\nvar $0bb11e8e9f3a1c4e$export$11bea4440904349c = 5663008;\nvar $0bb11e8e9f3a1c4e$export$6d61b980429516bd = 5663009;\nvar $0bb11e8e9f3a1c4e$export$819b1b0603d2a966 = 5663010;\nvar $0bb11e8e9f3a1c4e$export$592862d1b11e32ac = 5663011;\nvar $0bb11e8e9f3a1c4e$export$242af5597d94abaf = 5663012;\nvar $0bb11e8e9f3a1c4e$export$802b3ebe5297e360 = 5663013;\nvar $0bb11e8e9f3a1c4e$export$bed6f92dafea0623 = 5663014;\nvar $0bb11e8e9f3a1c4e$export$36c2547c3c4d823f = 5663015;\nvar $0bb11e8e9f3a1c4e$export$de92784c954d1b84 = 5663016;\nvar $0bb11e8e9f3a1c4e$export$b55a3eb3d894ad9f = 5663017;\nvar $0bb11e8e9f3a1c4e$export$4e4582c633fc423e = 5663018;\nvar $0bb11e8e9f3a1c4e$export$923893d5c076a47c = 5663019;\nvar $0bb11e8e9f3a1c4e$export$980469bdb5d5bd4f = 5663020;\nvar $0bb11e8e9f3a1c4e$export$8ff97fea1326b6e7 = 5663021;\nvar $0bb11e8e9f3a1c4e$export$204c62c0e8d2efcc = 5663022;\nvar $0bb11e8e9f3a1c4e$export$8c82dde5b12c9789 = 705e4;\nvar $0bb11e8e9f3a1c4e$export$a746609ecc2f6acf = 7050001;\nvar $0bb11e8e9f3a1c4e$export$c4d8217d3eb3eaf8 = 7050002;\nvar $0bb11e8e9f3a1c4e$export$5d0f06cd8bc8e3af = 7050003;\nvar $0bb11e8e9f3a1c4e$export$83c8fe2717d1b271 = 7050004;\nvar $0bb11e8e9f3a1c4e$export$39ead28cf48a604c = 7050005;\nvar $0bb11e8e9f3a1c4e$export$624f65633216eb57 = 7050006;\nvar $0bb11e8e9f3a1c4e$export$2bbd9403cb117ea7 = 7050007;\nvar $0bb11e8e9f3a1c4e$export$e108dd5343c4c11 = 7050008;\nvar $0bb11e8e9f3a1c4e$export$a504ed6cab09ce4a = 7050009;\nvar $0bb11e8e9f3a1c4e$export$8c1ae05eccc11ef9 = 7050010;\nvar $0bb11e8e9f3a1c4e$export$47df44101c6f04b0 = 7050011;\nvar $0bb11e8e9f3a1c4e$export$89ae0c424691fbcb = 7050012;\nvar $0bb11e8e9f3a1c4e$export$bea5f92951bc42e7 = 7050013;\nvar $0bb11e8e9f3a1c4e$export$91a668e132084ecf = 7050014;\nvar $0bb11e8e9f3a1c4e$export$211b9b84186690f0 = 7050015;\nvar $0bb11e8e9f3a1c4e$export$291ea8d5a7496fde = 7050016;\nvar $0bb11e8e9f3a1c4e$export$5f027a86397cba92 = 7050017;\nvar $0bb11e8e9f3a1c4e$export$58bf90c73afbc02e = 7050018;\nvar $0bb11e8e9f3a1c4e$export$b8b2610c9a910763 = 7050019;\nvar $0bb11e8e9f3a1c4e$export$fb693aebffa32676 = 7050020;\nvar $0bb11e8e9f3a1c4e$export$572954173bc64b66 = 7050021;\nvar $0bb11e8e9f3a1c4e$export$fa9a13f1b40ee2fb = 7050022;\nvar $0bb11e8e9f3a1c4e$export$95c94f6ea500f1ab = 7050023;\nvar $0bb11e8e9f3a1c4e$export$11d69fb6993b2cf5 = 7050024;\nvar $0bb11e8e9f3a1c4e$export$bd54a9a85614b3a7 = 7050025;\nvar $0bb11e8e9f3a1c4e$export$df4ef1824fd194a3 = 7050026;\nvar $0bb11e8e9f3a1c4e$export$2725d50dd432fb3a = 7050027;\nvar $0bb11e8e9f3a1c4e$export$41f13726b04d8d05 = 7050028;\nvar $0bb11e8e9f3a1c4e$export$7b4a7eebff68ca7b = 7050029;\nvar $0bb11e8e9f3a1c4e$export$e3a4007020a2e8f5 = 7050030;\nvar $0bb11e8e9f3a1c4e$export$2ecc275dffbc087c = 7050031;\nvar $0bb11e8e9f3a1c4e$export$e3289c5954208202 = 7050032;\nvar $0bb11e8e9f3a1c4e$export$3569c6c71e349538 = 7050033;\nvar $0bb11e8e9f3a1c4e$export$4f413e02d5e82221 = 7050034;\nvar $0bb11e8e9f3a1c4e$export$1cd0de5dfcdeb99d = 7050035;\nvar $0bb11e8e9f3a1c4e$export$87e01307d368f511 = 7050036;\nvar $0bb11e8e9f3a1c4e$export$4758b9d97c7acd49 = 7618e3;\nvar $0bb11e8e9f3a1c4e$export$2e5fda8b40bc9396 = 7618001;\nvar $0bb11e8e9f3a1c4e$export$b22811c3929e985a = 7618002;\nvar $0bb11e8e9f3a1c4e$export$12d6d18d48ba64e9 = 7618003;\nvar $0bb11e8e9f3a1c4e$export$9c9326ce1e3df40c = 8078e3;\nvar $0bb11e8e9f3a1c4e$export$18fbf24f19efc69b = 8078001;\nvar $0bb11e8e9f3a1c4e$export$93561b31b951410d = 8078002;\nvar $0bb11e8e9f3a1c4e$export$3417da5bc6bcb45 = 8078003;\nvar $0bb11e8e9f3a1c4e$export$c4c73ab3c0833591 = 8078004;\nvar $0bb11e8e9f3a1c4e$export$824d79ab1779d517 = 8078005;\nvar $0bb11e8e9f3a1c4e$export$c464f3b291f1f3d0 = 8078006;\nvar $0bb11e8e9f3a1c4e$export$c04710d31ef4d278 = 8078007;\nvar $0bb11e8e9f3a1c4e$export$1fa107ead8489cf2 = 8078008;\nvar $0bb11e8e9f3a1c4e$export$2bb0703affb8fe68 = 8078009;\nvar $0bb11e8e9f3a1c4e$export$f6bf8a7c1f3defe4 = 8078010;\nvar $0bb11e8e9f3a1c4e$export$8653c145864f47f4 = 8078011;\nvar $0bb11e8e9f3a1c4e$export$89b582b06852d433 = 8078012;\nvar $0bb11e8e9f3a1c4e$export$4c1fcb4bd20b2951 = 8078013;\nvar $0bb11e8e9f3a1c4e$export$a617dff403944ec6 = 8078014;\nvar $0bb11e8e9f3a1c4e$export$c89f43f0d783cd50 = 8078015;\nvar $0bb11e8e9f3a1c4e$export$f73fb8ecbd4b2395 = 8078016;\nvar $0bb11e8e9f3a1c4e$export$efbd199de191d2aa = 8078017;\nvar $0bb11e8e9f3a1c4e$export$cb77f5a0f0fa7f18 = 8078018;\nvar $0bb11e8e9f3a1c4e$export$47278510a511031b = 8078019;\nvar $0bb11e8e9f3a1c4e$export$a9282ed13660c9f6 = 8078020;\nvar $0bb11e8e9f3a1c4e$export$5bdfee6423bc35ce = 8078021;\nvar $0bb11e8e9f3a1c4e$export$a2e9526594022372 = 8078022;\nvar $0bb11e8e9f3a1c4e$export$11a7243580452ad8 = 8078023;\nvar $0bb11e8e9f3a1c4e$export$ef742b7036fb9005 = 81e5;\nvar $0bb11e8e9f3a1c4e$export$2a2f0f75708d1697 = 8100001;\nvar $0bb11e8e9f3a1c4e$export$7f6822f75edb8f41 = 8100002;\nvar $0bb11e8e9f3a1c4e$export$119023a74b281384 = 8100003;\nvar $0bb11e8e9f3a1c4e$export$c32108b180210fc5 = 819e4;\nvar $0bb11e8e9f3a1c4e$export$e1a3658b043aad8e = 8190001;\nvar $0bb11e8e9f3a1c4e$export$ae8da83a78732501 = 8190002;\nvar $0bb11e8e9f3a1c4e$export$73f01f46f9a97cf0 = 8190003;\nvar $0bb11e8e9f3a1c4e$export$5293460f390d6127 = 8190004;\nvar $0bb11e8e9f3a1c4e$export$a12ca71185bd51db = 99e5;\nvar $0bb11e8e9f3a1c4e$export$d5b3c70e0e0f470a = 9900001;\nvar $0bb11e8e9f3a1c4e$export$b57ffff6ec11f63 = 9900002;\nvar $0bb11e8e9f3a1c4e$export$6fe73388375373f = 9900003;\nvar $0bb11e8e9f3a1c4e$export$8b0d360227f3435e = 9900004;\nvar $0bb11e8e9f3a1c4e$export$bcbc513a8682960f = 9900005;\nvar $0bb11e8e9f3a1c4e$export$8f646bf76fb27ec0 = 9900006;\n// src/context.ts\nfunction $0bb11e8e9f3a1c4e$var$encodeValue(value) {\n    if (Array.isArray(value)) {\n        const commaSeparatedValues = value.map($0bb11e8e9f3a1c4e$var$encodeValue).join(\"%2C%20\");\n        return \"%5B\" + commaSeparatedValues + /* \"]\" */ \"%5D\";\n    } else if (typeof value === \"bigint\") return `${value}n`;\n    else return encodeURIComponent(String(value != null && Object.getPrototypeOf(value) === null ? // Plain objects with no prototype don't have a `toString` method.\n    // Convert them before stringifying them.\n    {\n        ...value\n    } : value));\n}\nfunction $0bb11e8e9f3a1c4e$var$encodeObjectContextEntry([key, value]) {\n    return `${key}=${$0bb11e8e9f3a1c4e$var$encodeValue(value)}`;\n}\nfunction $0bb11e8e9f3a1c4e$var$encodeContextObject(context) {\n    const searchParamsString = Object.entries(context).map($0bb11e8e9f3a1c4e$var$encodeObjectContextEntry).join(\"&\");\n    return btoa(searchParamsString);\n}\n// src/messages.ts\nvar $0bb11e8e9f3a1c4e$var$SolanaErrorMessages = {\n    [$0bb11e8e9f3a1c4e$export$8f39956700e64760]: \"Account not found at address: $address\",\n    [$0bb11e8e9f3a1c4e$export$f080cd056a56cd54]: \"Not all accounts were decoded. Encoded accounts found at addresses: $addresses.\",\n    [$0bb11e8e9f3a1c4e$export$57836d13a84f54b0]: \"Expected decoded account at address: $address\",\n    [$0bb11e8e9f3a1c4e$export$afc08ee11abbc257]: \"Failed to decode account data at address: $address\",\n    [$0bb11e8e9f3a1c4e$export$1239089c4564c858]: \"Accounts not found at addresses: $addresses\",\n    [$0bb11e8e9f3a1c4e$export$123d01dd469dc2ef]: \"Unable to find a viable program address bump seed.\",\n    [$0bb11e8e9f3a1c4e$export$e31a90a3bf6aebaa]: \"$putativeAddress is not a base58-encoded address.\",\n    [$0bb11e8e9f3a1c4e$export$fe284a92110eab86]: \"Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.\",\n    [$0bb11e8e9f3a1c4e$export$adaec66b544981e7]: \"The `CryptoKey` must be an `Ed25519` public key.\",\n    [$0bb11e8e9f3a1c4e$export$7ada2ae349acb674]: \"$putativeOffCurveAddress is not a base58-encoded off-curve address.\",\n    [$0bb11e8e9f3a1c4e$export$30501b98da9564bb]: \"Invalid seeds; point must fall off the Ed25519 curve.\",\n    [$0bb11e8e9f3a1c4e$export$523a769cce7318bf]: \"Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].\",\n    [$0bb11e8e9f3a1c4e$export$940d17d3b63dba7c]: \"A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.\",\n    [$0bb11e8e9f3a1c4e$export$a1cf857da540ee2e]: \"The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.\",\n    [$0bb11e8e9f3a1c4e$export$68473acf744cabf5]: \"Expected program derived address bump to be in the range [0, 255], got: $bump.\",\n    [$0bb11e8e9f3a1c4e$export$2a7684440f52314e]: \"Program address cannot end with PDA marker.\",\n    [$0bb11e8e9f3a1c4e$export$8aae3518bf4ea38c]: \"Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.\",\n    [$0bb11e8e9f3a1c4e$export$6ad19ea5e363a944]: \"Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.\",\n    [$0bb11e8e9f3a1c4e$export$637a712014b81b9c]: \"The network has progressed past the last block for which this transaction could have been committed.\",\n    [$0bb11e8e9f3a1c4e$export$9c9326ce1e3df40c]: \"Codec [$codecDescription] cannot decode empty byte arrays.\",\n    [$0bb11e8e9f3a1c4e$export$a2e9526594022372]: \"Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.\",\n    [$0bb11e8e9f3a1c4e$export$a9282ed13660c9f6]: \"Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].\",\n    [$0bb11e8e9f3a1c4e$export$824d79ab1779d517]: \"Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].\",\n    [$0bb11e8e9f3a1c4e$export$c464f3b291f1f3d0]: \"Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].\",\n    [$0bb11e8e9f3a1c4e$export$c4c73ab3c0833591]: \"Encoder and decoder must either both be fixed-size or variable-size.\",\n    [$0bb11e8e9f3a1c4e$export$1fa107ead8489cf2]: \"Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.\",\n    [$0bb11e8e9f3a1c4e$export$93561b31b951410d]: \"Expected a fixed-size codec, got a variable-size one.\",\n    [$0bb11e8e9f3a1c4e$export$4c1fcb4bd20b2951]: \"Codec [$codecDescription] expected a positive byte length, got $bytesLength.\",\n    [$0bb11e8e9f3a1c4e$export$3417da5bc6bcb45]: \"Expected a variable-size codec, got a fixed-size one.\",\n    [$0bb11e8e9f3a1c4e$export$47278510a511031b]: \"Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].\",\n    [$0bb11e8e9f3a1c4e$export$18fbf24f19efc69b]: \"Codec [$codecDescription] expected $expected bytes, got $bytesLength.\",\n    [$0bb11e8e9f3a1c4e$export$cb77f5a0f0fa7f18]: \"Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].\",\n    [$0bb11e8e9f3a1c4e$export$2bb0703affb8fe68]: \"Invalid discriminated union variant. Expected one of [$variants], got $value.\",\n    [$0bb11e8e9f3a1c4e$export$f6bf8a7c1f3defe4]: \"Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.\",\n    [$0bb11e8e9f3a1c4e$export$c89f43f0d783cd50]: \"Invalid literal union variant. Expected one of [$variants], got $value.\",\n    [$0bb11e8e9f3a1c4e$export$c04710d31ef4d278]: \"Expected [$codecDescription] to have $expected items, got $actual.\",\n    [$0bb11e8e9f3a1c4e$export$89b582b06852d433]: \"Invalid value $value for base $base with alphabet $alphabet.\",\n    [$0bb11e8e9f3a1c4e$export$f73fb8ecbd4b2395]: \"Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.\",\n    [$0bb11e8e9f3a1c4e$export$8653c145864f47f4]: \"Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.\",\n    [$0bb11e8e9f3a1c4e$export$a617dff403944ec6]: \"Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.\",\n    [$0bb11e8e9f3a1c4e$export$5bdfee6423bc35ce]: \"Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].\",\n    [$0bb11e8e9f3a1c4e$export$efbd199de191d2aa]: \"Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.\",\n    [$0bb11e8e9f3a1c4e$export$11a7243580452ad8]: \"This decoder expected a byte array of exactly $expectedLength bytes, but $numExcessBytes unexpected excess bytes remained after decoding. Are you sure that you have chosen the correct decoder for this data?\",\n    [$0bb11e8e9f3a1c4e$export$bc2b26beee0f9a0b]: \"No random values implementation could be found.\",\n    [$0bb11e8e9f3a1c4e$export$df0a6d6cbb0d96a1]: \"instruction requires an uninitialized account\",\n    [$0bb11e8e9f3a1c4e$export$ef486e0fcc8262b]: \"instruction tries to borrow reference for an account which is already borrowed\",\n    [$0bb11e8e9f3a1c4e$export$afcb9eeb4bf056b5]: \"instruction left account with an outstanding borrowed reference\",\n    [$0bb11e8e9f3a1c4e$export$3c4b9377ed4116a0]: \"program other than the account's owner changed the size of the account data\",\n    [$0bb11e8e9f3a1c4e$export$e170b44d99a3d17c]: \"account data too small for instruction\",\n    [$0bb11e8e9f3a1c4e$export$211b990ef3bd19ce]: \"instruction expected an executable account\",\n    [$0bb11e8e9f3a1c4e$export$9e62f446da191370]: \"An account does not have enough lamports to be rent-exempt\",\n    [$0bb11e8e9f3a1c4e$export$4d39d4c2f04b41a8]: \"Program arithmetic overflowed\",\n    [$0bb11e8e9f3a1c4e$export$57c1675a0c20931f]: \"Failed to serialize or deserialize account data: $encodedData\",\n    [$0bb11e8e9f3a1c4e$export$8aebe3e76f515046]: \"Builtin programs must consume compute units\",\n    [$0bb11e8e9f3a1c4e$export$8eb8ce58a8afa4d8]: \"Cross-program invocation call depth too deep\",\n    [$0bb11e8e9f3a1c4e$export$2c001ce75e66180d]: \"Computational budget exceeded\",\n    [$0bb11e8e9f3a1c4e$export$5abe2d1d040bf6cf]: \"custom program error: #$code\",\n    [$0bb11e8e9f3a1c4e$export$c390f45549d7336b]: \"instruction contains duplicate accounts\",\n    [$0bb11e8e9f3a1c4e$export$4db39a3a67e51db2]: \"instruction modifications of multiply-passed account differ\",\n    [$0bb11e8e9f3a1c4e$export$d13686e596713674]: \"executable accounts must be rent exempt\",\n    [$0bb11e8e9f3a1c4e$export$203fce7ce63eb278]: \"instruction changed executable accounts data\",\n    [$0bb11e8e9f3a1c4e$export$c65d87b69a4b86e5]: \"instruction changed the balance of an executable account\",\n    [$0bb11e8e9f3a1c4e$export$2ea2f2f9a9e26449]: \"instruction changed executable bit of an account\",\n    [$0bb11e8e9f3a1c4e$export$72e64aed285de589]: \"instruction modified data of an account it does not own\",\n    [$0bb11e8e9f3a1c4e$export$2b7e7e6bd3d5b8c4]: \"instruction spent from the balance of an account it does not own\",\n    [$0bb11e8e9f3a1c4e$export$ab2273c84ffc5d61]: \"generic instruction error\",\n    [$0bb11e8e9f3a1c4e$export$8a65209e9cece2cd]: \"Provided owner is not allowed\",\n    [$0bb11e8e9f3a1c4e$export$e343a153899b82e9]: \"Account is immutable\",\n    [$0bb11e8e9f3a1c4e$export$2199fb95c7d85b85]: \"Incorrect authority provided\",\n    [$0bb11e8e9f3a1c4e$export$4063fe8d5aed84a5]: \"incorrect program id for instruction\",\n    [$0bb11e8e9f3a1c4e$export$84ec8e94b54ae7d2]: \"insufficient funds for instruction\",\n    [$0bb11e8e9f3a1c4e$export$f9ae264f831e3bcf]: \"invalid account data for instruction\",\n    [$0bb11e8e9f3a1c4e$export$b5ccaf975fe486a0]: \"Invalid account owner\",\n    [$0bb11e8e9f3a1c4e$export$23cc359156888c7f]: \"invalid program argument\",\n    [$0bb11e8e9f3a1c4e$export$35a7a209cf9aaee8]: \"program returned invalid error code\",\n    [$0bb11e8e9f3a1c4e$export$a4193356408e9ff0]: \"invalid instruction data\",\n    [$0bb11e8e9f3a1c4e$export$8e6d399c8fb88eaa]: \"Failed to reallocate account data\",\n    [$0bb11e8e9f3a1c4e$export$fd7a98f0746b6c8a]: \"Provided seeds do not result in a valid address\",\n    [$0bb11e8e9f3a1c4e$export$6b675123aa59300c]: \"Accounts data allocations exceeded the maximum allowed per transaction\",\n    [$0bb11e8e9f3a1c4e$export$70b4e2dd1496c5a3]: \"Max accounts exceeded\",\n    [$0bb11e8e9f3a1c4e$export$43d5111034db211a]: \"Max instruction trace length exceeded\",\n    [$0bb11e8e9f3a1c4e$export$cbeea52e947eb081]: \"Length of the seed is too long for address generation\",\n    [$0bb11e8e9f3a1c4e$export$1224afa7bd705d3d]: \"An account required by the instruction is missing\",\n    [$0bb11e8e9f3a1c4e$export$ecdd3388f6a493b1]: \"missing required signature for instruction\",\n    [$0bb11e8e9f3a1c4e$export$fa2d8ac69bd6117e]: \"instruction illegally modified the program id of an account\",\n    [$0bb11e8e9f3a1c4e$export$2f331454431511bf]: \"insufficient account keys for instruction\",\n    [$0bb11e8e9f3a1c4e$export$ec7d592dad68aa12]: \"Cross-program invocation with unauthorized signer or writable account\",\n    [$0bb11e8e9f3a1c4e$export$8815da3ec592d05a]: \"Failed to create program execution environment\",\n    [$0bb11e8e9f3a1c4e$export$67715a67add5645f]: \"Program failed to compile\",\n    [$0bb11e8e9f3a1c4e$export$b1b9bf899899a525]: \"Program failed to complete\",\n    [$0bb11e8e9f3a1c4e$export$aa03f185732dc00b]: \"instruction modified data of a read-only account\",\n    [$0bb11e8e9f3a1c4e$export$95d7c72146ee65c6]: \"instruction changed the balance of a read-only account\",\n    [$0bb11e8e9f3a1c4e$export$547fdb4fff65c547]: \"Cross-program invocation reentrancy not allowed for this instruction\",\n    [$0bb11e8e9f3a1c4e$export$c9ece88629d0d2d8]: \"instruction modified rent epoch of an account\",\n    [$0bb11e8e9f3a1c4e$export$c2bfe7e903a0febb]: \"sum of account balances before and after instruction do not match\",\n    [$0bb11e8e9f3a1c4e$export$e45bdcd5a97f01d1]: \"instruction requires an initialized account\",\n    [$0bb11e8e9f3a1c4e$export$d308cb6df5c28ff6]: \"\",\n    [$0bb11e8e9f3a1c4e$export$a070310f29fe959b]: \"Unsupported program id\",\n    [$0bb11e8e9f3a1c4e$export$1997554dc67e9c4e]: \"Unsupported sysvar\",\n    [$0bb11e8e9f3a1c4e$export$bcbc513a8682960f]: \"Invalid instruction plan kind: $kind.\",\n    [$0bb11e8e9f3a1c4e$export$b22811c3929e985a]: \"The provided instruction plan is empty.\",\n    [$0bb11e8e9f3a1c4e$export$12d6d18d48ba64e9]: \"The provided transaction plan failed to execute. See the `transactionPlanResult` attribute and the `cause` error for more details.\",\n    [$0bb11e8e9f3a1c4e$export$4758b9d97c7acd49]: \"The provided message has insufficient capacity to accommodate the next instruction(s) in this plan. Expected at least $numBytesRequired free byte(s), got $numFreeBytes byte(s).\",\n    [$0bb11e8e9f3a1c4e$export$8f646bf76fb27ec0]: \"Invalid transaction plan kind: $kind.\",\n    [$0bb11e8e9f3a1c4e$export$2e5fda8b40bc9396]: \"No more instructions to pack; the message packer has completed the instruction plan.\",\n    [$0bb11e8e9f3a1c4e$export$552eeff1216c4a1e]: \"The instruction does not have any accounts.\",\n    [$0bb11e8e9f3a1c4e$export$b260fc8c8d3cde52]: \"The instruction does not have any data.\",\n    [$0bb11e8e9f3a1c4e$export$b81e507604713b9b]: \"Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.\",\n    [$0bb11e8e9f3a1c4e$export$c37fe345cc9b38e7]: \"Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.\",\n    [$0bb11e8e9f3a1c4e$export$2b45309b0547a9c4]: \"The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`\",\n    [$0bb11e8e9f3a1c4e$export$b57ffff6ec11f63]: \"Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [$0bb11e8e9f3a1c4e$export$8b0d360227f3435e]: \"Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.\",\n    [$0bb11e8e9f3a1c4e$export$d5b3c70e0e0f470a]: \"Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [$0bb11e8e9f3a1c4e$export$a12ca71185bd51db]: \"Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [$0bb11e8e9f3a1c4e$export$6fe73388375373f]: \"Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [$0bb11e8e9f3a1c4e$export$afa40fd3fc01204]: \"JSON-RPC error: Internal JSON-RPC error ($__serverMessage)\",\n    [$0bb11e8e9f3a1c4e$export$2981978a530b1a7c]: \"JSON-RPC error: Invalid method parameter(s) ($__serverMessage)\",\n    [$0bb11e8e9f3a1c4e$export$23cb4efd59427895]: \"JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)\",\n    [$0bb11e8e9f3a1c4e$export$5ec955cc8b7e8cf9]: \"JSON-RPC error: The method does not exist / is not available ($__serverMessage)\",\n    [$0bb11e8e9f3a1c4e$export$e09e3905081e44fe]: \"JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)\",\n    [$0bb11e8e9f3a1c4e$export$1b90c411626421b1]: \"$__serverMessage\",\n    [$0bb11e8e9f3a1c4e$export$6ae475e85fe02aad]: \"$__serverMessage\",\n    [$0bb11e8e9f3a1c4e$export$bfbf8b75e865efa0]: \"$__serverMessage\",\n    [$0bb11e8e9f3a1c4e$export$65235469ebe9845e]: \"$__serverMessage\",\n    [$0bb11e8e9f3a1c4e$export$1e95c50f9776ce34]: \"Epoch rewards period still active at slot $slot\",\n    [$0bb11e8e9f3a1c4e$export$54dea2286c43ec1e]: \"$__serverMessage\",\n    [$0bb11e8e9f3a1c4e$export$e71fbee92648fc61]: \"$__serverMessage\",\n    [$0bb11e8e9f3a1c4e$export$35d837f314929752]: \"Failed to query long-term storage; please try again\",\n    [$0bb11e8e9f3a1c4e$export$4f93db3d1b48599e]: \"Minimum context slot has not been reached\",\n    [$0bb11e8e9f3a1c4e$export$6bad0f4fb625ae6e]: \"Node is unhealthy; behind by $numSlotsBehind slots\",\n    [$0bb11e8e9f3a1c4e$export$eb4f7515ff6aa19d]: \"No snapshot\",\n    [$0bb11e8e9f3a1c4e$export$426cc73f5ad00f38]: \"Transaction simulation failed\",\n    [$0bb11e8e9f3a1c4e$export$86fc15c41ff3dc9c]: \"Rewards cannot be found because slot $slot is not the epoch boundary. This may be due to gap in the queried node's local ledger or long-term storage\",\n    [$0bb11e8e9f3a1c4e$export$d21075fd06730e]: \"$__serverMessage\",\n    [$0bb11e8e9f3a1c4e$export$8e678bf9b4e5cb64]: \"Transaction history is not available from this node\",\n    [$0bb11e8e9f3a1c4e$export$d964b43bb02eacdf]: \"$__serverMessage\",\n    [$0bb11e8e9f3a1c4e$export$bdeebdca616ef1f3]: \"Transaction signature length mismatch\",\n    [$0bb11e8e9f3a1c4e$export$83dce8c0aef70463]: \"Transaction signature verification failure\",\n    [$0bb11e8e9f3a1c4e$export$f7685139153f9191]: \"$__serverMessage\",\n    [$0bb11e8e9f3a1c4e$export$bc1242deaa4d848d]: \"Key pair bytes must be of length 64, got $byteLength.\",\n    [$0bb11e8e9f3a1c4e$export$44352af09ecae39f]: \"Expected private key bytes with length 32. Actual length: $actualLength.\",\n    [$0bb11e8e9f3a1c4e$export$d2a0e93e506be463]: \"Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.\",\n    [$0bb11e8e9f3a1c4e$export$436df06ce5af77b3]: \"The provided private key does not match the provided public key.\",\n    [$0bb11e8e9f3a1c4e$export$bbe4ed5687bc7f55]: \"Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.\",\n    [$0bb11e8e9f3a1c4e$export$cf7b28c4ea07497b]: \"Lamports value must be in the range [0, 2e64-1]\",\n    [$0bb11e8e9f3a1c4e$export$e8ff0c73a3d6800d]: \"`$value` cannot be parsed as a `BigInt`\",\n    [$0bb11e8e9f3a1c4e$export$1cf7bba40d7d2361]: \"$message\",\n    [$0bb11e8e9f3a1c4e$export$7dd7d17f1f93a166]: \"`$value` cannot be parsed as a `Number`\",\n    [$0bb11e8e9f3a1c4e$export$7cf14cde1226b7cb]: \"No nonce account could be found at address `$nonceAccountAddress`\",\n    [$0bb11e8e9f3a1c4e$export$c32108b180210fc5]: \"The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.\",\n    [$0bb11e8e9f3a1c4e$export$ae8da83a78732501]: \"WebSocket was closed before payload could be added to the send buffer\",\n    [$0bb11e8e9f3a1c4e$export$73f01f46f9a97cf0]: \"WebSocket connection closed\",\n    [$0bb11e8e9f3a1c4e$export$5293460f390d6127]: \"WebSocket failed to connect\",\n    [$0bb11e8e9f3a1c4e$export$e1a3658b043aad8e]: \"Failed to obtain a subscription id from the server\",\n    [$0bb11e8e9f3a1c4e$export$119023a74b281384]: \"Could not find an API plan for RPC method: `$method`\",\n    [$0bb11e8e9f3a1c4e$export$ef742b7036fb9005]: \"The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.\",\n    [$0bb11e8e9f3a1c4e$export$7f6822f75edb8f41]: \"HTTP error ($statusCode): $message\",\n    [$0bb11e8e9f3a1c4e$export$2a2f0f75708d1697]: \"HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.\",\n    [$0bb11e8e9f3a1c4e$export$ee84b29a9985e516]: \"Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.\",\n    [$0bb11e8e9f3a1c4e$export$9998b265c986beaa]: \"The provided value does not implement the `KeyPairSigner` interface\",\n    [$0bb11e8e9f3a1c4e$export$14d32fbdad2233cd]: \"The provided value does not implement the `MessageModifyingSigner` interface\",\n    [$0bb11e8e9f3a1c4e$export$8c6fc1cfcec8440c]: \"The provided value does not implement the `MessagePartialSigner` interface\",\n    [$0bb11e8e9f3a1c4e$export$dd792e9d67cd031b]: \"The provided value does not implement any of the `MessageSigner` interfaces\",\n    [$0bb11e8e9f3a1c4e$export$200acbfc722e322b]: \"The provided value does not implement the `TransactionModifyingSigner` interface\",\n    [$0bb11e8e9f3a1c4e$export$4c96d9a95880ae4b]: \"The provided value does not implement the `TransactionPartialSigner` interface\",\n    [$0bb11e8e9f3a1c4e$export$bba76b21ada319a5]: \"The provided value does not implement the `TransactionSendingSigner` interface\",\n    [$0bb11e8e9f3a1c4e$export$dcec7171cff295d1]: \"The provided value does not implement any of the `TransactionSigner` interfaces\",\n    [$0bb11e8e9f3a1c4e$export$3cb3b480d2bfdacc]: \"More than one `TransactionSendingSigner` was identified.\",\n    [$0bb11e8e9f3a1c4e$export$1f5fbaa83776feec]: \"No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.\",\n    [$0bb11e8e9f3a1c4e$export$1d51c4c8b2c49e09]: \"Wallet account signers do not support signing multiple messages/transactions in a single operation\",\n    [$0bb11e8e9f3a1c4e$export$b6497aaa1c3cb4a7]: \"Cannot export a non-extractable key.\",\n    [$0bb11e8e9f3a1c4e$export$f18173f573d8bb21]: \"No digest implementation could be found.\",\n    [$0bb11e8e9f3a1c4e$export$f2bbb3c14e29977e]: \"Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.\",\n    [$0bb11e8e9f3a1c4e$export$7ad09900bd645a86]: \"This runtime does not support the generation of Ed25519 key pairs.\\n\\nInstall @solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in environments that do not support Ed25519.\\n\\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.\",\n    [$0bb11e8e9f3a1c4e$export$69c08c51e1841f29]: \"No signature verification implementation could be found.\",\n    [$0bb11e8e9f3a1c4e$export$325dad4e0a6bd514]: \"No key generation implementation could be found.\",\n    [$0bb11e8e9f3a1c4e$export$242c341c7c464bee]: \"No signing implementation could be found.\",\n    [$0bb11e8e9f3a1c4e$export$a73c064bb32a7c36]: \"No key export implementation could be found.\",\n    [$0bb11e8e9f3a1c4e$export$8b23617676679e2d]: \"Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given\",\n    [$0bb11e8e9f3a1c4e$export$291ea8d5a7496fde]: \"Transaction processing left an account with an outstanding borrowed reference\",\n    [$0bb11e8e9f3a1c4e$export$a746609ecc2f6acf]: \"Account in use\",\n    [$0bb11e8e9f3a1c4e$export$c4d8217d3eb3eaf8]: \"Account loaded twice\",\n    [$0bb11e8e9f3a1c4e$export$5d0f06cd8bc8e3af]: \"Attempt to debit an account but found no record of a prior credit.\",\n    [$0bb11e8e9f3a1c4e$export$95c94f6ea500f1ab]: \"Transaction loads an address table account that doesn't exist\",\n    [$0bb11e8e9f3a1c4e$export$2bbd9403cb117ea7]: \"This transaction has already been processed\",\n    [$0bb11e8e9f3a1c4e$export$e108dd5343c4c11]: \"Blockhash not found\",\n    [$0bb11e8e9f3a1c4e$export$a504ed6cab09ce4a]: \"Loader call chain is too deep\",\n    [$0bb11e8e9f3a1c4e$export$211b9b84186690f0]: \"Transactions are currently disabled due to cluster maintenance\",\n    [$0bb11e8e9f3a1c4e$export$e3a4007020a2e8f5]: \"Transaction contains a duplicate instruction ($index) that is not allowed\",\n    [$0bb11e8e9f3a1c4e$export$39ead28cf48a604c]: \"Insufficient funds for fee\",\n    [$0bb11e8e9f3a1c4e$export$2ecc275dffbc087c]: \"Transaction results in an account ($accountIndex) with insufficient funds for rent\",\n    [$0bb11e8e9f3a1c4e$export$624f65633216eb57]: \"This account may not be used to pay transaction fees\",\n    [$0bb11e8e9f3a1c4e$export$47df44101c6f04b0]: \"Transaction contains an invalid account reference\",\n    [$0bb11e8e9f3a1c4e$export$bd54a9a85614b3a7]: \"Transaction loads an address table account with invalid data\",\n    [$0bb11e8e9f3a1c4e$export$df4ef1824fd194a3]: \"Transaction address table lookup uses an invalid index\",\n    [$0bb11e8e9f3a1c4e$export$11d69fb6993b2cf5]: \"Transaction loads an address table account with an invalid owner\",\n    [$0bb11e8e9f3a1c4e$export$3569c6c71e349538]: \"LoadedAccountsDataSizeLimit set for transaction must be greater than 0.\",\n    [$0bb11e8e9f3a1c4e$export$bea5f92951bc42e7]: \"This program may not be used for executing instructions\",\n    [$0bb11e8e9f3a1c4e$export$2725d50dd432fb3a]: \"Transaction leaves an account with a lower balance than rent-exempt minimum\",\n    [$0bb11e8e9f3a1c4e$export$b8b2610c9a910763]: \"Transaction loads a writable account that cannot be written\",\n    [$0bb11e8e9f3a1c4e$export$e3289c5954208202]: \"Transaction exceeded max loaded accounts data size cap\",\n    [$0bb11e8e9f3a1c4e$export$8c1ae05eccc11ef9]: \"Transaction requires a fee but has no signature present\",\n    [$0bb11e8e9f3a1c4e$export$83c8fe2717d1b271]: \"Attempt to load a program that does not exist\",\n    [$0bb11e8e9f3a1c4e$export$1cd0de5dfcdeb99d]: \"Execution of the program referenced by account at index $accountIndex is temporarily restricted.\",\n    [$0bb11e8e9f3a1c4e$export$4f413e02d5e82221]: \"ResanitizationNeeded\",\n    [$0bb11e8e9f3a1c4e$export$91a668e132084ecf]: \"Transaction failed to sanitize accounts offsets correctly\",\n    [$0bb11e8e9f3a1c4e$export$89ae0c424691fbcb]: \"Transaction did not pass signature verification\",\n    [$0bb11e8e9f3a1c4e$export$fa9a13f1b40ee2fb]: \"Transaction locked too many accounts\",\n    [$0bb11e8e9f3a1c4e$export$87e01307d368f511]: \"Sum of account balances before and after transaction do not match\",\n    [$0bb11e8e9f3a1c4e$export$8c82dde5b12c9789]: \"The transaction failed with the error `$errorName`\",\n    [$0bb11e8e9f3a1c4e$export$58bf90c73afbc02e]: \"Transaction version is unsupported\",\n    [$0bb11e8e9f3a1c4e$export$572954173bc64b66]: \"Transaction would exceed account data limit within the block\",\n    [$0bb11e8e9f3a1c4e$export$7b4a7eebff68ca7b]: \"Transaction would exceed total account data limit\",\n    [$0bb11e8e9f3a1c4e$export$fb693aebffa32676]: \"Transaction would exceed max account limit within the block\",\n    [$0bb11e8e9f3a1c4e$export$5f027a86397cba92]: \"Transaction would exceed max Block Cost Limit\",\n    [$0bb11e8e9f3a1c4e$export$41f13726b04d8d05]: \"Transaction would exceed max Vote Cost Limit\",\n    [$0bb11e8e9f3a1c4e$export$36c2547c3c4d823f]: \"Attempted to sign a transaction with an address that is not a signer for it\",\n    [$0bb11e8e9f3a1c4e$export$819b1b0603d2a966]: \"Transaction is missing an address at index: $index.\",\n    [$0bb11e8e9f3a1c4e$export$de92784c954d1b84]: \"Transaction has no expected signers therefore it cannot be encoded\",\n    [$0bb11e8e9f3a1c4e$export$980469bdb5d5bd4f]: \"Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes\",\n    [$0bb11e8e9f3a1c4e$export$e33d07a7526bded0]: \"Transaction does not have a blockhash lifetime\",\n    [$0bb11e8e9f3a1c4e$export$a20747f749dd4515]: \"Transaction is not a durable nonce transaction\",\n    [$0bb11e8e9f3a1c4e$export$b34a16b8adbffdc1]: \"Contents of these address lookup tables unknown: $lookupTableAddresses\",\n    [$0bb11e8e9f3a1c4e$export$3764bbcfb0679211]: \"Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved\",\n    [$0bb11e8e9f3a1c4e$export$11bea4440904349c]: \"No fee payer set in CompiledTransaction\",\n    [$0bb11e8e9f3a1c4e$export$ed2bdee7953e467f]: \"Could not find program address at index $index\",\n    [$0bb11e8e9f3a1c4e$export$4e4582c633fc423e]: \"Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more\",\n    [$0bb11e8e9f3a1c4e$export$923893d5c076a47c]: \"Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more\",\n    [$0bb11e8e9f3a1c4e$export$592862d1b11e32ac]: \"Transaction is missing a fee payer.\",\n    [$0bb11e8e9f3a1c4e$export$242af5597d94abaf]: \"Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.\",\n    [$0bb11e8e9f3a1c4e$export$bed6f92dafea0623]: \"Transaction first instruction is not advance nonce account instruction.\",\n    [$0bb11e8e9f3a1c4e$export$802b3ebe5297e360]: \"Transaction with no instructions cannot be durable nonce transaction.\",\n    [$0bb11e8e9f3a1c4e$export$694fd435994bcca]: \"This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees\",\n    [$0bb11e8e9f3a1c4e$export$707576ec00ca24d6]: \"This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable\",\n    [$0bb11e8e9f3a1c4e$export$b55a3eb3d894ad9f]: \"The transaction message expected the transaction to have $numRequiredSignatures signatures, got $signaturesLength.\",\n    [$0bb11e8e9f3a1c4e$export$6d61b980429516bd]: \"Transaction is missing signatures for addresses: $addresses.\",\n    [$0bb11e8e9f3a1c4e$export$3963d9bca4091810]: \"Transaction version must be in the range [0, 127]. `$actualVersion` given\",\n    [$0bb11e8e9f3a1c4e$export$8ff97fea1326b6e7]: \"This version of Kit does not support decoding transactions with version $unsupportedVersion. The current max supported version is 0.\",\n    [$0bb11e8e9f3a1c4e$export$204c62c0e8d2efcc]: \"The transaction has a durable nonce lifetime (with nonce `$nonce`), but the nonce account address is in a lookup table. The lifetime constraint cannot be constructed without fetching the lookup tables for the transaction.\"\n};\n// src/message-formatter.ts\nvar $0bb11e8e9f3a1c4e$var$START_INDEX = \"i\";\nvar $0bb11e8e9f3a1c4e$var$TYPE = \"t\";\nfunction $0bb11e8e9f3a1c4e$var$getHumanReadableErrorMessage(code, context = {}) {\n    const messageFormatString = $0bb11e8e9f3a1c4e$var$SolanaErrorMessages[code];\n    if (messageFormatString.length === 0) return \"\";\n    let state;\n    function commitStateUpTo(endIndex) {\n        if (state[$0bb11e8e9f3a1c4e$var$TYPE] === 2 /* Variable */ ) {\n            const variableName = messageFormatString.slice(state[$0bb11e8e9f3a1c4e$var$START_INDEX] + 1, endIndex);\n            fragments.push(variableName in context ? // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            `${context[variableName]}` : `$${variableName}`);\n        } else if (state[$0bb11e8e9f3a1c4e$var$TYPE] === 1 /* Text */ ) fragments.push(messageFormatString.slice(state[$0bb11e8e9f3a1c4e$var$START_INDEX], endIndex));\n    }\n    const fragments = [];\n    messageFormatString.split(\"\").forEach((char, ii)=>{\n        if (ii === 0) {\n            state = {\n                [$0bb11e8e9f3a1c4e$var$START_INDEX]: 0,\n                [$0bb11e8e9f3a1c4e$var$TYPE]: messageFormatString[0] === \"\\\\\" ? 0 /* EscapeSequence */  : messageFormatString[0] === \"$\" ? 2 /* Variable */  : 1 /* Text */ \n            };\n            return;\n        }\n        let nextState;\n        switch(state[$0bb11e8e9f3a1c4e$var$TYPE]){\n            case 0 /* EscapeSequence */ :\n                nextState = {\n                    [$0bb11e8e9f3a1c4e$var$START_INDEX]: ii,\n                    [$0bb11e8e9f3a1c4e$var$TYPE]: 1 /* Text */ \n                };\n                break;\n            case 1 /* Text */ :\n                if (char === \"\\\\\") nextState = {\n                    [$0bb11e8e9f3a1c4e$var$START_INDEX]: ii,\n                    [$0bb11e8e9f3a1c4e$var$TYPE]: 0 /* EscapeSequence */ \n                };\n                else if (char === \"$\") nextState = {\n                    [$0bb11e8e9f3a1c4e$var$START_INDEX]: ii,\n                    [$0bb11e8e9f3a1c4e$var$TYPE]: 2 /* Variable */ \n                };\n                break;\n            case 2 /* Variable */ :\n                if (char === \"\\\\\") nextState = {\n                    [$0bb11e8e9f3a1c4e$var$START_INDEX]: ii,\n                    [$0bb11e8e9f3a1c4e$var$TYPE]: 0 /* EscapeSequence */ \n                };\n                else if (char === \"$\") nextState = {\n                    [$0bb11e8e9f3a1c4e$var$START_INDEX]: ii,\n                    [$0bb11e8e9f3a1c4e$var$TYPE]: 2 /* Variable */ \n                };\n                else if (!char.match(/\\w/)) nextState = {\n                    [$0bb11e8e9f3a1c4e$var$START_INDEX]: ii,\n                    [$0bb11e8e9f3a1c4e$var$TYPE]: 1 /* Text */ \n                };\n                break;\n        }\n        if (nextState) {\n            if (state !== nextState) commitStateUpTo(ii);\n            state = nextState;\n        }\n    });\n    commitStateUpTo();\n    return fragments.join(\"\");\n}\nfunction $0bb11e8e9f3a1c4e$var$getErrorMessage(code, context = {}) {\n    {\n        let decodingAdviceMessage = `Solana error #${code}; Decode this error by running \\`npx @solana/errors decode -- ${code}`;\n        if (Object.keys(context).length) decodingAdviceMessage += ` '${$0bb11e8e9f3a1c4e$var$encodeContextObject(context)}'`;\n        return `${decodingAdviceMessage}\\``;\n    }\n}\n// src/error.ts\nfunction $0bb11e8e9f3a1c4e$export$cfead212e52d9961(e, code) {\n    const isSolanaError2 = e instanceof Error && e.name === \"SolanaError\";\n    if (isSolanaError2) {\n        if (code !== void 0) return e.context.__code === code;\n        return true;\n    }\n    return false;\n}\nvar $0bb11e8e9f3a1c4e$export$8349fd9adaaed269 = class extends Error {\n    /**\n   * Indicates the root cause of this {@link SolanaError}, if any.\n   *\n   * For example, a transaction error might have an instruction error as its root cause. In this\n   * case, you will be able to access the instruction error on the transaction error as `cause`.\n   */ cause = this.cause;\n    /**\n   * Contains context that can assist in understanding or recovering from a {@link SolanaError}.\n   */ context;\n    constructor(...[code, contextAndErrorOptions]){\n        let context;\n        let errorOptions;\n        if (contextAndErrorOptions) Object.entries(Object.getOwnPropertyDescriptors(contextAndErrorOptions)).forEach(([name, descriptor])=>{\n            if (name === \"cause\") errorOptions = {\n                cause: descriptor.value\n            };\n            else {\n                if (context === void 0) context = {};\n                Object.defineProperty(context, name, descriptor);\n            }\n        });\n        const message = $0bb11e8e9f3a1c4e$var$getErrorMessage(code, context);\n        super(message, errorOptions);\n        this.context = context === void 0 ? {} : context;\n        this.context.__code = code;\n        this.name = \"SolanaError\";\n    }\n};\n// src/stack-trace.ts\nfunction $0bb11e8e9f3a1c4e$export$4608fd6508cb51(...args) {\n    if (\"captureStackTrace\" in Error && typeof Error.captureStackTrace === \"function\") Error.captureStackTrace(...args);\n}\n// src/rpc-enum-errors.ts\nfunction $0bb11e8e9f3a1c4e$var$getSolanaErrorFromRpcError({ errorCodeBaseOffset: errorCodeBaseOffset, getErrorContext: getErrorContext, orderedErrorNames: orderedErrorNames, rpcEnumError: rpcEnumError }, constructorOpt) {\n    let rpcErrorName;\n    let rpcErrorContext;\n    if (typeof rpcEnumError === \"string\") rpcErrorName = rpcEnumError;\n    else {\n        rpcErrorName = Object.keys(rpcEnumError)[0];\n        rpcErrorContext = rpcEnumError[rpcErrorName];\n    }\n    const codeOffset = orderedErrorNames.indexOf(rpcErrorName);\n    const errorCode = errorCodeBaseOffset + codeOffset;\n    const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);\n    const err = new $0bb11e8e9f3a1c4e$export$8349fd9adaaed269(errorCode, errorContext);\n    $0bb11e8e9f3a1c4e$export$4608fd6508cb51(err, constructorOpt);\n    return err;\n}\n// src/instruction-error.ts\nvar $0bb11e8e9f3a1c4e$var$ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/program/src/instruction.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    \"GenericError\",\n    \"InvalidArgument\",\n    \"InvalidInstructionData\",\n    \"InvalidAccountData\",\n    \"AccountDataTooSmall\",\n    \"InsufficientFunds\",\n    \"IncorrectProgramId\",\n    \"MissingRequiredSignature\",\n    \"AccountAlreadyInitialized\",\n    \"UninitializedAccount\",\n    \"UnbalancedInstruction\",\n    \"ModifiedProgramId\",\n    \"ExternalAccountLamportSpend\",\n    \"ExternalAccountDataModified\",\n    \"ReadonlyLamportChange\",\n    \"ReadonlyDataModified\",\n    \"DuplicateAccountIndex\",\n    \"ExecutableModified\",\n    \"RentEpochModified\",\n    \"NotEnoughAccountKeys\",\n    \"AccountDataSizeChanged\",\n    \"AccountNotExecutable\",\n    \"AccountBorrowFailed\",\n    \"AccountBorrowOutstanding\",\n    \"DuplicateAccountOutOfSync\",\n    \"Custom\",\n    \"InvalidError\",\n    \"ExecutableDataModified\",\n    \"ExecutableLamportChange\",\n    \"ExecutableAccountNotRentExempt\",\n    \"UnsupportedProgramId\",\n    \"CallDepth\",\n    \"MissingAccount\",\n    \"ReentrancyNotAllowed\",\n    \"MaxSeedLengthExceeded\",\n    \"InvalidSeeds\",\n    \"InvalidRealloc\",\n    \"ComputationalBudgetExceeded\",\n    \"PrivilegeEscalation\",\n    \"ProgramEnvironmentSetupFailure\",\n    \"ProgramFailedToComplete\",\n    \"ProgramFailedToCompile\",\n    \"Immutable\",\n    \"IncorrectAuthority\",\n    \"BorshIoError\",\n    \"AccountNotRentExempt\",\n    \"InvalidAccountOwner\",\n    \"ArithmeticOverflow\",\n    \"UnsupportedSysvar\",\n    \"IllegalOwner\",\n    \"MaxAccountsDataAllocationsExceeded\",\n    \"MaxAccountsExceeded\",\n    \"MaxInstructionTraceLengthExceeded\",\n    \"BuiltinProgramsMustConsumeComputeUnits\"\n];\nfunction $0bb11e8e9f3a1c4e$export$4e38d43e41953f9e(index, instructionError) {\n    const numberIndex = Number(index);\n    return $0bb11e8e9f3a1c4e$var$getSolanaErrorFromRpcError({\n        errorCodeBaseOffset: 4615001,\n        getErrorContext (errorCode, rpcErrorName, rpcErrorContext) {\n            if (errorCode === $0bb11e8e9f3a1c4e$export$d308cb6df5c28ff6) return {\n                errorName: rpcErrorName,\n                index: numberIndex,\n                ...rpcErrorContext !== void 0 ? {\n                    instructionErrorContext: rpcErrorContext\n                } : null\n            };\n            else if (errorCode === $0bb11e8e9f3a1c4e$export$5abe2d1d040bf6cf) return {\n                code: Number(rpcErrorContext),\n                index: numberIndex\n            };\n            else if (errorCode === $0bb11e8e9f3a1c4e$export$57c1675a0c20931f) return {\n                encodedData: rpcErrorContext,\n                index: numberIndex\n            };\n            return {\n                index: numberIndex\n            };\n        },\n        orderedErrorNames: $0bb11e8e9f3a1c4e$var$ORDERED_ERROR_NAMES,\n        rpcEnumError: instructionError\n    }, $0bb11e8e9f3a1c4e$export$4e38d43e41953f9e);\n}\n// src/transaction-error.ts\nvar $0bb11e8e9f3a1c4e$var$ORDERED_ERROR_NAMES2 = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/src/transaction/error.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    \"AccountInUse\",\n    \"AccountLoadedTwice\",\n    \"AccountNotFound\",\n    \"ProgramAccountNotFound\",\n    \"InsufficientFundsForFee\",\n    \"InvalidAccountForFee\",\n    \"AlreadyProcessed\",\n    \"BlockhashNotFound\",\n    // `InstructionError` intentionally omitted; delegated to `getSolanaErrorFromInstructionError`\n    \"CallChainTooDeep\",\n    \"MissingSignatureForFee\",\n    \"InvalidAccountIndex\",\n    \"SignatureFailure\",\n    \"InvalidProgramForExecution\",\n    \"SanitizeFailure\",\n    \"ClusterMaintenance\",\n    \"AccountBorrowOutstanding\",\n    \"WouldExceedMaxBlockCostLimit\",\n    \"UnsupportedVersion\",\n    \"InvalidWritableAccount\",\n    \"WouldExceedMaxAccountCostLimit\",\n    \"WouldExceedAccountDataBlockLimit\",\n    \"TooManyAccountLocks\",\n    \"AddressLookupTableNotFound\",\n    \"InvalidAddressLookupTableOwner\",\n    \"InvalidAddressLookupTableData\",\n    \"InvalidAddressLookupTableIndex\",\n    \"InvalidRentPayingAccount\",\n    \"WouldExceedMaxVoteCostLimit\",\n    \"WouldExceedAccountDataTotalLimit\",\n    \"DuplicateInstruction\",\n    \"InsufficientFundsForRent\",\n    \"MaxLoadedAccountsDataSizeExceeded\",\n    \"InvalidLoadedAccountsDataSizeLimit\",\n    \"ResanitizationNeeded\",\n    \"ProgramExecutionTemporarilyRestricted\",\n    \"UnbalancedTransaction\"\n];\nfunction $0bb11e8e9f3a1c4e$export$c10ce7a2fd9c66f0(transactionError) {\n    if (typeof transactionError === \"object\" && \"InstructionError\" in transactionError) return $0bb11e8e9f3a1c4e$export$4e38d43e41953f9e(...transactionError.InstructionError);\n    return $0bb11e8e9f3a1c4e$var$getSolanaErrorFromRpcError({\n        errorCodeBaseOffset: 7050001,\n        getErrorContext (errorCode, rpcErrorName, rpcErrorContext) {\n            if (errorCode === $0bb11e8e9f3a1c4e$export$8c82dde5b12c9789) return {\n                errorName: rpcErrorName,\n                ...rpcErrorContext !== void 0 ? {\n                    transactionErrorContext: rpcErrorContext\n                } : null\n            };\n            else if (errorCode === $0bb11e8e9f3a1c4e$export$e3a4007020a2e8f5) return {\n                index: Number(rpcErrorContext)\n            };\n            else if (errorCode === $0bb11e8e9f3a1c4e$export$2ecc275dffbc087c || errorCode === $0bb11e8e9f3a1c4e$export$1cd0de5dfcdeb99d) return {\n                accountIndex: Number(rpcErrorContext.account_index)\n            };\n        },\n        orderedErrorNames: $0bb11e8e9f3a1c4e$var$ORDERED_ERROR_NAMES2,\n        rpcEnumError: transactionError\n    }, $0bb11e8e9f3a1c4e$export$c10ce7a2fd9c66f0);\n}\n// src/json-rpc-error.ts\nfunction $0bb11e8e9f3a1c4e$export$1f67f8d128316a6d(putativeErrorResponse) {\n    let out;\n    if ($0bb11e8e9f3a1c4e$var$isRpcErrorResponse(putativeErrorResponse)) {\n        const { code: rawCode, data: data, message: message } = putativeErrorResponse;\n        const code = Number(rawCode);\n        if (code === $0bb11e8e9f3a1c4e$export$426cc73f5ad00f38) {\n            const { err: err, ...preflightErrorContext } = data;\n            const causeObject = err ? {\n                cause: $0bb11e8e9f3a1c4e$export$c10ce7a2fd9c66f0(err)\n            } : null;\n            out = new $0bb11e8e9f3a1c4e$export$8349fd9adaaed269($0bb11e8e9f3a1c4e$export$426cc73f5ad00f38, {\n                ...preflightErrorContext,\n                ...causeObject\n            });\n        } else {\n            let errorContext;\n            switch(code){\n                case $0bb11e8e9f3a1c4e$export$afa40fd3fc01204:\n                case $0bb11e8e9f3a1c4e$export$2981978a530b1a7c:\n                case $0bb11e8e9f3a1c4e$export$23cb4efd59427895:\n                case $0bb11e8e9f3a1c4e$export$5ec955cc8b7e8cf9:\n                case $0bb11e8e9f3a1c4e$export$e09e3905081e44fe:\n                case $0bb11e8e9f3a1c4e$export$1b90c411626421b1:\n                case $0bb11e8e9f3a1c4e$export$6ae475e85fe02aad:\n                case $0bb11e8e9f3a1c4e$export$bfbf8b75e865efa0:\n                case $0bb11e8e9f3a1c4e$export$65235469ebe9845e:\n                case $0bb11e8e9f3a1c4e$export$54dea2286c43ec1e:\n                case $0bb11e8e9f3a1c4e$export$e71fbee92648fc61:\n                case $0bb11e8e9f3a1c4e$export$d21075fd06730e:\n                case $0bb11e8e9f3a1c4e$export$d964b43bb02eacdf:\n                case $0bb11e8e9f3a1c4e$export$f7685139153f9191:\n                    errorContext = {\n                        __serverMessage: message\n                    };\n                    break;\n                default:\n                    if (typeof data === \"object\" && !Array.isArray(data)) errorContext = data;\n            }\n            out = new $0bb11e8e9f3a1c4e$export$8349fd9adaaed269(code, errorContext);\n        }\n    } else {\n        const message = typeof putativeErrorResponse === \"object\" && putativeErrorResponse !== null && \"message\" in putativeErrorResponse && typeof putativeErrorResponse.message === \"string\" ? putativeErrorResponse.message : \"Malformed JSON-RPC error with no message attribute\";\n        out = new $0bb11e8e9f3a1c4e$export$8349fd9adaaed269($0bb11e8e9f3a1c4e$export$1cf7bba40d7d2361, {\n            error: putativeErrorResponse,\n            message: message\n        });\n    }\n    $0bb11e8e9f3a1c4e$export$4608fd6508cb51(out, $0bb11e8e9f3a1c4e$export$1f67f8d128316a6d);\n    return out;\n}\nfunction $0bb11e8e9f3a1c4e$var$isRpcErrorResponse(value) {\n    return typeof value === \"object\" && value !== null && \"code\" in value && \"message\" in value && (typeof value.code === \"number\" || typeof value.code === \"bigint\") && typeof value.message === \"string\";\n}\n //# sourceMappingURL=index.browser.mjs.map\n\n\n// src/add-codec-sentinel.ts\n// src/bytes.ts\nvar $b9bc3aaa401ff82b$export$6cf3317d55598fde = (byteArrays)=>{\n    const nonEmptyByteArrays = byteArrays.filter((arr)=>arr.length);\n    if (nonEmptyByteArrays.length === 0) return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    if (nonEmptyByteArrays.length === 1) return nonEmptyByteArrays[0];\n    const totalLength = nonEmptyByteArrays.reduce((total, arr)=>total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach((arr)=>{\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\nfunction $b9bc3aaa401ff82b$export$4c6b868113605df3(bytes, length) {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n}\nvar $b9bc3aaa401ff82b$export$11b3146a4f4702ef = (bytes, length)=>$b9bc3aaa401ff82b$export$4c6b868113605df3(bytes.length <= length ? bytes : bytes.slice(0, length), length);\nfunction $b9bc3aaa401ff82b$export$1b62aef2a79e6b21(data, bytes, offset) {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i)=>b === slice[i]);\n}\nfunction $b9bc3aaa401ff82b$export$30f3257599397621(value, encoder) {\n    return \"fixedSize\" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\nfunction $b9bc3aaa401ff82b$export$4e76eeb6df88c889(encoder) {\n    return Object.freeze({\n        ...encoder,\n        encode: (value)=>{\n            const bytes = new Uint8Array($b9bc3aaa401ff82b$export$30f3257599397621(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction $b9bc3aaa401ff82b$export$f8c898e83b60faaa(decoder) {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0)=>decoder.read(bytes, offset)[0]\n    });\n}\nfunction $b9bc3aaa401ff82b$export$a4cf2f585987cc8(codec) {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0)=>codec.read(bytes, offset)[0],\n        encode: (value)=>{\n            const bytes = new Uint8Array($b9bc3aaa401ff82b$export$30f3257599397621(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction $b9bc3aaa401ff82b$export$f9d60229c95384d4(codec) {\n    return \"fixedSize\" in codec && typeof codec.fixedSize === \"number\";\n}\nfunction $b9bc3aaa401ff82b$export$4e85b7423fd6bc55(codec) {\n    if (!$b9bc3aaa401ff82b$export$f9d60229c95384d4(codec)) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$93561b31b951410d));\n}\nfunction $b9bc3aaa401ff82b$export$d76fd0b6e42f051a(codec) {\n    return !$b9bc3aaa401ff82b$export$f9d60229c95384d4(codec);\n}\nfunction $b9bc3aaa401ff82b$export$6bf5fc425e413c8a(codec) {\n    if (!$b9bc3aaa401ff82b$export$d76fd0b6e42f051a(codec)) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$3417da5bc6bcb45));\n}\nfunction $b9bc3aaa401ff82b$export$b88681b853abde79(encoder, decoder) {\n    if ($b9bc3aaa401ff82b$export$f9d60229c95384d4(encoder) !== $b9bc3aaa401ff82b$export$f9d60229c95384d4(decoder)) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$c4c73ab3c0833591));\n    if ($b9bc3aaa401ff82b$export$f9d60229c95384d4(encoder) && $b9bc3aaa401ff82b$export$f9d60229c95384d4(decoder) && encoder.fixedSize !== decoder.fixedSize) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$824d79ab1779d517), {\n        decoderFixedSize: decoder.fixedSize,\n        encoderFixedSize: encoder.fixedSize\n    });\n    if (!$b9bc3aaa401ff82b$export$f9d60229c95384d4(encoder) && !$b9bc3aaa401ff82b$export$f9d60229c95384d4(decoder) && encoder.maxSize !== decoder.maxSize) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$c464f3b291f1f3d0), {\n        decoderMaxSize: decoder.maxSize,\n        encoderMaxSize: encoder.maxSize\n    });\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write\n    };\n}\n// src/add-codec-sentinel.ts\nfunction $b9bc3aaa401ff82b$export$e98b1308839de22(encoder, sentinel) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        if ($b9bc3aaa401ff82b$var$findSentinelIndex(encoderBytes, sentinel) >= 0) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$a9282ed13660c9f6), {\n            encodedBytes: encoderBytes,\n            hexEncodedBytes: $b9bc3aaa401ff82b$var$hexBytes(encoderBytes),\n            hexSentinel: $b9bc3aaa401ff82b$var$hexBytes(sentinel),\n            sentinel: sentinel\n        });\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    };\n    if ($b9bc3aaa401ff82b$export$f9d60229c95384d4(encoder)) return $b9bc3aaa401ff82b$export$4e76eeb6df88c889({\n        ...encoder,\n        fixedSize: encoder.fixedSize + sentinel.length,\n        write: write\n    });\n    return $b9bc3aaa401ff82b$export$4e76eeb6df88c889({\n        ...encoder,\n        ...encoder.maxSize != null ? {\n            maxSize: encoder.maxSize + sentinel.length\n        } : {},\n        getSizeFromValue: (value)=>encoder.getSizeFromValue(value) + sentinel.length,\n        write: write\n    });\n}\nfunction $b9bc3aaa401ff82b$export$cdbc1a8bfd8f69c8(decoder, sentinel) {\n    const read = (bytes, offset)=>{\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = $b9bc3aaa401ff82b$var$findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$5bdfee6423bc35ce), {\n            decodedBytes: candidateBytes,\n            hexDecodedBytes: $b9bc3aaa401ff82b$var$hexBytes(candidateBytes),\n            hexSentinel: $b9bc3aaa401ff82b$var$hexBytes(sentinel),\n            sentinel: sentinel\n        });\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        return [\n            decoder.decode(preSentinelBytes),\n            offset + preSentinelBytes.length + sentinel.length\n        ];\n    };\n    if ($b9bc3aaa401ff82b$export$f9d60229c95384d4(decoder)) return $b9bc3aaa401ff82b$export$f8c898e83b60faaa({\n        ...decoder,\n        fixedSize: decoder.fixedSize + sentinel.length,\n        read: read\n    });\n    return $b9bc3aaa401ff82b$export$f8c898e83b60faaa({\n        ...decoder,\n        ...decoder.maxSize != null ? {\n            maxSize: decoder.maxSize + sentinel.length\n        } : {},\n        read: read\n    });\n}\nfunction $b9bc3aaa401ff82b$export$56d7c5070d1e9d9b(codec, sentinel) {\n    return $b9bc3aaa401ff82b$export$b88681b853abde79($b9bc3aaa401ff82b$export$e98b1308839de22(codec, sentinel), $b9bc3aaa401ff82b$export$cdbc1a8bfd8f69c8(codec, sentinel));\n}\nfunction $b9bc3aaa401ff82b$var$findSentinelIndex(bytes, sentinel) {\n    return bytes.findIndex((byte, index, arr)=>{\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return $b9bc3aaa401ff82b$export$1b62aef2a79e6b21(arr, sentinel, index);\n    });\n}\nfunction $b9bc3aaa401ff82b$var$hexBytes(bytes) {\n    return bytes.reduce((str, byte)=>str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction $b9bc3aaa401ff82b$export$bf929351331b7b89(codecDescription, bytes, offset = 0) {\n    if (bytes.length - offset <= 0) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$9c9326ce1e3df40c), {\n        codecDescription: codecDescription\n    });\n}\nfunction $b9bc3aaa401ff82b$export$4a981e7c9ed0b6bf(codecDescription, expected, bytes, offset = 0) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$18fbf24f19efc69b), {\n        bytesLength: bytesLength,\n        codecDescription: codecDescription,\n        expected: expected\n    });\n}\nfunction $b9bc3aaa401ff82b$export$9319e0aa6a4927d2(codecDescription, offset, bytesLength) {\n    if (offset < 0 || offset > bytesLength) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$a617dff403944ec6), {\n        bytesLength: bytesLength,\n        codecDescription: codecDescription,\n        offset: offset\n    });\n}\n// src/add-codec-size-prefix.ts\nfunction $b9bc3aaa401ff82b$export$37e5b12cb5a8d560(encoder, prefix) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    };\n    if ($b9bc3aaa401ff82b$export$f9d60229c95384d4(prefix) && $b9bc3aaa401ff82b$export$f9d60229c95384d4(encoder)) return $b9bc3aaa401ff82b$export$4e76eeb6df88c889({\n        ...encoder,\n        fixedSize: prefix.fixedSize + encoder.fixedSize,\n        write: write\n    });\n    const prefixMaxSize = $b9bc3aaa401ff82b$export$f9d60229c95384d4(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const encoderMaxSize = $b9bc3aaa401ff82b$export$f9d60229c95384d4(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n    return $b9bc3aaa401ff82b$export$4e76eeb6df88c889({\n        ...encoder,\n        ...maxSize !== null ? {\n            maxSize: maxSize\n        } : {},\n        getSizeFromValue: (value)=>{\n            const encoderSize = $b9bc3aaa401ff82b$export$30f3257599397621(value, encoder);\n            return $b9bc3aaa401ff82b$export$30f3257599397621(encoderSize, prefix) + encoderSize;\n        },\n        write: write\n    });\n}\nfunction $b9bc3aaa401ff82b$export$fe2b33c81523b294(decoder, prefix) {\n    const read = (bytes, offset)=>{\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        if (offset > 0 || bytes.length > size) bytes = bytes.slice(offset, offset + size);\n        $b9bc3aaa401ff82b$export$4a981e7c9ed0b6bf(\"addDecoderSizePrefix\", size, bytes);\n        return [\n            decoder.decode(bytes),\n            offset + size\n        ];\n    };\n    if ($b9bc3aaa401ff82b$export$f9d60229c95384d4(prefix) && $b9bc3aaa401ff82b$export$f9d60229c95384d4(decoder)) return $b9bc3aaa401ff82b$export$f8c898e83b60faaa({\n        ...decoder,\n        fixedSize: prefix.fixedSize + decoder.fixedSize,\n        read: read\n    });\n    const prefixMaxSize = $b9bc3aaa401ff82b$export$f9d60229c95384d4(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const decoderMaxSize = $b9bc3aaa401ff82b$export$f9d60229c95384d4(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return $b9bc3aaa401ff82b$export$f8c898e83b60faaa({\n        ...decoder,\n        ...maxSize !== null ? {\n            maxSize: maxSize\n        } : {},\n        read: read\n    });\n}\nfunction $b9bc3aaa401ff82b$export$ec85c1caba397ab2(codec, prefix) {\n    return $b9bc3aaa401ff82b$export$b88681b853abde79($b9bc3aaa401ff82b$export$37e5b12cb5a8d560(codec, prefix), $b9bc3aaa401ff82b$export$fe2b33c81523b294(codec, prefix));\n}\nfunction $b9bc3aaa401ff82b$export$9fde90fcc5ed41ea(decoder) {\n    return $b9bc3aaa401ff82b$export$f8c898e83b60faaa({\n        ...decoder,\n        read (bytes, offset) {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            if (bytes.length > newOffset) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$11a7243580452ad8), {\n                expectedLength: newOffset,\n                numExcessBytes: bytes.length - newOffset\n            });\n            return [\n                value,\n                newOffset\n            ];\n        }\n    });\n}\n// src/fix-codec-size.ts\nfunction $b9bc3aaa401ff82b$export$cbdfce031443a1(encoder, fixedBytes) {\n    return $b9bc3aaa401ff82b$export$4e76eeb6df88c889({\n        fixedSize: fixedBytes,\n        write: (value, bytes, offset)=>{\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        }\n    });\n}\nfunction $b9bc3aaa401ff82b$export$1f85f8b8d2788007(decoder, fixedBytes) {\n    return $b9bc3aaa401ff82b$export$f8c898e83b60faaa({\n        fixedSize: fixedBytes,\n        read: (bytes, offset)=>{\n            $b9bc3aaa401ff82b$export$4a981e7c9ed0b6bf(\"fixCodecSize\", fixedBytes, bytes, offset);\n            if (offset > 0 || bytes.length > fixedBytes) bytes = bytes.slice(offset, offset + fixedBytes);\n            if ($b9bc3aaa401ff82b$export$f9d60229c95384d4(decoder)) bytes = $b9bc3aaa401ff82b$export$11b3146a4f4702ef(bytes, decoder.fixedSize);\n            const [value] = decoder.read(bytes, 0);\n            return [\n                value,\n                offset + fixedBytes\n            ];\n        }\n    });\n}\nfunction $b9bc3aaa401ff82b$export$ff7dc697d5cc308f(codec, fixedBytes) {\n    return $b9bc3aaa401ff82b$export$b88681b853abde79($b9bc3aaa401ff82b$export$cbdfce031443a1(codec, fixedBytes), $b9bc3aaa401ff82b$export$1f85f8b8d2788007(codec, fixedBytes));\n}\n// src/offset-codec.ts\nfunction $b9bc3aaa401ff82b$export$92407871fbff8926(encoder, config) {\n    return $b9bc3aaa401ff82b$export$4e76eeb6df88c889({\n        ...encoder,\n        write: (value, bytes, preOffset)=>{\n            const wrapBytes = (offset)=>$b9bc3aaa401ff82b$var$modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes: bytes,\n                preOffset: preOffset,\n                wrapBytes: wrapBytes\n            }) : preOffset;\n            $b9bc3aaa401ff82b$export$9319e0aa6a4927d2(\"offsetEncoder\", newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes: bytes,\n                newPreOffset: newPreOffset,\n                postOffset: postOffset,\n                preOffset: preOffset,\n                wrapBytes: wrapBytes\n            }) : postOffset;\n            $b9bc3aaa401ff82b$export$9319e0aa6a4927d2(\"offsetEncoder\", newPostOffset, bytes.length);\n            return newPostOffset;\n        }\n    });\n}\nfunction $b9bc3aaa401ff82b$export$24667feddece166a(decoder, config) {\n    return $b9bc3aaa401ff82b$export$f8c898e83b60faaa({\n        ...decoder,\n        read: (bytes, preOffset)=>{\n            const wrapBytes = (offset)=>$b9bc3aaa401ff82b$var$modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes: bytes,\n                preOffset: preOffset,\n                wrapBytes: wrapBytes\n            }) : preOffset;\n            $b9bc3aaa401ff82b$export$9319e0aa6a4927d2(\"offsetDecoder\", newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes: bytes,\n                newPreOffset: newPreOffset,\n                postOffset: postOffset,\n                preOffset: preOffset,\n                wrapBytes: wrapBytes\n            }) : postOffset;\n            $b9bc3aaa401ff82b$export$9319e0aa6a4927d2(\"offsetDecoder\", newPostOffset, bytes.length);\n            return [\n                value,\n                newPostOffset\n            ];\n        }\n    });\n}\nfunction $b9bc3aaa401ff82b$export$8170ddca0f3f53ea(codec, config) {\n    return $b9bc3aaa401ff82b$export$b88681b853abde79($b9bc3aaa401ff82b$export$92407871fbff8926(codec, config), $b9bc3aaa401ff82b$export$24667feddece166a(codec, config));\n}\nfunction $b9bc3aaa401ff82b$var$modulo(dividend, divisor) {\n    if (divisor === 0) return 0;\n    return (dividend % divisor + divisor) % divisor;\n}\nfunction $b9bc3aaa401ff82b$export$d41c2ca858573bc6(encoder, resize) {\n    if ($b9bc3aaa401ff82b$export$f9d60229c95384d4(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$4c1fcb4bd20b2951), {\n            bytesLength: fixedSize,\n            codecDescription: \"resizeEncoder\"\n        });\n        return $b9bc3aaa401ff82b$export$4e76eeb6df88c889({\n            ...encoder,\n            fixedSize: fixedSize\n        });\n    }\n    return $b9bc3aaa401ff82b$export$4e76eeb6df88c889({\n        ...encoder,\n        getSizeFromValue: (value)=>{\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$4c1fcb4bd20b2951), {\n                bytesLength: newSize,\n                codecDescription: \"resizeEncoder\"\n            });\n            return newSize;\n        }\n    });\n}\nfunction $b9bc3aaa401ff82b$export$7369e12a03366140(decoder, resize) {\n    if ($b9bc3aaa401ff82b$export$f9d60229c95384d4(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$4c1fcb4bd20b2951), {\n            bytesLength: fixedSize,\n            codecDescription: \"resizeDecoder\"\n        });\n        return $b9bc3aaa401ff82b$export$f8c898e83b60faaa({\n            ...decoder,\n            fixedSize: fixedSize\n        });\n    }\n    return decoder;\n}\nfunction $b9bc3aaa401ff82b$export$aff234b7657ae683(codec, resize) {\n    return $b9bc3aaa401ff82b$export$b88681b853abde79($b9bc3aaa401ff82b$export$d41c2ca858573bc6(codec, resize), $b9bc3aaa401ff82b$export$7369e12a03366140(codec, resize));\n}\n// src/pad-codec.ts\nfunction $b9bc3aaa401ff82b$export$66b1746799cd3030(encoder, offset) {\n    return $b9bc3aaa401ff82b$export$92407871fbff8926($b9bc3aaa401ff82b$export$d41c2ca858573bc6(encoder, (size)=>size + offset), {\n        preOffset: ({ preOffset: preOffset })=>preOffset + offset\n    });\n}\nfunction $b9bc3aaa401ff82b$export$770586d1e6f1e5b(encoder, offset) {\n    return $b9bc3aaa401ff82b$export$92407871fbff8926($b9bc3aaa401ff82b$export$d41c2ca858573bc6(encoder, (size)=>size + offset), {\n        postOffset: ({ postOffset: postOffset })=>postOffset + offset\n    });\n}\nfunction $b9bc3aaa401ff82b$export$d88f5bbaa5c2e177(decoder, offset) {\n    return $b9bc3aaa401ff82b$export$24667feddece166a($b9bc3aaa401ff82b$export$7369e12a03366140(decoder, (size)=>size + offset), {\n        preOffset: ({ preOffset: preOffset })=>preOffset + offset\n    });\n}\nfunction $b9bc3aaa401ff82b$export$57a7baba87e0aed9(decoder, offset) {\n    return $b9bc3aaa401ff82b$export$24667feddece166a($b9bc3aaa401ff82b$export$7369e12a03366140(decoder, (size)=>size + offset), {\n        postOffset: ({ postOffset: postOffset })=>postOffset + offset\n    });\n}\nfunction $b9bc3aaa401ff82b$export$d6ed5bbf596a5505(codec, offset) {\n    return $b9bc3aaa401ff82b$export$b88681b853abde79($b9bc3aaa401ff82b$export$66b1746799cd3030(codec, offset), $b9bc3aaa401ff82b$export$d88f5bbaa5c2e177(codec, offset));\n}\nfunction $b9bc3aaa401ff82b$export$b11ce69168faaa31(codec, offset) {\n    return $b9bc3aaa401ff82b$export$b88681b853abde79($b9bc3aaa401ff82b$export$770586d1e6f1e5b(codec, offset), $b9bc3aaa401ff82b$export$57a7baba87e0aed9(codec, offset));\n}\n// src/reverse-codec.ts\nfunction $b9bc3aaa401ff82b$var$copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {\n    while(sourceOffset < --sourceLength){\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n}\nfunction $b9bc3aaa401ff82b$export$290b4b66fdcc682c(encoder) {\n    $b9bc3aaa401ff82b$export$4e85b7423fd6bc55(encoder);\n    return $b9bc3aaa401ff82b$export$4e76eeb6df88c889({\n        ...encoder,\n        write: (value, bytes, offset)=>{\n            const newOffset = encoder.write(value, bytes, offset);\n            $b9bc3aaa401ff82b$var$copySourceToTargetInReverse(bytes, bytes, offset, offset + encoder.fixedSize);\n            return newOffset;\n        }\n    });\n}\nfunction $b9bc3aaa401ff82b$export$1dded7e9fb3087ff(decoder) {\n    $b9bc3aaa401ff82b$export$4e85b7423fd6bc55(decoder);\n    return $b9bc3aaa401ff82b$export$f8c898e83b60faaa({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const reversedBytes = bytes.slice();\n            $b9bc3aaa401ff82b$var$copySourceToTargetInReverse(bytes, reversedBytes, offset, offset + decoder.fixedSize);\n            return decoder.read(reversedBytes, offset);\n        }\n    });\n}\nfunction $b9bc3aaa401ff82b$export$e1ef688f83355e2e(codec) {\n    return $b9bc3aaa401ff82b$export$b88681b853abde79($b9bc3aaa401ff82b$export$290b4b66fdcc682c(codec), $b9bc3aaa401ff82b$export$1dded7e9fb3087ff(codec));\n}\n// src/transform-codec.ts\nfunction $b9bc3aaa401ff82b$export$30169aca64409a56(encoder, unmap) {\n    return $b9bc3aaa401ff82b$export$4e76eeb6df88c889({\n        ...$b9bc3aaa401ff82b$export$d76fd0b6e42f051a(encoder) ? {\n            ...encoder,\n            getSizeFromValue: (value)=>encoder.getSizeFromValue(unmap(value))\n        } : encoder,\n        write: (value, bytes, offset)=>encoder.write(unmap(value), bytes, offset)\n    });\n}\nfunction $b9bc3aaa401ff82b$export$605b10ee38669daa(decoder, map) {\n    return $b9bc3aaa401ff82b$export$f8c898e83b60faaa({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [\n                map(value, bytes, offset),\n                newOffset\n            ];\n        }\n    });\n}\nfunction $b9bc3aaa401ff82b$export$59b20038bbe52b5f(codec, unmap, map) {\n    return $b9bc3aaa401ff82b$export$a4cf2f585987cc8({\n        ...$b9bc3aaa401ff82b$export$30169aca64409a56(codec, unmap),\n        read: map ? $b9bc3aaa401ff82b$export$605b10ee38669daa(codec, map).read : codec.read\n    });\n}\n //# sourceMappingURL=index.browser.mjs.map\n\n\n\n\n// src/assertions.ts\nfunction $b5f941eb9a28d328$export$50ab5941a148d055(codecDescription, min, max, value) {\n    if (value < min || value > max) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$8653c145864f47f4), {\n        codecDescription: codecDescription,\n        max: max,\n        min: min,\n        value: value\n    });\n}\n// src/common.ts\nvar $b5f941eb9a28d328$export$54493dce0da47833 = /* @__PURE__ */ ((Endian2)=>{\n    Endian2[Endian2[\"Little\"] = 0] = \"Little\";\n    Endian2[Endian2[\"Big\"] = 1] = \"Big\";\n    return Endian2;\n})($b5f941eb9a28d328$export$54493dce0da47833 || {});\nfunction $b5f941eb9a28d328$var$isLittleEndian(config) {\n    return config?.endian === 1 /* Big */  ? false : true;\n}\nfunction $b5f941eb9a28d328$var$numberEncoderFactory(input) {\n    return (0, $b9bc3aaa401ff82b$export$4e76eeb6df88c889)({\n        fixedSize: input.size,\n        write (value, bytes, offset) {\n            if (input.range) $b5f941eb9a28d328$export$50ab5941a148d055(input.name, input.range[0], input.range[1], value);\n            const arrayBuffer = new ArrayBuffer(input.size);\n            input.set(new DataView(arrayBuffer), value, $b5f941eb9a28d328$var$isLittleEndian(input.config));\n            bytes.set(new Uint8Array(arrayBuffer), offset);\n            return offset + input.size;\n        }\n    });\n}\nfunction $b5f941eb9a28d328$var$numberDecoderFactory(input) {\n    return (0, $b9bc3aaa401ff82b$export$f8c898e83b60faaa)({\n        fixedSize: input.size,\n        read (bytes, offset = 0) {\n            (0, $b9bc3aaa401ff82b$export$bf929351331b7b89)(input.name, bytes, offset);\n            (0, $b9bc3aaa401ff82b$export$4a981e7c9ed0b6bf)(input.name, input.size, bytes, offset);\n            const view = new DataView($b5f941eb9a28d328$var$toArrayBuffer(bytes, offset, input.size));\n            return [\n                input.get(view, $b5f941eb9a28d328$var$isLittleEndian(input.config)),\n                offset + input.size\n            ];\n        }\n    });\n}\nfunction $b5f941eb9a28d328$var$toArrayBuffer(bytes, offset, length) {\n    const bytesOffset = bytes.byteOffset + (offset ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n// src/f32.ts\nvar $b5f941eb9a28d328$export$d76ef1cfec201bc9 = (config = {})=>$b5f941eb9a28d328$var$numberEncoderFactory({\n        config: config,\n        name: \"f32\",\n        set: (view, value, le)=>view.setFloat32(0, Number(value), le),\n        size: 4\n    });\nvar $b5f941eb9a28d328$export$314df11445cfa5d0 = (config = {})=>$b5f941eb9a28d328$var$numberDecoderFactory({\n        config: config,\n        get: (view, le)=>view.getFloat32(0, le),\n        name: \"f32\",\n        size: 4\n    });\nvar $b5f941eb9a28d328$export$97a035f0564c51de = (config = {})=>(0, $b9bc3aaa401ff82b$export$b88681b853abde79)($b5f941eb9a28d328$export$d76ef1cfec201bc9(config), $b5f941eb9a28d328$export$314df11445cfa5d0(config));\nvar $b5f941eb9a28d328$export$551368d522177b99 = (config = {})=>$b5f941eb9a28d328$var$numberEncoderFactory({\n        config: config,\n        name: \"f64\",\n        set: (view, value, le)=>view.setFloat64(0, Number(value), le),\n        size: 8\n    });\nvar $b5f941eb9a28d328$export$9475ae45ddf86dec = (config = {})=>$b5f941eb9a28d328$var$numberDecoderFactory({\n        config: config,\n        get: (view, le)=>view.getFloat64(0, le),\n        name: \"f64\",\n        size: 8\n    });\nvar $b5f941eb9a28d328$export$9db82e6fbf3ec8ac = (config = {})=>(0, $b9bc3aaa401ff82b$export$b88681b853abde79)($b5f941eb9a28d328$export$551368d522177b99(config), $b5f941eb9a28d328$export$9475ae45ddf86dec(config));\nvar $b5f941eb9a28d328$export$cf7587f741407205 = (config = {})=>$b5f941eb9a28d328$var$numberEncoderFactory({\n        config: config,\n        name: \"i128\",\n        range: [\n            -BigInt(\"0x7fffffffffffffffffffffffffffffff\") - 1n,\n            BigInt(\"0x7fffffffffffffffffffffffffffffff\")\n        ],\n        set: (view, value, le)=>{\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16\n    });\nvar $b5f941eb9a28d328$export$aacd18c97984700c = (config = {})=>$b5f941eb9a28d328$var$numberDecoderFactory({\n        config: config,\n        get: (view, le)=>{\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigInt64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: \"i128\",\n        size: 16\n    });\nvar $b5f941eb9a28d328$export$b2a180b15845f643 = (config = {})=>(0, $b9bc3aaa401ff82b$export$b88681b853abde79)($b5f941eb9a28d328$export$cf7587f741407205(config), $b5f941eb9a28d328$export$aacd18c97984700c(config));\nvar $b5f941eb9a28d328$export$45d575c12b2bb6a5 = (config = {})=>$b5f941eb9a28d328$var$numberEncoderFactory({\n        config: config,\n        name: \"i16\",\n        range: [\n            -Number(\"0x7fff\") - 1,\n            Number(\"0x7fff\")\n        ],\n        set: (view, value, le)=>view.setInt16(0, Number(value), le),\n        size: 2\n    });\nvar $b5f941eb9a28d328$export$4617ff1e22909f4 = (config = {})=>$b5f941eb9a28d328$var$numberDecoderFactory({\n        config: config,\n        get: (view, le)=>view.getInt16(0, le),\n        name: \"i16\",\n        size: 2\n    });\nvar $b5f941eb9a28d328$export$c82cd783a714bca2 = (config = {})=>(0, $b9bc3aaa401ff82b$export$b88681b853abde79)($b5f941eb9a28d328$export$45d575c12b2bb6a5(config), $b5f941eb9a28d328$export$4617ff1e22909f4(config));\nvar $b5f941eb9a28d328$export$73a58a16e77bb58b = (config = {})=>$b5f941eb9a28d328$var$numberEncoderFactory({\n        config: config,\n        name: \"i32\",\n        range: [\n            -Number(\"0x7fffffff\") - 1,\n            Number(\"0x7fffffff\")\n        ],\n        set: (view, value, le)=>view.setInt32(0, Number(value), le),\n        size: 4\n    });\nvar $b5f941eb9a28d328$export$a7167d44cb5c65b9 = (config = {})=>$b5f941eb9a28d328$var$numberDecoderFactory({\n        config: config,\n        get: (view, le)=>view.getInt32(0, le),\n        name: \"i32\",\n        size: 4\n    });\nvar $b5f941eb9a28d328$export$c31d2e083195a86f = (config = {})=>(0, $b9bc3aaa401ff82b$export$b88681b853abde79)($b5f941eb9a28d328$export$73a58a16e77bb58b(config), $b5f941eb9a28d328$export$a7167d44cb5c65b9(config));\nvar $b5f941eb9a28d328$export$42b58a304e7edd67 = (config = {})=>$b5f941eb9a28d328$var$numberEncoderFactory({\n        config: config,\n        name: \"i64\",\n        range: [\n            -BigInt(\"0x7fffffffffffffff\") - 1n,\n            BigInt(\"0x7fffffffffffffff\")\n        ],\n        set: (view, value, le)=>view.setBigInt64(0, BigInt(value), le),\n        size: 8\n    });\nvar $b5f941eb9a28d328$export$6f14c9b3a349f404 = (config = {})=>$b5f941eb9a28d328$var$numberDecoderFactory({\n        config: config,\n        get: (view, le)=>view.getBigInt64(0, le),\n        name: \"i64\",\n        size: 8\n    });\nvar $b5f941eb9a28d328$export$ebdc4dbdba726e6a = (config = {})=>(0, $b9bc3aaa401ff82b$export$b88681b853abde79)($b5f941eb9a28d328$export$42b58a304e7edd67(config), $b5f941eb9a28d328$export$6f14c9b3a349f404(config));\nvar $b5f941eb9a28d328$export$44792a8c35b3c0ce = ()=>$b5f941eb9a28d328$var$numberEncoderFactory({\n        name: \"i8\",\n        range: [\n            -Number(\"0x7f\") - 1,\n            Number(\"0x7f\")\n        ],\n        set: (view, value)=>view.setInt8(0, Number(value)),\n        size: 1\n    });\nvar $b5f941eb9a28d328$export$fdc22c4a59dfe6be = ()=>$b5f941eb9a28d328$var$numberDecoderFactory({\n        get: (view)=>view.getInt8(0),\n        name: \"i8\",\n        size: 1\n    });\nvar $b5f941eb9a28d328$export$f930a8952cfab173 = ()=>(0, $b9bc3aaa401ff82b$export$b88681b853abde79)($b5f941eb9a28d328$export$44792a8c35b3c0ce(), $b5f941eb9a28d328$export$fdc22c4a59dfe6be());\nvar $b5f941eb9a28d328$export$6f025a6ce2a023fc = ()=>(0, $b9bc3aaa401ff82b$export$4e76eeb6df88c889)({\n        getSizeFromValue: (value)=>{\n            if (value <= 127) return 1;\n            if (value <= 16383) return 2;\n            return 3;\n        },\n        maxSize: 3,\n        write: (value, bytes, offset)=>{\n            $b5f941eb9a28d328$export$50ab5941a148d055(\"shortU16\", 0, 65535, value);\n            const shortU16Bytes = [\n                0\n            ];\n            for(let ii = 0;; ii += 1){\n                const alignedValue = Number(value) >> ii * 7;\n                if (alignedValue === 0) break;\n                const nextSevenBits = 127 & alignedValue;\n                shortU16Bytes[ii] = nextSevenBits;\n                if (ii > 0) shortU16Bytes[ii - 1] |= 128;\n            }\n            bytes.set(shortU16Bytes, offset);\n            return offset + shortU16Bytes.length;\n        }\n    });\nvar $b5f941eb9a28d328$export$fa35aa457fb08b4a = ()=>(0, $b9bc3aaa401ff82b$export$f8c898e83b60faaa)({\n        maxSize: 3,\n        read: (bytes, offset)=>{\n            let value = 0;\n            let byteCount = 0;\n            while(++byteCount){\n                const byteIndex = byteCount - 1;\n                const currentByte = bytes[offset + byteIndex];\n                const nextSevenBits = 127 & currentByte;\n                value |= nextSevenBits << byteIndex * 7;\n                if ((currentByte & 128) === 0) break;\n            }\n            return [\n                value,\n                offset + byteCount\n            ];\n        }\n    });\nvar $b5f941eb9a28d328$export$9f6b1d6c8cda8e31 = ()=>(0, $b9bc3aaa401ff82b$export$b88681b853abde79)($b5f941eb9a28d328$export$6f025a6ce2a023fc(), $b5f941eb9a28d328$export$fa35aa457fb08b4a());\nvar $b5f941eb9a28d328$export$3333225663a8d6bb = (config = {})=>$b5f941eb9a28d328$var$numberEncoderFactory({\n        config: config,\n        name: \"u128\",\n        range: [\n            0n,\n            BigInt(\"0xffffffffffffffffffffffffffffffff\")\n        ],\n        set: (view, value, le)=>{\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16\n    });\nvar $b5f941eb9a28d328$export$523e33537e060693 = (config = {})=>$b5f941eb9a28d328$var$numberDecoderFactory({\n        config: config,\n        get: (view, le)=>{\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigUint64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: \"u128\",\n        size: 16\n    });\nvar $b5f941eb9a28d328$export$e775878beaafab29 = (config = {})=>(0, $b9bc3aaa401ff82b$export$b88681b853abde79)($b5f941eb9a28d328$export$3333225663a8d6bb(config), $b5f941eb9a28d328$export$523e33537e060693(config));\nvar $b5f941eb9a28d328$export$e156211d06496a2f = (config = {})=>$b5f941eb9a28d328$var$numberEncoderFactory({\n        config: config,\n        name: \"u16\",\n        range: [\n            0,\n            Number(\"0xffff\")\n        ],\n        set: (view, value, le)=>view.setUint16(0, Number(value), le),\n        size: 2\n    });\nvar $b5f941eb9a28d328$export$1a649eb0055ac058 = (config = {})=>$b5f941eb9a28d328$var$numberDecoderFactory({\n        config: config,\n        get: (view, le)=>view.getUint16(0, le),\n        name: \"u16\",\n        size: 2\n    });\nvar $b5f941eb9a28d328$export$dda1212c8afd5e5c = (config = {})=>(0, $b9bc3aaa401ff82b$export$b88681b853abde79)($b5f941eb9a28d328$export$e156211d06496a2f(config), $b5f941eb9a28d328$export$1a649eb0055ac058(config));\nvar $b5f941eb9a28d328$export$3e3136013a349951 = (config = {})=>$b5f941eb9a28d328$var$numberEncoderFactory({\n        config: config,\n        name: \"u32\",\n        range: [\n            0,\n            Number(\"0xffffffff\")\n        ],\n        set: (view, value, le)=>view.setUint32(0, Number(value), le),\n        size: 4\n    });\nvar $b5f941eb9a28d328$export$ddc26825031b1ac9 = (config = {})=>$b5f941eb9a28d328$var$numberDecoderFactory({\n        config: config,\n        get: (view, le)=>view.getUint32(0, le),\n        name: \"u32\",\n        size: 4\n    });\nvar $b5f941eb9a28d328$export$172bf721fe9bbfd1 = (config = {})=>(0, $b9bc3aaa401ff82b$export$b88681b853abde79)($b5f941eb9a28d328$export$3e3136013a349951(config), $b5f941eb9a28d328$export$ddc26825031b1ac9(config));\nvar $b5f941eb9a28d328$export$59d3bc8d559487ec = (config = {})=>$b5f941eb9a28d328$var$numberEncoderFactory({\n        config: config,\n        name: \"u64\",\n        range: [\n            0n,\n            BigInt(\"0xffffffffffffffff\")\n        ],\n        set: (view, value, le)=>view.setBigUint64(0, BigInt(value), le),\n        size: 8\n    });\nvar $b5f941eb9a28d328$export$faa05ffebebd465d = (config = {})=>$b5f941eb9a28d328$var$numberDecoderFactory({\n        config: config,\n        get: (view, le)=>view.getBigUint64(0, le),\n        name: \"u64\",\n        size: 8\n    });\nvar $b5f941eb9a28d328$export$7e56ec13f6029ccc = (config = {})=>(0, $b9bc3aaa401ff82b$export$b88681b853abde79)($b5f941eb9a28d328$export$59d3bc8d559487ec(config), $b5f941eb9a28d328$export$faa05ffebebd465d(config));\nvar $b5f941eb9a28d328$export$dc9732115561fb4b = ()=>$b5f941eb9a28d328$var$numberEncoderFactory({\n        name: \"u8\",\n        range: [\n            0,\n            Number(\"0xff\")\n        ],\n        set: (view, value)=>view.setUint8(0, Number(value)),\n        size: 1\n    });\nvar $b5f941eb9a28d328$export$edadf68f5f1a8bc6 = ()=>$b5f941eb9a28d328$var$numberDecoderFactory({\n        get: (view)=>view.getUint8(0),\n        name: \"u8\",\n        size: 1\n    });\nvar $b5f941eb9a28d328$export$5ae2d5c46a10d97 = ()=>(0, $b9bc3aaa401ff82b$export$b88681b853abde79)($b5f941eb9a28d328$export$dc9732115561fb4b(), $b5f941eb9a28d328$export$edadf68f5f1a8bc6());\n //# sourceMappingURL=index.browser.mjs.map\n\n\n\n// src/array.ts\nfunction $991819a0aa439d56$export$1e6cff54ac72b1a3(codecDescription, expected, actual) {\n    if (expected !== actual) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$c04710d31ef4d278), {\n        actual: actual,\n        codecDescription: codecDescription,\n        expected: expected\n    });\n}\nfunction $991819a0aa439d56$var$maxCodecSizes(sizes) {\n    return sizes.reduce((all, size)=>all === null || size === null ? null : Math.max(all, size), 0);\n}\nfunction $991819a0aa439d56$var$sumCodecSizes(sizes) {\n    return sizes.reduce((all, size)=>all === null || size === null ? null : all + size, 0);\n}\nfunction $991819a0aa439d56$var$getFixedSize(codec) {\n    return (0, $b9bc3aaa401ff82b$export$f9d60229c95384d4)(codec) ? codec.fixedSize : null;\n}\nfunction $991819a0aa439d56$var$getMaxSize(codec) {\n    return (0, $b9bc3aaa401ff82b$export$f9d60229c95384d4)(codec) ? codec.fixedSize : codec.maxSize ?? null;\n}\n// src/array.ts\nfunction $991819a0aa439d56$export$415199198053c0b(item, config = {}) {\n    const size = config.size ?? (0, $b5f941eb9a28d328$export$3e3136013a349951)();\n    const fixedSize = $991819a0aa439d56$var$computeArrayLikeCodecSize(size, $991819a0aa439d56$var$getFixedSize(item));\n    const maxSize = $991819a0aa439d56$var$computeArrayLikeCodecSize(size, $991819a0aa439d56$var$getMaxSize(item)) ?? void 0;\n    return (0, $b9bc3aaa401ff82b$export$4e76eeb6df88c889)({\n        ...fixedSize !== null ? {\n            fixedSize: fixedSize\n        } : {\n            getSizeFromValue: (array)=>{\n                const prefixSize = typeof size === \"object\" ? (0, $b9bc3aaa401ff82b$export$30f3257599397621)(array.length, size) : 0;\n                return prefixSize + [\n                    ...array\n                ].reduce((all, value)=>all + (0, $b9bc3aaa401ff82b$export$30f3257599397621)(value, item), 0);\n            },\n            maxSize: maxSize\n        },\n        write: (array, bytes, offset)=>{\n            if (typeof size === \"number\") $991819a0aa439d56$export$1e6cff54ac72b1a3(\"array\", size, array.length);\n            if (typeof size === \"object\") offset = size.write(array.length, bytes, offset);\n            array.forEach((value)=>{\n                offset = item.write(value, bytes, offset);\n            });\n            return offset;\n        }\n    });\n}\nfunction $991819a0aa439d56$export$9016038b2e3b0c2f(item, config = {}) {\n    const size = config.size ?? (0, $b5f941eb9a28d328$export$ddc26825031b1ac9)();\n    const itemSize = $991819a0aa439d56$var$getFixedSize(item);\n    const fixedSize = $991819a0aa439d56$var$computeArrayLikeCodecSize(size, itemSize);\n    const maxSize = $991819a0aa439d56$var$computeArrayLikeCodecSize(size, $991819a0aa439d56$var$getMaxSize(item)) ?? void 0;\n    return (0, $b9bc3aaa401ff82b$export$f8c898e83b60faaa)({\n        ...fixedSize !== null ? {\n            fixedSize: fixedSize\n        } : {\n            maxSize: maxSize\n        },\n        read: (bytes, offset)=>{\n            const array = [];\n            if (typeof size === \"object\" && bytes.slice(offset).length === 0) return [\n                array,\n                offset\n            ];\n            if (size === \"remainder\") {\n                while(offset < bytes.length){\n                    const [value, newOffset2] = item.read(bytes, offset);\n                    offset = newOffset2;\n                    array.push(value);\n                }\n                return [\n                    array,\n                    offset\n                ];\n            }\n            const [resolvedSize, newOffset] = typeof size === \"number\" ? [\n                size,\n                offset\n            ] : size.read(bytes, offset);\n            offset = newOffset;\n            for(let i = 0; i < resolvedSize; i += 1){\n                const [value, newOffset2] = item.read(bytes, offset);\n                offset = newOffset2;\n                array.push(value);\n            }\n            return [\n                array,\n                offset\n            ];\n        }\n    });\n}\nfunction $991819a0aa439d56$export$8390591075c4b219(item, config = {}) {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($991819a0aa439d56$export$415199198053c0b(item, config), $991819a0aa439d56$export$9016038b2e3b0c2f(item, config));\n}\nfunction $991819a0aa439d56$var$computeArrayLikeCodecSize(size, itemSize) {\n    if (typeof size !== \"number\") return null;\n    if (size === 0) return 0;\n    return itemSize === null ? null : itemSize * size;\n}\nfunction $991819a0aa439d56$export$f0392815667c42f2(size, config = {}) {\n    const parsedConfig = typeof config === \"boolean\" ? {\n        backward: config\n    } : config;\n    const backward = parsedConfig.backward ?? false;\n    return (0, $b9bc3aaa401ff82b$export$4e76eeb6df88c889)({\n        fixedSize: size,\n        write (value, bytes, offset) {\n            const bytesToAdd = [];\n            for(let i = 0; i < size; i += 1){\n                let byte = 0;\n                for(let j = 0; j < 8; j += 1){\n                    const feature = Number(value[i * 8 + j] ?? 0);\n                    byte |= feature << (backward ? j : 7 - j);\n                }\n                if (backward) bytesToAdd.unshift(byte);\n                else bytesToAdd.push(byte);\n            }\n            bytes.set(bytesToAdd, offset);\n            return size;\n        }\n    });\n}\nfunction $991819a0aa439d56$export$5b3f10dd092d835b(size, config = {}) {\n    const parsedConfig = typeof config === \"boolean\" ? {\n        backward: config\n    } : config;\n    const backward = parsedConfig.backward ?? false;\n    return (0, $b9bc3aaa401ff82b$export$f8c898e83b60faaa)({\n        fixedSize: size,\n        read (bytes, offset) {\n            (0, $b9bc3aaa401ff82b$export$4a981e7c9ed0b6bf)(\"bitArray\", size, bytes, offset);\n            const booleans = [];\n            let slice = bytes.slice(offset, offset + size);\n            slice = backward ? slice.reverse() : slice;\n            slice.forEach((byte)=>{\n                for(let i = 0; i < 8; i += 1)if (backward) {\n                    booleans.push(Boolean(byte & 1));\n                    byte >>= 1;\n                } else {\n                    booleans.push(Boolean(byte & 128));\n                    byte <<= 1;\n                }\n            });\n            return [\n                booleans,\n                offset + size\n            ];\n        }\n    });\n}\nfunction $991819a0aa439d56$export$eb1097a7c4c3befd(size, config = {}) {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($991819a0aa439d56$export$f0392815667c42f2(size, config), $991819a0aa439d56$export$5b3f10dd092d835b(size, config));\n}\nfunction $991819a0aa439d56$export$4a518d3f98f842eb(config = {}) {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)(config.size ?? (0, $b5f941eb9a28d328$export$dc9732115561fb4b)(), (value)=>value ? 1 : 0);\n}\nfunction $991819a0aa439d56$export$43a73c742ad521e1(config = {}) {\n    return (0, $b9bc3aaa401ff82b$export$605b10ee38669daa)(config.size ?? (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)(), (value)=>Number(value) === 1);\n}\nfunction $991819a0aa439d56$export$3071f075392d1897(config = {}) {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($991819a0aa439d56$export$4a518d3f98f842eb(config), $991819a0aa439d56$export$43a73c742ad521e1(config));\n}\nfunction $991819a0aa439d56$export$636c51ad84d0674a() {\n    return (0, $b9bc3aaa401ff82b$export$4e76eeb6df88c889)({\n        getSizeFromValue: (value)=>value.length,\n        write: (value, bytes, offset)=>{\n            bytes.set(value, offset);\n            return offset + value.length;\n        }\n    });\n}\nfunction $991819a0aa439d56$export$b90e67818b1b3d45() {\n    return (0, $b9bc3aaa401ff82b$export$f8c898e83b60faaa)({\n        read: (bytes, offset)=>{\n            const slice = bytes.slice(offset);\n            return [\n                slice,\n                offset + slice.length\n            ];\n        }\n    });\n}\nfunction $991819a0aa439d56$export$f3c2d67c19d09b74() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($991819a0aa439d56$export$636c51ad84d0674a(), $991819a0aa439d56$export$b90e67818b1b3d45());\n}\nvar $991819a0aa439d56$var$getBase16Decoder = ()=>(0, $b9bc3aaa401ff82b$export$f8c898e83b60faaa)({\n        read (bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte)=>str + byte.toString(16).padStart(2, \"0\"), \"\");\n            return [\n                value,\n                bytes.length\n            ];\n        }\n    });\nfunction $991819a0aa439d56$export$23a212060029ca97(constant) {\n    return (0, $b9bc3aaa401ff82b$export$4e76eeb6df88c889)({\n        fixedSize: constant.length,\n        write: (_, bytes, offset)=>{\n            bytes.set(constant, offset);\n            return offset + constant.length;\n        }\n    });\n}\nfunction $991819a0aa439d56$export$13c771567a4019f7(constant) {\n    return (0, $b9bc3aaa401ff82b$export$f8c898e83b60faaa)({\n        fixedSize: constant.length,\n        read: (bytes, offset)=>{\n            const base16 = $991819a0aa439d56$var$getBase16Decoder();\n            if (!(0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(bytes, constant, offset)) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$cb77f5a0f0fa7f18), {\n                constant: constant,\n                data: bytes,\n                hexConstant: base16.decode(constant),\n                hexData: base16.decode(bytes),\n                offset: offset\n            });\n            return [\n                void 0,\n                offset + constant.length\n            ];\n        }\n    });\n}\nfunction $991819a0aa439d56$export$ad029b7073097608(constant) {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($991819a0aa439d56$export$23a212060029ca97(constant), $991819a0aa439d56$export$13c771567a4019f7(constant));\n}\nfunction $991819a0aa439d56$export$6b19a6a85541fd99(items) {\n    const fixedSize = $991819a0aa439d56$var$sumCodecSizes(items.map($991819a0aa439d56$var$getFixedSize));\n    const maxSize = $991819a0aa439d56$var$sumCodecSizes(items.map($991819a0aa439d56$var$getMaxSize)) ?? void 0;\n    return (0, $b9bc3aaa401ff82b$export$4e76eeb6df88c889)({\n        ...fixedSize === null ? {\n            getSizeFromValue: (value)=>items.map((item, index)=>(0, $b9bc3aaa401ff82b$export$30f3257599397621)(value[index], item)).reduce((all, one)=>all + one, 0),\n            maxSize: maxSize\n        } : {\n            fixedSize: fixedSize\n        },\n        write: (value, bytes, offset)=>{\n            $991819a0aa439d56$export$1e6cff54ac72b1a3(\"tuple\", items.length, value.length);\n            items.forEach((item, index)=>{\n                offset = item.write(value[index], bytes, offset);\n            });\n            return offset;\n        }\n    });\n}\nfunction $991819a0aa439d56$export$9800955a9fcaec5(items) {\n    const fixedSize = $991819a0aa439d56$var$sumCodecSizes(items.map($991819a0aa439d56$var$getFixedSize));\n    const maxSize = $991819a0aa439d56$var$sumCodecSizes(items.map($991819a0aa439d56$var$getMaxSize)) ?? void 0;\n    return (0, $b9bc3aaa401ff82b$export$f8c898e83b60faaa)({\n        ...fixedSize === null ? {\n            maxSize: maxSize\n        } : {\n            fixedSize: fixedSize\n        },\n        read: (bytes, offset)=>{\n            const values = [];\n            items.forEach((item)=>{\n                const [newValue, newOffset] = item.read(bytes, offset);\n                values.push(newValue);\n                offset = newOffset;\n            });\n            return [\n                values,\n                offset\n            ];\n        }\n    });\n}\nfunction $991819a0aa439d56$export$dc2491d24b0f7b51(items) {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($991819a0aa439d56$export$6b19a6a85541fd99(items), $991819a0aa439d56$export$9800955a9fcaec5(items));\n}\nfunction $991819a0aa439d56$export$a9351c88c0e29fc0(variants, getIndexFromValue) {\n    const fixedSize = $991819a0aa439d56$var$getUnionFixedSize(variants);\n    const write = (variant, bytes, offset)=>{\n        const index = getIndexFromValue(variant);\n        $991819a0aa439d56$var$assertValidVariantIndex(variants, index);\n        return variants[index].write(variant, bytes, offset);\n    };\n    if (fixedSize !== null) return (0, $b9bc3aaa401ff82b$export$4e76eeb6df88c889)({\n        fixedSize: fixedSize,\n        write: write\n    });\n    const maxSize = $991819a0aa439d56$var$getUnionMaxSize(variants);\n    return (0, $b9bc3aaa401ff82b$export$4e76eeb6df88c889)({\n        ...maxSize !== null ? {\n            maxSize: maxSize\n        } : {},\n        getSizeFromValue: (variant)=>{\n            const index = getIndexFromValue(variant);\n            $991819a0aa439d56$var$assertValidVariantIndex(variants, index);\n            return (0, $b9bc3aaa401ff82b$export$30f3257599397621)(variant, variants[index]);\n        },\n        write: write\n    });\n}\nfunction $991819a0aa439d56$export$ba967eb6bc7384b7(variants, getIndexFromBytes) {\n    const fixedSize = $991819a0aa439d56$var$getUnionFixedSize(variants);\n    const read = (bytes, offset)=>{\n        const index = getIndexFromBytes(bytes, offset);\n        $991819a0aa439d56$var$assertValidVariantIndex(variants, index);\n        return variants[index].read(bytes, offset);\n    };\n    if (fixedSize !== null) return (0, $b9bc3aaa401ff82b$export$f8c898e83b60faaa)({\n        fixedSize: fixedSize,\n        read: read\n    });\n    const maxSize = $991819a0aa439d56$var$getUnionMaxSize(variants);\n    return (0, $b9bc3aaa401ff82b$export$f8c898e83b60faaa)({\n        ...maxSize !== null ? {\n            maxSize: maxSize\n        } : {},\n        read: read\n    });\n}\nfunction $991819a0aa439d56$export$8e8c799359f1b4d2(variants, getIndexFromValue, getIndexFromBytes) {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($991819a0aa439d56$export$a9351c88c0e29fc0(variants, getIndexFromValue), $991819a0aa439d56$export$ba967eb6bc7384b7(variants, getIndexFromBytes));\n}\nfunction $991819a0aa439d56$var$assertValidVariantIndex(variants, index) {\n    if (typeof variants[index] === \"undefined\") throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$efbd199de191d2aa), {\n        maxRange: variants.length - 1,\n        minRange: 0,\n        variant: index\n    });\n}\nfunction $991819a0aa439d56$var$getUnionFixedSize(variants) {\n    if (variants.length === 0) return 0;\n    if (!(0, $b9bc3aaa401ff82b$export$f9d60229c95384d4)(variants[0])) return null;\n    const variantSize = variants[0].fixedSize;\n    const sameSizedVariants = variants.every((variant)=>(0, $b9bc3aaa401ff82b$export$f9d60229c95384d4)(variant) && variant.fixedSize === variantSize);\n    return sameSizedVariants ? variantSize : null;\n}\nfunction $991819a0aa439d56$var$getUnionMaxSize(variants) {\n    return $991819a0aa439d56$var$maxCodecSizes(variants.map((variant)=>$991819a0aa439d56$var$getMaxSize(variant)));\n}\n// src/discriminated-union.ts\nfunction $991819a0aa439d56$export$927540af483f54a(variants, config = {}) {\n    const discriminatorProperty = config.discriminator ?? \"__kind\";\n    const prefix = config.size ?? (0, $b5f941eb9a28d328$export$dc9732115561fb4b)();\n    return $991819a0aa439d56$export$a9351c88c0e29fc0(variants.map(([, variant], index)=>(0, $b9bc3aaa401ff82b$export$30169aca64409a56)($991819a0aa439d56$export$6b19a6a85541fd99([\n            prefix,\n            variant\n        ]), (value)=>[\n                index,\n                value\n            ])), (value)=>$991819a0aa439d56$var$getVariantDiscriminator(variants, value[discriminatorProperty]));\n}\nfunction $991819a0aa439d56$export$46f8fe299eb88c54(variants, config = {}) {\n    const discriminatorProperty = config.discriminator ?? \"__kind\";\n    const prefix = config.size ?? (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)();\n    return $991819a0aa439d56$export$ba967eb6bc7384b7(variants.map(([discriminator, variant])=>(0, $b9bc3aaa401ff82b$export$605b10ee38669daa)($991819a0aa439d56$export$9800955a9fcaec5([\n            prefix,\n            variant\n        ]), ([, value])=>({\n                [discriminatorProperty]: discriminator,\n                ...value\n            }))), (bytes, offset)=>Number(prefix.read(bytes, offset)[0]));\n}\nfunction $991819a0aa439d56$export$54ce790fc77f87b2(variants, config = {}) {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($991819a0aa439d56$export$927540af483f54a(variants, config), $991819a0aa439d56$export$46f8fe299eb88c54(variants, config));\n}\nfunction $991819a0aa439d56$var$getVariantDiscriminator(variants, discriminatorValue) {\n    const discriminator = variants.findIndex(([key])=>discriminatorValue === key);\n    if (discriminator < 0) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$2bb0703affb8fe68), {\n        value: discriminatorValue,\n        variants: variants.map(([key])=>key)\n    });\n    return discriminator;\n}\n// src/enum-helpers.ts\nfunction $991819a0aa439d56$var$getEnumStats(constructor) {\n    const numericalValues = [\n        ...new Set(Object.values(constructor).filter((v)=>typeof v === \"number\"))\n    ].sort();\n    const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length));\n    const enumKeys = Object.keys(enumRecord);\n    const enumValues = Object.values(enumRecord);\n    const stringValues = [\n        .../* @__PURE__ */ new Set([\n            ...enumKeys,\n            ...enumValues.filter((v)=>typeof v === \"string\")\n        ])\n    ];\n    return {\n        enumKeys: enumKeys,\n        enumRecord: enumRecord,\n        enumValues: enumValues,\n        numericalValues: numericalValues,\n        stringValues: stringValues\n    };\n}\nfunction $991819a0aa439d56$var$getEnumIndexFromVariant({ enumKeys: enumKeys, enumValues: enumValues, variant: variant }) {\n    const valueIndex = $991819a0aa439d56$var$findLastIndex(enumValues, (value)=>value === variant);\n    if (valueIndex >= 0) return valueIndex;\n    return enumKeys.findIndex((key)=>key === variant);\n}\nfunction $991819a0aa439d56$var$getEnumIndexFromDiscriminator({ discriminator: discriminator, enumKeys: enumKeys, enumValues: enumValues, useValuesAsDiscriminators: useValuesAsDiscriminators }) {\n    if (!useValuesAsDiscriminators) return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;\n    return $991819a0aa439d56$var$findLastIndex(enumValues, (value)=>value === discriminator);\n}\nfunction $991819a0aa439d56$var$findLastIndex(array, predicate) {\n    let l = array.length;\n    while(l--){\n        if (predicate(array[l], l, array)) return l;\n    }\n    return -1;\n}\nfunction $991819a0aa439d56$var$formatNumericalValues(values) {\n    if (values.length === 0) return \"\";\n    let range = [\n        values[0],\n        values[0]\n    ];\n    const ranges = [];\n    for(let index = 1; index < values.length; index++){\n        const value = values[index];\n        if (range[1] + 1 === value) range[1] = value;\n        else {\n            ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n            range = [\n                value,\n                value\n            ];\n        }\n    }\n    ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n    return ranges.join(\", \");\n}\n// src/enum.ts\nfunction $991819a0aa439d56$export$d531177bc561a76e(constructor, config = {}) {\n    const prefix = config.size ?? (0, $b5f941eb9a28d328$export$dc9732115561fb4b)();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys: enumKeys, enumValues: enumValues, numericalValues: numericalValues, stringValues: stringValues } = $991819a0aa439d56$var$getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some((value)=>typeof value === \"string\")) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$a2e9526594022372), {\n        stringValues: enumValues.filter((v)=>typeof v === \"string\")\n    });\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)(prefix, (variant)=>{\n        const index = $991819a0aa439d56$var$getEnumIndexFromVariant({\n            enumKeys: enumKeys,\n            enumValues: enumValues,\n            variant: variant\n        });\n        if (index < 0) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$f6bf8a7c1f3defe4), {\n            formattedNumericalValues: $991819a0aa439d56$var$formatNumericalValues(numericalValues),\n            numericalValues: numericalValues,\n            stringValues: stringValues,\n            variant: variant\n        });\n        return useValuesAsDiscriminators ? enumValues[index] : index;\n    });\n}\nfunction $991819a0aa439d56$export$9999963707d133fe(constructor, config = {}) {\n    const prefix = config.size ?? (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys: enumKeys, enumValues: enumValues, numericalValues: numericalValues } = $991819a0aa439d56$var$getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some((value)=>typeof value === \"string\")) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$a2e9526594022372), {\n        stringValues: enumValues.filter((v)=>typeof v === \"string\")\n    });\n    return (0, $b9bc3aaa401ff82b$export$605b10ee38669daa)(prefix, (value)=>{\n        const discriminator = Number(value);\n        const index = $991819a0aa439d56$var$getEnumIndexFromDiscriminator({\n            discriminator: discriminator,\n            enumKeys: enumKeys,\n            enumValues: enumValues,\n            useValuesAsDiscriminators: useValuesAsDiscriminators\n        });\n        if (index < 0) {\n            const validDiscriminators = useValuesAsDiscriminators ? numericalValues : [\n                ...Array(enumKeys.length).keys()\n            ];\n            throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$1fa107ead8489cf2), {\n                discriminator: discriminator,\n                formattedValidDiscriminators: $991819a0aa439d56$var$formatNumericalValues(validDiscriminators),\n                validDiscriminators: validDiscriminators\n            });\n        }\n        return enumValues[index];\n    });\n}\nfunction $991819a0aa439d56$export$32fbd6339c31df5a(constructor, config = {}) {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($991819a0aa439d56$export$d531177bc561a76e(constructor, config), $991819a0aa439d56$export$9999963707d133fe(constructor, config));\n}\nfunction $991819a0aa439d56$export$e68e10087ec64330(encoder, prefixedEncoders) {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)($991819a0aa439d56$export$6b19a6a85541fd99([\n        ...prefixedEncoders,\n        encoder\n    ]), (value)=>[\n            ...prefixedEncoders.map(()=>void 0),\n            value\n        ]);\n}\nfunction $991819a0aa439d56$export$3e731190a51906e9(decoder, prefixedDecoders) {\n    return (0, $b9bc3aaa401ff82b$export$605b10ee38669daa)($991819a0aa439d56$export$9800955a9fcaec5([\n        ...prefixedDecoders,\n        decoder\n    ]), (tuple)=>tuple[tuple.length - 1]);\n}\nfunction $991819a0aa439d56$export$e34ca45edea62fa(codec, prefixedCodecs) {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($991819a0aa439d56$export$e68e10087ec64330(codec, prefixedCodecs), $991819a0aa439d56$export$3e731190a51906e9(codec, prefixedCodecs));\n}\nfunction $991819a0aa439d56$export$48adc3d128b1e47b(encoder, suffixedEncoders) {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)($991819a0aa439d56$export$6b19a6a85541fd99([\n        encoder,\n        ...suffixedEncoders\n    ]), (value)=>[\n            value,\n            ...suffixedEncoders.map(()=>void 0)\n        ]);\n}\nfunction $991819a0aa439d56$export$27bbee57fb582997(decoder, suffixedDecoders) {\n    return (0, $b9bc3aaa401ff82b$export$605b10ee38669daa)($991819a0aa439d56$export$9800955a9fcaec5([\n        decoder,\n        ...suffixedDecoders\n    ]), (tuple)=>tuple[0]);\n}\nfunction $991819a0aa439d56$export$997dd3a140dcd82a(codec, suffixedCodecs) {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($991819a0aa439d56$export$48adc3d128b1e47b(codec, suffixedCodecs), $991819a0aa439d56$export$27bbee57fb582997(codec, suffixedCodecs));\n}\nfunction $991819a0aa439d56$export$3f7417d371e4165(variants, config = {}) {\n    const discriminator = config.size ?? (0, $b5f941eb9a28d328$export$dc9732115561fb4b)();\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)(discriminator, (variant)=>{\n        const index = variants.indexOf(variant);\n        if (index < 0) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$c89f43f0d783cd50), {\n            value: variant,\n            variants: variants\n        });\n        return index;\n    });\n}\nfunction $991819a0aa439d56$export$3b5c8b1ca206b9dd(variants, config = {}) {\n    const discriminator = config.size ?? (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)();\n    return (0, $b9bc3aaa401ff82b$export$605b10ee38669daa)(discriminator, (index)=>{\n        if (index < 0 || index >= variants.length) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$f73fb8ecbd4b2395), {\n            discriminator: index,\n            maxRange: variants.length - 1,\n            minRange: 0\n        });\n        return variants[Number(index)];\n    });\n}\nfunction $991819a0aa439d56$export$2fdd3c409c335bd6(variants, config = {}) {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($991819a0aa439d56$export$3f7417d371e4165(variants, config), $991819a0aa439d56$export$3b5c8b1ca206b9dd(variants, config));\n}\nfunction $991819a0aa439d56$export$75c3a7c49a778905(key, value, config = {}) {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)($991819a0aa439d56$export$415199198053c0b($991819a0aa439d56$export$6b19a6a85541fd99([\n        key,\n        value\n    ]), config), (map)=>[\n            ...map.entries()\n        ]);\n}\nfunction $991819a0aa439d56$export$e102943539f62962(key, value, config = {}) {\n    return (0, $b9bc3aaa401ff82b$export$605b10ee38669daa)($991819a0aa439d56$export$9016038b2e3b0c2f($991819a0aa439d56$export$9800955a9fcaec5([\n        key,\n        value\n    ]), config), (entries)=>new Map(entries));\n}\nfunction $991819a0aa439d56$export$191db844d92ad593(key, value, config = {}) {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($991819a0aa439d56$export$75c3a7c49a778905(key, value, config), $991819a0aa439d56$export$e102943539f62962(key, value, config));\n}\nfunction $991819a0aa439d56$export$a222f4a6d9205421() {\n    return (0, $b9bc3aaa401ff82b$export$4e76eeb6df88c889)({\n        fixedSize: 0,\n        write: (_value, _bytes, offset)=>offset\n    });\n}\nfunction $991819a0aa439d56$export$46a76d99d5c61218() {\n    return (0, $b9bc3aaa401ff82b$export$f8c898e83b60faaa)({\n        fixedSize: 0,\n        read: (_bytes, offset)=>[\n                void 0,\n                offset\n            ]\n    });\n}\nfunction $991819a0aa439d56$export$68459b38e676038a() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($991819a0aa439d56$export$a222f4a6d9205421(), $991819a0aa439d56$export$46a76d99d5c61218());\n}\n// src/nullable.ts\nfunction $991819a0aa439d56$export$b0dc66f9f6de624b(item, config = {}) {\n    const prefix = (()=>{\n        if (config.prefix === null) return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)($991819a0aa439d56$export$a222f4a6d9205421(), (_boolean)=>void 0);\n        return $991819a0aa439d56$export$4a518d3f98f842eb({\n            size: config.prefix ?? (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        });\n    })();\n    const noneValue = (()=>{\n        if (config.noneValue === \"zeroes\") {\n            (0, $b9bc3aaa401ff82b$export$4e85b7423fd6bc55)(item);\n            return (0, $b9bc3aaa401ff82b$export$cbdfce031443a1)($991819a0aa439d56$export$a222f4a6d9205421(), item.fixedSize);\n        }\n        if (!config.noneValue) return $991819a0aa439d56$export$a222f4a6d9205421();\n        return $991819a0aa439d56$export$23a212060029ca97(config.noneValue);\n    })();\n    return $991819a0aa439d56$export$a9351c88c0e29fc0([\n        (0, $b9bc3aaa401ff82b$export$30169aca64409a56)($991819a0aa439d56$export$6b19a6a85541fd99([\n            prefix,\n            noneValue\n        ]), (_value)=>[\n                false,\n                void 0\n            ]),\n        (0, $b9bc3aaa401ff82b$export$30169aca64409a56)($991819a0aa439d56$export$6b19a6a85541fd99([\n            prefix,\n            item\n        ]), (value)=>[\n                true,\n                value\n            ])\n    ], (variant)=>Number(variant !== null));\n}\nfunction $991819a0aa439d56$export$320bb1c6ae316289(item, config = {}) {\n    const prefix = (()=>{\n        if (config.prefix === null) return (0, $b9bc3aaa401ff82b$export$605b10ee38669daa)($991819a0aa439d56$export$46a76d99d5c61218(), ()=>false);\n        return $991819a0aa439d56$export$43a73c742ad521e1({\n            size: config.prefix ?? (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        });\n    })();\n    const noneValue = (()=>{\n        if (config.noneValue === \"zeroes\") {\n            (0, $b9bc3aaa401ff82b$export$4e85b7423fd6bc55)(item);\n            return (0, $b9bc3aaa401ff82b$export$1f85f8b8d2788007)($991819a0aa439d56$export$46a76d99d5c61218(), item.fixedSize);\n        }\n        if (!config.noneValue) return $991819a0aa439d56$export$46a76d99d5c61218();\n        return $991819a0aa439d56$export$13c771567a4019f7(config.noneValue);\n    })();\n    return $991819a0aa439d56$export$ba967eb6bc7384b7([\n        (0, $b9bc3aaa401ff82b$export$605b10ee38669daa)($991819a0aa439d56$export$9800955a9fcaec5([\n            prefix,\n            noneValue\n        ]), ()=>null),\n        (0, $b9bc3aaa401ff82b$export$605b10ee38669daa)($991819a0aa439d56$export$9800955a9fcaec5([\n            prefix,\n            item\n        ]), ([, value])=>value)\n    ], (bytes, offset)=>{\n        if (config.prefix === null && !config.noneValue) return Number(offset < bytes.length);\n        if (config.prefix === null && config.noneValue != null) {\n            const zeroValue = config.noneValue === \"zeroes\" ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n            return (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(bytes, zeroValue, offset) ? 0 : 1;\n        }\n        return Number(prefix.read(bytes, offset)[0]);\n    });\n}\nfunction $991819a0aa439d56$export$ac13939aa9a57a06(item, config = {}) {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($991819a0aa439d56$export$b0dc66f9f6de624b(item, config), $991819a0aa439d56$export$320bb1c6ae316289(item, config));\n}\nfunction $991819a0aa439d56$export$b5f13ff6baa9ba6c(item, config = {}) {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)($991819a0aa439d56$export$415199198053c0b(item, config), (set)=>[\n            ...set\n        ]);\n}\nfunction $991819a0aa439d56$export$b5164526d93d52f2(item, config = {}) {\n    return (0, $b9bc3aaa401ff82b$export$605b10ee38669daa)($991819a0aa439d56$export$9016038b2e3b0c2f(item, config), (entries)=>new Set(entries));\n}\nfunction $991819a0aa439d56$export$a7c6e50519818c5d(item, config = {}) {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($991819a0aa439d56$export$b5f13ff6baa9ba6c(item, config), $991819a0aa439d56$export$b5164526d93d52f2(item, config));\n}\nfunction $991819a0aa439d56$export$64024546a32014b8(fields) {\n    const fieldCodecs = fields.map(([, codec])=>codec);\n    const fixedSize = $991819a0aa439d56$var$sumCodecSizes(fieldCodecs.map($991819a0aa439d56$var$getFixedSize));\n    const maxSize = $991819a0aa439d56$var$sumCodecSizes(fieldCodecs.map($991819a0aa439d56$var$getMaxSize)) ?? void 0;\n    return (0, $b9bc3aaa401ff82b$export$4e76eeb6df88c889)({\n        ...fixedSize === null ? {\n            getSizeFromValue: (value)=>fields.map(([key, codec])=>(0, $b9bc3aaa401ff82b$export$30f3257599397621)(value[key], codec)).reduce((all, one)=>all + one, 0),\n            maxSize: maxSize\n        } : {\n            fixedSize: fixedSize\n        },\n        write: (struct, bytes, offset)=>{\n            fields.forEach(([key, codec])=>{\n                offset = codec.write(struct[key], bytes, offset);\n            });\n            return offset;\n        }\n    });\n}\nfunction $991819a0aa439d56$export$7070fbe048971470(fields) {\n    const fieldCodecs = fields.map(([, codec])=>codec);\n    const fixedSize = $991819a0aa439d56$var$sumCodecSizes(fieldCodecs.map($991819a0aa439d56$var$getFixedSize));\n    const maxSize = $991819a0aa439d56$var$sumCodecSizes(fieldCodecs.map($991819a0aa439d56$var$getMaxSize)) ?? void 0;\n    return (0, $b9bc3aaa401ff82b$export$f8c898e83b60faaa)({\n        ...fixedSize === null ? {\n            maxSize: maxSize\n        } : {\n            fixedSize: fixedSize\n        },\n        read: (bytes, offset)=>{\n            const struct = {};\n            fields.forEach(([key, codec])=>{\n                const [value, newOffset] = codec.read(bytes, offset);\n                offset = newOffset;\n                struct[key] = value;\n            });\n            return [\n                struct,\n                offset\n            ];\n        }\n    });\n}\nfunction $991819a0aa439d56$export$e7bbe4696420bde8(fields) {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($991819a0aa439d56$export$64024546a32014b8(fields), $991819a0aa439d56$export$7070fbe048971470(fields));\n}\n //# sourceMappingURL=index.browser.mjs.map\n\n\n\n\n// src/assertions.ts\nfunction $278ae65923ee60f5$export$d81fb78fd5af226e(alphabet4, testValue, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet4}]*$`))) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$89b582b06852d433), {\n        alphabet: alphabet4,\n        base: alphabet4.length,\n        value: givenValue\n    });\n}\nvar $278ae65923ee60f5$export$604e39a60e9aaee6 = (alphabet4)=>{\n    return (0, $b9bc3aaa401ff82b$export$4e76eeb6df88c889)({\n        getSizeFromValue: (value)=>{\n            const [leadingZeroes, tailChars] = $278ae65923ee60f5$var$partitionLeadingZeroes(value, alphabet4[0]);\n            if (!tailChars) return value.length;\n            const base10Number = $278ae65923ee60f5$var$getBigIntFromBaseX(tailChars, alphabet4);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write (value, bytes, offset) {\n            $278ae65923ee60f5$export$d81fb78fd5af226e(alphabet4, value);\n            if (value === \"\") return offset;\n            const [leadingZeroes, tailChars] = $278ae65923ee60f5$var$partitionLeadingZeroes(value, alphabet4[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n            let base10Number = $278ae65923ee60f5$var$getBigIntFromBaseX(tailChars, alphabet4);\n            const tailBytes = [];\n            while(base10Number > 0n){\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n            const bytesToAdd = [\n                ...Array(leadingZeroes.length).fill(0),\n                ...tailBytes\n            ];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        }\n    });\n};\nvar $278ae65923ee60f5$export$4637bf000c106942 = (alphabet4)=>{\n    return (0, $b9bc3aaa401ff82b$export$f8c898e83b60faaa)({\n        read (rawBytes, offset) {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return [\n                \"\",\n                0\n            ];\n            let trailIndex = bytes.findIndex((n)=>n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet4[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [\n                leadingZeroes,\n                rawBytes.length\n            ];\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte)=>sum * 256n + BigInt(byte), 0n);\n            const tailChars = $278ae65923ee60f5$var$getBaseXFromBigInt(base10Number, alphabet4);\n            return [\n                leadingZeroes + tailChars,\n                rawBytes.length\n            ];\n        }\n    });\n};\nvar $278ae65923ee60f5$export$fb7555f212ab1005 = (alphabet4)=>(0, $b9bc3aaa401ff82b$export$b88681b853abde79)($278ae65923ee60f5$export$604e39a60e9aaee6(alphabet4), $278ae65923ee60f5$export$4637bf000c106942(alphabet4));\nfunction $278ae65923ee60f5$var$partitionLeadingZeroes(value, zeroCharacter) {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [\n        leadingZeros,\n        tailChars\n    ];\n}\nfunction $278ae65923ee60f5$var$getBigIntFromBaseX(value, alphabet4) {\n    const base = BigInt(alphabet4.length);\n    let sum = 0n;\n    for (const char of value){\n        sum *= base;\n        sum += BigInt(alphabet4.indexOf(char));\n    }\n    return sum;\n}\nfunction $278ae65923ee60f5$var$getBaseXFromBigInt(value, alphabet4) {\n    const base = BigInt(alphabet4.length);\n    const tailChars = [];\n    while(value > 0n){\n        tailChars.unshift(alphabet4[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join(\"\");\n}\n// src/base10.ts\nvar $278ae65923ee60f5$var$alphabet = \"0123456789\";\nvar $278ae65923ee60f5$export$2c0b6b55e979e1c1 = ()=>$278ae65923ee60f5$export$604e39a60e9aaee6($278ae65923ee60f5$var$alphabet);\nvar $278ae65923ee60f5$export$f430205c15d46a26 = ()=>$278ae65923ee60f5$export$4637bf000c106942($278ae65923ee60f5$var$alphabet);\nvar $278ae65923ee60f5$export$582e4cb05e79b066 = ()=>$278ae65923ee60f5$export$fb7555f212ab1005($278ae65923ee60f5$var$alphabet);\nvar $278ae65923ee60f5$var$INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: \"0123456789abcdef\",\n    base: 16\n};\nfunction $278ae65923ee60f5$var$charCodeToBase16(char) {\n    if (char >= 48 /* ZERO */  && char <= 57 /* NINE */ ) return char - 48 /* ZERO */ ;\n    if (char >= 65 /* A_UP */  && char <= 70 /* F_UP */ ) return char - 55;\n    if (char >= 97 /* A_LO */  && char <= 102 /* F_LO */ ) return char - 87;\n}\nvar $278ae65923ee60f5$export$4e36ea5b8d948c7 = ()=>(0, $b9bc3aaa401ff82b$export$4e76eeb6df88c889)({\n        getSizeFromValue: (value)=>Math.ceil(value.length / 2),\n        write (value, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = $278ae65923ee60f5$var$charCodeToBase16(c);\n                if (n === void 0) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$89b582b06852d433), {\n                    ...$278ae65923ee60f5$var$INVALID_STRING_ERROR_BASE_CONFIG,\n                    value: value\n                });\n                bytes.set([\n                    n\n                ], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for(let i = 0, j = 0; i < al; i++){\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n                const n1 = $278ae65923ee60f5$var$charCodeToBase16(c1);\n                const n2 = $278ae65923ee60f5$var$charCodeToBase16(c2);\n                if (n1 === void 0 || n2 === void 0 && !Number.isNaN(c2)) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$89b582b06852d433), {\n                    ...$278ae65923ee60f5$var$INVALID_STRING_ERROR_BASE_CONFIG,\n                    value: value\n                });\n                hexBytes[i] = !Number.isNaN(c2) ? n1 << 4 | (n2 ?? 0) : n1;\n            }\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        }\n    });\nvar $278ae65923ee60f5$export$a8743d71ec78d9cd = ()=>(0, $b9bc3aaa401ff82b$export$f8c898e83b60faaa)({\n        read (bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte)=>str + byte.toString(16).padStart(2, \"0\"), \"\");\n            return [\n                value,\n                bytes.length\n            ];\n        }\n    });\nvar $278ae65923ee60f5$export$38b0279df5920b98 = ()=>(0, $b9bc3aaa401ff82b$export$b88681b853abde79)($278ae65923ee60f5$export$4e36ea5b8d948c7(), $278ae65923ee60f5$export$a8743d71ec78d9cd());\n// src/base58.ts\nvar $278ae65923ee60f5$var$alphabet2 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nvar $278ae65923ee60f5$export$c9b1da42c197e8e5 = ()=>$278ae65923ee60f5$export$604e39a60e9aaee6($278ae65923ee60f5$var$alphabet2);\nvar $278ae65923ee60f5$export$81723918e05f84c7 = ()=>$278ae65923ee60f5$export$4637bf000c106942($278ae65923ee60f5$var$alphabet2);\nvar $278ae65923ee60f5$export$6edf7801eef2b1bb = ()=>$278ae65923ee60f5$export$fb7555f212ab1005($278ae65923ee60f5$var$alphabet2);\nvar $278ae65923ee60f5$export$72d35c538ba15ebf = (alphabet4, bits)=>(0, $b9bc3aaa401ff82b$export$4e76eeb6df88c889)({\n        getSizeFromValue: (value)=>Math.floor(value.length * bits / 8),\n        write (value, bytes, offset) {\n            $278ae65923ee60f5$export$d81fb78fd5af226e(alphabet4, value);\n            if (value === \"\") return offset;\n            const charIndices = [\n                ...value\n            ].map((c)=>alphabet4.indexOf(c));\n            const reslicedBytes = $278ae65923ee60f5$var$reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        }\n    });\nvar $278ae65923ee60f5$export$ae1f0b87cf8eee1e = (alphabet4, bits)=>(0, $b9bc3aaa401ff82b$export$f8c898e83b60faaa)({\n        read (rawBytes, offset = 0) {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return [\n                \"\",\n                rawBytes.length\n            ];\n            const charIndices = $278ae65923ee60f5$var$reslice([\n                ...bytes\n            ], 8, bits, true);\n            return [\n                charIndices.map((i)=>alphabet4[i]).join(\"\"),\n                rawBytes.length\n            ];\n        }\n    });\nvar $278ae65923ee60f5$export$d828ca4fa0b3e3bb = (alphabet4, bits)=>(0, $b9bc3aaa401ff82b$export$b88681b853abde79)($278ae65923ee60f5$export$72d35c538ba15ebf(alphabet4, bits), $278ae65923ee60f5$export$ae1f0b87cf8eee1e(alphabet4, bits));\nfunction $278ae65923ee60f5$var$reslice(input, inputBits, outputBits, useRemainder) {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input){\n        accumulator = accumulator << inputBits | value;\n        bitsInAccumulator += inputBits;\n        while(bitsInAccumulator >= outputBits){\n            bitsInAccumulator -= outputBits;\n            output.push(accumulator >> bitsInAccumulator & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) output.push(accumulator << outputBits - bitsInAccumulator & mask);\n    return output;\n}\n// src/base64.ts\nvar $278ae65923ee60f5$var$alphabet3 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar $278ae65923ee60f5$export$7a87b201ca045431 = ()=>{\n    return (0, $b9bc3aaa401ff82b$export$4e76eeb6df88c889)({\n        getSizeFromValue: (value)=>{\n            try {\n                return atob(value).length;\n            } catch  {\n                throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$89b582b06852d433), {\n                    alphabet: $278ae65923ee60f5$var$alphabet3,\n                    base: 64,\n                    value: value\n                });\n            }\n        },\n        write (value, bytes, offset) {\n            try {\n                const bytesToAdd = atob(value).split(\"\").map((c)=>c.charCodeAt(0));\n                bytes.set(bytesToAdd, offset);\n                return bytesToAdd.length + offset;\n            } catch  {\n                throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$89b582b06852d433), {\n                    alphabet: $278ae65923ee60f5$var$alphabet3,\n                    base: 64,\n                    value: value\n                });\n            }\n        }\n    });\n};\nvar $278ae65923ee60f5$export$ee20ac553cec1cb2 = ()=>{\n    return (0, $b9bc3aaa401ff82b$export$f8c898e83b60faaa)({\n        read (bytes, offset = 0) {\n            const slice = bytes.slice(offset);\n            const value = btoa(String.fromCharCode(...slice));\n            return [\n                value,\n                bytes.length\n            ];\n        }\n    });\n};\nvar $278ae65923ee60f5$export$90e6baef93ad018a = ()=>(0, $b9bc3aaa401ff82b$export$b88681b853abde79)($278ae65923ee60f5$export$7a87b201ca045431(), $278ae65923ee60f5$export$ee20ac553cec1cb2());\n// src/null-characters.ts\nvar $278ae65923ee60f5$export$33e68217e0ffdbfd = (value)=>// eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, \"\");\nvar $278ae65923ee60f5$export$f9f4f744d6dfac88 = (value, chars)=>value.padEnd(chars, \"\\0\");\n// ../text-encoding-impl/dist/index.browser.mjs\nvar $278ae65923ee60f5$var$e = globalThis.TextDecoder;\nvar $278ae65923ee60f5$var$o = globalThis.TextEncoder;\n// src/utf8.ts\nvar $278ae65923ee60f5$export$9a335ef9e29610a7 = ()=>{\n    let textEncoder;\n    return (0, $b9bc3aaa401ff82b$export$4e76eeb6df88c889)({\n        getSizeFromValue: (value)=>(textEncoder ||= new $278ae65923ee60f5$var$o()).encode(value).length,\n        write: (value, bytes, offset)=>{\n            const bytesToAdd = (textEncoder ||= new $278ae65923ee60f5$var$o()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        }\n    });\n};\nvar $278ae65923ee60f5$export$3cdd8a41d7d6b55d = ()=>{\n    let textDecoder;\n    return (0, $b9bc3aaa401ff82b$export$f8c898e83b60faaa)({\n        read (bytes, offset) {\n            const value = (textDecoder ||= new $278ae65923ee60f5$var$e()).decode(bytes.slice(offset));\n            return [\n                $278ae65923ee60f5$export$33e68217e0ffdbfd(value),\n                bytes.length\n            ];\n        }\n    });\n};\nvar $278ae65923ee60f5$export$7c78620cf2c2b679 = ()=>(0, $b9bc3aaa401ff82b$export$b88681b853abde79)($278ae65923ee60f5$export$9a335ef9e29610a7(), $278ae65923ee60f5$export$3cdd8a41d7d6b55d());\n //# sourceMappingURL=index.browser.mjs.map\n\n\n\n\n// src/crypto.ts\nfunction $1ec973a571fb3503$export$9ea69ae0922ea694() {\n    if (typeof globalThis.crypto === \"undefined\" || typeof globalThis.crypto.getRandomValues !== \"function\") throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$bc2b26beee0f9a0b));\n}\nfunction $1ec973a571fb3503$var$assertIsSecureContext() {\n    if (!globalThis.isSecureContext) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$f2bbb3c14e29977e));\n}\nvar $1ec973a571fb3503$var$cachedEd25519Decision;\nasync function $1ec973a571fb3503$var$isEd25519CurveSupported(subtle) {\n    if ($1ec973a571fb3503$var$cachedEd25519Decision === void 0) $1ec973a571fb3503$var$cachedEd25519Decision = new Promise((resolve)=>{\n        subtle.generateKey(\"Ed25519\", /* extractable */ false, [\n            \"sign\",\n            \"verify\"\n        ]).then(()=>{\n            resolve($1ec973a571fb3503$var$cachedEd25519Decision = true);\n        }).catch(()=>{\n            resolve($1ec973a571fb3503$var$cachedEd25519Decision = false);\n        });\n    });\n    if (typeof $1ec973a571fb3503$var$cachedEd25519Decision === \"boolean\") return $1ec973a571fb3503$var$cachedEd25519Decision;\n    else return await $1ec973a571fb3503$var$cachedEd25519Decision;\n}\nfunction $1ec973a571fb3503$export$4ec0c2a1c3ac9154() {\n    $1ec973a571fb3503$var$assertIsSecureContext();\n    if (typeof globalThis.crypto === \"undefined\" || typeof globalThis.crypto.subtle?.digest !== \"function\") throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$f18173f573d8bb21));\n}\nasync function $1ec973a571fb3503$export$c8b831ead944a354() {\n    $1ec973a571fb3503$var$assertIsSecureContext();\n    if (typeof globalThis.crypto === \"undefined\" || typeof globalThis.crypto.subtle?.generateKey !== \"function\") throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$325dad4e0a6bd514));\n    if (!await $1ec973a571fb3503$var$isEd25519CurveSupported(globalThis.crypto.subtle)) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$7ad09900bd645a86));\n}\nfunction $1ec973a571fb3503$export$833df987f9577189() {\n    $1ec973a571fb3503$var$assertIsSecureContext();\n    if (typeof globalThis.crypto === \"undefined\" || typeof globalThis.crypto.subtle?.exportKey !== \"function\") throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$69c08c51e1841f29));\n}\nfunction $1ec973a571fb3503$export$a60e81a6d8aa0738() {\n    $1ec973a571fb3503$var$assertIsSecureContext();\n    if (typeof globalThis.crypto === \"undefined\" || typeof globalThis.crypto.subtle?.sign !== \"function\") throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$242c341c7c464bee));\n}\nfunction $1ec973a571fb3503$export$abe752f2065eb545() {\n    $1ec973a571fb3503$var$assertIsSecureContext();\n    if (typeof globalThis.crypto === \"undefined\" || typeof globalThis.crypto.subtle?.verify !== \"function\") throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$a73c064bb32a7c36));\n}\n //# sourceMappingURL=index.browser.mjs.map\n\n\n// src/address.ts\nvar $fadd3f4c7539d2fa$var$memoizedBase58Encoder;\nvar $fadd3f4c7539d2fa$var$memoizedBase58Decoder;\nfunction $fadd3f4c7539d2fa$var$getMemoizedBase58Encoder() {\n    if (!$fadd3f4c7539d2fa$var$memoizedBase58Encoder) $fadd3f4c7539d2fa$var$memoizedBase58Encoder = (0, $278ae65923ee60f5$export$c9b1da42c197e8e5)();\n    return $fadd3f4c7539d2fa$var$memoizedBase58Encoder;\n}\nfunction $fadd3f4c7539d2fa$var$getMemoizedBase58Decoder() {\n    if (!$fadd3f4c7539d2fa$var$memoizedBase58Decoder) $fadd3f4c7539d2fa$var$memoizedBase58Decoder = (0, $278ae65923ee60f5$export$81723918e05f84c7)();\n    return $fadd3f4c7539d2fa$var$memoizedBase58Decoder;\n}\nfunction $fadd3f4c7539d2fa$export$977e255126d763d6(putativeAddress) {\n    if (// Lowest address (32 bytes of zeroes)\n    putativeAddress.length < 32 || // Highest address (32 bytes of 255)\n    putativeAddress.length > 44) return false;\n    const base58Encoder = $fadd3f4c7539d2fa$var$getMemoizedBase58Encoder();\n    try {\n        return base58Encoder.encode(putativeAddress).byteLength === 32;\n    } catch  {\n        return false;\n    }\n}\nfunction $fadd3f4c7539d2fa$export$ce82521337b7000f(putativeAddress) {\n    if (// Lowest address (32 bytes of zeroes)\n    putativeAddress.length < 32 || // Highest address (32 bytes of 255)\n    putativeAddress.length > 44) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$8aae3518bf4ea38c), {\n        actualLength: putativeAddress.length\n    });\n    const base58Encoder = $fadd3f4c7539d2fa$var$getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeAddress);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$fe284a92110eab86), {\n        actualLength: numBytes\n    });\n}\nfunction $fadd3f4c7539d2fa$export$f7d3c097ceca6c15(putativeAddress) {\n    $fadd3f4c7539d2fa$export$ce82521337b7000f(putativeAddress);\n    return putativeAddress;\n}\nfunction $fadd3f4c7539d2fa$export$796121a945d5c29b() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $b9bc3aaa401ff82b$export$cbdfce031443a1)($fadd3f4c7539d2fa$var$getMemoizedBase58Encoder(), 32), (putativeAddress)=>$fadd3f4c7539d2fa$export$f7d3c097ceca6c15(putativeAddress));\n}\nfunction $fadd3f4c7539d2fa$export$5fd6a09ea9008295() {\n    return (0, $b9bc3aaa401ff82b$export$1f85f8b8d2788007)($fadd3f4c7539d2fa$var$getMemoizedBase58Decoder(), 32);\n}\nfunction $fadd3f4c7539d2fa$export$872beb68e6a83b96() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($fadd3f4c7539d2fa$export$796121a945d5c29b(), $fadd3f4c7539d2fa$export$5fd6a09ea9008295());\n}\nfunction $fadd3f4c7539d2fa$export$be47cbc6fd88c6e6() {\n    return new Intl.Collator(\"en\", {\n        caseFirst: \"lower\",\n        ignorePunctuation: false,\n        localeMatcher: \"best fit\",\n        numeric: false,\n        sensitivity: \"variant\",\n        usage: \"sort\"\n    }).compare;\n}\n// src/vendor/noble/ed25519.ts\nvar $fadd3f4c7539d2fa$var$D = 37095705934669439343138083508754565189542113879843219016388785533085940283555n;\nvar $fadd3f4c7539d2fa$var$P = 57896044618658097711785492504343953926634992332820282019728792003956564819949n;\nvar $fadd3f4c7539d2fa$var$RM1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n;\nfunction $fadd3f4c7539d2fa$var$mod(a) {\n    const r = a % $fadd3f4c7539d2fa$var$P;\n    return r >= 0n ? r : $fadd3f4c7539d2fa$var$P + r;\n}\nfunction $fadd3f4c7539d2fa$var$pow2(x, power) {\n    let r = x;\n    while(power-- > 0n){\n        r *= r;\n        r %= $fadd3f4c7539d2fa$var$P;\n    }\n    return r;\n}\nfunction $fadd3f4c7539d2fa$var$pow_2_252_3(x) {\n    const x2 = x * x % $fadd3f4c7539d2fa$var$P;\n    const b2 = x2 * x % $fadd3f4c7539d2fa$var$P;\n    const b4 = $fadd3f4c7539d2fa$var$pow2(b2, 2n) * b2 % $fadd3f4c7539d2fa$var$P;\n    const b5 = $fadd3f4c7539d2fa$var$pow2(b4, 1n) * x % $fadd3f4c7539d2fa$var$P;\n    const b10 = $fadd3f4c7539d2fa$var$pow2(b5, 5n) * b5 % $fadd3f4c7539d2fa$var$P;\n    const b20 = $fadd3f4c7539d2fa$var$pow2(b10, 10n) * b10 % $fadd3f4c7539d2fa$var$P;\n    const b40 = $fadd3f4c7539d2fa$var$pow2(b20, 20n) * b20 % $fadd3f4c7539d2fa$var$P;\n    const b80 = $fadd3f4c7539d2fa$var$pow2(b40, 40n) * b40 % $fadd3f4c7539d2fa$var$P;\n    const b160 = $fadd3f4c7539d2fa$var$pow2(b80, 80n) * b80 % $fadd3f4c7539d2fa$var$P;\n    const b240 = $fadd3f4c7539d2fa$var$pow2(b160, 80n) * b80 % $fadd3f4c7539d2fa$var$P;\n    const b250 = $fadd3f4c7539d2fa$var$pow2(b240, 10n) * b10 % $fadd3f4c7539d2fa$var$P;\n    const pow_p_5_8 = $fadd3f4c7539d2fa$var$pow2(b250, 2n) * x % $fadd3f4c7539d2fa$var$P;\n    return pow_p_5_8;\n}\nfunction $fadd3f4c7539d2fa$var$uvRatio(u, v) {\n    const v3 = $fadd3f4c7539d2fa$var$mod(v * v * v);\n    const v7 = $fadd3f4c7539d2fa$var$mod(v3 * v3 * v);\n    const pow = $fadd3f4c7539d2fa$var$pow_2_252_3(u * v7);\n    let x = $fadd3f4c7539d2fa$var$mod(u * v3 * pow);\n    const vx2 = $fadd3f4c7539d2fa$var$mod(v * x * x);\n    const root1 = x;\n    const root2 = $fadd3f4c7539d2fa$var$mod(x * $fadd3f4c7539d2fa$var$RM1);\n    const useRoot1 = vx2 === u;\n    const useRoot2 = vx2 === $fadd3f4c7539d2fa$var$mod(-u);\n    const noRoot = vx2 === $fadd3f4c7539d2fa$var$mod(-u * $fadd3f4c7539d2fa$var$RM1);\n    if (useRoot1) x = root1;\n    if (useRoot2 || noRoot) x = root2;\n    if (($fadd3f4c7539d2fa$var$mod(x) & 1n) === 1n) x = $fadd3f4c7539d2fa$var$mod(-x);\n    if (!useRoot1 && !useRoot2) return null;\n    return x;\n}\nfunction $fadd3f4c7539d2fa$var$pointIsOnCurve(y, lastByte) {\n    const y2 = $fadd3f4c7539d2fa$var$mod(y * y);\n    const u = $fadd3f4c7539d2fa$var$mod(y2 - 1n);\n    const v = $fadd3f4c7539d2fa$var$mod($fadd3f4c7539d2fa$var$D * y2 + 1n);\n    const x = $fadd3f4c7539d2fa$var$uvRatio(u, v);\n    if (x === null) return false;\n    const isLastByteOdd = (lastByte & 128) !== 0;\n    if (x === 0n && isLastByteOdd) return false;\n    return true;\n}\n// src/curve-internal.ts\nfunction $fadd3f4c7539d2fa$var$byteToHex(byte) {\n    const hexString = byte.toString(16);\n    if (hexString.length === 1) return `0${hexString}`;\n    else return hexString;\n}\nfunction $fadd3f4c7539d2fa$var$decompressPointBytes(bytes) {\n    const hexString = bytes.reduce((acc, byte, ii)=>`${$fadd3f4c7539d2fa$var$byteToHex(ii === 31 ? byte & -129 : byte)}${acc}`, \"\");\n    const integerLiteralString = `0x${hexString}`;\n    return BigInt(integerLiteralString);\n}\nfunction $fadd3f4c7539d2fa$var$compressedPointBytesAreOnCurve(bytes) {\n    if (bytes.byteLength !== 32) return false;\n    const y = $fadd3f4c7539d2fa$var$decompressPointBytes(bytes);\n    return $fadd3f4c7539d2fa$var$pointIsOnCurve(y, bytes[31]);\n}\n// src/curve.ts\nfunction $fadd3f4c7539d2fa$export$6be0de63ec3caf15(putativeOffCurveAddress) {\n    const addressBytes = $fadd3f4c7539d2fa$export$872beb68e6a83b96().encode(putativeOffCurveAddress);\n    return $fadd3f4c7539d2fa$var$compressedPointBytesAreOnCurve(addressBytes) === false;\n}\nfunction $fadd3f4c7539d2fa$export$8f1b8960967e8769(putativeOffCurveAddress) {\n    if (!$fadd3f4c7539d2fa$export$6be0de63ec3caf15(putativeOffCurveAddress)) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$7ada2ae349acb674));\n}\nfunction $fadd3f4c7539d2fa$export$c2f76c3a1dcb2609(putativeOffCurveAddress) {\n    $fadd3f4c7539d2fa$export$8f1b8960967e8769(putativeOffCurveAddress);\n    return putativeOffCurveAddress;\n}\nfunction $fadd3f4c7539d2fa$export$62e170af72c8a219(value) {\n    return Array.isArray(value) && value.length === 2 && typeof value[0] === \"string\" && typeof value[1] === \"number\" && value[1] >= 0 && value[1] <= 255 && $fadd3f4c7539d2fa$export$977e255126d763d6(value[0]);\n}\nfunction $fadd3f4c7539d2fa$export$b41ce18a9d54e115(value) {\n    const validFormat = Array.isArray(value) && value.length === 2 && typeof value[0] === \"string\" && typeof value[1] === \"number\";\n    if (!validFormat) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$523a769cce7318bf));\n    if (value[1] < 0 || value[1] > 255) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$68473acf744cabf5), {\n        bump: value[1]\n    });\n    $fadd3f4c7539d2fa$export$ce82521337b7000f(value[0]);\n}\nvar $fadd3f4c7539d2fa$var$MAX_SEED_LENGTH = 32;\nvar $fadd3f4c7539d2fa$var$MAX_SEEDS = 16;\nvar $fadd3f4c7539d2fa$var$PDA_MARKER_BYTES = [\n    // The string 'ProgramDerivedAddress'\n    80,\n    114,\n    111,\n    103,\n    114,\n    97,\n    109,\n    68,\n    101,\n    114,\n    105,\n    118,\n    101,\n    100,\n    65,\n    100,\n    100,\n    114,\n    101,\n    115,\n    115\n];\nasync function $fadd3f4c7539d2fa$var$createProgramDerivedAddress({ programAddress: programAddress, seeds: seeds }) {\n    (0, $1ec973a571fb3503$export$4ec0c2a1c3ac9154)();\n    if (seeds.length > $fadd3f4c7539d2fa$var$MAX_SEEDS) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$940d17d3b63dba7c), {\n        actual: seeds.length,\n        maxSeeds: $fadd3f4c7539d2fa$var$MAX_SEEDS\n    });\n    let textEncoder;\n    const seedBytes = seeds.reduce((acc, seed, ii)=>{\n        const bytes = typeof seed === \"string\" ? (textEncoder ||= new TextEncoder()).encode(seed) : seed;\n        if (bytes.byteLength > $fadd3f4c7539d2fa$var$MAX_SEED_LENGTH) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$a1cf857da540ee2e), {\n            actual: bytes.byteLength,\n            index: ii,\n            maxSeedLength: $fadd3f4c7539d2fa$var$MAX_SEED_LENGTH\n        });\n        acc.push(...bytes);\n        return acc;\n    }, []);\n    const base58EncodedAddressCodec = $fadd3f4c7539d2fa$export$872beb68e6a83b96();\n    const programAddressBytes = base58EncodedAddressCodec.encode(programAddress);\n    const addressBytesBuffer = await crypto.subtle.digest(\"SHA-256\", new Uint8Array([\n        ...seedBytes,\n        ...programAddressBytes,\n        ...$fadd3f4c7539d2fa$var$PDA_MARKER_BYTES\n    ]));\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n    if ($fadd3f4c7539d2fa$var$compressedPointBytesAreOnCurve(addressBytes)) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$30501b98da9564bb));\n    return base58EncodedAddressCodec.decode(addressBytes);\n}\nasync function $fadd3f4c7539d2fa$export$4e565ad19ba445b({ programAddress: programAddress, seeds: seeds }) {\n    let bumpSeed = 255;\n    while(bumpSeed > 0)try {\n        const address2 = await $fadd3f4c7539d2fa$var$createProgramDerivedAddress({\n            programAddress: programAddress,\n            seeds: [\n                ...seeds,\n                new Uint8Array([\n                    bumpSeed\n                ])\n            ]\n        });\n        return [\n            address2,\n            bumpSeed\n        ];\n    } catch (e) {\n        if ((0, $0bb11e8e9f3a1c4e$export$cfead212e52d9961)(e, (0, $0bb11e8e9f3a1c4e$export$30501b98da9564bb))) bumpSeed--;\n        else throw e;\n    }\n    throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$123d01dd469dc2ef));\n}\nasync function $fadd3f4c7539d2fa$export$be6e74907809ce04({ baseAddress: baseAddress, programAddress: programAddress, seed: seed }) {\n    const { encode: encode, decode: decode } = $fadd3f4c7539d2fa$export$872beb68e6a83b96();\n    const seedBytes = typeof seed === \"string\" ? new TextEncoder().encode(seed) : seed;\n    if (seedBytes.byteLength > $fadd3f4c7539d2fa$var$MAX_SEED_LENGTH) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$a1cf857da540ee2e), {\n        actual: seedBytes.byteLength,\n        index: 0,\n        maxSeedLength: $fadd3f4c7539d2fa$var$MAX_SEED_LENGTH\n    });\n    const programAddressBytes = encode(programAddress);\n    if (programAddressBytes.length >= $fadd3f4c7539d2fa$var$PDA_MARKER_BYTES.length && programAddressBytes.slice(-$fadd3f4c7539d2fa$var$PDA_MARKER_BYTES.length).every((byte, index)=>byte === $fadd3f4c7539d2fa$var$PDA_MARKER_BYTES[index])) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$2a7684440f52314e));\n    const addressBytesBuffer = await crypto.subtle.digest(\"SHA-256\", new Uint8Array([\n        ...encode(baseAddress),\n        ...seedBytes,\n        ...programAddressBytes\n    ]));\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n    return decode(addressBytes);\n}\nasync function $fadd3f4c7539d2fa$export$a28ea21350b9dd16(publicKey) {\n    (0, $1ec973a571fb3503$export$833df987f9577189)();\n    if (publicKey.type !== \"public\" || publicKey.algorithm.name !== \"Ed25519\") throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$adaec66b544981e7));\n    const publicKeyBytes = await crypto.subtle.exportKey(\"raw\", publicKey);\n    return $fadd3f4c7539d2fa$export$5fd6a09ea9008295().decode(new Uint8Array(publicKeyBytes));\n}\nasync function $fadd3f4c7539d2fa$export$bca2d63cbdc990ff(address2) {\n    const addressBytes = $fadd3f4c7539d2fa$export$796121a945d5c29b().encode(address2);\n    return await crypto.subtle.importKey(\"raw\", addressBytes, {\n        name: \"Ed25519\"\n    }, true, [\n        \"verify\"\n    ]);\n}\n //# sourceMappingURL=index.browser.mjs.map\n\n\n\n\n// src/option.ts\nvar $6e02c1c9c7315aa4$export$ad14ef4001db2bcd = (value)=>({\n        __option: \"Some\",\n        value: value\n    });\nvar $6e02c1c9c7315aa4$export$f883a24d5edde77c = ()=>({\n        __option: \"None\"\n    });\nvar $6e02c1c9c7315aa4$export$707cacfe2982dfac = (input)=>!!(input && typeof input === \"object\" && \"__option\" in input && (input.__option === \"Some\" && \"value\" in input || input.__option === \"None\"));\nvar $6e02c1c9c7315aa4$export$5d7e502287836e58 = (option)=>option.__option === \"Some\";\nvar $6e02c1c9c7315aa4$export$e56af863d5645d5f = (option)=>option.__option === \"None\";\n// src/unwrap-option.ts\nfunction $6e02c1c9c7315aa4$export$48e5a1ea856d8959(option, fallback) {\n    if ($6e02c1c9c7315aa4$export$5d7e502287836e58(option)) return option.value;\n    return fallback ? fallback() : null;\n}\nvar $6e02c1c9c7315aa4$export$44ac850edddcd9ae = (nullable)=>nullable !== null ? $6e02c1c9c7315aa4$export$ad14ef4001db2bcd(nullable) : $6e02c1c9c7315aa4$export$f883a24d5edde77c();\n// src/option-codec.ts\nfunction $6e02c1c9c7315aa4$export$99f28d5468429524(item, config = {}) {\n    const prefix = (()=>{\n        if (config.prefix === null) return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$a222f4a6d9205421)(), (_boolean)=>void 0);\n        return (0, $991819a0aa439d56$export$4a518d3f98f842eb)({\n            size: config.prefix ?? (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        });\n    })();\n    const noneValue = (()=>{\n        if (config.noneValue === \"zeroes\") {\n            (0, $b9bc3aaa401ff82b$export$4e85b7423fd6bc55)(item);\n            return (0, $b9bc3aaa401ff82b$export$cbdfce031443a1)((0, $991819a0aa439d56$export$a222f4a6d9205421)(), item.fixedSize);\n        }\n        if (!config.noneValue) return (0, $991819a0aa439d56$export$a222f4a6d9205421)();\n        return (0, $991819a0aa439d56$export$23a212060029ca97)(config.noneValue);\n    })();\n    return (0, $991819a0aa439d56$export$a9351c88c0e29fc0)([\n        (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$6b19a6a85541fd99)([\n            prefix,\n            noneValue\n        ]), (_value)=>[\n                false,\n                void 0\n            ]),\n        (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$6b19a6a85541fd99)([\n            prefix,\n            item\n        ]), (value)=>[\n                true,\n                $6e02c1c9c7315aa4$export$707cacfe2982dfac(value) && $6e02c1c9c7315aa4$export$5d7e502287836e58(value) ? value.value : value\n            ])\n    ], (variant)=>{\n        const option = $6e02c1c9c7315aa4$export$707cacfe2982dfac(variant) ? variant : $6e02c1c9c7315aa4$export$44ac850edddcd9ae(variant);\n        return Number($6e02c1c9c7315aa4$export$5d7e502287836e58(option));\n    });\n}\nfunction $6e02c1c9c7315aa4$export$9e19f3834a721c2f(item, config = {}) {\n    const prefix = (()=>{\n        if (config.prefix === null) return (0, $b9bc3aaa401ff82b$export$605b10ee38669daa)((0, $991819a0aa439d56$export$46a76d99d5c61218)(), ()=>false);\n        return (0, $991819a0aa439d56$export$43a73c742ad521e1)({\n            size: config.prefix ?? (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        });\n    })();\n    const noneValue = (()=>{\n        if (config.noneValue === \"zeroes\") {\n            (0, $b9bc3aaa401ff82b$export$4e85b7423fd6bc55)(item);\n            return (0, $b9bc3aaa401ff82b$export$1f85f8b8d2788007)((0, $991819a0aa439d56$export$46a76d99d5c61218)(), item.fixedSize);\n        }\n        if (!config.noneValue) return (0, $991819a0aa439d56$export$46a76d99d5c61218)();\n        return (0, $991819a0aa439d56$export$13c771567a4019f7)(config.noneValue);\n    })();\n    return (0, $991819a0aa439d56$export$ba967eb6bc7384b7)([\n        (0, $b9bc3aaa401ff82b$export$605b10ee38669daa)((0, $991819a0aa439d56$export$9800955a9fcaec5)([\n            prefix,\n            noneValue\n        ]), ()=>$6e02c1c9c7315aa4$export$f883a24d5edde77c()),\n        (0, $b9bc3aaa401ff82b$export$605b10ee38669daa)((0, $991819a0aa439d56$export$9800955a9fcaec5)([\n            prefix,\n            item\n        ]), ([, value])=>$6e02c1c9c7315aa4$export$ad14ef4001db2bcd(value))\n    ], (bytes, offset)=>{\n        if (config.prefix === null && !config.noneValue) return Number(offset < bytes.length);\n        if (config.prefix === null && config.noneValue != null) {\n            const zeroValue = config.noneValue === \"zeroes\" ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n            return (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(bytes, zeroValue, offset) ? 0 : 1;\n        }\n        return Number(prefix.read(bytes, offset)[0]);\n    });\n}\nfunction $6e02c1c9c7315aa4$export$5cabfe8a66f1b3c3(item, config = {}) {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($6e02c1c9c7315aa4$export$99f28d5468429524(item, config), $6e02c1c9c7315aa4$export$9e19f3834a721c2f(item, config));\n}\n// src/unwrap-option-recursively.ts\nfunction $6e02c1c9c7315aa4$export$d08fb897178424ea(input, fallback) {\n    if (!input || ArrayBuffer.isView(input)) return input;\n    const next = (x)=>fallback ? $6e02c1c9c7315aa4$export$d08fb897178424ea(x, fallback) : $6e02c1c9c7315aa4$export$d08fb897178424ea(x);\n    if ($6e02c1c9c7315aa4$export$707cacfe2982dfac(input)) {\n        if ($6e02c1c9c7315aa4$export$5d7e502287836e58(input)) return next(input.value);\n        return fallback ? fallback() : null;\n    }\n    if (Array.isArray(input)) return input.map(next);\n    if (typeof input === \"object\") return Object.fromEntries(Object.entries(input).map(([k, v])=>[\n            k,\n            next(v)\n        ]));\n    return input;\n}\n //# sourceMappingURL=index.browser.mjs.map\n\n\n\n// src/account.ts\nvar $3f6992d190194f4d$export$e150c881007e7b71 = 128;\nfunction $3f6992d190194f4d$export$cf5ddfea0105a5b4(encodedAccount, decoder) {\n    try {\n        if (\"exists\" in encodedAccount && !encodedAccount.exists) return encodedAccount;\n        return Object.freeze({\n            ...encodedAccount,\n            data: decoder.decode(encodedAccount.data)\n        });\n    } catch  {\n        throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$afc08ee11abbc257), {\n            address: encodedAccount.address\n        });\n    }\n}\nfunction $3f6992d190194f4d$var$accountExists(account) {\n    return !(\"exists\" in account) || \"exists\" in account && account.exists;\n}\nfunction $3f6992d190194f4d$export$6049f3842486bd08(account) {\n    if ($3f6992d190194f4d$var$accountExists(account) && account.data instanceof Uint8Array) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$57836d13a84f54b0), {\n        address: account.address\n    });\n}\nfunction $3f6992d190194f4d$export$16b2c5553d4ee2a4(accounts) {\n    const encoded = accounts.filter((a)=>$3f6992d190194f4d$var$accountExists(a) && a.data instanceof Uint8Array);\n    if (encoded.length > 0) {\n        const encodedAddresses = encoded.map((a)=>a.address);\n        throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$f080cd056a56cd54), {\n            addresses: encodedAddresses\n        });\n    }\n}\nfunction $3f6992d190194f4d$export$97e28684359b540a(address, rpcAccount) {\n    if (!rpcAccount) return Object.freeze({\n        address: address,\n        exists: false\n    });\n    const data = (0, $278ae65923ee60f5$export$7a87b201ca045431)().encode(rpcAccount.data[0]);\n    return Object.freeze({\n        ...$3f6992d190194f4d$var$parseBaseAccount(rpcAccount),\n        address: address,\n        data: data,\n        exists: true\n    });\n}\nfunction $3f6992d190194f4d$export$6b22ad22dd272f59(address, rpcAccount) {\n    if (!rpcAccount) return Object.freeze({\n        address: address,\n        exists: false\n    });\n    const data = (0, $278ae65923ee60f5$export$c9b1da42c197e8e5)().encode(typeof rpcAccount.data === \"string\" ? rpcAccount.data : rpcAccount.data[0]);\n    return Object.freeze({\n        ...$3f6992d190194f4d$var$parseBaseAccount(rpcAccount),\n        address: address,\n        data: data,\n        exists: true\n    });\n}\nfunction $3f6992d190194f4d$export$448740964ee0180a(address, rpcAccount) {\n    if (!rpcAccount) return Object.freeze({\n        address: address,\n        exists: false\n    });\n    const data = rpcAccount.data.parsed.info;\n    return Object.freeze({\n        ...$3f6992d190194f4d$var$parseBaseAccount(rpcAccount),\n        address: address,\n        data: data,\n        exists: true\n    });\n}\nfunction $3f6992d190194f4d$var$parseBaseAccount(rpcAccount) {\n    return Object.freeze({\n        executable: rpcAccount.executable,\n        lamports: rpcAccount.lamports,\n        programAddress: rpcAccount.owner,\n        space: rpcAccount.space\n    });\n}\n// src/fetch-account.ts\nasync function $3f6992d190194f4d$export$14418aaf1acfa4e5(rpc, address, config = {}) {\n    const { abortSignal: abortSignal, ...rpcConfig } = config;\n    const response = await rpc.getAccountInfo(address, {\n        ...rpcConfig,\n        encoding: \"base64\"\n    }).send({\n        abortSignal: abortSignal\n    });\n    return $3f6992d190194f4d$export$97e28684359b540a(address, response.value);\n}\nasync function $3f6992d190194f4d$export$285f3311f1f2c6b5(rpc, address, config = {}) {\n    const { abortSignal: abortSignal, ...rpcConfig } = config;\n    const { value: account } = await rpc.getAccountInfo(address, {\n        ...rpcConfig,\n        encoding: \"jsonParsed\"\n    }).send({\n        abortSignal: abortSignal\n    });\n    return !!account && typeof account === \"object\" && \"parsed\" in account.data ? $3f6992d190194f4d$export$448740964ee0180a(address, account) : $3f6992d190194f4d$export$97e28684359b540a(address, account);\n}\nasync function $3f6992d190194f4d$export$ea06bd5bf72cf183(rpc, addresses, config = {}) {\n    const { abortSignal: abortSignal, ...rpcConfig } = config;\n    const response = await rpc.getMultipleAccounts(addresses, {\n        ...rpcConfig,\n        encoding: \"base64\"\n    }).send({\n        abortSignal: abortSignal\n    });\n    return response.value.map((account, index)=>$3f6992d190194f4d$export$97e28684359b540a(addresses[index], account));\n}\nasync function $3f6992d190194f4d$export$702e45bf23b10097(rpc, addresses, config = {}) {\n    const { abortSignal: abortSignal, ...rpcConfig } = config;\n    const response = await rpc.getMultipleAccounts(addresses, {\n        ...rpcConfig,\n        encoding: \"jsonParsed\"\n    }).send({\n        abortSignal: abortSignal\n    });\n    return response.value.map((account, index)=>{\n        return !!account && typeof account === \"object\" && \"parsed\" in account.data ? $3f6992d190194f4d$export$448740964ee0180a(addresses[index], account) : $3f6992d190194f4d$export$97e28684359b540a(addresses[index], account);\n    });\n}\nfunction $3f6992d190194f4d$export$c5f1bc6464904f18(account) {\n    if (!account.exists) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$8f39956700e64760), {\n        address: account.address\n    });\n}\nfunction $3f6992d190194f4d$export$e34754ea38e46745(accounts) {\n    const missingAccounts = accounts.filter((a)=>!a.exists);\n    if (missingAccounts.length > 0) {\n        const missingAddresses = missingAccounts.map((a)=>a.address);\n        throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$1239089c4564c858), {\n            addresses: missingAddresses\n        });\n    }\n}\n //# sourceMappingURL=index.browser.mjs.map\n\n\n// src/program-error.ts\nfunction $d0aa1aba7ff24d28$export$868b481be3894762(error, transactionMessage, programAddress, code) {\n    if (!(0, $0bb11e8e9f3a1c4e$export$cfead212e52d9961)(error, (0, $0bb11e8e9f3a1c4e$export$5abe2d1d040bf6cf))) return false;\n    const instructionProgramAddress = transactionMessage.instructions[error.context.index]?.programAddress;\n    if (!instructionProgramAddress || instructionProgramAddress !== programAddress) return false;\n    return typeof code === \"undefined\" || error.context.code === code;\n}\n //# sourceMappingURL=index.browser.mjs.map\n\n\n// src/instruction.ts\nfunction $bc6d449c2ea12356$export$9a49872cbc8237f4(instruction, programAddress) {\n    return instruction.programAddress === programAddress;\n}\nfunction $bc6d449c2ea12356$export$4c06825b7494bd4e(instruction, programAddress) {\n    if (instruction.programAddress !== programAddress) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$b81e507604713b9b), {\n        actualProgramAddress: instruction.programAddress,\n        expectedProgramAddress: programAddress\n    });\n}\nfunction $bc6d449c2ea12356$export$e0a178b995494ead(instruction) {\n    return instruction.accounts !== void 0;\n}\nfunction $bc6d449c2ea12356$export$c2d07e8bb86331d7(instruction) {\n    if (instruction.accounts === void 0) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$552eeff1216c4a1e), {\n        data: instruction.data,\n        programAddress: instruction.programAddress\n    });\n}\nfunction $bc6d449c2ea12356$export$372cbaa3512415cd(instruction) {\n    return instruction.data !== void 0;\n}\nfunction $bc6d449c2ea12356$export$943d40a87be89f(instruction) {\n    if (instruction.data === void 0) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$b260fc8c8d3cde52), {\n        accountAddresses: instruction.accounts?.map((a)=>a.address),\n        programAddress: instruction.programAddress\n    });\n}\n// src/roles.ts\nvar $bc6d449c2ea12356$export$ee58f0c89e8fce3b = /* @__PURE__ */ ((AccountRole2)=>{\n    AccountRole2[AccountRole2[\"WRITABLE_SIGNER\"] = /* 3 */ 3] = \"WRITABLE_SIGNER\";\n    AccountRole2[AccountRole2[\"READONLY_SIGNER\"] = /* 2 */ 2] = \"READONLY_SIGNER\";\n    AccountRole2[AccountRole2[\"WRITABLE\"] = /* 1 */ 1] = \"WRITABLE\";\n    AccountRole2[AccountRole2[\"READONLY\"] = /* 0 */ 0] = \"READONLY\";\n    return AccountRole2;\n})($bc6d449c2ea12356$export$ee58f0c89e8fce3b || {});\nvar $bc6d449c2ea12356$var$IS_SIGNER_BITMASK = 2;\nvar $bc6d449c2ea12356$var$IS_WRITABLE_BITMASK = 1;\nfunction $bc6d449c2ea12356$export$105050aeb753d88f(role) {\n    return role & -3;\n}\nfunction $bc6d449c2ea12356$export$5b55d95a3627f56b(role) {\n    return role & -2;\n}\nfunction $bc6d449c2ea12356$export$dbf3fcc3475d4854(role) {\n    return role >= 2 /* READONLY_SIGNER */ ;\n}\nfunction $bc6d449c2ea12356$export$661070639376864a(role) {\n    return (role & $bc6d449c2ea12356$var$IS_WRITABLE_BITMASK) !== 0;\n}\nfunction $bc6d449c2ea12356$export$31fe16b7ab542c12(roleA, roleB) {\n    return roleA | roleB;\n}\nfunction $bc6d449c2ea12356$export$1b6e630330d6ac34(role) {\n    return role | $bc6d449c2ea12356$var$IS_SIGNER_BITMASK;\n}\nfunction $bc6d449c2ea12356$export$23afbfc9ff274de1(role) {\n    return role | $bc6d449c2ea12356$var$IS_WRITABLE_BITMASK;\n}\n //# sourceMappingURL=index.browser.mjs.map\n\n\n\n\n\n\n\n// src/key-pair.ts\n// src/algorithm.ts\nvar $69d8b348c1bcf261$var$ED25519_ALGORITHM_IDENTIFIER = // Resist the temptation to convert this to a simple string; As of version 133.0.3, Firefox\n// requires the object form of `AlgorithmIdentifier` and will throw a `DOMException` otherwise.\nObject.freeze({\n    name: \"Ed25519\"\n});\nfunction $69d8b348c1bcf261$var$addPkcs8Header(bytes) {\n    return new Uint8Array([\n        /**\n     * PKCS#8 header\n     */ 48,\n        // ASN.1 sequence tag\n        46,\n        // Length of sequence (46 more bytes)\n        2,\n        // ASN.1 integer tag\n        1,\n        // Length of integer\n        0,\n        // Version number\n        48,\n        // ASN.1 sequence tag\n        5,\n        // Length of sequence\n        6,\n        // ASN.1 object identifier tag\n        3,\n        // Length of object identifier\n        // Edwards curve algorithms identifier https://oid-rep.orange-labs.fr/get/1.3.101.112\n        43,\n        // iso(1) / identified-organization(3) (The first node is multiplied by the decimal 40 and the result is added to the value of the second node)\n        101,\n        // thawte(101)\n        // Ed25519 identifier\n        112,\n        // id-Ed25519(112)\n        /**\n     * Private key payload\n     */ 4,\n        // ASN.1 octet string tag\n        34,\n        // String length (34 more bytes)\n        // Private key bytes as octet string\n        4,\n        // ASN.1 octet string tag\n        32,\n        // String length (32 bytes)\n        ...bytes\n    ]);\n}\nasync function $69d8b348c1bcf261$export$e559ed46ceda263(bytes, extractable = false) {\n    const actualLength = bytes.byteLength;\n    if (actualLength !== 32) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$44352af09ecae39f), {\n        actualLength: actualLength\n    });\n    const privateKeyBytesPkcs8 = $69d8b348c1bcf261$var$addPkcs8Header(bytes);\n    return await crypto.subtle.importKey(\"pkcs8\", privateKeyBytesPkcs8, $69d8b348c1bcf261$var$ED25519_ALGORITHM_IDENTIFIER, extractable, [\n        \"sign\"\n    ]);\n}\nasync function $69d8b348c1bcf261$export$ed88b4ab65c31445(privateKey, extractable = false) {\n    (0, $1ec973a571fb3503$export$833df987f9577189)();\n    if (privateKey.extractable === false) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$b6497aaa1c3cb4a7), {\n        key: privateKey\n    });\n    const jwk = await crypto.subtle.exportKey(\"jwk\", privateKey);\n    return await crypto.subtle.importKey(\"jwk\", {\n        crv: \"Ed25519\",\n        ext: extractable,\n        key_ops: [\n            \"verify\"\n        ],\n        kty: \"OKP\",\n        x: jwk.x\n    }, \"Ed25519\", extractable, [\n        \"verify\"\n    ]);\n}\nvar $69d8b348c1bcf261$var$base58Encoder;\nfunction $69d8b348c1bcf261$export$286ca27fb0be7645(putativeSignature) {\n    if (!$69d8b348c1bcf261$var$base58Encoder) $69d8b348c1bcf261$var$base58Encoder = (0, $278ae65923ee60f5$export$c9b1da42c197e8e5)();\n    if (// Lowest value (64 bytes of zeroes)\n    putativeSignature.length < 64 || // Highest value (64 bytes of 255)\n    putativeSignature.length > 88) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$bbe4ed5687bc7f55), {\n        actualLength: putativeSignature.length\n    });\n    const bytes = $69d8b348c1bcf261$var$base58Encoder.encode(putativeSignature);\n    $69d8b348c1bcf261$export$c17e5a0171dc4cb2(bytes);\n}\nfunction $69d8b348c1bcf261$export$c17e5a0171dc4cb2(putativeSignatureBytes) {\n    const numBytes = putativeSignatureBytes.byteLength;\n    if (numBytes !== 64) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$d2a0e93e506be463), {\n        actualLength: numBytes\n    });\n}\nfunction $69d8b348c1bcf261$export$6151cd800850129c(putativeSignature) {\n    if (!$69d8b348c1bcf261$var$base58Encoder) $69d8b348c1bcf261$var$base58Encoder = (0, $278ae65923ee60f5$export$c9b1da42c197e8e5)();\n    if (// Lowest value (64 bytes of zeroes)\n    putativeSignature.length < 64 || // Highest value (64 bytes of 255)\n    putativeSignature.length > 88) return false;\n    const bytes = $69d8b348c1bcf261$var$base58Encoder.encode(putativeSignature);\n    return $69d8b348c1bcf261$export$4eb44cfebe0317f9(bytes);\n}\nfunction $69d8b348c1bcf261$export$4eb44cfebe0317f9(putativeSignatureBytes) {\n    return putativeSignatureBytes.byteLength === 64;\n}\nasync function $69d8b348c1bcf261$export$fff1e9696fc728a2(key, data) {\n    (0, $1ec973a571fb3503$export$a60e81a6d8aa0738)();\n    const signedData = await crypto.subtle.sign($69d8b348c1bcf261$var$ED25519_ALGORITHM_IDENTIFIER, key, data);\n    return new Uint8Array(signedData);\n}\nfunction $69d8b348c1bcf261$export$c9cd164b539ebb63(putativeSignature) {\n    $69d8b348c1bcf261$export$286ca27fb0be7645(putativeSignature);\n    return putativeSignature;\n}\nfunction $69d8b348c1bcf261$export$38d37b6875f04a3f(putativeSignatureBytes) {\n    $69d8b348c1bcf261$export$c17e5a0171dc4cb2(putativeSignatureBytes);\n    return putativeSignatureBytes;\n}\nasync function $69d8b348c1bcf261$export$ab54e47fdf2903bb(key, signature2, data) {\n    (0, $1ec973a571fb3503$export$abe752f2065eb545)();\n    return await crypto.subtle.verify($69d8b348c1bcf261$var$ED25519_ALGORITHM_IDENTIFIER, key, signature2, data);\n}\n// src/key-pair.ts\nasync function $69d8b348c1bcf261$export$a949d36eab55b41f() {\n    await (0, $1ec973a571fb3503$export$c8b831ead944a354)();\n    const keyPair = await crypto.subtle.generateKey(/* algorithm */ $69d8b348c1bcf261$var$ED25519_ALGORITHM_IDENTIFIER, // Native implementation status: https://github.com/WICG/webcrypto-secure-curves/issues/20\n    /* extractable */ false, // Prevents the bytes of the private key from being visible to JS.\n    /* allowed uses */ [\n        \"sign\",\n        \"verify\"\n    ]);\n    return keyPair;\n}\nasync function $69d8b348c1bcf261$export$fd6bf6b448cc1055(bytes, extractable = false) {\n    (0, $1ec973a571fb3503$export$9ea69ae0922ea694)();\n    if (bytes.byteLength !== 64) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$bc1242deaa4d848d), {\n        byteLength: bytes.byteLength\n    });\n    const [publicKey, privateKey] = await Promise.all([\n        crypto.subtle.importKey(\"raw\", bytes.slice(32), $69d8b348c1bcf261$var$ED25519_ALGORITHM_IDENTIFIER, /* extractable */ true, [\n            \"verify\"\n        ]),\n        $69d8b348c1bcf261$export$e559ed46ceda263(bytes.slice(0, 32), extractable)\n    ]);\n    const randomBytes = new Uint8Array(32);\n    crypto.getRandomValues(randomBytes);\n    const signedData = await $69d8b348c1bcf261$export$fff1e9696fc728a2(privateKey, randomBytes);\n    const isValid = await $69d8b348c1bcf261$export$ab54e47fdf2903bb(publicKey, signedData, randomBytes);\n    if (!isValid) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$436df06ce5af77b3));\n    return {\n        privateKey: privateKey,\n        publicKey: publicKey\n    };\n}\nasync function $69d8b348c1bcf261$export$d80945a4e9f5adcb(bytes, extractable = false) {\n    const privateKeyPromise = $69d8b348c1bcf261$export$e559ed46ceda263(bytes, extractable);\n    const [publicKey, privateKey] = await Promise.all([\n        // This nested promise makes things efficient by\n        // creating the public key in parallel with the\n        // second private key creation, if it is needed.\n        (extractable ? privateKeyPromise : $69d8b348c1bcf261$export$e559ed46ceda263(bytes, true)).then(async (privateKey2)=>await $69d8b348c1bcf261$export$ed88b4ab65c31445(privateKey2, true)),\n        privateKeyPromise\n    ]);\n    return {\n        privateKey: privateKey,\n        publicKey: publicKey\n    };\n}\n //# sourceMappingURL=index.browser.mjs.map\n\n\n\n\n\n\n\n\n\n\n\n\n// src/blockhash.ts\nfunction $ca0959b8e0bcee2a$export$f04f5af7ffd7bee(putativeBlockhash) {\n    return (0, $fadd3f4c7539d2fa$export$977e255126d763d6)(putativeBlockhash);\n}\nfunction $ca0959b8e0bcee2a$export$f08d12622c91db73(putativeBlockhash) {\n    try {\n        (0, $fadd3f4c7539d2fa$export$ce82521337b7000f)(putativeBlockhash);\n    } catch (error) {\n        if ((0, $0bb11e8e9f3a1c4e$export$cfead212e52d9961)(error, (0, $0bb11e8e9f3a1c4e$export$8aae3518bf4ea38c))) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$6ad19ea5e363a944), error.context);\n        if ((0, $0bb11e8e9f3a1c4e$export$cfead212e52d9961)(error, (0, $0bb11e8e9f3a1c4e$export$fe284a92110eab86))) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$c37fe345cc9b38e7), error.context);\n        throw error;\n    }\n}\nfunction $ca0959b8e0bcee2a$export$d4616ce1597d060(putativeBlockhash) {\n    $ca0959b8e0bcee2a$export$f08d12622c91db73(putativeBlockhash);\n    return putativeBlockhash;\n}\nfunction $ca0959b8e0bcee2a$export$2102c40640eb7803() {\n    const addressEncoder = (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)();\n    return (0, $b9bc3aaa401ff82b$export$4e76eeb6df88c889)({\n        fixedSize: 32,\n        write: (value, bytes, offset)=>{\n            $ca0959b8e0bcee2a$export$f08d12622c91db73(value);\n            return addressEncoder.write(value, bytes, offset);\n        }\n    });\n}\nfunction $ca0959b8e0bcee2a$export$3bd4205b3e3e56c4() {\n    return (0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)();\n}\nfunction $ca0959b8e0bcee2a$export$99bdaead60311e6a() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($ca0959b8e0bcee2a$export$2102c40640eb7803(), $ca0959b8e0bcee2a$export$3bd4205b3e3e56c4());\n}\nfunction $ca0959b8e0bcee2a$export$2a7a2b99defe76ca() {\n    return new Intl.Collator(\"en\", {\n        caseFirst: \"lower\",\n        ignorePunctuation: false,\n        localeMatcher: \"best fit\",\n        numeric: false,\n        sensitivity: \"variant\",\n        usage: \"sort\"\n    }).compare;\n}\n// src/cluster-url.ts\nfunction $ca0959b8e0bcee2a$export$536d3e0d2c7baf54(putativeString) {\n    return putativeString;\n}\nfunction $ca0959b8e0bcee2a$export$462ad409658d5ed5(putativeString) {\n    return putativeString;\n}\nfunction $ca0959b8e0bcee2a$export$d7bd83e6af043bd2(putativeString) {\n    return putativeString;\n}\nfunction $ca0959b8e0bcee2a$var$getCommitmentScore(commitment) {\n    switch(commitment){\n        case \"finalized\":\n            return 2;\n        case \"confirmed\":\n            return 1;\n        case \"processed\":\n            return 0;\n        default:\n            throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$6fe73388375373f), {\n                unexpectedValue: commitment\n            });\n    }\n}\nfunction $ca0959b8e0bcee2a$export$43e7693c5c691e99(a, b) {\n    if (a === b) return 0;\n    return $ca0959b8e0bcee2a$var$getCommitmentScore(a) < $ca0959b8e0bcee2a$var$getCommitmentScore(b) ? -1 : 1;\n}\nvar $ca0959b8e0bcee2a$var$maxU64Value = 18446744073709551615n;\nvar $ca0959b8e0bcee2a$var$memoizedU64Encoder;\nvar $ca0959b8e0bcee2a$var$memoizedU64Decoder;\nfunction $ca0959b8e0bcee2a$var$getMemoizedU64Encoder() {\n    if (!$ca0959b8e0bcee2a$var$memoizedU64Encoder) $ca0959b8e0bcee2a$var$memoizedU64Encoder = (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)();\n    return $ca0959b8e0bcee2a$var$memoizedU64Encoder;\n}\nfunction $ca0959b8e0bcee2a$var$getMemoizedU64Decoder() {\n    if (!$ca0959b8e0bcee2a$var$memoizedU64Decoder) $ca0959b8e0bcee2a$var$memoizedU64Decoder = (0, $b5f941eb9a28d328$export$faa05ffebebd465d)();\n    return $ca0959b8e0bcee2a$var$memoizedU64Decoder;\n}\nfunction $ca0959b8e0bcee2a$export$8b78f033d8508a32(putativeLamports) {\n    return putativeLamports >= 0 && putativeLamports <= $ca0959b8e0bcee2a$var$maxU64Value;\n}\nfunction $ca0959b8e0bcee2a$export$483f206e4417d482(putativeLamports) {\n    if (putativeLamports < 0 || putativeLamports > $ca0959b8e0bcee2a$var$maxU64Value) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$cf7b28c4ea07497b));\n}\nfunction $ca0959b8e0bcee2a$export$b40486d51d67dc90(putativeLamports) {\n    $ca0959b8e0bcee2a$export$483f206e4417d482(putativeLamports);\n    return putativeLamports;\n}\nfunction $ca0959b8e0bcee2a$export$2f3071245f801283() {\n    return $ca0959b8e0bcee2a$export$bb5130f1025befc6($ca0959b8e0bcee2a$var$getMemoizedU64Encoder());\n}\nfunction $ca0959b8e0bcee2a$export$bb5130f1025befc6(innerEncoder) {\n    return innerEncoder;\n}\nfunction $ca0959b8e0bcee2a$export$a32171385d01c30e() {\n    return $ca0959b8e0bcee2a$export$bc74b63820c4f0b1($ca0959b8e0bcee2a$var$getMemoizedU64Decoder());\n}\nfunction $ca0959b8e0bcee2a$export$bc74b63820c4f0b1(innerDecoder) {\n    return (0, $b9bc3aaa401ff82b$export$605b10ee38669daa)(innerDecoder, (value)=>$ca0959b8e0bcee2a$export$b40486d51d67dc90(typeof value === \"bigint\" ? value : BigInt(value)));\n}\nfunction $ca0959b8e0bcee2a$export$a1a1253b28f12d33() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($ca0959b8e0bcee2a$export$2f3071245f801283(), $ca0959b8e0bcee2a$export$a32171385d01c30e());\n}\nfunction $ca0959b8e0bcee2a$export$86dbd64b778f18d(innerCodec) {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($ca0959b8e0bcee2a$export$bb5130f1025befc6(innerCodec), $ca0959b8e0bcee2a$export$bc74b63820c4f0b1(innerCodec));\n}\nfunction $ca0959b8e0bcee2a$export$65651a19dfd88f3a(putativeBigInt) {\n    try {\n        BigInt(putativeBigInt);\n        return true;\n    } catch  {\n        return false;\n    }\n}\nfunction $ca0959b8e0bcee2a$export$6810dc6f723cee5d(putativeBigInt) {\n    try {\n        BigInt(putativeBigInt);\n    } catch  {\n        throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$e8ff0c73a3d6800d), {\n            value: putativeBigInt\n        });\n    }\n}\nfunction $ca0959b8e0bcee2a$export$7eccb90d0c461850(putativeBigInt) {\n    $ca0959b8e0bcee2a$export$6810dc6f723cee5d(putativeBigInt);\n    return putativeBigInt;\n}\nfunction $ca0959b8e0bcee2a$export$6de41c36bdbcc059(putativeNumber) {\n    return !Number.isNaN(Number(putativeNumber));\n}\nfunction $ca0959b8e0bcee2a$export$1f8ed380b3f333b(putativeNumber) {\n    if (Number.isNaN(Number(putativeNumber))) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$7dd7d17f1f93a166), {\n        value: putativeNumber\n    });\n}\nfunction $ca0959b8e0bcee2a$export$511f4cc775861fd(putativeNumber) {\n    $ca0959b8e0bcee2a$export$1f8ed380b3f333b(putativeNumber);\n    return putativeNumber;\n}\nvar $ca0959b8e0bcee2a$var$maxI64Value = 9223372036854775807n;\nvar $ca0959b8e0bcee2a$var$minI64Value = -9223372036854775808n;\nfunction $ca0959b8e0bcee2a$export$3e0dcc4e1ddc8dbf(putativeTimestamp) {\n    return putativeTimestamp >= $ca0959b8e0bcee2a$var$minI64Value && putativeTimestamp <= $ca0959b8e0bcee2a$var$maxI64Value;\n}\nfunction $ca0959b8e0bcee2a$export$a027db293145bef7(putativeTimestamp) {\n    if (putativeTimestamp < $ca0959b8e0bcee2a$var$minI64Value || putativeTimestamp > $ca0959b8e0bcee2a$var$maxI64Value) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$8b23617676679e2d), {\n        value: putativeTimestamp\n    });\n}\nfunction $ca0959b8e0bcee2a$export$a6ce9493be6fab25(putativeTimestamp) {\n    $ca0959b8e0bcee2a$export$a027db293145bef7(putativeTimestamp);\n    return putativeTimestamp;\n}\n //# sourceMappingURL=index.browser.mjs.map\n\n\n\n\n\n\n\n// src/pipe.ts\nfunction $b5a2243413675af7$export$a4627e546088548d(init, ...fns) {\n    return fns.reduce((acc, fn)=>fn(acc), init);\n}\n //# sourceMappingURL=index.browser.mjs.map\n\n\n// src/blockhash.ts\nfunction $b4ed957d06eb8202$export$eeeaaab335de65fd(transactionMessage) {\n    return \"lifetimeConstraint\" in transactionMessage && typeof transactionMessage.lifetimeConstraint.blockhash === \"string\" && typeof transactionMessage.lifetimeConstraint.lastValidBlockHeight === \"bigint\" && (0, $ca0959b8e0bcee2a$export$f04f5af7ffd7bee)(transactionMessage.lifetimeConstraint.blockhash);\n}\nfunction $b4ed957d06eb8202$export$a12b20b888c80c39(transactionMessage) {\n    if (!$b4ed957d06eb8202$export$eeeaaab335de65fd(transactionMessage)) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$e33d07a7526bded0));\n}\nfunction $b4ed957d06eb8202$export$7e1319dc00734f3f(blockhashLifetimeConstraint, transactionMessage) {\n    if (\"lifetimeConstraint\" in transactionMessage && transactionMessage.lifetimeConstraint && \"blockhash\" in transactionMessage.lifetimeConstraint && transactionMessage.lifetimeConstraint.blockhash === blockhashLifetimeConstraint.blockhash && transactionMessage.lifetimeConstraint.lastValidBlockHeight === blockhashLifetimeConstraint.lastValidBlockHeight) return transactionMessage;\n    return Object.freeze({\n        ...transactionMessage,\n        lifetimeConstraint: Object.freeze(blockhashLifetimeConstraint)\n    });\n}\nfunction $b4ed957d06eb8202$var$assertValidBaseString(alphabet4, testValue, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet4}]*$`))) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$89b582b06852d433), {\n        alphabet: alphabet4,\n        base: alphabet4.length,\n        value: givenValue\n    });\n}\nvar $b4ed957d06eb8202$var$getBaseXEncoder = (alphabet4)=>{\n    return (0, $b9bc3aaa401ff82b$export$4e76eeb6df88c889)({\n        getSizeFromValue: (value)=>{\n            const [leadingZeroes, tailChars] = $b4ed957d06eb8202$var$partitionLeadingZeroes(value, alphabet4[0]);\n            if (!tailChars) return value.length;\n            const base10Number = $b4ed957d06eb8202$var$getBigIntFromBaseX(tailChars, alphabet4);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write (value, bytes, offset) {\n            $b4ed957d06eb8202$var$assertValidBaseString(alphabet4, value);\n            if (value === \"\") return offset;\n            const [leadingZeroes, tailChars] = $b4ed957d06eb8202$var$partitionLeadingZeroes(value, alphabet4[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n            let base10Number = $b4ed957d06eb8202$var$getBigIntFromBaseX(tailChars, alphabet4);\n            const tailBytes = [];\n            while(base10Number > 0n){\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n            const bytesToAdd = [\n                ...Array(leadingZeroes.length).fill(0),\n                ...tailBytes\n            ];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        }\n    });\n};\nvar $b4ed957d06eb8202$var$getBaseXDecoder = (alphabet4)=>{\n    return (0, $b9bc3aaa401ff82b$export$f8c898e83b60faaa)({\n        read (rawBytes, offset) {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return [\n                \"\",\n                0\n            ];\n            let trailIndex = bytes.findIndex((n)=>n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet4[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [\n                leadingZeroes,\n                rawBytes.length\n            ];\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte)=>sum * 256n + BigInt(byte), 0n);\n            const tailChars = $b4ed957d06eb8202$var$getBaseXFromBigInt(base10Number, alphabet4);\n            return [\n                leadingZeroes + tailChars,\n                rawBytes.length\n            ];\n        }\n    });\n};\nfunction $b4ed957d06eb8202$var$partitionLeadingZeroes(value, zeroCharacter) {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [\n        leadingZeros,\n        tailChars\n    ];\n}\nfunction $b4ed957d06eb8202$var$getBigIntFromBaseX(value, alphabet4) {\n    const base = BigInt(alphabet4.length);\n    let sum = 0n;\n    for (const char of value){\n        sum *= base;\n        sum += BigInt(alphabet4.indexOf(char));\n    }\n    return sum;\n}\nfunction $b4ed957d06eb8202$var$getBaseXFromBigInt(value, alphabet4) {\n    const base = BigInt(alphabet4.length);\n    const tailChars = [];\n    while(value > 0n){\n        tailChars.unshift(alphabet4[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join(\"\");\n}\nvar $b4ed957d06eb8202$var$alphabet2 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nvar $b4ed957d06eb8202$var$getBase58Encoder = ()=>$b4ed957d06eb8202$var$getBaseXEncoder($b4ed957d06eb8202$var$alphabet2);\nvar $b4ed957d06eb8202$var$getBase58Decoder = ()=>$b4ed957d06eb8202$var$getBaseXDecoder($b4ed957d06eb8202$var$alphabet2);\nvar $b4ed957d06eb8202$var$memoizedAddressTableLookupEncoder;\nfunction $b4ed957d06eb8202$var$getAddressTableLookupEncoder() {\n    if (!$b4ed957d06eb8202$var$memoizedAddressTableLookupEncoder) {\n        const indexEncoder = (0, $991819a0aa439d56$export$415199198053c0b)((0, $b5f941eb9a28d328$export$dc9732115561fb4b)(), {\n            size: (0, $b5f941eb9a28d328$export$6f025a6ce2a023fc)()\n        });\n        $b4ed957d06eb8202$var$memoizedAddressTableLookupEncoder = (0, $991819a0aa439d56$export$64024546a32014b8)([\n            [\n                \"lookupTableAddress\",\n                (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)()\n            ],\n            [\n                \"writableIndexes\",\n                indexEncoder\n            ],\n            [\n                \"readonlyIndexes\",\n                indexEncoder\n            ]\n        ]);\n    }\n    return $b4ed957d06eb8202$var$memoizedAddressTableLookupEncoder;\n}\nvar $b4ed957d06eb8202$var$memoizedAddressTableLookupDecoder;\nfunction $b4ed957d06eb8202$var$getAddressTableLookupDecoder() {\n    if (!$b4ed957d06eb8202$var$memoizedAddressTableLookupDecoder) {\n        const indexEncoder = (0, $991819a0aa439d56$export$9016038b2e3b0c2f)((0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)(), {\n            size: (0, $b5f941eb9a28d328$export$fa35aa457fb08b4a)()\n        });\n        $b4ed957d06eb8202$var$memoizedAddressTableLookupDecoder = (0, $991819a0aa439d56$export$7070fbe048971470)([\n            [\n                \"lookupTableAddress\",\n                (0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)()\n            ],\n            [\n                \"writableIndexes\",\n                indexEncoder\n            ],\n            [\n                \"readonlyIndexes\",\n                indexEncoder\n            ]\n        ]);\n    }\n    return $b4ed957d06eb8202$var$memoizedAddressTableLookupDecoder;\n}\nvar $b4ed957d06eb8202$var$memoizedU8Encoder;\nfunction $b4ed957d06eb8202$var$getMemoizedU8Encoder() {\n    if (!$b4ed957d06eb8202$var$memoizedU8Encoder) $b4ed957d06eb8202$var$memoizedU8Encoder = (0, $b5f941eb9a28d328$export$dc9732115561fb4b)();\n    return $b4ed957d06eb8202$var$memoizedU8Encoder;\n}\nvar $b4ed957d06eb8202$var$memoizedU8Decoder;\nfunction $b4ed957d06eb8202$var$getMemoizedU8Decoder() {\n    if (!$b4ed957d06eb8202$var$memoizedU8Decoder) $b4ed957d06eb8202$var$memoizedU8Decoder = (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)();\n    return $b4ed957d06eb8202$var$memoizedU8Decoder;\n}\nfunction $b4ed957d06eb8202$var$getMessageHeaderEncoder() {\n    return (0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"numSignerAccounts\",\n            $b4ed957d06eb8202$var$getMemoizedU8Encoder()\n        ],\n        [\n            \"numReadonlySignerAccounts\",\n            $b4ed957d06eb8202$var$getMemoizedU8Encoder()\n        ],\n        [\n            \"numReadonlyNonSignerAccounts\",\n            $b4ed957d06eb8202$var$getMemoizedU8Encoder()\n        ]\n    ]);\n}\nfunction $b4ed957d06eb8202$var$getMessageHeaderDecoder() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"numSignerAccounts\",\n            $b4ed957d06eb8202$var$getMemoizedU8Decoder()\n        ],\n        [\n            \"numReadonlySignerAccounts\",\n            $b4ed957d06eb8202$var$getMemoizedU8Decoder()\n        ],\n        [\n            \"numReadonlyNonSignerAccounts\",\n            $b4ed957d06eb8202$var$getMemoizedU8Decoder()\n        ]\n    ]);\n}\nvar $b4ed957d06eb8202$var$memoizedGetInstructionEncoder;\nfunction $b4ed957d06eb8202$var$getInstructionEncoder() {\n    if (!$b4ed957d06eb8202$var$memoizedGetInstructionEncoder) $b4ed957d06eb8202$var$memoizedGetInstructionEncoder = (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"programAddressIndex\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"accountIndices\",\n            (0, $991819a0aa439d56$export$415199198053c0b)((0, $b5f941eb9a28d328$export$dc9732115561fb4b)(), {\n                size: (0, $b5f941eb9a28d328$export$6f025a6ce2a023fc)()\n            })\n        ],\n        [\n            \"data\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$636c51ad84d0674a)(), (0, $b5f941eb9a28d328$export$6f025a6ce2a023fc)())\n        ]\n    ]), // Convert an instruction to have all fields defined\n    (instruction)=>{\n        if (instruction.accountIndices !== void 0 && instruction.data !== void 0) return instruction;\n        return {\n            ...instruction,\n            accountIndices: instruction.accountIndices ?? [],\n            data: instruction.data ?? new Uint8Array(0)\n        };\n    });\n    return $b4ed957d06eb8202$var$memoizedGetInstructionEncoder;\n}\nvar $b4ed957d06eb8202$var$memoizedGetInstructionDecoder;\nfunction $b4ed957d06eb8202$var$getInstructionDecoder() {\n    if (!$b4ed957d06eb8202$var$memoizedGetInstructionDecoder) $b4ed957d06eb8202$var$memoizedGetInstructionDecoder = (0, $b9bc3aaa401ff82b$export$605b10ee38669daa)((0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"programAddressIndex\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"accountIndices\",\n            (0, $991819a0aa439d56$export$9016038b2e3b0c2f)((0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)(), {\n                size: (0, $b5f941eb9a28d328$export$fa35aa457fb08b4a)()\n            })\n        ],\n        [\n            \"data\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$b90e67818b1b3d45)(), (0, $b5f941eb9a28d328$export$fa35aa457fb08b4a)())\n        ]\n    ]), // Convert an instruction to exclude optional fields if they are empty\n    (instruction)=>{\n        if (instruction.accountIndices.length && instruction.data.byteLength) return instruction;\n        const { accountIndices: accountIndices, data: data, ...rest } = instruction;\n        return {\n            ...rest,\n            ...accountIndices.length ? {\n                accountIndices: accountIndices\n            } : null,\n            ...data.byteLength ? {\n                data: data\n            } : null\n        };\n    });\n    return $b4ed957d06eb8202$var$memoizedGetInstructionDecoder;\n}\n// src/transaction-message.ts\nvar $b4ed957d06eb8202$export$6e8f9d49124aa1db = 0;\n// src/codecs/transaction-version.ts\nvar $b4ed957d06eb8202$var$VERSION_FLAG_MASK = 128;\nfunction $b4ed957d06eb8202$export$e23fb559bc9d0d07() {\n    return (0, $b9bc3aaa401ff82b$export$4e76eeb6df88c889)({\n        getSizeFromValue: (value)=>value === \"legacy\" ? 0 : 1,\n        maxSize: 1,\n        write: (value, bytes, offset)=>{\n            if (value === \"legacy\") return offset;\n            if (value < 0 || value > 127) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$3963d9bca4091810), {\n                actualVersion: value\n            });\n            if (value > $b4ed957d06eb8202$export$6e8f9d49124aa1db) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$8ff97fea1326b6e7), {\n                unsupportedVersion: value\n            });\n            bytes.set([\n                value | $b4ed957d06eb8202$var$VERSION_FLAG_MASK\n            ], offset);\n            return offset + 1;\n        }\n    });\n}\nfunction $b4ed957d06eb8202$export$ef3eb451884ff775() {\n    return (0, $b9bc3aaa401ff82b$export$f8c898e83b60faaa)({\n        maxSize: 1,\n        read: (bytes, offset)=>{\n            const firstByte = bytes[offset];\n            if ((firstByte & $b4ed957d06eb8202$var$VERSION_FLAG_MASK) === 0) return [\n                \"legacy\",\n                offset\n            ];\n            else {\n                const version = firstByte ^ $b4ed957d06eb8202$var$VERSION_FLAG_MASK;\n                if (version > $b4ed957d06eb8202$export$6e8f9d49124aa1db) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$8ff97fea1326b6e7), {\n                    unsupportedVersion: version\n                });\n                return [\n                    version,\n                    offset + 1\n                ];\n            }\n        }\n    });\n}\nfunction $b4ed957d06eb8202$export$16d5c73b70d357f5() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($b4ed957d06eb8202$export$e23fb559bc9d0d07(), $b4ed957d06eb8202$export$ef3eb451884ff775());\n}\n// src/codecs/message.ts\nfunction $b4ed957d06eb8202$var$getCompiledMessageLegacyEncoder() {\n    return (0, $991819a0aa439d56$export$64024546a32014b8)($b4ed957d06eb8202$var$getPreludeStructEncoderTuple());\n}\nfunction $b4ed957d06eb8202$var$getCompiledMessageVersionedEncoder() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        ...$b4ed957d06eb8202$var$getPreludeStructEncoderTuple(),\n        [\n            \"addressTableLookups\",\n            $b4ed957d06eb8202$var$getAddressTableLookupArrayEncoder()\n        ]\n    ]), (value)=>{\n        if (value.version === \"legacy\") return value;\n        return {\n            ...value,\n            addressTableLookups: value.addressTableLookups ?? []\n        };\n    });\n}\nfunction $b4ed957d06eb8202$var$getPreludeStructEncoderTuple() {\n    const lifetimeTokenEncoder = (0, $991819a0aa439d56$export$a9351c88c0e29fc0)([\n        // Use a 32-byte constant encoder for a missing lifetime token (index 0).\n        (0, $991819a0aa439d56$export$23a212060029ca97)(new Uint8Array(32)),\n        // Use a 32-byte base58 encoder for a valid lifetime token (index 1).\n        (0, $b9bc3aaa401ff82b$export$cbdfce031443a1)($b4ed957d06eb8202$var$getBase58Encoder(), 32)\n    ], (value)=>value === void 0 ? 0 : 1);\n    return [\n        [\n            \"version\",\n            $b4ed957d06eb8202$export$e23fb559bc9d0d07()\n        ],\n        [\n            \"header\",\n            $b4ed957d06eb8202$var$getMessageHeaderEncoder()\n        ],\n        [\n            \"staticAccounts\",\n            (0, $991819a0aa439d56$export$415199198053c0b)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                size: (0, $b5f941eb9a28d328$export$6f025a6ce2a023fc)()\n            })\n        ],\n        [\n            \"lifetimeToken\",\n            lifetimeTokenEncoder\n        ],\n        [\n            \"instructions\",\n            (0, $991819a0aa439d56$export$415199198053c0b)($b4ed957d06eb8202$var$getInstructionEncoder(), {\n                size: (0, $b5f941eb9a28d328$export$6f025a6ce2a023fc)()\n            })\n        ]\n    ];\n}\nfunction $b4ed957d06eb8202$var$getPreludeStructDecoderTuple() {\n    return [\n        [\n            \"version\",\n            $b4ed957d06eb8202$export$ef3eb451884ff775()\n        ],\n        [\n            \"header\",\n            $b4ed957d06eb8202$var$getMessageHeaderDecoder()\n        ],\n        [\n            \"staticAccounts\",\n            (0, $991819a0aa439d56$export$9016038b2e3b0c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                size: (0, $b5f941eb9a28d328$export$fa35aa457fb08b4a)()\n            })\n        ],\n        [\n            \"lifetimeToken\",\n            (0, $b9bc3aaa401ff82b$export$1f85f8b8d2788007)($b4ed957d06eb8202$var$getBase58Decoder(), 32)\n        ],\n        [\n            \"instructions\",\n            (0, $991819a0aa439d56$export$9016038b2e3b0c2f)($b4ed957d06eb8202$var$getInstructionDecoder(), {\n                size: (0, $b5f941eb9a28d328$export$fa35aa457fb08b4a)()\n            })\n        ],\n        [\n            \"addressTableLookups\",\n            $b4ed957d06eb8202$var$getAddressTableLookupArrayDecoder()\n        ]\n    ];\n}\nfunction $b4ed957d06eb8202$var$getAddressTableLookupArrayEncoder() {\n    return (0, $991819a0aa439d56$export$415199198053c0b)($b4ed957d06eb8202$var$getAddressTableLookupEncoder(), {\n        size: (0, $b5f941eb9a28d328$export$6f025a6ce2a023fc)()\n    });\n}\nfunction $b4ed957d06eb8202$var$getAddressTableLookupArrayDecoder() {\n    return (0, $991819a0aa439d56$export$9016038b2e3b0c2f)($b4ed957d06eb8202$var$getAddressTableLookupDecoder(), {\n        size: (0, $b5f941eb9a28d328$export$fa35aa457fb08b4a)()\n    });\n}\nfunction $b4ed957d06eb8202$export$61435546aadd1929() {\n    return (0, $b9bc3aaa401ff82b$export$4e76eeb6df88c889)({\n        getSizeFromValue: (compiledMessage)=>{\n            if (compiledMessage.version === \"legacy\") return $b4ed957d06eb8202$var$getCompiledMessageLegacyEncoder().getSizeFromValue(compiledMessage);\n            else return $b4ed957d06eb8202$var$getCompiledMessageVersionedEncoder().getSizeFromValue(compiledMessage);\n        },\n        write: (compiledMessage, bytes, offset)=>{\n            if (compiledMessage.version === \"legacy\") return $b4ed957d06eb8202$var$getCompiledMessageLegacyEncoder().write(compiledMessage, bytes, offset);\n            else return $b4ed957d06eb8202$var$getCompiledMessageVersionedEncoder().write(compiledMessage, bytes, offset);\n        }\n    });\n}\nfunction $b4ed957d06eb8202$export$1ac390c777a62c05() {\n    return (0, $b9bc3aaa401ff82b$export$605b10ee38669daa)((0, $991819a0aa439d56$export$7070fbe048971470)($b4ed957d06eb8202$var$getPreludeStructDecoderTuple()), ({ addressTableLookups: addressTableLookups, ...restOfMessage })=>{\n        if (restOfMessage.version === \"legacy\" || !addressTableLookups?.length) return restOfMessage;\n        return {\n            ...restOfMessage,\n            addressTableLookups: addressTableLookups\n        };\n    });\n}\nfunction $b4ed957d06eb8202$export$1637a97a6d5396f9() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($b4ed957d06eb8202$export$61435546aadd1929(), $b4ed957d06eb8202$export$1ac390c777a62c05());\n}\nfunction $b4ed957d06eb8202$var$upsert(addressMap, address, update) {\n    addressMap[address] = update(addressMap[address] ?? {\n        role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY\n    });\n}\nvar $b4ed957d06eb8202$var$TYPE = Symbol(\"AddressMapTypeProperty\");\nfunction $b4ed957d06eb8202$var$getAddressMapFromInstructions(feePayer, instructions) {\n    const addressMap = {\n        [feePayer]: {\n            [$b4ed957d06eb8202$var$TYPE]: 0 /* FEE_PAYER */ ,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).WRITABLE_SIGNER\n        }\n    };\n    const addressesOfInvokedPrograms = /* @__PURE__ */ new Set();\n    for (const instruction of instructions){\n        $b4ed957d06eb8202$var$upsert(addressMap, instruction.programAddress, (entry)=>{\n            addressesOfInvokedPrograms.add(instruction.programAddress);\n            if ($b4ed957d06eb8202$var$TYPE in entry) {\n                if ((0, $bc6d449c2ea12356$export$661070639376864a)(entry.role)) switch(entry[$b4ed957d06eb8202$var$TYPE]){\n                    case 0 /* FEE_PAYER */ :\n                        throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$694fd435994bcca), {\n                            programAddress: instruction.programAddress\n                        });\n                    default:\n                        throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$707576ec00ca24d6), {\n                            programAddress: instruction.programAddress\n                        });\n                }\n                if (entry[$b4ed957d06eb8202$var$TYPE] === 2 /* STATIC */ ) return entry;\n            }\n            return {\n                [$b4ed957d06eb8202$var$TYPE]: 2 /* STATIC */ ,\n                role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY\n            };\n        });\n        let addressComparator;\n        if (!instruction.accounts) continue;\n        for (const account of instruction.accounts)$b4ed957d06eb8202$var$upsert(addressMap, account.address, (entry)=>{\n            const { // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            address: _, ...accountMeta } = account;\n            if ($b4ed957d06eb8202$var$TYPE in entry) switch(entry[$b4ed957d06eb8202$var$TYPE]){\n                case 0 /* FEE_PAYER */ :\n                    return entry;\n                case 1 /* LOOKUP_TABLE */ :\n                    {\n                        const nextRole = (0, $bc6d449c2ea12356$export$31fe16b7ab542c12)(entry.role, accountMeta.role);\n                        if (\"lookupTableAddress\" in accountMeta) {\n                            const shouldReplaceEntry = // Consider using the new LOOKUP_TABLE if its address is different...\n                            entry.lookupTableAddress !== accountMeta.lookupTableAddress && // ...and sorts before the existing one.\n                            (addressComparator ||= (0, $fadd3f4c7539d2fa$export$be47cbc6fd88c6e6)())(accountMeta.lookupTableAddress, entry.lookupTableAddress) < 0;\n                            if (shouldReplaceEntry) return {\n                                [$b4ed957d06eb8202$var$TYPE]: 1 /* LOOKUP_TABLE */ ,\n                                ...accountMeta,\n                                role: nextRole\n                            };\n                        } else if ((0, $bc6d449c2ea12356$export$dbf3fcc3475d4854)(accountMeta.role)) return {\n                            [$b4ed957d06eb8202$var$TYPE]: 2 /* STATIC */ ,\n                            role: nextRole\n                        };\n                        if (entry.role !== nextRole) return {\n                            ...entry,\n                            role: nextRole\n                        };\n                        else return entry;\n                    }\n                case 2 /* STATIC */ :\n                    {\n                        const nextRole = (0, $bc6d449c2ea12356$export$31fe16b7ab542c12)(entry.role, accountMeta.role);\n                        if (// Check to see if this address represents a program that is invoked\n                        // in this transaction.\n                        addressesOfInvokedPrograms.has(account.address)) {\n                            if ((0, $bc6d449c2ea12356$export$661070639376864a)(accountMeta.role)) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$707576ec00ca24d6), {\n                                programAddress: account.address\n                            });\n                            if (entry.role !== nextRole) return {\n                                ...entry,\n                                role: nextRole\n                            };\n                            else return entry;\n                        } else if (\"lookupTableAddress\" in accountMeta && // Static accounts can be 'upgraded' to lookup table accounts as\n                        // long as they are not require to sign the transaction.\n                        !(0, $bc6d449c2ea12356$export$dbf3fcc3475d4854)(entry.role)) return {\n                            ...accountMeta,\n                            [$b4ed957d06eb8202$var$TYPE]: 1 /* LOOKUP_TABLE */ ,\n                            role: nextRole\n                        };\n                        else {\n                            if (entry.role !== nextRole) return {\n                                ...entry,\n                                role: nextRole\n                            };\n                            else return entry;\n                        }\n                    }\n            }\n            if (\"lookupTableAddress\" in accountMeta) return {\n                ...accountMeta,\n                [$b4ed957d06eb8202$var$TYPE]: 1 /* LOOKUP_TABLE */ \n            };\n            else return {\n                ...accountMeta,\n                [$b4ed957d06eb8202$var$TYPE]: 2 /* STATIC */ \n            };\n        });\n    }\n    return addressMap;\n}\nfunction $b4ed957d06eb8202$var$getOrderedAccountsFromAddressMap(addressMap) {\n    let addressComparator;\n    const orderedAccounts = Object.entries(addressMap).sort(([leftAddress, leftEntry], [rightAddress, rightEntry])=>{\n        if (leftEntry[$b4ed957d06eb8202$var$TYPE] !== rightEntry[$b4ed957d06eb8202$var$TYPE]) {\n            if (leftEntry[$b4ed957d06eb8202$var$TYPE] === 0 /* FEE_PAYER */ ) return -1;\n            else if (rightEntry[$b4ed957d06eb8202$var$TYPE] === 0 /* FEE_PAYER */ ) return 1;\n            else if (leftEntry[$b4ed957d06eb8202$var$TYPE] === 2 /* STATIC */ ) return -1;\n            else if (rightEntry[$b4ed957d06eb8202$var$TYPE] === 2 /* STATIC */ ) return 1;\n        }\n        const leftIsSigner = (0, $bc6d449c2ea12356$export$dbf3fcc3475d4854)(leftEntry.role);\n        if (leftIsSigner !== (0, $bc6d449c2ea12356$export$dbf3fcc3475d4854)(rightEntry.role)) return leftIsSigner ? -1 : 1;\n        const leftIsWritable = (0, $bc6d449c2ea12356$export$661070639376864a)(leftEntry.role);\n        if (leftIsWritable !== (0, $bc6d449c2ea12356$export$661070639376864a)(rightEntry.role)) return leftIsWritable ? -1 : 1;\n        addressComparator ||= (0, $fadd3f4c7539d2fa$export$be47cbc6fd88c6e6)();\n        if (leftEntry[$b4ed957d06eb8202$var$TYPE] === 1 /* LOOKUP_TABLE */  && rightEntry[$b4ed957d06eb8202$var$TYPE] === 1 /* LOOKUP_TABLE */  && leftEntry.lookupTableAddress !== rightEntry.lookupTableAddress) return addressComparator(leftEntry.lookupTableAddress, rightEntry.lookupTableAddress);\n        else return addressComparator(leftAddress, rightAddress);\n    }).map(([address, addressMeta])=>({\n            address: address,\n            ...addressMeta\n        }));\n    return orderedAccounts;\n}\nfunction $b4ed957d06eb8202$var$getCompiledAddressTableLookups(orderedAccounts) {\n    const index = {};\n    for (const account of orderedAccounts){\n        if (!(\"lookupTableAddress\" in account)) continue;\n        const entry = index[account.lookupTableAddress] ||= {\n            readonlyIndexes: [],\n            writableIndexes: []\n        };\n        if (account.role === (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).WRITABLE) entry.writableIndexes.push(account.addressIndex);\n        else entry.readonlyIndexes.push(account.addressIndex);\n    }\n    return Object.keys(index).sort((0, $fadd3f4c7539d2fa$export$be47cbc6fd88c6e6)()).map((lookupTableAddress)=>({\n            lookupTableAddress: lookupTableAddress,\n            ...index[lookupTableAddress]\n        }));\n}\nfunction $b4ed957d06eb8202$var$getCompiledMessageHeader(orderedAccounts) {\n    let numReadonlyNonSignerAccounts = 0;\n    let numReadonlySignerAccounts = 0;\n    let numSignerAccounts = 0;\n    for (const account of orderedAccounts){\n        if (\"lookupTableAddress\" in account) break;\n        const accountIsWritable = (0, $bc6d449c2ea12356$export$661070639376864a)(account.role);\n        if ((0, $bc6d449c2ea12356$export$dbf3fcc3475d4854)(account.role)) {\n            numSignerAccounts++;\n            if (!accountIsWritable) numReadonlySignerAccounts++;\n        } else if (!accountIsWritable) numReadonlyNonSignerAccounts++;\n    }\n    return {\n        numReadonlyNonSignerAccounts: numReadonlyNonSignerAccounts,\n        numReadonlySignerAccounts: numReadonlySignerAccounts,\n        numSignerAccounts: numSignerAccounts\n    };\n}\n// src/compile/instructions.ts\nfunction $b4ed957d06eb8202$var$getAccountIndex(orderedAccounts) {\n    const out = {};\n    for (const [index, account] of orderedAccounts.entries())out[account.address] = index;\n    return out;\n}\nfunction $b4ed957d06eb8202$var$getCompiledInstructions(instructions, orderedAccounts) {\n    const accountIndex = $b4ed957d06eb8202$var$getAccountIndex(orderedAccounts);\n    return instructions.map(({ accounts: accounts, data: data, programAddress: programAddress })=>{\n        return {\n            programAddressIndex: accountIndex[programAddress],\n            ...accounts ? {\n                accountIndices: accounts.map(({ address: address })=>accountIndex[address])\n            } : null,\n            ...data ? {\n                data: data\n            } : null\n        };\n    });\n}\n// src/compile/lifetime-token.ts\nfunction $b4ed957d06eb8202$var$getCompiledLifetimeToken(lifetimeConstraint) {\n    if (\"nonce\" in lifetimeConstraint) return lifetimeConstraint.nonce;\n    return lifetimeConstraint.blockhash;\n}\n// src/compile/static-accounts.ts\nfunction $b4ed957d06eb8202$var$getCompiledStaticAccounts(orderedAccounts) {\n    const firstLookupTableAccountIndex = orderedAccounts.findIndex((account)=>\"lookupTableAddress\" in account);\n    const orderedStaticAccounts = firstLookupTableAccountIndex === -1 ? orderedAccounts : orderedAccounts.slice(0, firstLookupTableAccountIndex);\n    return orderedStaticAccounts.map(({ address: address })=>address);\n}\n// src/compile/message.ts\nfunction $b4ed957d06eb8202$export$ab915614a909c9c3(transactionMessage) {\n    const addressMap = $b4ed957d06eb8202$var$getAddressMapFromInstructions(transactionMessage.feePayer.address, transactionMessage.instructions);\n    const orderedAccounts = $b4ed957d06eb8202$var$getOrderedAccountsFromAddressMap(addressMap);\n    const lifetimeConstraint = transactionMessage.lifetimeConstraint;\n    return {\n        ...transactionMessage.version !== \"legacy\" ? {\n            addressTableLookups: $b4ed957d06eb8202$var$getCompiledAddressTableLookups(orderedAccounts)\n        } : null,\n        ...lifetimeConstraint ? {\n            lifetimeToken: $b4ed957d06eb8202$var$getCompiledLifetimeToken(lifetimeConstraint)\n        } : null,\n        header: $b4ed957d06eb8202$var$getCompiledMessageHeader(orderedAccounts),\n        instructions: $b4ed957d06eb8202$var$getCompiledInstructions(transactionMessage.instructions, orderedAccounts),\n        staticAccounts: $b4ed957d06eb8202$var$getCompiledStaticAccounts(orderedAccounts),\n        version: transactionMessage.version\n    };\n}\nfunction $b4ed957d06eb8202$var$findAddressInLookupTables(address, role, addressesByLookupTableAddress) {\n    for (const [lookupTableAddress, addresses] of Object.entries(addressesByLookupTableAddress))for(let i = 0; i < addresses.length; i++){\n        if (address === addresses[i]) return {\n            address: address,\n            addressIndex: i,\n            lookupTableAddress: lookupTableAddress,\n            role: role\n        };\n    }\n}\nfunction $b4ed957d06eb8202$export$25816b2d259c4123(transactionMessage, addressesByLookupTableAddress) {\n    const programAddresses = new Set(transactionMessage.instructions.map((ix)=>ix.programAddress));\n    const eligibleLookupAddresses = new Set(Object.values(addressesByLookupTableAddress).flatMap((a)=>a).filter((address)=>!programAddresses.has(address)));\n    const newInstructions = [];\n    let updatedAnyInstructions = false;\n    for (const instruction of transactionMessage.instructions){\n        if (!instruction.accounts) {\n            newInstructions.push(instruction);\n            continue;\n        }\n        const newAccounts = [];\n        let updatedAnyAccounts = false;\n        for (const account of instruction.accounts){\n            if (\"lookupTableAddress\" in account || !eligibleLookupAddresses.has(account.address) || (0, $bc6d449c2ea12356$export$dbf3fcc3475d4854)(account.role)) {\n                newAccounts.push(account);\n                continue;\n            }\n            const lookupMetaAccount = $b4ed957d06eb8202$var$findAddressInLookupTables(account.address, account.role, addressesByLookupTableAddress);\n            newAccounts.push(Object.freeze(lookupMetaAccount));\n            updatedAnyAccounts = true;\n            updatedAnyInstructions = true;\n        }\n        newInstructions.push(Object.freeze(updatedAnyAccounts ? {\n            ...instruction,\n            accounts: newAccounts\n        } : instruction));\n    }\n    return Object.freeze(updatedAnyInstructions ? {\n        ...transactionMessage,\n        instructions: newInstructions\n    } : transactionMessage);\n}\n// src/create-transaction-message.ts\nfunction $b4ed957d06eb8202$export$fa5a900d7845fd71(config) {\n    return Object.freeze({\n        instructions: Object.freeze([]),\n        version: config.version\n    });\n}\nvar $b4ed957d06eb8202$var$RECENT_BLOCKHASHES_SYSVAR_ADDRESS = \"SysvarRecentB1ockHashes11111111111111111111\";\nvar $b4ed957d06eb8202$var$SYSTEM_PROGRAM_ADDRESS = \"11111111111111111111111111111111\";\nfunction $b4ed957d06eb8202$var$createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress) {\n    return {\n        accounts: [\n            {\n                address: nonceAccountAddress,\n                role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).WRITABLE\n            },\n            {\n                address: $b4ed957d06eb8202$var$RECENT_BLOCKHASHES_SYSVAR_ADDRESS,\n                role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY\n            },\n            {\n                address: nonceAuthorityAddress,\n                role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER\n            }\n        ],\n        data: new Uint8Array([\n            4,\n            0,\n            0,\n            0\n        ]),\n        programAddress: $b4ed957d06eb8202$var$SYSTEM_PROGRAM_ADDRESS\n    };\n}\nfunction $b4ed957d06eb8202$export$8f07b90563c937e(instruction) {\n    return instruction.programAddress === $b4ed957d06eb8202$var$SYSTEM_PROGRAM_ADDRESS && // Test for `AdvanceNonceAccount` instruction data\n    instruction.data != null && $b4ed957d06eb8202$var$isAdvanceNonceAccountInstructionData(instruction.data) && // Test for exactly 3 accounts\n    instruction.accounts?.length === 3 && // First account is nonce account address\n    instruction.accounts[0].address != null && instruction.accounts[0].role === (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).WRITABLE && // Second account is recent blockhashes sysvar\n    instruction.accounts[1].address === $b4ed957d06eb8202$var$RECENT_BLOCKHASHES_SYSVAR_ADDRESS && instruction.accounts[1].role === (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY && // Third account is nonce authority account\n    instruction.accounts[2].address != null && (0, $bc6d449c2ea12356$export$dbf3fcc3475d4854)(instruction.accounts[2].role);\n}\nfunction $b4ed957d06eb8202$var$isAdvanceNonceAccountInstructionData(data) {\n    return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\n// src/durable-nonce.ts\nfunction $b4ed957d06eb8202$export$5942b3b48a8c9753(transactionMessage) {\n    return \"lifetimeConstraint\" in transactionMessage && typeof transactionMessage.lifetimeConstraint.nonce === \"string\" && transactionMessage.instructions[0] != null && $b4ed957d06eb8202$export$8f07b90563c937e(transactionMessage.instructions[0]);\n}\nfunction $b4ed957d06eb8202$export$60c0a36d690eebd8(transactionMessage) {\n    if (!$b4ed957d06eb8202$export$5942b3b48a8c9753(transactionMessage)) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$a20747f749dd4515));\n}\nfunction $b4ed957d06eb8202$var$isAdvanceNonceAccountInstructionForNonce(instruction, nonceAccountAddress, nonceAuthorityAddress) {\n    return instruction.accounts[0].address === nonceAccountAddress && instruction.accounts[2].address === nonceAuthorityAddress;\n}\nfunction $b4ed957d06eb8202$export$5963bfa5a11d18c8({ nonce: nonce, nonceAccountAddress: nonceAccountAddress, nonceAuthorityAddress: nonceAuthorityAddress }, transactionMessage) {\n    let newInstructions;\n    const firstInstruction = transactionMessage.instructions[0];\n    if (firstInstruction && $b4ed957d06eb8202$export$8f07b90563c937e(firstInstruction)) {\n        if ($b4ed957d06eb8202$var$isAdvanceNonceAccountInstructionForNonce(firstInstruction, nonceAccountAddress, nonceAuthorityAddress)) {\n            if ($b4ed957d06eb8202$export$5942b3b48a8c9753(transactionMessage) && transactionMessage.lifetimeConstraint.nonce === nonce) return transactionMessage;\n            else newInstructions = [\n                firstInstruction,\n                ...transactionMessage.instructions.slice(1)\n            ];\n        } else newInstructions = [\n            Object.freeze($b4ed957d06eb8202$var$createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n            ...transactionMessage.instructions.slice(1)\n        ];\n    } else newInstructions = [\n        Object.freeze($b4ed957d06eb8202$var$createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n        ...transactionMessage.instructions\n    ];\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze(newInstructions),\n        lifetimeConstraint: Object.freeze({\n            nonce: nonce\n        })\n    });\n}\n// src/fee-payer.ts\nfunction $b4ed957d06eb8202$export$dfc9ef9454287ce(feePayer, transactionMessage) {\n    if (\"feePayer\" in transactionMessage && feePayer === transactionMessage.feePayer?.address && $b4ed957d06eb8202$var$isAddressOnlyFeePayer(transactionMessage.feePayer)) return transactionMessage;\n    const out = {\n        ...transactionMessage,\n        feePayer: Object.freeze({\n            address: feePayer\n        })\n    };\n    Object.freeze(out);\n    return out;\n}\nfunction $b4ed957d06eb8202$var$isAddressOnlyFeePayer(feePayer) {\n    return !!feePayer && \"address\" in feePayer && typeof feePayer.address === \"string\" && Object.keys(feePayer).length === 1;\n}\n// src/instructions.ts\nfunction $b4ed957d06eb8202$export$fb1e74cf5d453d25(instruction, transactionMessage) {\n    return $b4ed957d06eb8202$export$d669f7eb03cb2936([\n        instruction\n    ], transactionMessage);\n}\nfunction $b4ed957d06eb8202$export$d669f7eb03cb2936(instructions, transactionMessage) {\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze([\n            ...transactionMessage.instructions,\n            ...instructions\n        ])\n    });\n}\nfunction $b4ed957d06eb8202$export$ebc7a6b8cfd58349(instruction, transactionMessage) {\n    return $b4ed957d06eb8202$export$23f0c44f254456b7([\n        instruction\n    ], transactionMessage);\n}\nfunction $b4ed957d06eb8202$export$23f0c44f254456b7(instructions, transactionMessage) {\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze([\n            ...instructions,\n            ...transactionMessage.instructions\n        ])\n    });\n}\n// src/decompile-message.ts\nfunction $b4ed957d06eb8202$var$getAccountMetas(message) {\n    const { header: header } = message;\n    const numWritableSignerAccounts = header.numSignerAccounts - header.numReadonlySignerAccounts;\n    const numWritableNonSignerAccounts = message.staticAccounts.length - header.numSignerAccounts - header.numReadonlyNonSignerAccounts;\n    const accountMetas = [];\n    let accountIndex = 0;\n    for(let i = 0; i < numWritableSignerAccounts; i++){\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).WRITABLE_SIGNER\n        });\n        accountIndex++;\n    }\n    for(let i = 0; i < header.numReadonlySignerAccounts; i++){\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER\n        });\n        accountIndex++;\n    }\n    for(let i = 0; i < numWritableNonSignerAccounts; i++){\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).WRITABLE\n        });\n        accountIndex++;\n    }\n    for(let i = 0; i < header.numReadonlyNonSignerAccounts; i++){\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY\n        });\n        accountIndex++;\n    }\n    return accountMetas;\n}\nfunction $b4ed957d06eb8202$var$getAddressLookupMetas(compiledAddressTableLookups, addressesByLookupTableAddress) {\n    const compiledAddressTableLookupAddresses = compiledAddressTableLookups.map((l)=>l.lookupTableAddress);\n    const missing = compiledAddressTableLookupAddresses.filter((a)=>addressesByLookupTableAddress[a] === void 0);\n    if (missing.length > 0) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$b34a16b8adbffdc1), {\n        lookupTableAddresses: missing\n    });\n    const readOnlyMetas = [];\n    const writableMetas = [];\n    for (const lookup of compiledAddressTableLookups){\n        const addresses = addressesByLookupTableAddress[lookup.lookupTableAddress];\n        const readonlyIndexes = lookup.readonlyIndexes;\n        const writableIndexes = lookup.writableIndexes;\n        const highestIndex = Math.max(...readonlyIndexes, ...writableIndexes);\n        if (highestIndex >= addresses.length) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$3764bbcfb0679211), {\n            highestKnownIndex: addresses.length - 1,\n            highestRequestedIndex: highestIndex,\n            lookupTableAddress: lookup.lookupTableAddress\n        });\n        const readOnlyForLookup = readonlyIndexes.map((r)=>({\n                address: addresses[r],\n                addressIndex: r,\n                lookupTableAddress: lookup.lookupTableAddress,\n                role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY\n            }));\n        readOnlyMetas.push(...readOnlyForLookup);\n        const writableForLookup = writableIndexes.map((w)=>({\n                address: addresses[w],\n                addressIndex: w,\n                lookupTableAddress: lookup.lookupTableAddress,\n                role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).WRITABLE\n            }));\n        writableMetas.push(...writableForLookup);\n    }\n    return [\n        ...writableMetas,\n        ...readOnlyMetas\n    ];\n}\nfunction $b4ed957d06eb8202$var$convertInstruction(instruction, accountMetas) {\n    const programAddress = accountMetas[instruction.programAddressIndex]?.address;\n    if (!programAddress) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$ed2bdee7953e467f), {\n        index: instruction.programAddressIndex\n    });\n    const accounts = instruction.accountIndices?.map((accountIndex)=>accountMetas[accountIndex]);\n    const { data: data } = instruction;\n    return Object.freeze({\n        programAddress: programAddress,\n        ...accounts && accounts.length ? {\n            accounts: Object.freeze(accounts)\n        } : {},\n        ...data && data.length ? {\n            data: data\n        } : {}\n    });\n}\nfunction $b4ed957d06eb8202$var$getLifetimeConstraint(messageLifetimeToken, firstInstruction, lastValidBlockHeight) {\n    if (!firstInstruction || !$b4ed957d06eb8202$export$8f07b90563c937e(firstInstruction)) return {\n        blockhash: messageLifetimeToken,\n        lastValidBlockHeight: lastValidBlockHeight ?? 2n ** 64n - 1n\n    };\n    else {\n        const nonceAccountAddress = firstInstruction.accounts[0].address;\n        (0, $fadd3f4c7539d2fa$export$ce82521337b7000f)(nonceAccountAddress);\n        const nonceAuthorityAddress = firstInstruction.accounts[2].address;\n        (0, $fadd3f4c7539d2fa$export$ce82521337b7000f)(nonceAuthorityAddress);\n        return {\n            nonce: messageLifetimeToken,\n            nonceAccountAddress: nonceAccountAddress,\n            nonceAuthorityAddress: nonceAuthorityAddress\n        };\n    }\n}\nfunction $b4ed957d06eb8202$export$23df4756774795d(compiledTransactionMessage, config) {\n    const feePayer = compiledTransactionMessage.staticAccounts[0];\n    if (!feePayer) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$11bea4440904349c));\n    const accountMetas = $b4ed957d06eb8202$var$getAccountMetas(compiledTransactionMessage);\n    const accountLookupMetas = \"addressTableLookups\" in compiledTransactionMessage && compiledTransactionMessage.addressTableLookups !== void 0 && compiledTransactionMessage.addressTableLookups.length > 0 ? $b4ed957d06eb8202$var$getAddressLookupMetas(compiledTransactionMessage.addressTableLookups, config?.addressesByLookupTableAddress ?? {}) : [];\n    const transactionMetas = [\n        ...accountMetas,\n        ...accountLookupMetas\n    ];\n    const instructions = compiledTransactionMessage.instructions.map((compiledInstruction)=>$b4ed957d06eb8202$var$convertInstruction(compiledInstruction, transactionMetas));\n    const firstInstruction = instructions[0];\n    const lifetimeConstraint = $b4ed957d06eb8202$var$getLifetimeConstraint(compiledTransactionMessage.lifetimeToken, firstInstruction, config?.lastValidBlockHeight);\n    return (0, $b5a2243413675af7$export$a4627e546088548d)($b4ed957d06eb8202$export$fa5a900d7845fd71({\n        version: compiledTransactionMessage.version\n    }), (m)=>$b4ed957d06eb8202$export$dfc9ef9454287ce(feePayer, m), (m)=>instructions.reduce((acc, instruction)=>$b4ed957d06eb8202$export$fb1e74cf5d453d25(instruction, acc), m), (m)=>\"blockhash\" in lifetimeConstraint ? $b4ed957d06eb8202$export$7e1319dc00734f3f(lifetimeConstraint, m) : $b4ed957d06eb8202$export$5963bfa5a11d18c8(lifetimeConstraint, m));\n}\n //# sourceMappingURL=index.browser.mjs.map\n\n\n\n\n\n// src/codecs/transaction-codec.ts\nfunction $510c612dc6dcbb18$var$getSignaturesToEncode(signaturesMap) {\n    const signatures = Object.values(signaturesMap);\n    if (signatures.length === 0) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$de92784c954d1b84));\n    return signatures.map((signature)=>{\n        if (!signature) return new Uint8Array(64).fill(0);\n        return signature;\n    });\n}\nfunction $510c612dc6dcbb18$var$getSignaturesEncoder() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$415199198053c0b)((0, $b9bc3aaa401ff82b$export$cbdfce031443a1)((0, $991819a0aa439d56$export$636c51ad84d0674a)(), 64), {\n        size: (0, $b5f941eb9a28d328$export$6f025a6ce2a023fc)()\n    }), $510c612dc6dcbb18$var$getSignaturesToEncode);\n}\n// src/codecs/transaction-codec.ts\nfunction $510c612dc6dcbb18$export$90da87f86b3622ea() {\n    return (0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"signatures\",\n            $510c612dc6dcbb18$var$getSignaturesEncoder()\n        ],\n        [\n            \"messageBytes\",\n            (0, $991819a0aa439d56$export$636c51ad84d0674a)()\n        ]\n    ]);\n}\nfunction $510c612dc6dcbb18$export$6da713d7b4a24e94() {\n    return (0, $b9bc3aaa401ff82b$export$605b10ee38669daa)((0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"signatures\",\n            (0, $991819a0aa439d56$export$9016038b2e3b0c2f)((0, $b9bc3aaa401ff82b$export$1f85f8b8d2788007)((0, $991819a0aa439d56$export$b90e67818b1b3d45)(), 64), {\n                size: (0, $b5f941eb9a28d328$export$fa35aa457fb08b4a)()\n            })\n        ],\n        [\n            \"messageBytes\",\n            (0, $991819a0aa439d56$export$b90e67818b1b3d45)()\n        ]\n    ]), $510c612dc6dcbb18$var$decodePartiallyDecodedTransaction);\n}\nfunction $510c612dc6dcbb18$export$e3332878c4f78c9() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($510c612dc6dcbb18$export$90da87f86b3622ea(), $510c612dc6dcbb18$export$6da713d7b4a24e94());\n}\nfunction $510c612dc6dcbb18$var$decodePartiallyDecodedTransaction(transaction) {\n    const { messageBytes: messageBytes, signatures: signatures } = transaction;\n    const signerAddressesDecoder = (0, $991819a0aa439d56$export$9800955a9fcaec5)([\n        // read transaction version\n        (0, $b4ed957d06eb8202$export$ef3eb451884ff775)(),\n        // read first byte of header, `numSignerAccounts`\n        // padRight to skip the next 2 bytes, `numReadOnlySignedAccounts` and `numReadOnlyUnsignedAccounts` which we don't need\n        (0, $b9bc3aaa401ff82b$export$57a7baba87e0aed9)((0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)(), 2),\n        // read static addresses\n        (0, $991819a0aa439d56$export$9016038b2e3b0c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n            size: (0, $b5f941eb9a28d328$export$fa35aa457fb08b4a)()\n        })\n    ]);\n    const [_txVersion, numRequiredSignatures, staticAddresses] = signerAddressesDecoder.decode(messageBytes);\n    const signerAddresses = staticAddresses.slice(0, numRequiredSignatures);\n    if (signerAddresses.length !== signatures.length) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$b55a3eb3d894ad9f), {\n        numRequiredSignatures: numRequiredSignatures,\n        signaturesLength: signatures.length,\n        signerAddresses: signerAddresses\n    });\n    const signaturesMap = {};\n    signerAddresses.forEach((address, index)=>{\n        const signatureForAddress = signatures[index];\n        if (signatureForAddress.every((b)=>b === 0)) signaturesMap[address] = null;\n        else signaturesMap[address] = signatureForAddress;\n    });\n    return {\n        messageBytes: messageBytes,\n        signatures: Object.freeze(signaturesMap)\n    };\n}\nvar $510c612dc6dcbb18$var$SYSTEM_PROGRAM_ADDRESS = \"11111111111111111111111111111111\";\nfunction $510c612dc6dcbb18$var$compiledInstructionIsAdvanceNonceInstruction(instruction, staticAddresses) {\n    return staticAddresses[instruction.programAddressIndex] === $510c612dc6dcbb18$var$SYSTEM_PROGRAM_ADDRESS && // Test for `AdvanceNonceAccount` instruction data\n    instruction.data != null && $510c612dc6dcbb18$var$isAdvanceNonceAccountInstructionData(instruction.data) && // Test for exactly 3 accounts\n    instruction.accountIndices?.length === 3;\n}\nfunction $510c612dc6dcbb18$var$isAdvanceNonceAccountInstructionData(data) {\n    return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\nasync function $510c612dc6dcbb18$export$da783b03eba4545a(compiledTransactionMessage) {\n    const firstInstruction = compiledTransactionMessage.instructions[0];\n    const { staticAccounts: staticAccounts } = compiledTransactionMessage;\n    if (firstInstruction && $510c612dc6dcbb18$var$compiledInstructionIsAdvanceNonceInstruction(firstInstruction, staticAccounts)) {\n        const nonceAccountAddress = staticAccounts[firstInstruction.accountIndices[0]];\n        if (!nonceAccountAddress) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$204c62c0e8d2efcc), {\n            nonce: compiledTransactionMessage.lifetimeToken\n        });\n        return {\n            nonce: compiledTransactionMessage.lifetimeToken,\n            nonceAccountAddress: nonceAccountAddress\n        };\n    } else return {\n        blockhash: compiledTransactionMessage.lifetimeToken,\n        // This is not known from the compiled message, so we set it to the maximum possible value\n        lastValidBlockHeight: 0xffffffffffffffffn\n    };\n}\nfunction $510c612dc6dcbb18$export$3b3b9473a432ba30(transaction) {\n    return \"lifetimeConstraint\" in transaction && \"blockhash\" in transaction.lifetimeConstraint && typeof transaction.lifetimeConstraint.blockhash === \"string\" && typeof transaction.lifetimeConstraint.lastValidBlockHeight === \"bigint\" && (0, $ca0959b8e0bcee2a$export$f04f5af7ffd7bee)(transaction.lifetimeConstraint.blockhash);\n}\nfunction $510c612dc6dcbb18$export$7ee0645ac0d3594e(transaction) {\n    if (!$510c612dc6dcbb18$export$3b3b9473a432ba30(transaction)) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$e33d07a7526bded0));\n}\nfunction $510c612dc6dcbb18$export$94b523640ba356b1(transaction) {\n    return \"lifetimeConstraint\" in transaction && \"nonce\" in transaction.lifetimeConstraint && typeof transaction.lifetimeConstraint.nonce === \"string\" && typeof transaction.lifetimeConstraint.nonceAccountAddress === \"string\" && (0, $fadd3f4c7539d2fa$export$977e255126d763d6)(transaction.lifetimeConstraint.nonceAccountAddress);\n}\nfunction $510c612dc6dcbb18$export$2b53094f3ca3285d(transaction) {\n    if (!$510c612dc6dcbb18$export$94b523640ba356b1(transaction)) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$a20747f749dd4515));\n}\nfunction $510c612dc6dcbb18$export$ffb6deeb6467931b(transactionMessage) {\n    const compiledMessage = (0, $b4ed957d06eb8202$export$ab915614a909c9c3)(transactionMessage);\n    const messageBytes = (0, $b4ed957d06eb8202$export$61435546aadd1929)().encode(compiledMessage);\n    const transactionSigners = compiledMessage.staticAccounts.slice(0, compiledMessage.header.numSignerAccounts);\n    const signatures = {};\n    for (const signerAddress of transactionSigners)signatures[signerAddress] = null;\n    let lifetimeConstraint;\n    if ((0, $b4ed957d06eb8202$export$eeeaaab335de65fd)(transactionMessage)) lifetimeConstraint = {\n        blockhash: transactionMessage.lifetimeConstraint.blockhash,\n        lastValidBlockHeight: transactionMessage.lifetimeConstraint.lastValidBlockHeight\n    };\n    else if ((0, $b4ed957d06eb8202$export$5942b3b48a8c9753)(transactionMessage)) lifetimeConstraint = {\n        nonce: transactionMessage.lifetimeConstraint.nonce,\n        nonceAccountAddress: transactionMessage.instructions[0].accounts[0].address\n    };\n    return Object.freeze({\n        ...lifetimeConstraint ? {\n            lifetimeConstraint: lifetimeConstraint\n        } : void 0,\n        messageBytes: messageBytes,\n        signatures: Object.freeze(signatures)\n    });\n}\nvar $510c612dc6dcbb18$var$base58Decoder;\nfunction $510c612dc6dcbb18$export$47a7dd4eae342cd2(transaction) {\n    if (!$510c612dc6dcbb18$var$base58Decoder) $510c612dc6dcbb18$var$base58Decoder = (0, $278ae65923ee60f5$export$81723918e05f84c7)();\n    const signatureBytes = Object.values(transaction.signatures)[0];\n    if (!signatureBytes) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$242af5597d94abaf));\n    const transactionSignature = $510c612dc6dcbb18$var$base58Decoder.decode(signatureBytes);\n    return transactionSignature;\n}\nfunction $510c612dc6dcbb18$var$uint8ArraysEqual(arr1, arr2) {\n    return arr1.length === arr2.length && arr1.every((value, index)=>value === arr2[index]);\n}\nasync function $510c612dc6dcbb18$export$6dfc7a6bb6c757f6(keyPairs, transaction) {\n    let newSignatures;\n    let unexpectedSigners;\n    await Promise.all(keyPairs.map(async (keyPair)=>{\n        const address = await (0, $fadd3f4c7539d2fa$export$a28ea21350b9dd16)(keyPair.publicKey);\n        const existingSignature = transaction.signatures[address];\n        if (existingSignature === void 0) {\n            unexpectedSigners ||= /* @__PURE__ */ new Set();\n            unexpectedSigners.add(address);\n            return;\n        }\n        if (unexpectedSigners) return;\n        const newSignature = await (0, $69d8b348c1bcf261$export$fff1e9696fc728a2)(keyPair.privateKey, transaction.messageBytes);\n        if (existingSignature !== null && $510c612dc6dcbb18$var$uint8ArraysEqual(newSignature, existingSignature)) return;\n        newSignatures ||= {};\n        newSignatures[address] = newSignature;\n    }));\n    if (unexpectedSigners && unexpectedSigners.size > 0) {\n        const expectedSigners = Object.keys(transaction.signatures);\n        throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$36c2547c3c4d823f), {\n            expectedAddresses: expectedSigners,\n            unexpectedAddresses: [\n                ...unexpectedSigners\n            ]\n        });\n    }\n    if (!newSignatures) return transaction;\n    return Object.freeze({\n        ...transaction,\n        signatures: Object.freeze({\n            ...transaction.signatures,\n            ...newSignatures\n        })\n    });\n}\nasync function $510c612dc6dcbb18$export$6ad02cc4966b42ab(keyPairs, transaction) {\n    const out = await $510c612dc6dcbb18$export$6dfc7a6bb6c757f6(keyPairs, transaction);\n    $510c612dc6dcbb18$export$56f67f70c65884e4(out);\n    Object.freeze(out);\n    return out;\n}\nfunction $510c612dc6dcbb18$export$670ac5744debb367(transaction) {\n    return Object.entries(transaction.signatures).every(([_, signatureBytes])=>!!signatureBytes);\n}\nfunction $510c612dc6dcbb18$export$56f67f70c65884e4(transaction) {\n    const missingSigs = [];\n    Object.entries(transaction.signatures).forEach(([address, signatureBytes])=>{\n        if (!signatureBytes) missingSigs.push(address);\n    });\n    if (missingSigs.length > 0) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$6d61b980429516bd), {\n        addresses: missingSigs\n    });\n}\nfunction $510c612dc6dcbb18$export$4df93c89115b28d8(transaction) {\n    const wireTransactionBytes = $510c612dc6dcbb18$export$90da87f86b3622ea().encode(transaction);\n    return (0, $278ae65923ee60f5$export$ee20ac553cec1cb2)().decode(wireTransactionBytes);\n}\nvar $510c612dc6dcbb18$export$28201dd2173b4e95 = 1280;\nvar $510c612dc6dcbb18$export$ab4b734cb8022b77 = 48;\nvar $510c612dc6dcbb18$export$ea172eee5a9b002 = $510c612dc6dcbb18$export$28201dd2173b4e95 - $510c612dc6dcbb18$export$ab4b734cb8022b77;\nfunction $510c612dc6dcbb18$export$eaaa2560bd2b6e0e(transaction) {\n    return $510c612dc6dcbb18$export$90da87f86b3622ea().getSizeFromValue(transaction);\n}\nfunction $510c612dc6dcbb18$export$eb970e56528f983f(transaction) {\n    return $510c612dc6dcbb18$export$eaaa2560bd2b6e0e(transaction) <= $510c612dc6dcbb18$export$ea172eee5a9b002;\n}\nfunction $510c612dc6dcbb18$export$5f27bd1cdd986097(transaction) {\n    const transactionSize = $510c612dc6dcbb18$export$eaaa2560bd2b6e0e(transaction);\n    if (transactionSize > $510c612dc6dcbb18$export$ea172eee5a9b002) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$980469bdb5d5bd4f), {\n        transactionSize: transactionSize,\n        transactionSizeLimit: $510c612dc6dcbb18$export$ea172eee5a9b002\n    });\n}\n// src/sendable-transaction.ts\nfunction $510c612dc6dcbb18$export$5df373f11f5516c4(transaction) {\n    return $510c612dc6dcbb18$export$670ac5744debb367(transaction) && $510c612dc6dcbb18$export$eb970e56528f983f(transaction);\n}\nfunction $510c612dc6dcbb18$export$c9ec0f28c291aaa5(transaction) {\n    $510c612dc6dcbb18$export$56f67f70c65884e4(transaction);\n    $510c612dc6dcbb18$export$5f27bd1cdd986097(transaction);\n}\nfunction $510c612dc6dcbb18$export$d9642340305c59d0(transactionMessage) {\n    return $510c612dc6dcbb18$export$eaaa2560bd2b6e0e($510c612dc6dcbb18$export$ffb6deeb6467931b(transactionMessage));\n}\nfunction $510c612dc6dcbb18$export$84e441a83fdea377(transactionMessage) {\n    return $510c612dc6dcbb18$export$d9642340305c59d0(transactionMessage) <= $510c612dc6dcbb18$export$ea172eee5a9b002;\n}\nfunction $510c612dc6dcbb18$export$424d618653086775(transactionMessage) {\n    const transactionSize = $510c612dc6dcbb18$export$d9642340305c59d0(transactionMessage);\n    if (transactionSize > $510c612dc6dcbb18$export$ea172eee5a9b002) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$980469bdb5d5bd4f), {\n        transactionSize: transactionSize,\n        transactionSizeLimit: $510c612dc6dcbb18$export$ea172eee5a9b002\n    });\n}\n //# sourceMappingURL=index.browser.mjs.map\n\n\n// src/deduplicate-signers.ts\nfunction $433f7983d96e2c09$var$deduplicateSigners(signers) {\n    const deduplicated = {};\n    signers.forEach((signer)=>{\n        if (!deduplicated[signer.address]) deduplicated[signer.address] = signer;\n        else if (deduplicated[signer.address] !== signer) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$ee84b29a9985e516), {\n            address: signer.address\n        });\n    });\n    return Object.values(deduplicated);\n}\nfunction $433f7983d96e2c09$export$ab888f0180deef68(value) {\n    return \"modifyAndSignTransactions\" in value && typeof value.modifyAndSignTransactions === \"function\";\n}\nfunction $433f7983d96e2c09$export$c3ce3103ae5deb03(value) {\n    if (!$433f7983d96e2c09$export$ab888f0180deef68(value)) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$200acbfc722e322b), {\n        address: value.address\n    });\n}\nfunction $433f7983d96e2c09$export$64b5a5ad2bd153ab(value) {\n    return \"signTransactions\" in value && typeof value.signTransactions === \"function\";\n}\nfunction $433f7983d96e2c09$export$b5e06ac8cb9de89e(value) {\n    if (!$433f7983d96e2c09$export$64b5a5ad2bd153ab(value)) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$4c96d9a95880ae4b), {\n        address: value.address\n    });\n}\nfunction $433f7983d96e2c09$export$55375a48851534bd(value) {\n    return \"signAndSendTransactions\" in value && typeof value.signAndSendTransactions === \"function\";\n}\nfunction $433f7983d96e2c09$export$a1090b394e827304(value) {\n    if (!$433f7983d96e2c09$export$55375a48851534bd(value)) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$bba76b21ada319a5), {\n        address: value.address\n    });\n}\n// src/transaction-signer.ts\nfunction $433f7983d96e2c09$export$45e3afa456b0ef0e(value) {\n    return $433f7983d96e2c09$export$64b5a5ad2bd153ab(value) || $433f7983d96e2c09$export$ab888f0180deef68(value) || $433f7983d96e2c09$export$55375a48851534bd(value);\n}\nfunction $433f7983d96e2c09$export$65beb8a04cc9c582(value) {\n    if (!$433f7983d96e2c09$export$45e3afa456b0ef0e(value)) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$dcec7171cff295d1), {\n        address: value.address\n    });\n}\n// src/account-signer-meta.ts\nfunction $433f7983d96e2c09$export$2089642163d2fd1c(instruction) {\n    return $433f7983d96e2c09$var$deduplicateSigners((instruction.accounts ?? []).flatMap((account)=>\"signer\" in account ? account.signer : []));\n}\nfunction $433f7983d96e2c09$export$7284bb5e065a46cc(transaction) {\n    return $433f7983d96e2c09$var$deduplicateSigners([\n        ...transaction.feePayer && $433f7983d96e2c09$export$45e3afa456b0ef0e(transaction.feePayer) ? [\n            transaction.feePayer\n        ] : [],\n        ...transaction.instructions.flatMap($433f7983d96e2c09$export$2089642163d2fd1c)\n    ]);\n}\nfunction $433f7983d96e2c09$export$7284bd5e215aa78c(signers, instruction) {\n    if (!instruction.accounts || instruction.accounts.length === 0) return instruction;\n    const signerByAddress = new Map($433f7983d96e2c09$var$deduplicateSigners(signers).map((signer)=>[\n            signer.address,\n            signer\n        ]));\n    return Object.freeze({\n        ...instruction,\n        accounts: instruction.accounts.map((account)=>{\n            const signer = signerByAddress.get(account.address);\n            if (!(0, $bc6d449c2ea12356$export$dbf3fcc3475d4854)(account.role) || \"signer\" in account || !signer) return account;\n            return Object.freeze({\n                ...account,\n                signer: signer\n            });\n        })\n    });\n}\nfunction $433f7983d96e2c09$export$f5bf1b34b1746f9a(signers, transactionMessage) {\n    const feePayerSigner = $433f7983d96e2c09$var$hasAddressOnlyFeePayer(transactionMessage) ? signers.find((signer)=>signer.address === transactionMessage.feePayer.address) : void 0;\n    if (!feePayerSigner && transactionMessage.instructions.length === 0) return transactionMessage;\n    return Object.freeze({\n        ...transactionMessage,\n        ...feePayerSigner ? {\n            feePayer: feePayerSigner\n        } : null,\n        instructions: transactionMessage.instructions.map((instruction)=>$433f7983d96e2c09$export$7284bd5e215aa78c(signers, instruction))\n    });\n}\nfunction $433f7983d96e2c09$var$hasAddressOnlyFeePayer(message) {\n    return !!message && \"feePayer\" in message && !!message.feePayer && typeof message.feePayer.address === \"string\" && !$433f7983d96e2c09$export$45e3afa456b0ef0e(message.feePayer);\n}\n// src/fee-payer-signer.ts\nfunction $433f7983d96e2c09$export$17730ab620b6268f(feePayer, transactionMessage) {\n    Object.freeze(feePayer);\n    const out = {\n        ...transactionMessage,\n        feePayer: feePayer\n    };\n    Object.freeze(out);\n    return out;\n}\nfunction $433f7983d96e2c09$export$8fcb4c803d840767(value) {\n    return \"signMessages\" in value && typeof value.signMessages === \"function\";\n}\nfunction $433f7983d96e2c09$export$6490719c0fb76486(value) {\n    if (!$433f7983d96e2c09$export$8fcb4c803d840767(value)) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$8c6fc1cfcec8440c), {\n        address: value.address\n    });\n}\n// src/keypair-signer.ts\nfunction $433f7983d96e2c09$export$9d3b1e49cee6c52e(value) {\n    return \"keyPair\" in value && typeof value.keyPair === \"object\" && $433f7983d96e2c09$export$8fcb4c803d840767(value) && $433f7983d96e2c09$export$64b5a5ad2bd153ab(value);\n}\nfunction $433f7983d96e2c09$export$f2c86008ec90e309(value) {\n    if (!$433f7983d96e2c09$export$9d3b1e49cee6c52e(value)) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$9998b265c986beaa), {\n        address: value.address\n    });\n}\nasync function $433f7983d96e2c09$export$736a8581e40d179e(keyPair) {\n    const address = await (0, $fadd3f4c7539d2fa$export$a28ea21350b9dd16)(keyPair.publicKey);\n    const out = {\n        address: address,\n        keyPair: keyPair,\n        signMessages: (messages)=>Promise.all(messages.map(async (message)=>Object.freeze({\n                    [address]: await (0, $69d8b348c1bcf261$export$fff1e9696fc728a2)(keyPair.privateKey, message.content)\n                }))),\n        signTransactions: (transactions)=>Promise.all(transactions.map(async (transaction)=>{\n                const signedTransaction = await (0, $510c612dc6dcbb18$export$6dfc7a6bb6c757f6)([\n                    keyPair\n                ], transaction);\n                return Object.freeze({\n                    [address]: signedTransaction.signatures[address]\n                });\n            }))\n    };\n    return Object.freeze(out);\n}\nasync function $433f7983d96e2c09$export$b25923bc1fe81ec8() {\n    return await $433f7983d96e2c09$export$736a8581e40d179e(await (0, $69d8b348c1bcf261$export$a949d36eab55b41f)());\n}\nasync function $433f7983d96e2c09$export$f72b478359b35df7(bytes, extractable) {\n    return await $433f7983d96e2c09$export$736a8581e40d179e(await (0, $69d8b348c1bcf261$export$fd6bf6b448cc1055)(bytes, extractable));\n}\nasync function $433f7983d96e2c09$export$eebc380f35368787(bytes, extractable) {\n    return await $433f7983d96e2c09$export$736a8581e40d179e(await (0, $69d8b348c1bcf261$export$d80945a4e9f5adcb)(bytes, extractable));\n}\nfunction $433f7983d96e2c09$export$81bcb03d1cc62692(value) {\n    return (0, $fadd3f4c7539d2fa$export$977e255126d763d6)(value.address) && \"modifyAndSignMessages\" in value && typeof value.modifyAndSignMessages === \"function\";\n}\nfunction $433f7983d96e2c09$export$dbf3c63845d68d7f(value) {\n    if (!$433f7983d96e2c09$export$81bcb03d1cc62692(value)) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$14d32fbdad2233cd), {\n        address: value.address\n    });\n}\nfunction $433f7983d96e2c09$export$47969c4a50f646be(value) {\n    return $433f7983d96e2c09$export$8fcb4c803d840767(value) || $433f7983d96e2c09$export$81bcb03d1cc62692(value);\n}\nfunction $433f7983d96e2c09$export$c2e24c494937c4d3(value) {\n    if (!$433f7983d96e2c09$export$47969c4a50f646be(value)) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$dd792e9d67cd031b), {\n        address: value.address\n    });\n}\n// src/noop-signer.ts\nfunction $433f7983d96e2c09$export$7a9d5b0c874644cc(address) {\n    const out = {\n        address: address,\n        signMessages: (messages)=>Promise.resolve(messages.map(()=>Object.freeze({}))),\n        signTransactions: (transactions)=>Promise.resolve(transactions.map(()=>Object.freeze({})))\n    };\n    return Object.freeze(out);\n}\nfunction $433f7983d96e2c09$export$b39c07ad0d307df6(transaction) {\n    try {\n        $433f7983d96e2c09$export$aa249d7e634f8f65(transaction);\n        return true;\n    } catch  {\n        return false;\n    }\n}\nfunction $433f7983d96e2c09$export$aa249d7e634f8f65(transaction) {\n    const signers = $433f7983d96e2c09$export$7284bb5e065a46cc(transaction);\n    const sendingSigners = signers.filter($433f7983d96e2c09$export$55375a48851534bd);\n    if (sendingSigners.length === 0) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$1f5fbaa83776feec));\n    const sendingOnlySigners = sendingSigners.filter((signer)=>!$433f7983d96e2c09$export$64b5a5ad2bd153ab(signer) && !$433f7983d96e2c09$export$ab888f0180deef68(signer));\n    if (sendingOnlySigners.length > 1) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$3cb3b480d2bfdacc));\n}\n// src/sign-transaction.ts\nasync function $433f7983d96e2c09$export$30f851f6ab6173cb(transactionMessage, config) {\n    const { partialSigners: partialSigners, modifyingSigners: modifyingSigners } = $433f7983d96e2c09$var$categorizeTransactionSigners($433f7983d96e2c09$var$deduplicateSigners($433f7983d96e2c09$export$7284bb5e065a46cc(transactionMessage).filter($433f7983d96e2c09$export$45e3afa456b0ef0e)), {\n        identifySendingSigner: false\n    });\n    return await $433f7983d96e2c09$var$signModifyingAndPartialTransactionSigners(transactionMessage, modifyingSigners, partialSigners, config);\n}\nasync function $433f7983d96e2c09$export$353f4a9fd782633d(transactionMessage, config) {\n    const signedTransaction = await $433f7983d96e2c09$export$30f851f6ab6173cb(transactionMessage, config);\n    (0, $510c612dc6dcbb18$export$56f67f70c65884e4)(signedTransaction);\n    return signedTransaction;\n}\nasync function $433f7983d96e2c09$export$e4daf3ba3be42a63(transaction, config) {\n    $433f7983d96e2c09$export$aa249d7e634f8f65(transaction);\n    const abortSignal = config?.abortSignal;\n    const { partialSigners: partialSigners, modifyingSigners: modifyingSigners, sendingSigner: sendingSigner } = $433f7983d96e2c09$var$categorizeTransactionSigners($433f7983d96e2c09$var$deduplicateSigners($433f7983d96e2c09$export$7284bb5e065a46cc(transaction).filter($433f7983d96e2c09$export$45e3afa456b0ef0e)));\n    abortSignal?.throwIfAborted();\n    const signedTransaction = await $433f7983d96e2c09$var$signModifyingAndPartialTransactionSigners(transaction, modifyingSigners, partialSigners, config);\n    if (!sendingSigner) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$1f5fbaa83776feec));\n    abortSignal?.throwIfAborted();\n    const [signature] = await sendingSigner.signAndSendTransactions([\n        signedTransaction\n    ], config);\n    abortSignal?.throwIfAborted();\n    return signature;\n}\nfunction $433f7983d96e2c09$var$categorizeTransactionSigners(signers, config = {}) {\n    const identifySendingSigner = config.identifySendingSigner ?? true;\n    const sendingSigner = identifySendingSigner ? $433f7983d96e2c09$var$identifyTransactionSendingSigner(signers) : null;\n    const otherSigners = signers.filter((signer)=>signer !== sendingSigner && ($433f7983d96e2c09$export$ab888f0180deef68(signer) || $433f7983d96e2c09$export$64b5a5ad2bd153ab(signer)));\n    const modifyingSigners = $433f7983d96e2c09$var$identifyTransactionModifyingSigners(otherSigners);\n    const partialSigners = otherSigners.filter($433f7983d96e2c09$export$64b5a5ad2bd153ab).filter((signer)=>!modifyingSigners.includes(signer));\n    return Object.freeze({\n        modifyingSigners: modifyingSigners,\n        partialSigners: partialSigners,\n        sendingSigner: sendingSigner\n    });\n}\nfunction $433f7983d96e2c09$var$identifyTransactionSendingSigner(signers) {\n    const sendingSigners = signers.filter($433f7983d96e2c09$export$55375a48851534bd);\n    if (sendingSigners.length === 0) return null;\n    const sendingOnlySigners = sendingSigners.filter((signer)=>!$433f7983d96e2c09$export$ab888f0180deef68(signer) && !$433f7983d96e2c09$export$64b5a5ad2bd153ab(signer));\n    if (sendingOnlySigners.length > 0) return sendingOnlySigners[0];\n    return sendingSigners[0];\n}\nfunction $433f7983d96e2c09$var$identifyTransactionModifyingSigners(signers) {\n    const modifyingSigners = signers.filter($433f7983d96e2c09$export$ab888f0180deef68);\n    if (modifyingSigners.length === 0) return [];\n    const nonPartialSigners = modifyingSigners.filter((signer)=>!$433f7983d96e2c09$export$64b5a5ad2bd153ab(signer));\n    if (nonPartialSigners.length > 0) return nonPartialSigners;\n    return [\n        modifyingSigners[0]\n    ];\n}\nasync function $433f7983d96e2c09$var$signModifyingAndPartialTransactionSigners(transactionMessage, modifyingSigners = [], partialSigners = [], config) {\n    const transaction = (0, $510c612dc6dcbb18$export$ffb6deeb6467931b)(transactionMessage);\n    const modifiedTransaction = await modifyingSigners.reduce(async (transaction2, modifyingSigner)=>{\n        config?.abortSignal?.throwIfAborted();\n        const [tx] = await modifyingSigner.modifyAndSignTransactions([\n            await transaction2\n        ], config);\n        return Object.freeze(tx);\n    }, Promise.resolve(transaction));\n    config?.abortSignal?.throwIfAborted();\n    const signatureDictionaries = await Promise.all(partialSigners.map(async (partialSigner)=>{\n        const [signatures] = await partialSigner.signTransactions([\n            modifiedTransaction\n        ], config);\n        return signatures;\n    }));\n    return Object.freeze({\n        ...modifiedTransaction,\n        signatures: Object.freeze(signatureDictionaries.reduce((signatures, signatureDictionary)=>{\n            return {\n                ...signatures,\n                ...signatureDictionary\n            };\n        }, modifiedTransaction.signatures ?? {}))\n    });\n}\nvar $433f7983d96e2c09$var$o = globalThis.TextEncoder;\n// src/signable-message.ts\nfunction $433f7983d96e2c09$export$8eca4b264803da5(content, signatures = {}) {\n    return Object.freeze({\n        content: typeof content === \"string\" ? new $433f7983d96e2c09$var$o().encode(content) : content,\n        signatures: Object.freeze({\n            ...signatures\n        })\n    });\n}\n //# sourceMappingURL=index.browser.mjs.map\n\n\n\n\n\n\n// src/clock.ts\nvar $ea79aff0bcfab408$export$8f452dedfe83b561 = \"SysvarC1ock11111111111111111111111111111111\";\nvar $ea79aff0bcfab408$export$5b23b8930859e331 = \"SysvarEpochRewards1111111111111111111111111\";\nvar $ea79aff0bcfab408$export$e43411b558febffa = \"SysvarEpochSchedu1e111111111111111111111111\";\nvar $ea79aff0bcfab408$export$a0d32901ddc54f5e = \"Sysvar1nstructions1111111111111111111111111\";\nvar $ea79aff0bcfab408$export$aeb7bb2ff304347c = \"SysvarLastRestartS1ot1111111111111111111111\";\nvar $ea79aff0bcfab408$export$d694f4b4f557caab = \"SysvarRecentB1ockHashes11111111111111111111\";\nvar $ea79aff0bcfab408$export$462d24217026cbc9 = \"SysvarRent111111111111111111111111111111111\";\nvar $ea79aff0bcfab408$export$60cbcae9ad956345 = \"SysvarS1otHashes111111111111111111111111111\";\nvar $ea79aff0bcfab408$export$41ccfafc3937cab4 = \"SysvarS1otHistory11111111111111111111111111\";\nvar $ea79aff0bcfab408$export$649e07d788678a88 = \"SysvarStakeHistory1111111111111111111111111\";\nasync function $ea79aff0bcfab408$export$fced9a3731bb74db(rpc, address, config) {\n    return await (0, $3f6992d190194f4d$export$14418aaf1acfa4e5)(rpc, address, config);\n}\nasync function $ea79aff0bcfab408$export$246f41055a3e82cd(rpc, address, config) {\n    return await (0, $3f6992d190194f4d$export$285f3311f1f2c6b5)(rpc, address, config);\n}\n// src/clock.ts\nfunction $ea79aff0bcfab408$export$66e43381a2d73689() {\n    return (0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"slot\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ],\n        [\n            \"epochStartTimestamp\",\n            (0, $b5f941eb9a28d328$export$42b58a304e7edd67)()\n        ],\n        [\n            \"epoch\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ],\n        [\n            \"leaderScheduleEpoch\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ],\n        [\n            \"unixTimestamp\",\n            (0, $b5f941eb9a28d328$export$42b58a304e7edd67)()\n        ]\n    ]);\n}\nfunction $ea79aff0bcfab408$export$80740a2921037518() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"slot\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ],\n        [\n            \"epochStartTimestamp\",\n            (0, $b5f941eb9a28d328$export$6f14c9b3a349f404)()\n        ],\n        [\n            \"epoch\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ],\n        [\n            \"leaderScheduleEpoch\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ],\n        [\n            \"unixTimestamp\",\n            (0, $b5f941eb9a28d328$export$6f14c9b3a349f404)()\n        ]\n    ]);\n}\nfunction $ea79aff0bcfab408$export$2af8d35660a91365() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($ea79aff0bcfab408$export$66e43381a2d73689(), $ea79aff0bcfab408$export$80740a2921037518());\n}\nasync function $ea79aff0bcfab408$export$7a194c048c5290ae(rpc, config) {\n    const account = await $ea79aff0bcfab408$export$fced9a3731bb74db(rpc, $ea79aff0bcfab408$export$8f452dedfe83b561, config);\n    (0, $3f6992d190194f4d$export$c5f1bc6464904f18)(account);\n    const decoded = (0, $3f6992d190194f4d$export$cf5ddfea0105a5b4)(account, $ea79aff0bcfab408$export$80740a2921037518());\n    return decoded.data;\n}\nfunction $ea79aff0bcfab408$export$d1d72ba3f1288fdd() {\n    return (0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"distributionStartingBlockHeight\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ],\n        [\n            \"numPartitions\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ],\n        [\n            \"parentBlockhash\",\n            (0, $ca0959b8e0bcee2a$export$2102c40640eb7803)()\n        ],\n        [\n            \"totalPoints\",\n            (0, $b5f941eb9a28d328$export$3333225663a8d6bb)()\n        ],\n        [\n            \"totalRewards\",\n            (0, $ca0959b8e0bcee2a$export$2f3071245f801283)()\n        ],\n        [\n            \"distributedRewards\",\n            (0, $ca0959b8e0bcee2a$export$2f3071245f801283)()\n        ],\n        [\n            \"active\",\n            (0, $991819a0aa439d56$export$4a518d3f98f842eb)()\n        ]\n    ]);\n}\nfunction $ea79aff0bcfab408$export$79835808d2d5e538() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"distributionStartingBlockHeight\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ],\n        [\n            \"numPartitions\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ],\n        [\n            \"parentBlockhash\",\n            (0, $ca0959b8e0bcee2a$export$3bd4205b3e3e56c4)()\n        ],\n        [\n            \"totalPoints\",\n            (0, $b5f941eb9a28d328$export$523e33537e060693)()\n        ],\n        [\n            \"totalRewards\",\n            (0, $ca0959b8e0bcee2a$export$a32171385d01c30e)()\n        ],\n        [\n            \"distributedRewards\",\n            (0, $ca0959b8e0bcee2a$export$a32171385d01c30e)()\n        ],\n        [\n            \"active\",\n            (0, $991819a0aa439d56$export$43a73c742ad521e1)()\n        ]\n    ]);\n}\nfunction $ea79aff0bcfab408$export$e340d190747fea32() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($ea79aff0bcfab408$export$d1d72ba3f1288fdd(), $ea79aff0bcfab408$export$79835808d2d5e538());\n}\nasync function $ea79aff0bcfab408$export$f00fb59af61f69e5(rpc, config) {\n    const account = await $ea79aff0bcfab408$export$fced9a3731bb74db(rpc, $ea79aff0bcfab408$export$5b23b8930859e331, config);\n    (0, $3f6992d190194f4d$export$c5f1bc6464904f18)(account);\n    const decoded = (0, $3f6992d190194f4d$export$cf5ddfea0105a5b4)(account, $ea79aff0bcfab408$export$79835808d2d5e538());\n    return decoded.data;\n}\nfunction $ea79aff0bcfab408$export$abdd069c4d1c5b65() {\n    return (0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"slotsPerEpoch\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ],\n        [\n            \"leaderScheduleSlotOffset\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ],\n        [\n            \"warmup\",\n            (0, $991819a0aa439d56$export$4a518d3f98f842eb)()\n        ],\n        [\n            \"firstNormalEpoch\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ],\n        [\n            \"firstNormalSlot\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ]\n    ]);\n}\nfunction $ea79aff0bcfab408$export$539aac408afa96d8() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"slotsPerEpoch\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ],\n        [\n            \"leaderScheduleSlotOffset\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ],\n        [\n            \"warmup\",\n            (0, $991819a0aa439d56$export$43a73c742ad521e1)()\n        ],\n        [\n            \"firstNormalEpoch\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ],\n        [\n            \"firstNormalSlot\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ]\n    ]);\n}\nfunction $ea79aff0bcfab408$export$37b10ccbb7613dba() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($ea79aff0bcfab408$export$abdd069c4d1c5b65(), $ea79aff0bcfab408$export$539aac408afa96d8());\n}\nasync function $ea79aff0bcfab408$export$85bc899e41ad9947(rpc, config) {\n    const account = await $ea79aff0bcfab408$export$fced9a3731bb74db(rpc, $ea79aff0bcfab408$export$e43411b558febffa, config);\n    (0, $3f6992d190194f4d$export$c5f1bc6464904f18)(account);\n    const decoded = (0, $3f6992d190194f4d$export$cf5ddfea0105a5b4)(account, $ea79aff0bcfab408$export$539aac408afa96d8());\n    return decoded.data;\n}\nfunction $ea79aff0bcfab408$export$9c7ef803fbbed57d() {\n    return (0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"lastRestartSlot\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ]\n    ]);\n}\nfunction $ea79aff0bcfab408$export$45b10dd2e0a5e070() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"lastRestartSlot\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ]\n    ]);\n}\nfunction $ea79aff0bcfab408$export$872b67535458a92a() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($ea79aff0bcfab408$export$9c7ef803fbbed57d(), $ea79aff0bcfab408$export$45b10dd2e0a5e070());\n}\nasync function $ea79aff0bcfab408$export$f4ec936b1284ba8a(rpc, config) {\n    const account = await $ea79aff0bcfab408$export$fced9a3731bb74db(rpc, $ea79aff0bcfab408$export$aeb7bb2ff304347c, config);\n    (0, $3f6992d190194f4d$export$c5f1bc6464904f18)(account);\n    const decoded = (0, $3f6992d190194f4d$export$cf5ddfea0105a5b4)(account, $ea79aff0bcfab408$export$45b10dd2e0a5e070());\n    return decoded.data;\n}\nfunction $ea79aff0bcfab408$export$dedd8a8487ef5708() {\n    return (0, $991819a0aa439d56$export$415199198053c0b)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"blockhash\",\n            (0, $ca0959b8e0bcee2a$export$2102c40640eb7803)()\n        ],\n        [\n            \"feeCalculator\",\n            (0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"lamportsPerSignature\",\n                    (0, $ca0959b8e0bcee2a$export$2f3071245f801283)()\n                ]\n            ])\n        ]\n    ]));\n}\nfunction $ea79aff0bcfab408$export$1d2cce657e1299b9() {\n    return (0, $991819a0aa439d56$export$9016038b2e3b0c2f)((0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"blockhash\",\n            (0, $ca0959b8e0bcee2a$export$3bd4205b3e3e56c4)()\n        ],\n        [\n            \"feeCalculator\",\n            (0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"lamportsPerSignature\",\n                    (0, $ca0959b8e0bcee2a$export$a32171385d01c30e)()\n                ]\n            ])\n        ]\n    ]));\n}\nfunction $ea79aff0bcfab408$export$9fa48867ae85152a() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($ea79aff0bcfab408$export$dedd8a8487ef5708(), $ea79aff0bcfab408$export$1d2cce657e1299b9());\n}\nasync function $ea79aff0bcfab408$export$fdd0e361e3fc6043(rpc, config) {\n    const account = await $ea79aff0bcfab408$export$fced9a3731bb74db(rpc, $ea79aff0bcfab408$export$d694f4b4f557caab, config);\n    (0, $3f6992d190194f4d$export$c5f1bc6464904f18)(account);\n    const decoded = (0, $3f6992d190194f4d$export$cf5ddfea0105a5b4)(account, $ea79aff0bcfab408$export$1d2cce657e1299b9());\n    return decoded.data;\n}\nfunction $ea79aff0bcfab408$export$cb172f179923e870() {\n    return (0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"lamportsPerByteYear\",\n            (0, $ca0959b8e0bcee2a$export$2f3071245f801283)()\n        ],\n        [\n            \"exemptionThreshold\",\n            (0, $b5f941eb9a28d328$export$551368d522177b99)()\n        ],\n        [\n            \"burnPercent\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]);\n}\nfunction $ea79aff0bcfab408$export$61c0e56d11986dcf() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"lamportsPerByteYear\",\n            (0, $ca0959b8e0bcee2a$export$a32171385d01c30e)()\n        ],\n        [\n            \"exemptionThreshold\",\n            (0, $b5f941eb9a28d328$export$9475ae45ddf86dec)()\n        ],\n        [\n            \"burnPercent\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $ea79aff0bcfab408$export$8982d0b70c883e30() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($ea79aff0bcfab408$export$cb172f179923e870(), $ea79aff0bcfab408$export$61c0e56d11986dcf());\n}\nasync function $ea79aff0bcfab408$export$e749860f6e72e6ad(rpc, config) {\n    const account = await $ea79aff0bcfab408$export$fced9a3731bb74db(rpc, $ea79aff0bcfab408$export$462d24217026cbc9, config);\n    (0, $3f6992d190194f4d$export$c5f1bc6464904f18)(account);\n    const decoded = (0, $3f6992d190194f4d$export$cf5ddfea0105a5b4)(account, $ea79aff0bcfab408$export$61c0e56d11986dcf());\n    return decoded.data;\n}\nfunction $ea79aff0bcfab408$export$c68d7ccc462f1114() {\n    return (0, $991819a0aa439d56$export$415199198053c0b)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"slot\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ],\n        [\n            \"hash\",\n            (0, $ca0959b8e0bcee2a$export$2102c40640eb7803)()\n        ]\n    ]));\n}\nfunction $ea79aff0bcfab408$export$897ab3b127475ee0() {\n    return (0, $991819a0aa439d56$export$9016038b2e3b0c2f)((0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"slot\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ],\n        [\n            \"hash\",\n            (0, $ca0959b8e0bcee2a$export$3bd4205b3e3e56c4)()\n        ]\n    ]));\n}\nfunction $ea79aff0bcfab408$export$ec8da64a049b79a3() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($ea79aff0bcfab408$export$c68d7ccc462f1114(), $ea79aff0bcfab408$export$897ab3b127475ee0());\n}\nasync function $ea79aff0bcfab408$export$f644b9346822f07a(rpc, config) {\n    const account = await $ea79aff0bcfab408$export$fced9a3731bb74db(rpc, $ea79aff0bcfab408$export$60cbcae9ad956345, config);\n    (0, $3f6992d190194f4d$export$c5f1bc6464904f18)(account);\n    const decoded = (0, $3f6992d190194f4d$export$cf5ddfea0105a5b4)(account, $ea79aff0bcfab408$export$897ab3b127475ee0());\n    return decoded.data;\n}\nvar $ea79aff0bcfab408$var$BITVEC_DISCRIMINATOR = 1;\nvar $ea79aff0bcfab408$var$BITVEC_NUM_BITS = 1048576;\nvar $ea79aff0bcfab408$var$BITVEC_LENGTH = $ea79aff0bcfab408$var$BITVEC_NUM_BITS / 64;\nvar $ea79aff0bcfab408$var$SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE = 9 + // bitvector length (u64)\n$ea79aff0bcfab408$var$BITVEC_LENGTH * 8 + 8 + // Number of bits (u64)\n8;\nvar $ea79aff0bcfab408$var$memoizedU64Encoder;\nvar $ea79aff0bcfab408$var$memoizedU64Decoder;\nvar $ea79aff0bcfab408$var$memoizedU64ArrayEncoder;\nvar $ea79aff0bcfab408$var$memoizedU64ArrayDecoder;\nfunction $ea79aff0bcfab408$var$getMemoizedU64Encoder() {\n    if (!$ea79aff0bcfab408$var$memoizedU64Encoder) $ea79aff0bcfab408$var$memoizedU64Encoder = (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)();\n    return $ea79aff0bcfab408$var$memoizedU64Encoder;\n}\nfunction $ea79aff0bcfab408$var$getMemoizedU64Decoder() {\n    if (!$ea79aff0bcfab408$var$memoizedU64Decoder) $ea79aff0bcfab408$var$memoizedU64Decoder = (0, $b5f941eb9a28d328$export$faa05ffebebd465d)();\n    return $ea79aff0bcfab408$var$memoizedU64Decoder;\n}\nfunction $ea79aff0bcfab408$var$getMemoizedU64ArrayEncoder() {\n    if (!$ea79aff0bcfab408$var$memoizedU64ArrayEncoder) $ea79aff0bcfab408$var$memoizedU64ArrayEncoder = (0, $991819a0aa439d56$export$8390591075c4b219)((0, $b5f941eb9a28d328$export$7e56ec13f6029ccc)(), {\n        size: $ea79aff0bcfab408$var$BITVEC_LENGTH\n    });\n    return $ea79aff0bcfab408$var$memoizedU64ArrayEncoder;\n}\nfunction $ea79aff0bcfab408$var$getMemoizedU64ArrayDecoder() {\n    if (!$ea79aff0bcfab408$var$memoizedU64ArrayDecoder) $ea79aff0bcfab408$var$memoizedU64ArrayDecoder = (0, $991819a0aa439d56$export$8390591075c4b219)((0, $b5f941eb9a28d328$export$7e56ec13f6029ccc)(), {\n        size: $ea79aff0bcfab408$var$BITVEC_LENGTH\n    });\n    return $ea79aff0bcfab408$var$memoizedU64ArrayDecoder;\n}\nfunction $ea79aff0bcfab408$export$44b8fab2f29be3f8() {\n    return (0, $b9bc3aaa401ff82b$export$4e76eeb6df88c889)({\n        fixedSize: $ea79aff0bcfab408$var$SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE,\n        write: (value, bytes, offset)=>{\n            bytes.set([\n                $ea79aff0bcfab408$var$BITVEC_DISCRIMINATOR\n            ], offset);\n            offset += 1;\n            $ea79aff0bcfab408$var$getMemoizedU64Encoder().write(BigInt($ea79aff0bcfab408$var$BITVEC_LENGTH), bytes, offset);\n            offset += 8;\n            $ea79aff0bcfab408$var$getMemoizedU64ArrayEncoder().write(value.bits, bytes, offset);\n            offset += $ea79aff0bcfab408$var$BITVEC_LENGTH * 8;\n            $ea79aff0bcfab408$var$getMemoizedU64Encoder().write(BigInt($ea79aff0bcfab408$var$BITVEC_NUM_BITS), bytes, offset);\n            offset += 8;\n            $ea79aff0bcfab408$var$getMemoizedU64Encoder().write(value.nextSlot, bytes, offset);\n            offset += 8;\n            return offset;\n        }\n    });\n}\nfunction $ea79aff0bcfab408$export$e9cf5c43e2b6c04d() {\n    return (0, $b9bc3aaa401ff82b$export$f8c898e83b60faaa)({\n        fixedSize: $ea79aff0bcfab408$var$SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE,\n        read: (bytes, offset)=>{\n            if (bytes.length != $ea79aff0bcfab408$var$SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$18fbf24f19efc69b), {\n                actual: bytes.length,\n                expected: $ea79aff0bcfab408$var$SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE\n            });\n            const discriminator = bytes[offset];\n            offset += 1;\n            if (discriminator !== $ea79aff0bcfab408$var$BITVEC_DISCRIMINATOR) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$1fa107ead8489cf2), {\n                actual: discriminator,\n                expected: $ea79aff0bcfab408$var$BITVEC_DISCRIMINATOR\n            });\n            const bitVecLength = $ea79aff0bcfab408$var$getMemoizedU64Decoder().read(bytes, offset)[0];\n            offset += 8;\n            if (bitVecLength !== BigInt($ea79aff0bcfab408$var$BITVEC_LENGTH)) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$c04710d31ef4d278), {\n                actual: bitVecLength,\n                codecDescription: \"SysvarSlotHistoryCodec\",\n                expected: $ea79aff0bcfab408$var$BITVEC_LENGTH\n            });\n            const bits = $ea79aff0bcfab408$var$getMemoizedU64ArrayDecoder().read(bytes, offset)[0];\n            offset += $ea79aff0bcfab408$var$BITVEC_LENGTH * 8;\n            const numBits = $ea79aff0bcfab408$var$getMemoizedU64Decoder().read(bytes, offset)[0];\n            offset += 8;\n            if (numBits !== BigInt($ea79aff0bcfab408$var$BITVEC_NUM_BITS)) throw new (0, $0bb11e8e9f3a1c4e$export$8349fd9adaaed269)((0, $0bb11e8e9f3a1c4e$export$c04710d31ef4d278), {\n                actual: numBits,\n                codecDescription: \"SysvarSlotHistoryCodec\",\n                expected: $ea79aff0bcfab408$var$BITVEC_NUM_BITS\n            });\n            const nextSlot = $ea79aff0bcfab408$var$getMemoizedU64Decoder().read(bytes, offset)[0];\n            offset += 8;\n            return [\n                {\n                    bits: bits,\n                    nextSlot: nextSlot\n                },\n                offset\n            ];\n        }\n    });\n}\nfunction $ea79aff0bcfab408$export$1ac5b9136027b657() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($ea79aff0bcfab408$export$44b8fab2f29be3f8(), $ea79aff0bcfab408$export$e9cf5c43e2b6c04d());\n}\nasync function $ea79aff0bcfab408$export$f83071f12b6d259f(rpc, config) {\n    const account = await $ea79aff0bcfab408$export$fced9a3731bb74db(rpc, $ea79aff0bcfab408$export$41ccfafc3937cab4, config);\n    (0, $3f6992d190194f4d$export$c5f1bc6464904f18)(account);\n    const decoded = (0, $3f6992d190194f4d$export$cf5ddfea0105a5b4)(account, $ea79aff0bcfab408$export$e9cf5c43e2b6c04d());\n    return decoded.data;\n}\nfunction $ea79aff0bcfab408$export$5aa6fa63422dbfb9() {\n    return (0, $991819a0aa439d56$export$415199198053c0b)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"epoch\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ],\n        [\n            \"stakeHistory\",\n            (0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"effective\",\n                    (0, $ca0959b8e0bcee2a$export$2f3071245f801283)()\n                ],\n                [\n                    \"activating\",\n                    (0, $ca0959b8e0bcee2a$export$2f3071245f801283)()\n                ],\n                [\n                    \"deactivating\",\n                    (0, $ca0959b8e0bcee2a$export$2f3071245f801283)()\n                ]\n            ])\n        ]\n    ]), {\n        size: (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n    });\n}\nfunction $ea79aff0bcfab408$export$20448f31fa658a15() {\n    return (0, $991819a0aa439d56$export$9016038b2e3b0c2f)((0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"epoch\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ],\n        [\n            \"stakeHistory\",\n            (0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"effective\",\n                    (0, $ca0959b8e0bcee2a$export$a32171385d01c30e)()\n                ],\n                [\n                    \"activating\",\n                    (0, $ca0959b8e0bcee2a$export$a32171385d01c30e)()\n                ],\n                [\n                    \"deactivating\",\n                    (0, $ca0959b8e0bcee2a$export$a32171385d01c30e)()\n                ]\n            ])\n        ]\n    ]), {\n        size: (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n    });\n}\nfunction $ea79aff0bcfab408$export$3176a8d095f09aa3() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($ea79aff0bcfab408$export$5aa6fa63422dbfb9(), $ea79aff0bcfab408$export$20448f31fa658a15());\n}\nasync function $ea79aff0bcfab408$export$9ada3f616fcd3f7a(rpc, config) {\n    const account = await $ea79aff0bcfab408$export$fced9a3731bb74db(rpc, $ea79aff0bcfab408$export$649e07d788678a88, config);\n    (0, $3f6992d190194f4d$export$c5f1bc6464904f18)(account);\n    const decoded = (0, $3f6992d190194f4d$export$cf5ddfea0105a5b4)(account, $ea79aff0bcfab408$export$20448f31fa658a15());\n    return decoded.data;\n}\n //# sourceMappingURL=index.browser.mjs.map\n\n\n// src/generated/accounts/mint.ts\nvar $c5679bb0a1fb1418$export$70504fba2ce56d52 = /* @__PURE__ */ ((AccountState2)=>{\n    AccountState2[AccountState2[\"Uninitialized\"] = 0] = \"Uninitialized\";\n    AccountState2[AccountState2[\"Initialized\"] = 1] = \"Initialized\";\n    AccountState2[AccountState2[\"Frozen\"] = 2] = \"Frozen\";\n    return AccountState2;\n})($c5679bb0a1fb1418$export$70504fba2ce56d52 || {});\nfunction $c5679bb0a1fb1418$export$f9e14159fc53d3a0() {\n    return (0, $991819a0aa439d56$export$d531177bc561a76e)($c5679bb0a1fb1418$export$70504fba2ce56d52);\n}\nfunction $c5679bb0a1fb1418$export$29eadaa90b440d19() {\n    return (0, $991819a0aa439d56$export$9999963707d133fe)($c5679bb0a1fb1418$export$70504fba2ce56d52);\n}\nfunction $c5679bb0a1fb1418$export$6a89812ed292093f() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$f9e14159fc53d3a0(), $c5679bb0a1fb1418$export$29eadaa90b440d19());\n}\nvar $c5679bb0a1fb1418$export$cd82032b224a3839 = /* @__PURE__ */ ((AuthorityType2)=>{\n    AuthorityType2[AuthorityType2[\"MintTokens\"] = 0] = \"MintTokens\";\n    AuthorityType2[AuthorityType2[\"FreezeAccount\"] = 1] = \"FreezeAccount\";\n    AuthorityType2[AuthorityType2[\"AccountOwner\"] = 2] = \"AccountOwner\";\n    AuthorityType2[AuthorityType2[\"CloseAccount\"] = 3] = \"CloseAccount\";\n    AuthorityType2[AuthorityType2[\"TransferFeeConfig\"] = 4] = \"TransferFeeConfig\";\n    AuthorityType2[AuthorityType2[\"WithheldWithdraw\"] = 5] = \"WithheldWithdraw\";\n    AuthorityType2[AuthorityType2[\"CloseMint\"] = 6] = \"CloseMint\";\n    AuthorityType2[AuthorityType2[\"InterestRate\"] = 7] = \"InterestRate\";\n    AuthorityType2[AuthorityType2[\"PermanentDelegate\"] = 8] = \"PermanentDelegate\";\n    AuthorityType2[AuthorityType2[\"ConfidentialTransferMint\"] = 9] = \"ConfidentialTransferMint\";\n    AuthorityType2[AuthorityType2[\"TransferHookProgramId\"] = 10] = \"TransferHookProgramId\";\n    AuthorityType2[AuthorityType2[\"ConfidentialTransferFeeConfig\"] = 11] = \"ConfidentialTransferFeeConfig\";\n    AuthorityType2[AuthorityType2[\"MetadataPointer\"] = 12] = \"MetadataPointer\";\n    AuthorityType2[AuthorityType2[\"GroupPointer\"] = 13] = \"GroupPointer\";\n    AuthorityType2[AuthorityType2[\"GroupMemberPointer\"] = 14] = \"GroupMemberPointer\";\n    AuthorityType2[AuthorityType2[\"ScaledUiAmount\"] = 15] = \"ScaledUiAmount\";\n    AuthorityType2[AuthorityType2[\"Pause\"] = 16] = \"Pause\";\n    return AuthorityType2;\n})($c5679bb0a1fb1418$export$cd82032b224a3839 || {});\nfunction $c5679bb0a1fb1418$export$f6d1e14b900ddfd1() {\n    return (0, $991819a0aa439d56$export$d531177bc561a76e)($c5679bb0a1fb1418$export$cd82032b224a3839);\n}\nfunction $c5679bb0a1fb1418$export$a03cb29b3edd2426() {\n    return (0, $991819a0aa439d56$export$9999963707d133fe)($c5679bb0a1fb1418$export$cd82032b224a3839);\n}\nfunction $c5679bb0a1fb1418$export$bbb172da3b8c2fc2() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$f6d1e14b900ddfd1(), $c5679bb0a1fb1418$export$a03cb29b3edd2426());\n}\nfunction $c5679bb0a1fb1418$export$81b4437e7425f22a() {\n    return (0, $b9bc3aaa401ff82b$export$cbdfce031443a1)((0, $991819a0aa439d56$export$636c51ad84d0674a)(), 36);\n}\nfunction $c5679bb0a1fb1418$export$2dde3d52f3fe8173() {\n    return (0, $b9bc3aaa401ff82b$export$1f85f8b8d2788007)((0, $991819a0aa439d56$export$b90e67818b1b3d45)(), 36);\n}\nfunction $c5679bb0a1fb1418$export$a754e1df8f34addc() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$81b4437e7425f22a(), $c5679bb0a1fb1418$export$2dde3d52f3fe8173());\n}\nfunction $c5679bb0a1fb1418$export$7f3654dcb63abd80() {\n    return (0, $b9bc3aaa401ff82b$export$cbdfce031443a1)((0, $991819a0aa439d56$export$636c51ad84d0674a)(), 64);\n}\nfunction $c5679bb0a1fb1418$export$c4e7c4cedd2ecdcc() {\n    return (0, $b9bc3aaa401ff82b$export$1f85f8b8d2788007)((0, $991819a0aa439d56$export$b90e67818b1b3d45)(), 64);\n}\nfunction $c5679bb0a1fb1418$export$122c9c0433f2aca7() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$7f3654dcb63abd80(), $c5679bb0a1fb1418$export$c4e7c4cedd2ecdcc());\n}\nfunction $c5679bb0a1fb1418$export$554cb049ed2dcdf0() {\n    return (0, $991819a0aa439d56$export$927540af483f54a)([\n        [\n            \"Uninitialized\",\n            (0, $991819a0aa439d56$export$a222f4a6d9205421)()\n        ],\n        [\n            \"TransferFeeConfig\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"transferFeeConfigAuthority\",\n                    (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)()\n                ],\n                [\n                    \"withdrawWithheldAuthority\",\n                    (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)()\n                ],\n                [\n                    \"withheldAmount\",\n                    (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n                ],\n                [\n                    \"olderTransferFee\",\n                    $c5679bb0a1fb1418$export$a2d7bfd8658f3f2d()\n                ],\n                [\n                    \"newerTransferFee\",\n                    $c5679bb0a1fb1418$export$a2d7bfd8658f3f2d()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"TransferFeeAmount\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"withheldAmount\",\n                    (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"MintCloseAuthority\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"closeAuthority\",\n                    (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"ConfidentialTransferMint\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"authority\",\n                    (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                        prefix: null,\n                        noneValue: \"zeroes\"\n                    })\n                ],\n                [\n                    \"autoApproveNewAccounts\",\n                    (0, $991819a0aa439d56$export$4a518d3f98f842eb)()\n                ],\n                [\n                    \"auditorElgamalPubkey\",\n                    (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                        prefix: null,\n                        noneValue: \"zeroes\"\n                    })\n                ]\n            ]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"ConfidentialTransferAccount\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"approved\",\n                    (0, $991819a0aa439d56$export$4a518d3f98f842eb)()\n                ],\n                [\n                    \"elgamalPubkey\",\n                    (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)()\n                ],\n                [\n                    \"pendingBalanceLow\",\n                    $c5679bb0a1fb1418$export$7f3654dcb63abd80()\n                ],\n                [\n                    \"pendingBalanceHigh\",\n                    $c5679bb0a1fb1418$export$7f3654dcb63abd80()\n                ],\n                [\n                    \"availableBalance\",\n                    $c5679bb0a1fb1418$export$7f3654dcb63abd80()\n                ],\n                [\n                    \"decryptableAvailableBalance\",\n                    $c5679bb0a1fb1418$export$81b4437e7425f22a()\n                ],\n                [\n                    \"allowConfidentialCredits\",\n                    (0, $991819a0aa439d56$export$4a518d3f98f842eb)()\n                ],\n                [\n                    \"allowNonConfidentialCredits\",\n                    (0, $991819a0aa439d56$export$4a518d3f98f842eb)()\n                ],\n                [\n                    \"pendingBalanceCreditCounter\",\n                    (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n                ],\n                [\n                    \"maximumPendingBalanceCreditCounter\",\n                    (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n                ],\n                [\n                    \"expectedPendingBalanceCreditCounter\",\n                    (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n                ],\n                [\n                    \"actualPendingBalanceCreditCounter\",\n                    (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"DefaultAccountState\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"state\",\n                    $c5679bb0a1fb1418$export$f9e14159fc53d3a0()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"ImmutableOwner\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"MemoTransfer\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"requireIncomingTransferMemos\",\n                    (0, $991819a0aa439d56$export$4a518d3f98f842eb)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"NonTransferable\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"InterestBearingConfig\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"rateAuthority\",\n                    (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)()\n                ],\n                [\n                    \"initializationTimestamp\",\n                    (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n                ],\n                [\n                    \"preUpdateAverageRate\",\n                    (0, $b5f941eb9a28d328$export$45d575c12b2bb6a5)()\n                ],\n                [\n                    \"lastUpdateTimestamp\",\n                    (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n                ],\n                [\n                    \"currentRate\",\n                    (0, $b5f941eb9a28d328$export$45d575c12b2bb6a5)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"CpiGuard\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"lockCpi\",\n                    (0, $991819a0aa439d56$export$4a518d3f98f842eb)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"PermanentDelegate\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"delegate\",\n                    (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"NonTransferableAccount\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"TransferHook\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"authority\",\n                    (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)()\n                ],\n                [\n                    \"programId\",\n                    (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"TransferHookAccount\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"transferring\",\n                    (0, $991819a0aa439d56$export$4a518d3f98f842eb)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"ConfidentialTransferFee\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"authority\",\n                    (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                        prefix: null,\n                        noneValue: \"zeroes\"\n                    })\n                ],\n                [\n                    \"elgamalPubkey\",\n                    (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)()\n                ],\n                [\n                    \"harvestToMintEnabled\",\n                    (0, $991819a0aa439d56$export$4a518d3f98f842eb)()\n                ],\n                [\n                    \"withheldAmount\",\n                    $c5679bb0a1fb1418$export$7f3654dcb63abd80()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"ConfidentialTransferFeeAmount\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"withheldAmount\",\n                    $c5679bb0a1fb1418$export$7f3654dcb63abd80()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"MetadataPointer\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"authority\",\n                    (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                        prefix: null,\n                        noneValue: \"zeroes\"\n                    })\n                ],\n                [\n                    \"metadataAddress\",\n                    (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                        prefix: null,\n                        noneValue: \"zeroes\"\n                    })\n                ]\n            ]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"TokenMetadata\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"updateAuthority\",\n                    (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                        prefix: null,\n                        noneValue: \"zeroes\"\n                    })\n                ],\n                [\n                    \"mint\",\n                    (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)()\n                ],\n                [\n                    \"name\",\n                    (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $278ae65923ee60f5$export$9a335ef9e29610a7)(), (0, $b5f941eb9a28d328$export$3e3136013a349951)())\n                ],\n                [\n                    \"symbol\",\n                    (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $278ae65923ee60f5$export$9a335ef9e29610a7)(), (0, $b5f941eb9a28d328$export$3e3136013a349951)())\n                ],\n                [\n                    \"uri\",\n                    (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $278ae65923ee60f5$export$9a335ef9e29610a7)(), (0, $b5f941eb9a28d328$export$3e3136013a349951)())\n                ],\n                [\n                    \"additionalMetadata\",\n                    (0, $991819a0aa439d56$export$75c3a7c49a778905)((0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $278ae65923ee60f5$export$9a335ef9e29610a7)(), (0, $b5f941eb9a28d328$export$3e3136013a349951)()), (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $278ae65923ee60f5$export$9a335ef9e29610a7)(), (0, $b5f941eb9a28d328$export$3e3136013a349951)()))\n                ]\n            ]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"GroupPointer\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"authority\",\n                    (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                        prefix: null,\n                        noneValue: \"zeroes\"\n                    })\n                ],\n                [\n                    \"groupAddress\",\n                    (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                        prefix: null,\n                        noneValue: \"zeroes\"\n                    })\n                ]\n            ]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"TokenGroup\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"updateAuthority\",\n                    (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                        prefix: null,\n                        noneValue: \"zeroes\"\n                    })\n                ],\n                [\n                    \"mint\",\n                    (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)()\n                ],\n                [\n                    \"size\",\n                    (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n                ],\n                [\n                    \"maxSize\",\n                    (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"GroupMemberPointer\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"authority\",\n                    (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                        prefix: null,\n                        noneValue: \"zeroes\"\n                    })\n                ],\n                [\n                    \"memberAddress\",\n                    (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                        prefix: null,\n                        noneValue: \"zeroes\"\n                    })\n                ]\n            ]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"TokenGroupMember\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"mint\",\n                    (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)()\n                ],\n                [\n                    \"group\",\n                    (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)()\n                ],\n                [\n                    \"memberNumber\",\n                    (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"ConfidentialMintBurn\",\n            (0, $991819a0aa439d56$export$a222f4a6d9205421)()\n        ],\n        [\n            \"ScaledUiAmountConfig\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"authority\",\n                    (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)()\n                ],\n                [\n                    \"multiplier\",\n                    (0, $b5f941eb9a28d328$export$551368d522177b99)()\n                ],\n                [\n                    \"newMultiplierEffectiveTimestamp\",\n                    (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n                ],\n                [\n                    \"newMultiplier\",\n                    (0, $b5f941eb9a28d328$export$551368d522177b99)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"PausableConfig\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"authority\",\n                    (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                        prefix: null,\n                        noneValue: \"zeroes\"\n                    })\n                ],\n                [\n                    \"paused\",\n                    (0, $991819a0aa439d56$export$4a518d3f98f842eb)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$e156211d06496a2f)())\n        ],\n        [\n            \"PausableAccount\",\n            (0, $991819a0aa439d56$export$a222f4a6d9205421)()\n        ]\n    ], {\n        size: (0, $b5f941eb9a28d328$export$e156211d06496a2f)()\n    });\n}\nfunction $c5679bb0a1fb1418$export$acd08efaae7b95e() {\n    return (0, $991819a0aa439d56$export$46f8fe299eb88c54)([\n        [\n            \"Uninitialized\",\n            (0, $991819a0aa439d56$export$46a76d99d5c61218)()\n        ],\n        [\n            \"TransferFeeConfig\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"transferFeeConfigAuthority\",\n                    (0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)()\n                ],\n                [\n                    \"withdrawWithheldAuthority\",\n                    (0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)()\n                ],\n                [\n                    \"withheldAmount\",\n                    (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n                ],\n                [\n                    \"olderTransferFee\",\n                    $c5679bb0a1fb1418$export$37045bd5cbd8823d()\n                ],\n                [\n                    \"newerTransferFee\",\n                    $c5679bb0a1fb1418$export$37045bd5cbd8823d()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"TransferFeeAmount\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"withheldAmount\",\n                    (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"MintCloseAuthority\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"closeAuthority\",\n                    (0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"ConfidentialTransferMint\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"authority\",\n                    (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                        prefix: null,\n                        noneValue: \"zeroes\"\n                    })\n                ],\n                [\n                    \"autoApproveNewAccounts\",\n                    (0, $991819a0aa439d56$export$43a73c742ad521e1)()\n                ],\n                [\n                    \"auditorElgamalPubkey\",\n                    (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                        prefix: null,\n                        noneValue: \"zeroes\"\n                    })\n                ]\n            ]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"ConfidentialTransferAccount\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"approved\",\n                    (0, $991819a0aa439d56$export$43a73c742ad521e1)()\n                ],\n                [\n                    \"elgamalPubkey\",\n                    (0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)()\n                ],\n                [\n                    \"pendingBalanceLow\",\n                    $c5679bb0a1fb1418$export$c4e7c4cedd2ecdcc()\n                ],\n                [\n                    \"pendingBalanceHigh\",\n                    $c5679bb0a1fb1418$export$c4e7c4cedd2ecdcc()\n                ],\n                [\n                    \"availableBalance\",\n                    $c5679bb0a1fb1418$export$c4e7c4cedd2ecdcc()\n                ],\n                [\n                    \"decryptableAvailableBalance\",\n                    $c5679bb0a1fb1418$export$2dde3d52f3fe8173()\n                ],\n                [\n                    \"allowConfidentialCredits\",\n                    (0, $991819a0aa439d56$export$43a73c742ad521e1)()\n                ],\n                [\n                    \"allowNonConfidentialCredits\",\n                    (0, $991819a0aa439d56$export$43a73c742ad521e1)()\n                ],\n                [\n                    \"pendingBalanceCreditCounter\",\n                    (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n                ],\n                [\n                    \"maximumPendingBalanceCreditCounter\",\n                    (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n                ],\n                [\n                    \"expectedPendingBalanceCreditCounter\",\n                    (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n                ],\n                [\n                    \"actualPendingBalanceCreditCounter\",\n                    (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"DefaultAccountState\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"state\",\n                    $c5679bb0a1fb1418$export$29eadaa90b440d19()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"ImmutableOwner\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"MemoTransfer\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"requireIncomingTransferMemos\",\n                    (0, $991819a0aa439d56$export$43a73c742ad521e1)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"NonTransferable\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"InterestBearingConfig\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"rateAuthority\",\n                    (0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)()\n                ],\n                [\n                    \"initializationTimestamp\",\n                    (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n                ],\n                [\n                    \"preUpdateAverageRate\",\n                    (0, $b5f941eb9a28d328$export$4617ff1e22909f4)()\n                ],\n                [\n                    \"lastUpdateTimestamp\",\n                    (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n                ],\n                [\n                    \"currentRate\",\n                    (0, $b5f941eb9a28d328$export$4617ff1e22909f4)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"CpiGuard\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"lockCpi\",\n                    (0, $991819a0aa439d56$export$43a73c742ad521e1)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"PermanentDelegate\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"delegate\",\n                    (0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"NonTransferableAccount\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"TransferHook\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"authority\",\n                    (0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)()\n                ],\n                [\n                    \"programId\",\n                    (0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"TransferHookAccount\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"transferring\",\n                    (0, $991819a0aa439d56$export$43a73c742ad521e1)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"ConfidentialTransferFee\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"authority\",\n                    (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                        prefix: null,\n                        noneValue: \"zeroes\"\n                    })\n                ],\n                [\n                    \"elgamalPubkey\",\n                    (0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)()\n                ],\n                [\n                    \"harvestToMintEnabled\",\n                    (0, $991819a0aa439d56$export$43a73c742ad521e1)()\n                ],\n                [\n                    \"withheldAmount\",\n                    $c5679bb0a1fb1418$export$c4e7c4cedd2ecdcc()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"ConfidentialTransferFeeAmount\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"withheldAmount\",\n                    $c5679bb0a1fb1418$export$c4e7c4cedd2ecdcc()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"MetadataPointer\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"authority\",\n                    (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                        prefix: null,\n                        noneValue: \"zeroes\"\n                    })\n                ],\n                [\n                    \"metadataAddress\",\n                    (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                        prefix: null,\n                        noneValue: \"zeroes\"\n                    })\n                ]\n            ]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"TokenMetadata\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"updateAuthority\",\n                    (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                        prefix: null,\n                        noneValue: \"zeroes\"\n                    })\n                ],\n                [\n                    \"mint\",\n                    (0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)()\n                ],\n                [\n                    \"name\",\n                    (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $278ae65923ee60f5$export$3cdd8a41d7d6b55d)(), (0, $b5f941eb9a28d328$export$ddc26825031b1ac9)())\n                ],\n                [\n                    \"symbol\",\n                    (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $278ae65923ee60f5$export$3cdd8a41d7d6b55d)(), (0, $b5f941eb9a28d328$export$ddc26825031b1ac9)())\n                ],\n                [\n                    \"uri\",\n                    (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $278ae65923ee60f5$export$3cdd8a41d7d6b55d)(), (0, $b5f941eb9a28d328$export$ddc26825031b1ac9)())\n                ],\n                [\n                    \"additionalMetadata\",\n                    (0, $991819a0aa439d56$export$e102943539f62962)((0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $278ae65923ee60f5$export$3cdd8a41d7d6b55d)(), (0, $b5f941eb9a28d328$export$ddc26825031b1ac9)()), (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $278ae65923ee60f5$export$3cdd8a41d7d6b55d)(), (0, $b5f941eb9a28d328$export$ddc26825031b1ac9)()))\n                ]\n            ]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"GroupPointer\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"authority\",\n                    (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                        prefix: null,\n                        noneValue: \"zeroes\"\n                    })\n                ],\n                [\n                    \"groupAddress\",\n                    (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                        prefix: null,\n                        noneValue: \"zeroes\"\n                    })\n                ]\n            ]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"TokenGroup\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"updateAuthority\",\n                    (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                        prefix: null,\n                        noneValue: \"zeroes\"\n                    })\n                ],\n                [\n                    \"mint\",\n                    (0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)()\n                ],\n                [\n                    \"size\",\n                    (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n                ],\n                [\n                    \"maxSize\",\n                    (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"GroupMemberPointer\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"authority\",\n                    (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                        prefix: null,\n                        noneValue: \"zeroes\"\n                    })\n                ],\n                [\n                    \"memberAddress\",\n                    (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                        prefix: null,\n                        noneValue: \"zeroes\"\n                    })\n                ]\n            ]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"TokenGroupMember\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"mint\",\n                    (0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)()\n                ],\n                [\n                    \"group\",\n                    (0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)()\n                ],\n                [\n                    \"memberNumber\",\n                    (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"ConfidentialMintBurn\",\n            (0, $991819a0aa439d56$export$46a76d99d5c61218)()\n        ],\n        [\n            \"ScaledUiAmountConfig\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"authority\",\n                    (0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)()\n                ],\n                [\n                    \"multiplier\",\n                    (0, $b5f941eb9a28d328$export$9475ae45ddf86dec)()\n                ],\n                [\n                    \"newMultiplierEffectiveTimestamp\",\n                    (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n                ],\n                [\n                    \"newMultiplier\",\n                    (0, $b5f941eb9a28d328$export$9475ae45ddf86dec)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"PausableConfig\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"authority\",\n                    (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                        prefix: null,\n                        noneValue: \"zeroes\"\n                    })\n                ],\n                [\n                    \"paused\",\n                    (0, $991819a0aa439d56$export$43a73c742ad521e1)()\n                ]\n            ]), (0, $b5f941eb9a28d328$export$1a649eb0055ac058)())\n        ],\n        [\n            \"PausableAccount\",\n            (0, $991819a0aa439d56$export$46a76d99d5c61218)()\n        ]\n    ], {\n        size: (0, $b5f941eb9a28d328$export$1a649eb0055ac058)()\n    });\n}\nfunction $c5679bb0a1fb1418$export$9cec944b3697466b() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$554cb049ed2dcdf0(), $c5679bb0a1fb1418$export$acd08efaae7b95e());\n}\nfunction $c5679bb0a1fb1418$export$1b45514b112dd749(kind, data) {\n    return Array.isArray(data) ? {\n        __kind: kind,\n        fields: data\n    } : {\n        __kind: kind,\n        ...data ?? {}\n    };\n}\nfunction $c5679bb0a1fb1418$export$ddf8ad45a7aca8d5(kind, value) {\n    return value.__kind === kind;\n}\nvar $c5679bb0a1fb1418$export$4f037c6ec2da4eeb = /* @__PURE__ */ ((ExtensionType2)=>{\n    ExtensionType2[ExtensionType2[\"Uninitialized\"] = 0] = \"Uninitialized\";\n    ExtensionType2[ExtensionType2[\"TransferFeeConfig\"] = 1] = \"TransferFeeConfig\";\n    ExtensionType2[ExtensionType2[\"TransferFeeAmount\"] = 2] = \"TransferFeeAmount\";\n    ExtensionType2[ExtensionType2[\"MintCloseAuthority\"] = 3] = \"MintCloseAuthority\";\n    ExtensionType2[ExtensionType2[\"ConfidentialTransferMint\"] = 4] = \"ConfidentialTransferMint\";\n    ExtensionType2[ExtensionType2[\"ConfidentialTransferAccount\"] = 5] = \"ConfidentialTransferAccount\";\n    ExtensionType2[ExtensionType2[\"DefaultAccountState\"] = 6] = \"DefaultAccountState\";\n    ExtensionType2[ExtensionType2[\"ImmutableOwner\"] = 7] = \"ImmutableOwner\";\n    ExtensionType2[ExtensionType2[\"MemoTransfer\"] = 8] = \"MemoTransfer\";\n    ExtensionType2[ExtensionType2[\"NonTransferable\"] = 9] = \"NonTransferable\";\n    ExtensionType2[ExtensionType2[\"InterestBearingConfig\"] = 10] = \"InterestBearingConfig\";\n    ExtensionType2[ExtensionType2[\"CpiGuard\"] = 11] = \"CpiGuard\";\n    ExtensionType2[ExtensionType2[\"PermanentDelegate\"] = 12] = \"PermanentDelegate\";\n    ExtensionType2[ExtensionType2[\"NonTransferableAccount\"] = 13] = \"NonTransferableAccount\";\n    ExtensionType2[ExtensionType2[\"TransferHook\"] = 14] = \"TransferHook\";\n    ExtensionType2[ExtensionType2[\"TransferHookAccount\"] = 15] = \"TransferHookAccount\";\n    ExtensionType2[ExtensionType2[\"ConfidentialTransferFee\"] = 16] = \"ConfidentialTransferFee\";\n    ExtensionType2[ExtensionType2[\"ConfidentialTransferFeeAmount\"] = 17] = \"ConfidentialTransferFeeAmount\";\n    ExtensionType2[ExtensionType2[\"ScaledUiAmountConfig\"] = 18] = \"ScaledUiAmountConfig\";\n    ExtensionType2[ExtensionType2[\"PausableConfig\"] = 19] = \"PausableConfig\";\n    ExtensionType2[ExtensionType2[\"PausableAccount\"] = 20] = \"PausableAccount\";\n    ExtensionType2[ExtensionType2[\"MetadataPointer\"] = 21] = \"MetadataPointer\";\n    ExtensionType2[ExtensionType2[\"TokenMetadata\"] = 22] = \"TokenMetadata\";\n    ExtensionType2[ExtensionType2[\"GroupPointer\"] = 23] = \"GroupPointer\";\n    ExtensionType2[ExtensionType2[\"TokenGroup\"] = 24] = \"TokenGroup\";\n    ExtensionType2[ExtensionType2[\"GroupMemberPointer\"] = 25] = \"GroupMemberPointer\";\n    ExtensionType2[ExtensionType2[\"TokenGroupMember\"] = 26] = \"TokenGroupMember\";\n    return ExtensionType2;\n})($c5679bb0a1fb1418$export$4f037c6ec2da4eeb || {});\nfunction $c5679bb0a1fb1418$export$7c1483c3b497276b() {\n    return (0, $991819a0aa439d56$export$d531177bc561a76e)($c5679bb0a1fb1418$export$4f037c6ec2da4eeb, {\n        size: (0, $b5f941eb9a28d328$export$e156211d06496a2f)()\n    });\n}\nfunction $c5679bb0a1fb1418$export$269c0b898b017d4e() {\n    return (0, $991819a0aa439d56$export$9999963707d133fe)($c5679bb0a1fb1418$export$4f037c6ec2da4eeb, {\n        size: (0, $b5f941eb9a28d328$export$1a649eb0055ac058)()\n    });\n}\nfunction $c5679bb0a1fb1418$export$f00fe60c792c381a() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$7c1483c3b497276b(), $c5679bb0a1fb1418$export$269c0b898b017d4e());\n}\nfunction $c5679bb0a1fb1418$export$e5db494efe819c74() {\n    return (0, $991819a0aa439d56$export$927540af483f54a)([\n        [\n            \"Name\",\n            (0, $991819a0aa439d56$export$a222f4a6d9205421)()\n        ],\n        [\n            \"Symbol\",\n            (0, $991819a0aa439d56$export$a222f4a6d9205421)()\n        ],\n        [\n            \"Uri\",\n            (0, $991819a0aa439d56$export$a222f4a6d9205421)()\n        ],\n        [\n            \"Key\",\n            (0, $991819a0aa439d56$export$64024546a32014b8)([\n                [\n                    \"fields\",\n                    (0, $991819a0aa439d56$export$6b19a6a85541fd99)([\n                        (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $278ae65923ee60f5$export$9a335ef9e29610a7)(), (0, $b5f941eb9a28d328$export$3e3136013a349951)())\n                    ])\n                ]\n            ])\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$24bf2a22886c19e0() {\n    return (0, $991819a0aa439d56$export$46f8fe299eb88c54)([\n        [\n            \"Name\",\n            (0, $991819a0aa439d56$export$46a76d99d5c61218)()\n        ],\n        [\n            \"Symbol\",\n            (0, $991819a0aa439d56$export$46a76d99d5c61218)()\n        ],\n        [\n            \"Uri\",\n            (0, $991819a0aa439d56$export$46a76d99d5c61218)()\n        ],\n        [\n            \"Key\",\n            (0, $991819a0aa439d56$export$7070fbe048971470)([\n                [\n                    \"fields\",\n                    (0, $991819a0aa439d56$export$9800955a9fcaec5)([\n                        (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $278ae65923ee60f5$export$3cdd8a41d7d6b55d)(), (0, $b5f941eb9a28d328$export$ddc26825031b1ac9)())\n                    ])\n                ]\n            ])\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$9861d38565e49aac() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$e5db494efe819c74(), $c5679bb0a1fb1418$export$24bf2a22886c19e0());\n}\nfunction $c5679bb0a1fb1418$export$73772c79054da156(kind, data) {\n    return Array.isArray(data) ? {\n        __kind: kind,\n        fields: data\n    } : {\n        __kind: kind,\n        ...data ?? {}\n    };\n}\nfunction $c5679bb0a1fb1418$export$f5255864db2bc913(kind, value) {\n    return value.__kind === kind;\n}\nfunction $c5679bb0a1fb1418$export$a2d7bfd8658f3f2d() {\n    return (0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"epoch\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ],\n        [\n            \"maximumFee\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ],\n        [\n            \"transferFeeBasisPoints\",\n            (0, $b5f941eb9a28d328$export$e156211d06496a2f)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$37045bd5cbd8823d() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"epoch\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ],\n        [\n            \"maximumFee\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ],\n        [\n            \"transferFeeBasisPoints\",\n            (0, $b5f941eb9a28d328$export$1a649eb0055ac058)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$5576a442a4300cc7() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$a2d7bfd8658f3f2d(), $c5679bb0a1fb1418$export$37045bd5cbd8823d());\n}\n// src/generated/accounts/mint.ts\nfunction $c5679bb0a1fb1418$export$419daee9803d873f() {\n    return (0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"mintAuthority\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: (0, $b5f941eb9a28d328$export$3e3136013a349951)(),\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"supply\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ],\n        [\n            \"decimals\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"isInitialized\",\n            (0, $991819a0aa439d56$export$4a518d3f98f842eb)()\n        ],\n        [\n            \"freezeAuthority\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: (0, $b5f941eb9a28d328$export$3e3136013a349951)(),\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"extensions\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $991819a0aa439d56$export$e68e10087ec64330)((0, $991819a0aa439d56$export$415199198053c0b)($c5679bb0a1fb1418$export$554cb049ed2dcdf0(), {\n                size: \"remainder\"\n            }), [\n                (0, $991819a0aa439d56$export$23a212060029ca97)((0, $b9bc3aaa401ff82b$export$66b1746799cd3030)((0, $b5f941eb9a28d328$export$dc9732115561fb4b)(), 83).encode(1))\n            ]), {\n                prefix: null\n            })\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$b192a608537a22e9() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"mintAuthority\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: (0, $b5f941eb9a28d328$export$ddc26825031b1ac9)(),\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"supply\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ],\n        [\n            \"decimals\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"isInitialized\",\n            (0, $991819a0aa439d56$export$43a73c742ad521e1)()\n        ],\n        [\n            \"freezeAuthority\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: (0, $b5f941eb9a28d328$export$ddc26825031b1ac9)(),\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"extensions\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $991819a0aa439d56$export$3e731190a51906e9)((0, $991819a0aa439d56$export$9016038b2e3b0c2f)($c5679bb0a1fb1418$export$acd08efaae7b95e(), {\n                size: \"remainder\"\n            }), [\n                (0, $991819a0aa439d56$export$13c771567a4019f7)((0, $b9bc3aaa401ff82b$export$66b1746799cd3030)((0, $b5f941eb9a28d328$export$dc9732115561fb4b)(), 83).encode(1))\n            ]), {\n                prefix: null\n            })\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$c089e0501b91f4ab() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$419daee9803d873f(), $c5679bb0a1fb1418$export$b192a608537a22e9());\n}\nfunction $c5679bb0a1fb1418$export$9592a0a5e95277c1(encodedAccount) {\n    return (0, $3f6992d190194f4d$export$cf5ddfea0105a5b4)(encodedAccount, $c5679bb0a1fb1418$export$b192a608537a22e9());\n}\nasync function $c5679bb0a1fb1418$export$b7c99361c5bcd3c4(rpc, address, config) {\n    const maybeAccount = await $c5679bb0a1fb1418$export$d9d70397ce5b88c5(rpc, address, config);\n    (0, $3f6992d190194f4d$export$c5f1bc6464904f18)(maybeAccount);\n    return maybeAccount;\n}\nasync function $c5679bb0a1fb1418$export$d9d70397ce5b88c5(rpc, address, config) {\n    const maybeAccount = await (0, $3f6992d190194f4d$export$14418aaf1acfa4e5)(rpc, address, config);\n    return $c5679bb0a1fb1418$export$9592a0a5e95277c1(maybeAccount);\n}\nasync function $c5679bb0a1fb1418$export$a65d9b6a4332d872(rpc, addresses, config) {\n    const maybeAccounts = await $c5679bb0a1fb1418$export$df9a7b6e7a568c02(rpc, addresses, config);\n    (0, $3f6992d190194f4d$export$e34754ea38e46745)(maybeAccounts);\n    return maybeAccounts;\n}\nasync function $c5679bb0a1fb1418$export$df9a7b6e7a568c02(rpc, addresses, config) {\n    const maybeAccounts = await (0, $3f6992d190194f4d$export$ea06bd5bf72cf183)(rpc, addresses, config);\n    return maybeAccounts.map((maybeAccount)=>$c5679bb0a1fb1418$export$9592a0a5e95277c1(maybeAccount));\n}\nfunction $c5679bb0a1fb1418$export$3661af40a8f0f72b() {\n    return (0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"m\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"n\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"isInitialized\",\n            (0, $991819a0aa439d56$export$4a518d3f98f842eb)()\n        ],\n        [\n            \"signers\",\n            (0, $991819a0aa439d56$export$415199198053c0b)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                size: 11\n            })\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$5c881a9c1c7738d1() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"m\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"n\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"isInitialized\",\n            (0, $991819a0aa439d56$export$43a73c742ad521e1)()\n        ],\n        [\n            \"signers\",\n            (0, $991819a0aa439d56$export$9016038b2e3b0c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                size: 11\n            })\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$47e637c6f3aad6fa() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$3661af40a8f0f72b(), $c5679bb0a1fb1418$export$5c881a9c1c7738d1());\n}\nfunction $c5679bb0a1fb1418$export$61d8d4551781eda9(encodedAccount) {\n    return (0, $3f6992d190194f4d$export$cf5ddfea0105a5b4)(encodedAccount, $c5679bb0a1fb1418$export$5c881a9c1c7738d1());\n}\nasync function $c5679bb0a1fb1418$export$b4db2dbf2812158d(rpc, address, config) {\n    const maybeAccount = await $c5679bb0a1fb1418$export$adc332435cda2162(rpc, address, config);\n    (0, $3f6992d190194f4d$export$c5f1bc6464904f18)(maybeAccount);\n    return maybeAccount;\n}\nasync function $c5679bb0a1fb1418$export$adc332435cda2162(rpc, address, config) {\n    const maybeAccount = await (0, $3f6992d190194f4d$export$14418aaf1acfa4e5)(rpc, address, config);\n    return $c5679bb0a1fb1418$export$61d8d4551781eda9(maybeAccount);\n}\nasync function $c5679bb0a1fb1418$export$88cfaecde6f9985(rpc, addresses, config) {\n    const maybeAccounts = await $c5679bb0a1fb1418$export$437ad706b5407eb8(rpc, addresses, config);\n    (0, $3f6992d190194f4d$export$e34754ea38e46745)(maybeAccounts);\n    return maybeAccounts;\n}\nasync function $c5679bb0a1fb1418$export$437ad706b5407eb8(rpc, addresses, config) {\n    const maybeAccounts = await (0, $3f6992d190194f4d$export$ea06bd5bf72cf183)(rpc, addresses, config);\n    return maybeAccounts.map((maybeAccount)=>$c5679bb0a1fb1418$export$61d8d4551781eda9(maybeAccount));\n}\nfunction $c5679bb0a1fb1418$export$a88b454af71d72f5() {\n    return 355;\n}\nfunction $c5679bb0a1fb1418$export$8094cc56fb87f303() {\n    return (0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"mint\",\n            (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)()\n        ],\n        [\n            \"owner\",\n            (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ],\n        [\n            \"delegate\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: (0, $b5f941eb9a28d328$export$3e3136013a349951)(),\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"state\",\n            $c5679bb0a1fb1418$export$f9e14159fc53d3a0()\n        ],\n        [\n            \"isNative\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $b5f941eb9a28d328$export$59d3bc8d559487ec)(), {\n                prefix: (0, $b5f941eb9a28d328$export$3e3136013a349951)(),\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"delegatedAmount\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ],\n        [\n            \"closeAuthority\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: (0, $b5f941eb9a28d328$export$3e3136013a349951)(),\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"extensions\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $991819a0aa439d56$export$e68e10087ec64330)((0, $991819a0aa439d56$export$415199198053c0b)($c5679bb0a1fb1418$export$554cb049ed2dcdf0(), {\n                size: \"remainder\"\n            }), [\n                (0, $991819a0aa439d56$export$23a212060029ca97)((0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(2))\n            ]), {\n                prefix: null\n            })\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$13c8a3e3aac02e58() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"mint\",\n            (0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)()\n        ],\n        [\n            \"owner\",\n            (0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ],\n        [\n            \"delegate\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: (0, $b5f941eb9a28d328$export$ddc26825031b1ac9)(),\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"state\",\n            $c5679bb0a1fb1418$export$29eadaa90b440d19()\n        ],\n        [\n            \"isNative\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $b5f941eb9a28d328$export$faa05ffebebd465d)(), {\n                prefix: (0, $b5f941eb9a28d328$export$ddc26825031b1ac9)(),\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"delegatedAmount\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ],\n        [\n            \"closeAuthority\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: (0, $b5f941eb9a28d328$export$ddc26825031b1ac9)(),\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"extensions\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $991819a0aa439d56$export$3e731190a51906e9)((0, $991819a0aa439d56$export$9016038b2e3b0c2f)($c5679bb0a1fb1418$export$acd08efaae7b95e(), {\n                size: \"remainder\"\n            }), [\n                (0, $991819a0aa439d56$export$13c771567a4019f7)((0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(2))\n            ]), {\n                prefix: null\n            })\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$5c47bb7b45ae860f() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$8094cc56fb87f303(), $c5679bb0a1fb1418$export$13c8a3e3aac02e58());\n}\nfunction $c5679bb0a1fb1418$export$4b61618bdb99cb7e(encodedAccount) {\n    return (0, $3f6992d190194f4d$export$cf5ddfea0105a5b4)(encodedAccount, $c5679bb0a1fb1418$export$13c8a3e3aac02e58());\n}\nasync function $c5679bb0a1fb1418$export$77ad5286853a8a58(rpc, address, config) {\n    const maybeAccount = await $c5679bb0a1fb1418$export$52705d85675548cb(rpc, address, config);\n    (0, $3f6992d190194f4d$export$c5f1bc6464904f18)(maybeAccount);\n    return maybeAccount;\n}\nasync function $c5679bb0a1fb1418$export$52705d85675548cb(rpc, address, config) {\n    const maybeAccount = await (0, $3f6992d190194f4d$export$14418aaf1acfa4e5)(rpc, address, config);\n    return $c5679bb0a1fb1418$export$4b61618bdb99cb7e(maybeAccount);\n}\nasync function $c5679bb0a1fb1418$export$86609295e565ee55(rpc, addresses, config) {\n    const maybeAccounts = await $c5679bb0a1fb1418$export$75a65a8dd007ae7f(rpc, addresses, config);\n    (0, $3f6992d190194f4d$export$e34754ea38e46745)(maybeAccounts);\n    return maybeAccounts;\n}\nasync function $c5679bb0a1fb1418$export$75a65a8dd007ae7f(rpc, addresses, config) {\n    const maybeAccounts = await (0, $3f6992d190194f4d$export$ea06bd5bf72cf183)(rpc, addresses, config);\n    return maybeAccounts.map((maybeAccount)=>$c5679bb0a1fb1418$export$4b61618bdb99cb7e(maybeAccount));\n}\nvar $c5679bb0a1fb1418$export$97ae793257bad8ba = \"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\";\nvar $c5679bb0a1fb1418$export$694c519e7c5de7e7 = /* @__PURE__ */ ((AssociatedTokenInstruction2)=>{\n    AssociatedTokenInstruction2[AssociatedTokenInstruction2[\"CreateAssociatedToken\"] = 0] = \"CreateAssociatedToken\";\n    AssociatedTokenInstruction2[AssociatedTokenInstruction2[\"CreateAssociatedTokenIdempotent\"] = 1] = \"CreateAssociatedTokenIdempotent\";\n    AssociatedTokenInstruction2[AssociatedTokenInstruction2[\"RecoverNestedAssociatedToken\"] = 2] = \"RecoverNestedAssociatedToken\";\n    return AssociatedTokenInstruction2;\n})($c5679bb0a1fb1418$export$694c519e7c5de7e7 || {});\nfunction $c5679bb0a1fb1418$export$f7541a3735072c66(instruction) {\n    const data = \"data\" in instruction ? instruction.data : instruction;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(0), 0)) return 0 /* CreateAssociatedToken */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(1), 0)) return 1 /* CreateAssociatedTokenIdempotent */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(2), 0)) return 2 /* RecoverNestedAssociatedToken */ ;\n    throw new Error(\"The provided instruction could not be identified as a associatedToken instruction.\");\n}\nvar $c5679bb0a1fb1418$export$69a22f9c8498afc2 = \"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\";\nvar $c5679bb0a1fb1418$export$b8ef38820c59ed7a = /* @__PURE__ */ ((Token2022Account2)=>{\n    Token2022Account2[Token2022Account2[\"Mint\"] = 0] = \"Mint\";\n    Token2022Account2[Token2022Account2[\"Token\"] = 1] = \"Token\";\n    Token2022Account2[Token2022Account2[\"Multisig\"] = 2] = \"Multisig\";\n    return Token2022Account2;\n})($c5679bb0a1fb1418$export$b8ef38820c59ed7a || {});\nfunction $c5679bb0a1fb1418$export$d523e9de4d2f5581(account) {\n    const data = \"data\" in account ? account.data : account;\n    if (data.length === 82) return 0 /* Mint */ ;\n    if (data.length === 165) return 1 /* Token */ ;\n    if (data.length === 355) return 2 /* Multisig */ ;\n    throw new Error(\"The provided account could not be identified as a token-2022 account.\");\n}\nvar $c5679bb0a1fb1418$export$3559bd77d1c508e9 = /* @__PURE__ */ ((Token2022Instruction2)=>{\n    Token2022Instruction2[Token2022Instruction2[\"InitializeMint\"] = 0] = \"InitializeMint\";\n    Token2022Instruction2[Token2022Instruction2[\"InitializeAccount\"] = 1] = \"InitializeAccount\";\n    Token2022Instruction2[Token2022Instruction2[\"InitializeMultisig\"] = 2] = \"InitializeMultisig\";\n    Token2022Instruction2[Token2022Instruction2[\"Transfer\"] = 3] = \"Transfer\";\n    Token2022Instruction2[Token2022Instruction2[\"Approve\"] = 4] = \"Approve\";\n    Token2022Instruction2[Token2022Instruction2[\"Revoke\"] = 5] = \"Revoke\";\n    Token2022Instruction2[Token2022Instruction2[\"SetAuthority\"] = 6] = \"SetAuthority\";\n    Token2022Instruction2[Token2022Instruction2[\"MintTo\"] = 7] = \"MintTo\";\n    Token2022Instruction2[Token2022Instruction2[\"Burn\"] = 8] = \"Burn\";\n    Token2022Instruction2[Token2022Instruction2[\"CloseAccount\"] = 9] = \"CloseAccount\";\n    Token2022Instruction2[Token2022Instruction2[\"FreezeAccount\"] = 10] = \"FreezeAccount\";\n    Token2022Instruction2[Token2022Instruction2[\"ThawAccount\"] = 11] = \"ThawAccount\";\n    Token2022Instruction2[Token2022Instruction2[\"TransferChecked\"] = 12] = \"TransferChecked\";\n    Token2022Instruction2[Token2022Instruction2[\"ApproveChecked\"] = 13] = \"ApproveChecked\";\n    Token2022Instruction2[Token2022Instruction2[\"MintToChecked\"] = 14] = \"MintToChecked\";\n    Token2022Instruction2[Token2022Instruction2[\"BurnChecked\"] = 15] = \"BurnChecked\";\n    Token2022Instruction2[Token2022Instruction2[\"InitializeAccount2\"] = 16] = \"InitializeAccount2\";\n    Token2022Instruction2[Token2022Instruction2[\"SyncNative\"] = 17] = \"SyncNative\";\n    Token2022Instruction2[Token2022Instruction2[\"InitializeAccount3\"] = 18] = \"InitializeAccount3\";\n    Token2022Instruction2[Token2022Instruction2[\"InitializeMultisig2\"] = 19] = \"InitializeMultisig2\";\n    Token2022Instruction2[Token2022Instruction2[\"InitializeMint2\"] = 20] = \"InitializeMint2\";\n    Token2022Instruction2[Token2022Instruction2[\"GetAccountDataSize\"] = 21] = \"GetAccountDataSize\";\n    Token2022Instruction2[Token2022Instruction2[\"InitializeImmutableOwner\"] = 22] = \"InitializeImmutableOwner\";\n    Token2022Instruction2[Token2022Instruction2[\"AmountToUiAmount\"] = 23] = \"AmountToUiAmount\";\n    Token2022Instruction2[Token2022Instruction2[\"UiAmountToAmount\"] = 24] = \"UiAmountToAmount\";\n    Token2022Instruction2[Token2022Instruction2[\"InitializeMintCloseAuthority\"] = 25] = \"InitializeMintCloseAuthority\";\n    Token2022Instruction2[Token2022Instruction2[\"InitializeTransferFeeConfig\"] = 26] = \"InitializeTransferFeeConfig\";\n    Token2022Instruction2[Token2022Instruction2[\"TransferCheckedWithFee\"] = 27] = \"TransferCheckedWithFee\";\n    Token2022Instruction2[Token2022Instruction2[\"WithdrawWithheldTokensFromMint\"] = 28] = \"WithdrawWithheldTokensFromMint\";\n    Token2022Instruction2[Token2022Instruction2[\"WithdrawWithheldTokensFromAccounts\"] = 29] = \"WithdrawWithheldTokensFromAccounts\";\n    Token2022Instruction2[Token2022Instruction2[\"HarvestWithheldTokensToMint\"] = 30] = \"HarvestWithheldTokensToMint\";\n    Token2022Instruction2[Token2022Instruction2[\"SetTransferFee\"] = 31] = \"SetTransferFee\";\n    Token2022Instruction2[Token2022Instruction2[\"InitializeConfidentialTransferMint\"] = 32] = \"InitializeConfidentialTransferMint\";\n    Token2022Instruction2[Token2022Instruction2[\"UpdateConfidentialTransferMint\"] = 33] = \"UpdateConfidentialTransferMint\";\n    Token2022Instruction2[Token2022Instruction2[\"ConfigureConfidentialTransferAccount\"] = 34] = \"ConfigureConfidentialTransferAccount\";\n    Token2022Instruction2[Token2022Instruction2[\"ApproveConfidentialTransferAccount\"] = 35] = \"ApproveConfidentialTransferAccount\";\n    Token2022Instruction2[Token2022Instruction2[\"EmptyConfidentialTransferAccount\"] = 36] = \"EmptyConfidentialTransferAccount\";\n    Token2022Instruction2[Token2022Instruction2[\"ConfidentialDeposit\"] = 37] = \"ConfidentialDeposit\";\n    Token2022Instruction2[Token2022Instruction2[\"ConfidentialWithdraw\"] = 38] = \"ConfidentialWithdraw\";\n    Token2022Instruction2[Token2022Instruction2[\"ConfidentialTransfer\"] = 39] = \"ConfidentialTransfer\";\n    Token2022Instruction2[Token2022Instruction2[\"ApplyConfidentialPendingBalance\"] = 40] = \"ApplyConfidentialPendingBalance\";\n    Token2022Instruction2[Token2022Instruction2[\"EnableConfidentialCredits\"] = 41] = \"EnableConfidentialCredits\";\n    Token2022Instruction2[Token2022Instruction2[\"DisableConfidentialCredits\"] = 42] = \"DisableConfidentialCredits\";\n    Token2022Instruction2[Token2022Instruction2[\"EnableNonConfidentialCredits\"] = 43] = \"EnableNonConfidentialCredits\";\n    Token2022Instruction2[Token2022Instruction2[\"DisableNonConfidentialCredits\"] = 44] = \"DisableNonConfidentialCredits\";\n    Token2022Instruction2[Token2022Instruction2[\"ConfidentialTransferWithFee\"] = 45] = \"ConfidentialTransferWithFee\";\n    Token2022Instruction2[Token2022Instruction2[\"InitializeDefaultAccountState\"] = 46] = \"InitializeDefaultAccountState\";\n    Token2022Instruction2[Token2022Instruction2[\"UpdateDefaultAccountState\"] = 47] = \"UpdateDefaultAccountState\";\n    Token2022Instruction2[Token2022Instruction2[\"Reallocate\"] = 48] = \"Reallocate\";\n    Token2022Instruction2[Token2022Instruction2[\"EnableMemoTransfers\"] = 49] = \"EnableMemoTransfers\";\n    Token2022Instruction2[Token2022Instruction2[\"DisableMemoTransfers\"] = 50] = \"DisableMemoTransfers\";\n    Token2022Instruction2[Token2022Instruction2[\"CreateNativeMint\"] = 51] = \"CreateNativeMint\";\n    Token2022Instruction2[Token2022Instruction2[\"InitializeNonTransferableMint\"] = 52] = \"InitializeNonTransferableMint\";\n    Token2022Instruction2[Token2022Instruction2[\"InitializeInterestBearingMint\"] = 53] = \"InitializeInterestBearingMint\";\n    Token2022Instruction2[Token2022Instruction2[\"UpdateRateInterestBearingMint\"] = 54] = \"UpdateRateInterestBearingMint\";\n    Token2022Instruction2[Token2022Instruction2[\"EnableCpiGuard\"] = 55] = \"EnableCpiGuard\";\n    Token2022Instruction2[Token2022Instruction2[\"DisableCpiGuard\"] = 56] = \"DisableCpiGuard\";\n    Token2022Instruction2[Token2022Instruction2[\"InitializePermanentDelegate\"] = 57] = \"InitializePermanentDelegate\";\n    Token2022Instruction2[Token2022Instruction2[\"InitializeTransferHook\"] = 58] = \"InitializeTransferHook\";\n    Token2022Instruction2[Token2022Instruction2[\"UpdateTransferHook\"] = 59] = \"UpdateTransferHook\";\n    Token2022Instruction2[Token2022Instruction2[\"InitializeConfidentialTransferFee\"] = 60] = \"InitializeConfidentialTransferFee\";\n    Token2022Instruction2[Token2022Instruction2[\"WithdrawWithheldTokensFromMintForConfidentialTransferFee\"] = 61] = \"WithdrawWithheldTokensFromMintForConfidentialTransferFee\";\n    Token2022Instruction2[Token2022Instruction2[\"WithdrawWithheldTokensFromAccountsForConfidentialTransferFee\"] = 62] = \"WithdrawWithheldTokensFromAccountsForConfidentialTransferFee\";\n    Token2022Instruction2[Token2022Instruction2[\"HarvestWithheldTokensToMintForConfidentialTransferFee\"] = 63] = \"HarvestWithheldTokensToMintForConfidentialTransferFee\";\n    Token2022Instruction2[Token2022Instruction2[\"EnableHarvestToMint\"] = 64] = \"EnableHarvestToMint\";\n    Token2022Instruction2[Token2022Instruction2[\"DisableHarvestToMint\"] = 65] = \"DisableHarvestToMint\";\n    Token2022Instruction2[Token2022Instruction2[\"WithdrawExcessLamports\"] = 66] = \"WithdrawExcessLamports\";\n    Token2022Instruction2[Token2022Instruction2[\"InitializeMetadataPointer\"] = 67] = \"InitializeMetadataPointer\";\n    Token2022Instruction2[Token2022Instruction2[\"UpdateMetadataPointer\"] = 68] = \"UpdateMetadataPointer\";\n    Token2022Instruction2[Token2022Instruction2[\"InitializeGroupPointer\"] = 69] = \"InitializeGroupPointer\";\n    Token2022Instruction2[Token2022Instruction2[\"UpdateGroupPointer\"] = 70] = \"UpdateGroupPointer\";\n    Token2022Instruction2[Token2022Instruction2[\"InitializeGroupMemberPointer\"] = 71] = \"InitializeGroupMemberPointer\";\n    Token2022Instruction2[Token2022Instruction2[\"UpdateGroupMemberPointer\"] = 72] = \"UpdateGroupMemberPointer\";\n    Token2022Instruction2[Token2022Instruction2[\"InitializeScaledUiAmountMint\"] = 73] = \"InitializeScaledUiAmountMint\";\n    Token2022Instruction2[Token2022Instruction2[\"UpdateMultiplierScaledUiMint\"] = 74] = \"UpdateMultiplierScaledUiMint\";\n    Token2022Instruction2[Token2022Instruction2[\"InitializePausableConfig\"] = 75] = \"InitializePausableConfig\";\n    Token2022Instruction2[Token2022Instruction2[\"Pause\"] = 76] = \"Pause\";\n    Token2022Instruction2[Token2022Instruction2[\"Resume\"] = 77] = \"Resume\";\n    Token2022Instruction2[Token2022Instruction2[\"InitializeTokenMetadata\"] = 78] = \"InitializeTokenMetadata\";\n    Token2022Instruction2[Token2022Instruction2[\"UpdateTokenMetadataField\"] = 79] = \"UpdateTokenMetadataField\";\n    Token2022Instruction2[Token2022Instruction2[\"RemoveTokenMetadataKey\"] = 80] = \"RemoveTokenMetadataKey\";\n    Token2022Instruction2[Token2022Instruction2[\"UpdateTokenMetadataUpdateAuthority\"] = 81] = \"UpdateTokenMetadataUpdateAuthority\";\n    Token2022Instruction2[Token2022Instruction2[\"EmitTokenMetadata\"] = 82] = \"EmitTokenMetadata\";\n    Token2022Instruction2[Token2022Instruction2[\"InitializeTokenGroup\"] = 83] = \"InitializeTokenGroup\";\n    Token2022Instruction2[Token2022Instruction2[\"UpdateTokenGroupMaxSize\"] = 84] = \"UpdateTokenGroupMaxSize\";\n    Token2022Instruction2[Token2022Instruction2[\"UpdateTokenGroupUpdateAuthority\"] = 85] = \"UpdateTokenGroupUpdateAuthority\";\n    Token2022Instruction2[Token2022Instruction2[\"InitializeTokenGroupMember\"] = 86] = \"InitializeTokenGroupMember\";\n    return Token2022Instruction2;\n})($c5679bb0a1fb1418$export$3559bd77d1c508e9 || {});\nfunction $c5679bb0a1fb1418$export$86f08ee65792f9c6(instruction) {\n    const data = \"data\" in instruction ? instruction.data : instruction;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(0), 0)) return 0 /* InitializeMint */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(1), 0)) return 1 /* InitializeAccount */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(2), 0)) return 2 /* InitializeMultisig */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(3), 0)) return 3 /* Transfer */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(4), 0)) return 4 /* Approve */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(5), 0)) return 5 /* Revoke */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(6), 0)) return 6 /* SetAuthority */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(7), 0)) return 7 /* MintTo */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(8), 0)) return 8 /* Burn */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(9), 0)) return 9 /* CloseAccount */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(10), 0)) return 10 /* FreezeAccount */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(11), 0)) return 11 /* ThawAccount */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(12), 0)) return 12 /* TransferChecked */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(13), 0)) return 13 /* ApproveChecked */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(14), 0)) return 14 /* MintToChecked */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(15), 0)) return 15 /* BurnChecked */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(16), 0)) return 16 /* InitializeAccount2 */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(17), 0)) return 17 /* SyncNative */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(18), 0)) return 18 /* InitializeAccount3 */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(19), 0)) return 19 /* InitializeMultisig2 */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(20), 0)) return 20 /* InitializeMint2 */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(21), 0)) return 21 /* GetAccountDataSize */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(22), 0)) return 22 /* InitializeImmutableOwner */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(23), 0)) return 23 /* AmountToUiAmount */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(24), 0)) return 24 /* UiAmountToAmount */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(25), 0)) return 25 /* InitializeMintCloseAuthority */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(26), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(0), 1)) return 26 /* InitializeTransferFeeConfig */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(26), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(1), 1)) return 27 /* TransferCheckedWithFee */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(26), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(2), 1)) return 28 /* WithdrawWithheldTokensFromMint */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(26), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(3), 1)) return 29 /* WithdrawWithheldTokensFromAccounts */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(26), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(4), 1)) return 30 /* HarvestWithheldTokensToMint */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(26), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(5), 1)) return 31 /* SetTransferFee */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(27), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(0), 1)) return 32 /* InitializeConfidentialTransferMint */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(27), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(1), 1)) return 33 /* UpdateConfidentialTransferMint */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(27), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(2), 1)) return 34 /* ConfigureConfidentialTransferAccount */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(27), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(3), 1)) return 35 /* ApproveConfidentialTransferAccount */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(27), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(4), 1)) return 36 /* EmptyConfidentialTransferAccount */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(27), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(5), 1)) return 37 /* ConfidentialDeposit */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(27), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(6), 1)) return 38 /* ConfidentialWithdraw */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(27), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(7), 1)) return 39 /* ConfidentialTransfer */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(27), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(8), 1)) return 40 /* ApplyConfidentialPendingBalance */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(27), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(9), 1)) return 41 /* EnableConfidentialCredits */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(27), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(10), 1)) return 42 /* DisableConfidentialCredits */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(27), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(11), 1)) return 43 /* EnableNonConfidentialCredits */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(27), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(12), 1)) return 44 /* DisableNonConfidentialCredits */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(27), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(13), 1)) return 45 /* ConfidentialTransferWithFee */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(28), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(0), 1)) return 46 /* InitializeDefaultAccountState */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(28), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(1), 1)) return 47 /* UpdateDefaultAccountState */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(29), 0)) return 48 /* Reallocate */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(30), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(0), 1)) return 49 /* EnableMemoTransfers */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(30), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(1), 1)) return 50 /* DisableMemoTransfers */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(31), 0)) return 51 /* CreateNativeMint */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(32), 0)) return 52 /* InitializeNonTransferableMint */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(33), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(0), 1)) return 53 /* InitializeInterestBearingMint */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(33), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(1), 1)) return 54 /* UpdateRateInterestBearingMint */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(34), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(0), 1)) return 55 /* EnableCpiGuard */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(34), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(1), 1)) return 56 /* DisableCpiGuard */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(35), 0)) return 57 /* InitializePermanentDelegate */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(36), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(0), 1)) return 58 /* InitializeTransferHook */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(36), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(1), 1)) return 59 /* UpdateTransferHook */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(37), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(0), 1)) return 60 /* InitializeConfidentialTransferFee */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(37), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(1), 1)) return 61 /* WithdrawWithheldTokensFromMintForConfidentialTransferFee */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(37), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(2), 1)) return 62 /* WithdrawWithheldTokensFromAccountsForConfidentialTransferFee */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(37), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(3), 1)) return 63 /* HarvestWithheldTokensToMintForConfidentialTransferFee */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(37), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(4), 1)) return 64 /* EnableHarvestToMint */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(37), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(5), 1)) return 65 /* DisableHarvestToMint */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(38), 0)) return 66 /* WithdrawExcessLamports */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(39), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(0), 1)) return 67 /* InitializeMetadataPointer */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(39), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(1), 1)) return 68 /* UpdateMetadataPointer */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(40), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(0), 1)) return 69 /* InitializeGroupPointer */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(40), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(1), 1)) return 70 /* UpdateGroupPointer */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(41), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(0), 1)) return 71 /* InitializeGroupMemberPointer */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(41), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(1), 1)) return 72 /* UpdateGroupMemberPointer */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(43), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(0), 1)) return 73 /* InitializeScaledUiAmountMint */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(43), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(1), 1)) return 74 /* UpdateMultiplierScaledUiMint */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(44), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(0), 1)) return 75 /* InitializePausableConfig */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(44), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(1), 1)) return 76 /* Pause */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(44), 0) && (0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(2), 1)) return 77 /* Resume */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, new Uint8Array([\n        210,\n        225,\n        30,\n        162,\n        88,\n        184,\n        77,\n        141\n    ]), 0)) return 78 /* InitializeTokenMetadata */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, new Uint8Array([\n        221,\n        233,\n        49,\n        45,\n        181,\n        202,\n        220,\n        200\n    ]), 0)) return 79 /* UpdateTokenMetadataField */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, new Uint8Array([\n        234,\n        18,\n        32,\n        56,\n        89,\n        141,\n        37,\n        181\n    ]), 0)) return 80 /* RemoveTokenMetadataKey */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, new Uint8Array([\n        215,\n        228,\n        166,\n        228,\n        84,\n        100,\n        86,\n        123\n    ]), 0)) return 81 /* UpdateTokenMetadataUpdateAuthority */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, new Uint8Array([\n        250,\n        166,\n        180,\n        250,\n        13,\n        12,\n        184,\n        70\n    ]), 0)) return 82 /* EmitTokenMetadata */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, new Uint8Array([\n        121,\n        113,\n        108,\n        39,\n        54,\n        51,\n        0,\n        4\n    ]), 0)) return 83 /* InitializeTokenGroup */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, new Uint8Array([\n        108,\n        37,\n        171,\n        143,\n        248,\n        30,\n        18,\n        110\n    ]), 0)) return 84 /* UpdateTokenGroupMaxSize */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, new Uint8Array([\n        161,\n        105,\n        88,\n        1,\n        237,\n        221,\n        216,\n        203\n    ]), 0)) return 85 /* UpdateTokenGroupUpdateAuthority */ ;\n    if ((0, $b9bc3aaa401ff82b$export$1b62aef2a79e6b21)(data, new Uint8Array([\n        152,\n        32,\n        222,\n        176,\n        223,\n        237,\n        116,\n        134\n    ]), 0)) return 86 /* InitializeTokenGroupMember */ ;\n    throw new Error(\"The provided instruction could not be identified as a token-2022 instruction.\");\n}\n// src/generated/errors/associatedToken.ts\nvar $c5679bb0a1fb1418$export$c14b93c434a7df8e = 0;\nvar $c5679bb0a1fb1418$var$associatedTokenErrorMessages;\nfunction $c5679bb0a1fb1418$export$9e84666824b5f043(code) {\n    return \"Error message not available in production bundles.\";\n}\nfunction $c5679bb0a1fb1418$export$65903b9550674e09(error, transactionMessage, code) {\n    return (0, $d0aa1aba7ff24d28$export$868b481be3894762)(error, transactionMessage, $c5679bb0a1fb1418$export$97ae793257bad8ba, code);\n}\nvar $c5679bb0a1fb1418$export$484e8b0c2e1b2791 = 0;\nvar $c5679bb0a1fb1418$export$606ca1ffbbb999ae = 1;\nvar $c5679bb0a1fb1418$export$cb7fc67706a21e3f = 2;\nvar $c5679bb0a1fb1418$export$ae76b9c51ea61d37 = 3;\nvar $c5679bb0a1fb1418$export$693cca57a8c6b24c = 4;\nvar $c5679bb0a1fb1418$export$93df9b2caab406ab = 5;\nvar $c5679bb0a1fb1418$export$6930346b47e02fa9 = 6;\nvar $c5679bb0a1fb1418$export$31c7445c5b7e61ba = 7;\nvar $c5679bb0a1fb1418$export$d580fed199cfa8f4 = 8;\nvar $c5679bb0a1fb1418$export$67900b2fe33aab86 = 9;\nvar $c5679bb0a1fb1418$export$4a2280e7202121ba = 10;\nvar $c5679bb0a1fb1418$export$5432f9b1eabe627a = 11;\nvar $c5679bb0a1fb1418$export$3312412d54496148 = 12;\nvar $c5679bb0a1fb1418$export$4da84bdc09ff6eb3 = 13;\nvar $c5679bb0a1fb1418$export$67e26be50dc8aaae = 14;\nvar $c5679bb0a1fb1418$export$cd8983d4cc6db58d = 15;\nvar $c5679bb0a1fb1418$export$7f5dc5d75fe3fd2d = 16;\nvar $c5679bb0a1fb1418$export$f165c89fd9643b9c = 17;\nvar $c5679bb0a1fb1418$export$11f1870296ae5514 = 18;\nvar $c5679bb0a1fb1418$export$f98d30240786a9b = 19;\nvar $c5679bb0a1fb1418$var$token2022ErrorMessages;\nfunction $c5679bb0a1fb1418$export$3c3f017a59f2f912(code) {\n    return \"Error message not available in production bundles.\";\n}\nfunction $c5679bb0a1fb1418$export$2ac24d513d6fb18d(error, transactionMessage, code) {\n    return (0, $d0aa1aba7ff24d28$export$868b481be3894762)(error, transactionMessage, $c5679bb0a1fb1418$export$69a22f9c8498afc2, code);\n}\nfunction $c5679bb0a1fb1418$var$expectAddress(value) {\n    if (!value) throw new Error(\"Expected a Address.\");\n    if (typeof value === \"object\" && \"address\" in value) return value.address;\n    if (Array.isArray(value)) return value[0];\n    return value;\n}\nfunction $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress, optionalAccountStrategy) {\n    return (account)=>{\n        if (!account.value) return Object.freeze({\n            address: programAddress,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY\n        });\n        const writableRole = account.isWritable ? (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).WRITABLE : (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY;\n        return Object.freeze({\n            address: $c5679bb0a1fb1418$var$expectAddress(account.value),\n            role: $c5679bb0a1fb1418$var$isTransactionSigner(account.value) ? (0, $bc6d449c2ea12356$export$1b6e630330d6ac34)(writableRole) : writableRole,\n            ...$c5679bb0a1fb1418$var$isTransactionSigner(account.value) ? {\n                signer: account.value\n            } : {}\n        });\n    };\n}\nfunction $c5679bb0a1fb1418$var$isTransactionSigner(value) {\n    return !!value && typeof value === \"object\" && \"address\" in value && (0, $433f7983d96e2c09$export$45e3afa456b0ef0e)(value);\n}\n// src/generated/instructions/amountToUiAmount.ts\nvar $c5679bb0a1fb1418$export$990f6008f1320f95 = 23;\nfunction $c5679bb0a1fb1418$export$9e229383968e994() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$990f6008f1320f95);\n}\nfunction $c5679bb0a1fb1418$export$fb20727ed8fd2b65() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$990f6008f1320f95\n        }));\n}\nfunction $c5679bb0a1fb1418$export$7c153de6935d5ef5() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$15d7aa51dd8e2326() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$fb20727ed8fd2b65(), $c5679bb0a1fb1418$export$7c153de6935d5ef5());\n}\nfunction $c5679bb0a1fb1418$export$d4b91f1f10dad3b4(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint)\n        ],\n        data: $c5679bb0a1fb1418$export$fb20727ed8fd2b65().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$e79c20997af315a7(instruction) {\n    if (instruction.accounts.length < 1) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$7c153de6935d5ef5().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$53704acba6f09ba1 = 27;\nfunction $c5679bb0a1fb1418$export$f491f5e2b83ade2() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$53704acba6f09ba1);\n}\nvar $c5679bb0a1fb1418$export$bbeee1276a815996 = 8;\nfunction $c5679bb0a1fb1418$export$8209bf5af797ecb3() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$bbeee1276a815996);\n}\nfunction $c5679bb0a1fb1418$export$6ef44a7e3e3a5906() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"expectedPendingBalanceCreditCounter\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ],\n        [\n            \"newDecryptableAvailableBalance\",\n            $c5679bb0a1fb1418$export$81b4437e7425f22a()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$53704acba6f09ba1,\n            confidentialTransferDiscriminator: $c5679bb0a1fb1418$export$bbeee1276a815996\n        }));\n}\nfunction $c5679bb0a1fb1418$export$b636dd2632e952e1() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"expectedPendingBalanceCreditCounter\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ],\n        [\n            \"newDecryptableAvailableBalance\",\n            $c5679bb0a1fb1418$export$2dde3d52f3fe8173()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$dda8977db23acbcd() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$6ef44a7e3e3a5906(), $c5679bb0a1fb1418$export$b636dd2632e952e1());\n}\nfunction $c5679bb0a1fb1418$export$eee2734845f4549f(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        token: {\n            value: input.token ?? null,\n            isWritable: true\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.token),\n            getAccountMeta(accounts.authority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$6ef44a7e3e3a5906().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$5bb5ecf0c81b5692(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            token: getNextAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$b636dd2632e952e1().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$395913de6ab54171 = 4;\nfunction $c5679bb0a1fb1418$export$98e6779092d9a66c() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$395913de6ab54171);\n}\nfunction $c5679bb0a1fb1418$export$fb9bf051ac1601bb() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$395913de6ab54171\n        }));\n}\nfunction $c5679bb0a1fb1418$export$721e2aa6355140f7() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$3a4ffd4525b71661() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$fb9bf051ac1601bb(), $c5679bb0a1fb1418$export$721e2aa6355140f7());\n}\nfunction $c5679bb0a1fb1418$export$6921e06fc2ace176(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        source: {\n            value: input.source ?? null,\n            isWritable: true\n        },\n        delegate: {\n            value: input.delegate ?? null,\n            isWritable: false\n        },\n        owner: {\n            value: input.owner ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.source),\n            getAccountMeta(accounts.delegate),\n            getAccountMeta(accounts.owner),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$fb9bf051ac1601bb().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$5748f7f5ad040fa9(instruction) {\n    if (instruction.accounts.length < 3) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            source: getNextAccount(),\n            delegate: getNextAccount(),\n            owner: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$721e2aa6355140f7().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$1bd4d69cd2abeb48 = 13;\nfunction $c5679bb0a1fb1418$export$c40a225a83a789ac() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$1bd4d69cd2abeb48);\n}\nfunction $c5679bb0a1fb1418$export$292783efce23e833() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ],\n        [\n            \"decimals\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$1bd4d69cd2abeb48\n        }));\n}\nfunction $c5679bb0a1fb1418$export$932dac36e8e08bca() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ],\n        [\n            \"decimals\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$e536a755193737c9() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$292783efce23e833(), $c5679bb0a1fb1418$export$932dac36e8e08bca());\n}\nfunction $c5679bb0a1fb1418$export$ba27236ad0fbafad(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        source: {\n            value: input.source ?? null,\n            isWritable: true\n        },\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        },\n        delegate: {\n            value: input.delegate ?? null,\n            isWritable: false\n        },\n        owner: {\n            value: input.owner ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.source),\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.delegate),\n            getAccountMeta(accounts.owner),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$292783efce23e833().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$7d2212583846bd56(instruction) {\n    if (instruction.accounts.length < 4) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            source: getNextAccount(),\n            mint: getNextAccount(),\n            delegate: getNextAccount(),\n            owner: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$932dac36e8e08bca().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$a9a41dd81166de1c = 27;\nfunction $c5679bb0a1fb1418$export$2fc69d6bee0b5c92() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$a9a41dd81166de1c);\n}\nvar $c5679bb0a1fb1418$export$e309ad10efd320ff = 3;\nfunction $c5679bb0a1fb1418$export$fb6fbd5f83003327() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$e309ad10efd320ff);\n}\nfunction $c5679bb0a1fb1418$export$1de46dd1c7adb18a() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$a9a41dd81166de1c,\n            confidentialTransferDiscriminator: $c5679bb0a1fb1418$export$e309ad10efd320ff\n        }));\n}\nfunction $c5679bb0a1fb1418$export$16c6e7323a7a6128() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$918da764ac710177() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$1de46dd1c7adb18a(), $c5679bb0a1fb1418$export$16c6e7323a7a6128());\n}\nfunction $c5679bb0a1fb1418$export$a15d1d8c4b93b397(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        token: {\n            value: input.token ?? null,\n            isWritable: true\n        },\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.token),\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.authority)\n        ],\n        data: $c5679bb0a1fb1418$export$1de46dd1c7adb18a().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$47c2c04580880cee(instruction) {\n    if (instruction.accounts.length < 3) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            token: getNextAccount(),\n            mint: getNextAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$16c6e7323a7a6128().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$e2f4028928a3eb03 = 8;\nfunction $c5679bb0a1fb1418$export$31214411534118ef() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$e2f4028928a3eb03);\n}\nfunction $c5679bb0a1fb1418$export$48e1eeec96d122ef() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$e2f4028928a3eb03\n        }));\n}\nfunction $c5679bb0a1fb1418$export$956c0b671f5c1615() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$93d053a64568d294() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$48e1eeec96d122ef(), $c5679bb0a1fb1418$export$956c0b671f5c1615());\n}\nfunction $c5679bb0a1fb1418$export$187967851fc7cc93(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        account: {\n            value: input.account ?? null,\n            isWritable: true\n        },\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.account),\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.authority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$48e1eeec96d122ef().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$98f13e8582301494(instruction) {\n    if (instruction.accounts.length < 3) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            account: getNextAccount(),\n            mint: getNextAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$956c0b671f5c1615().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$19a373740ce10d26 = 15;\nfunction $c5679bb0a1fb1418$export$d3bb1e733c620cd5() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$19a373740ce10d26);\n}\nfunction $c5679bb0a1fb1418$export$38abcad69f53137b() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ],\n        [\n            \"decimals\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$19a373740ce10d26\n        }));\n}\nfunction $c5679bb0a1fb1418$export$ac9045698eae9454() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ],\n        [\n            \"decimals\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$36ba703d7fe4adeb() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$38abcad69f53137b(), $c5679bb0a1fb1418$export$ac9045698eae9454());\n}\nfunction $c5679bb0a1fb1418$export$3a397b7650cf76cf(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        account: {\n            value: input.account ?? null,\n            isWritable: true\n        },\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.account),\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.authority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$38abcad69f53137b().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$4c8ee80f058c1d7b(instruction) {\n    if (instruction.accounts.length < 3) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            account: getNextAccount(),\n            mint: getNextAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$ac9045698eae9454().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$ec105e6c6f02f514 = 9;\nfunction $c5679bb0a1fb1418$export$f936bb3ffc9c0a65() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$ec105e6c6f02f514);\n}\nfunction $c5679bb0a1fb1418$export$b6e176f5533f1f0d() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$ec105e6c6f02f514\n        }));\n}\nfunction $c5679bb0a1fb1418$export$9e1d34bee5f5d282() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$432693b9857f41d2() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$b6e176f5533f1f0d(), $c5679bb0a1fb1418$export$9e1d34bee5f5d282());\n}\nfunction $c5679bb0a1fb1418$export$e9a96f6ced4e92f0(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        account: {\n            value: input.account ?? null,\n            isWritable: true\n        },\n        destination: {\n            value: input.destination ?? null,\n            isWritable: true\n        },\n        owner: {\n            value: input.owner ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.account),\n            getAccountMeta(accounts.destination),\n            getAccountMeta(accounts.owner),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$b6e176f5533f1f0d().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$22dc7ebeed90a769(instruction) {\n    if (instruction.accounts.length < 3) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            account: getNextAccount(),\n            destination: getNextAccount(),\n            owner: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$9e1d34bee5f5d282().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$6bce98a8f7ab7c9a = 27;\nfunction $c5679bb0a1fb1418$export$4864ae5fd26e3341() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$6bce98a8f7ab7c9a);\n}\nvar $c5679bb0a1fb1418$export$252e3385bb5ef618 = 5;\nfunction $c5679bb0a1fb1418$export$64c4ebef0c2d49cd() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$252e3385bb5ef618);\n}\nfunction $c5679bb0a1fb1418$export$5eea03081d94a2f0() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ],\n        [\n            \"decimals\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$6bce98a8f7ab7c9a,\n            confidentialTransferDiscriminator: $c5679bb0a1fb1418$export$252e3385bb5ef618\n        }));\n}\nfunction $c5679bb0a1fb1418$export$a0db05801e761ba() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ],\n        [\n            \"decimals\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$c21be3c72a2a6ade() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$5eea03081d94a2f0(), $c5679bb0a1fb1418$export$a0db05801e761ba());\n}\nfunction $c5679bb0a1fb1418$export$77b6f2430e0b00b6(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        token: {\n            value: input.token ?? null,\n            isWritable: true\n        },\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.token),\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.authority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$5eea03081d94a2f0().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$f3a73079df55f19a(instruction) {\n    if (instruction.accounts.length < 3) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            token: getNextAccount(),\n            mint: getNextAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$a0db05801e761ba().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$22d50a52135749f6 = 27;\nfunction $c5679bb0a1fb1418$export$ad158760ebb22dff() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$22d50a52135749f6);\n}\nvar $c5679bb0a1fb1418$export$9de283e5906ebaac = 7;\nfunction $c5679bb0a1fb1418$export$58c3897120645b63() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$9de283e5906ebaac);\n}\nfunction $c5679bb0a1fb1418$export$80b4f36bc5f2589f() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"newSourceDecryptableAvailableBalance\",\n            $c5679bb0a1fb1418$export$81b4437e7425f22a()\n        ],\n        [\n            \"equalityProofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$44792a8c35b3c0ce)()\n        ],\n        [\n            \"ciphertextValidityProofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$44792a8c35b3c0ce)()\n        ],\n        [\n            \"rangeProofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$44792a8c35b3c0ce)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$22d50a52135749f6,\n            confidentialTransferDiscriminator: $c5679bb0a1fb1418$export$9de283e5906ebaac\n        }));\n}\nfunction $c5679bb0a1fb1418$export$ef5eba2e7eec67f0() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"newSourceDecryptableAvailableBalance\",\n            $c5679bb0a1fb1418$export$2dde3d52f3fe8173()\n        ],\n        [\n            \"equalityProofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$fdc22c4a59dfe6be)()\n        ],\n        [\n            \"ciphertextValidityProofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$fdc22c4a59dfe6be)()\n        ],\n        [\n            \"rangeProofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$fdc22c4a59dfe6be)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$5ec786a635fd444a() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$80b4f36bc5f2589f(), $c5679bb0a1fb1418$export$ef5eba2e7eec67f0());\n}\nfunction $c5679bb0a1fb1418$export$1327335aeeabb10(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        sourceToken: {\n            value: input.sourceToken ?? null,\n            isWritable: true\n        },\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        },\n        destinationToken: {\n            value: input.destinationToken ?? null,\n            isWritable: true\n        },\n        instructionsSysvar: {\n            value: input.instructionsSysvar ?? null,\n            isWritable: false\n        },\n        equalityRecord: {\n            value: input.equalityRecord ?? null,\n            isWritable: false\n        },\n        ciphertextValidityRecord: {\n            value: input.ciphertextValidityRecord ?? null,\n            isWritable: false\n        },\n        rangeRecord: {\n            value: input.rangeRecord ?? null,\n            isWritable: false\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.sourceToken),\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.destinationToken),\n            getAccountMeta(accounts.instructionsSysvar),\n            getAccountMeta(accounts.equalityRecord),\n            getAccountMeta(accounts.ciphertextValidityRecord),\n            getAccountMeta(accounts.rangeRecord),\n            getAccountMeta(accounts.authority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$80b4f36bc5f2589f().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$f2b17f5c09ed30(instruction) {\n    if (instruction.accounts.length < 8) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    const getNextOptionalAccount = ()=>{\n        const accountMeta = getNextAccount();\n        return accountMeta.address === $c5679bb0a1fb1418$export$69a22f9c8498afc2 ? void 0 : accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            sourceToken: getNextAccount(),\n            mint: getNextAccount(),\n            destinationToken: getNextAccount(),\n            instructionsSysvar: getNextOptionalAccount(),\n            equalityRecord: getNextOptionalAccount(),\n            ciphertextValidityRecord: getNextOptionalAccount(),\n            rangeRecord: getNextOptionalAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$ef5eba2e7eec67f0().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$930bc7b85a0f25a6 = 27;\nfunction $c5679bb0a1fb1418$export$c6f7b744142d19b5() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$930bc7b85a0f25a6);\n}\nvar $c5679bb0a1fb1418$export$1e2ae83c61b8db36 = 13;\nfunction $c5679bb0a1fb1418$export$4b7f19c04eff5f9f() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$1e2ae83c61b8db36);\n}\nfunction $c5679bb0a1fb1418$export$cc8c8438b2389070() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"newSourceDecryptableAvailableBalance\",\n            $c5679bb0a1fb1418$export$81b4437e7425f22a()\n        ],\n        [\n            \"equalityProofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$44792a8c35b3c0ce)()\n        ],\n        [\n            \"transferAmountCiphertextValidityProofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$44792a8c35b3c0ce)()\n        ],\n        [\n            \"feeSigmaProofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$44792a8c35b3c0ce)()\n        ],\n        [\n            \"feeCiphertextValidityProofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$44792a8c35b3c0ce)()\n        ],\n        [\n            \"rangeProofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$44792a8c35b3c0ce)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$930bc7b85a0f25a6,\n            confidentialTransferDiscriminator: $c5679bb0a1fb1418$export$1e2ae83c61b8db36\n        }));\n}\nfunction $c5679bb0a1fb1418$export$8796935240813963() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"newSourceDecryptableAvailableBalance\",\n            $c5679bb0a1fb1418$export$2dde3d52f3fe8173()\n        ],\n        [\n            \"equalityProofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$fdc22c4a59dfe6be)()\n        ],\n        [\n            \"transferAmountCiphertextValidityProofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$fdc22c4a59dfe6be)()\n        ],\n        [\n            \"feeSigmaProofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$fdc22c4a59dfe6be)()\n        ],\n        [\n            \"feeCiphertextValidityProofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$fdc22c4a59dfe6be)()\n        ],\n        [\n            \"rangeProofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$fdc22c4a59dfe6be)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$9ef9391740743ad2() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$cc8c8438b2389070(), $c5679bb0a1fb1418$export$8796935240813963());\n}\nfunction $c5679bb0a1fb1418$export$3fa8d4599dd3c90d(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        sourceToken: {\n            value: input.sourceToken ?? null,\n            isWritable: true\n        },\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        },\n        destinationToken: {\n            value: input.destinationToken ?? null,\n            isWritable: true\n        },\n        instructionsSysvar: {\n            value: input.instructionsSysvar ?? null,\n            isWritable: false\n        },\n        equalityRecord: {\n            value: input.equalityRecord ?? null,\n            isWritable: false\n        },\n        transferAmountCiphertextValidityRecord: {\n            value: input.transferAmountCiphertextValidityRecord ?? null,\n            isWritable: false\n        },\n        feeSigmaRecord: {\n            value: input.feeSigmaRecord ?? null,\n            isWritable: false\n        },\n        feeCiphertextValidityRecord: {\n            value: input.feeCiphertextValidityRecord ?? null,\n            isWritable: false\n        },\n        rangeRecord: {\n            value: input.rangeRecord ?? null,\n            isWritable: false\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.sourceToken),\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.destinationToken),\n            getAccountMeta(accounts.instructionsSysvar),\n            getAccountMeta(accounts.equalityRecord),\n            getAccountMeta(accounts.transferAmountCiphertextValidityRecord),\n            getAccountMeta(accounts.feeSigmaRecord),\n            getAccountMeta(accounts.feeCiphertextValidityRecord),\n            getAccountMeta(accounts.rangeRecord),\n            getAccountMeta(accounts.authority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$cc8c8438b2389070().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$c442fc72a3af80a1(instruction) {\n    if (instruction.accounts.length < 10) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    const getNextOptionalAccount = ()=>{\n        const accountMeta = getNextAccount();\n        return accountMeta.address === $c5679bb0a1fb1418$export$69a22f9c8498afc2 ? void 0 : accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            sourceToken: getNextAccount(),\n            mint: getNextAccount(),\n            destinationToken: getNextAccount(),\n            instructionsSysvar: getNextOptionalAccount(),\n            equalityRecord: getNextOptionalAccount(),\n            transferAmountCiphertextValidityRecord: getNextOptionalAccount(),\n            feeSigmaRecord: getNextOptionalAccount(),\n            feeCiphertextValidityRecord: getNextOptionalAccount(),\n            rangeRecord: getNextOptionalAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$8796935240813963().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$1ad03a4822e07353 = 27;\nfunction $c5679bb0a1fb1418$export$4d521c9ebc7cbe6d() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$1ad03a4822e07353);\n}\nvar $c5679bb0a1fb1418$export$6ffb9d6c1ab99171 = 6;\nfunction $c5679bb0a1fb1418$export$a586c23f364f3750() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$6ffb9d6c1ab99171);\n}\nfunction $c5679bb0a1fb1418$export$8da5755c1d34718f() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ],\n        [\n            \"decimals\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"newDecryptableAvailableBalance\",\n            $c5679bb0a1fb1418$export$81b4437e7425f22a()\n        ],\n        [\n            \"equalityProofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$44792a8c35b3c0ce)()\n        ],\n        [\n            \"rangeProofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$44792a8c35b3c0ce)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$1ad03a4822e07353,\n            confidentialTransferDiscriminator: $c5679bb0a1fb1418$export$6ffb9d6c1ab99171\n        }));\n}\nfunction $c5679bb0a1fb1418$export$65843b6527d6e136() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ],\n        [\n            \"decimals\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"newDecryptableAvailableBalance\",\n            $c5679bb0a1fb1418$export$2dde3d52f3fe8173()\n        ],\n        [\n            \"equalityProofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$fdc22c4a59dfe6be)()\n        ],\n        [\n            \"rangeProofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$fdc22c4a59dfe6be)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$1398d45fbedba2ad() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$8da5755c1d34718f(), $c5679bb0a1fb1418$export$65843b6527d6e136());\n}\nfunction $c5679bb0a1fb1418$export$88426185b5764134(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        token: {\n            value: input.token ?? null,\n            isWritable: true\n        },\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        },\n        instructionsSysvar: {\n            value: input.instructionsSysvar ?? null,\n            isWritable: false\n        },\n        equalityRecord: {\n            value: input.equalityRecord ?? null,\n            isWritable: false\n        },\n        rangeRecord: {\n            value: input.rangeRecord ?? null,\n            isWritable: false\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.token),\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.instructionsSysvar),\n            getAccountMeta(accounts.equalityRecord),\n            getAccountMeta(accounts.rangeRecord),\n            getAccountMeta(accounts.authority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$8da5755c1d34718f().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$d25d9f3075b894cd(instruction) {\n    if (instruction.accounts.length < 6) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    const getNextOptionalAccount = ()=>{\n        const accountMeta = getNextAccount();\n        return accountMeta.address === $c5679bb0a1fb1418$export$69a22f9c8498afc2 ? void 0 : accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            token: getNextAccount(),\n            mint: getNextAccount(),\n            instructionsSysvar: getNextOptionalAccount(),\n            equalityRecord: getNextOptionalAccount(),\n            rangeRecord: getNextOptionalAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$65843b6527d6e136().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$4ddd663f8bff58a = 27;\nfunction $c5679bb0a1fb1418$export$9365e9f31d9a1332() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$4ddd663f8bff58a);\n}\nvar $c5679bb0a1fb1418$export$f224c0383bd4dbb6 = 2;\nfunction $c5679bb0a1fb1418$export$a123af87d9076871() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$f224c0383bd4dbb6);\n}\nfunction $c5679bb0a1fb1418$export$2ea1cd7130d4b38b() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"decryptableZeroBalance\",\n            $c5679bb0a1fb1418$export$81b4437e7425f22a()\n        ],\n        [\n            \"maximumPendingBalanceCreditCounter\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ],\n        [\n            \"proofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$44792a8c35b3c0ce)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$4ddd663f8bff58a,\n            confidentialTransferDiscriminator: $c5679bb0a1fb1418$export$f224c0383bd4dbb6\n        }));\n}\nfunction $c5679bb0a1fb1418$export$983b04f54f18022a() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"decryptableZeroBalance\",\n            $c5679bb0a1fb1418$export$2dde3d52f3fe8173()\n        ],\n        [\n            \"maximumPendingBalanceCreditCounter\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ],\n        [\n            \"proofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$fdc22c4a59dfe6be)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$a390a7b49e483a66() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$2ea1cd7130d4b38b(), $c5679bb0a1fb1418$export$983b04f54f18022a());\n}\nfunction $c5679bb0a1fb1418$export$a31a0cae65d95a95(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        token: {\n            value: input.token ?? null,\n            isWritable: true\n        },\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        },\n        instructionsSysvarOrContextState: {\n            value: input.instructionsSysvarOrContextState ?? null,\n            isWritable: false\n        },\n        record: {\n            value: input.record ?? null,\n            isWritable: false\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    if (!accounts.instructionsSysvarOrContextState.value) accounts.instructionsSysvarOrContextState.value = \"Sysvar1nstructions1111111111111111111111111\";\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.token),\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.instructionsSysvarOrContextState),\n            getAccountMeta(accounts.record),\n            getAccountMeta(accounts.authority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$2ea1cd7130d4b38b().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$c954ba416ed79ff1(instruction) {\n    if (instruction.accounts.length < 5) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    const getNextOptionalAccount = ()=>{\n        const accountMeta = getNextAccount();\n        return accountMeta.address === $c5679bb0a1fb1418$export$69a22f9c8498afc2 ? void 0 : accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            token: getNextAccount(),\n            mint: getNextAccount(),\n            instructionsSysvarOrContextState: getNextAccount(),\n            record: getNextOptionalAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$983b04f54f18022a().decode(instruction.data)\n    };\n}\nasync function $c5679bb0a1fb1418$export$261fb6f487940719(seeds, config = {}) {\n    const { programAddress: programAddress = \"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\" } = config;\n    return await (0, $fadd3f4c7539d2fa$export$4e565ad19ba445b)({\n        programAddress: programAddress,\n        seeds: [\n            (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)().encode(seeds.owner),\n            (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)().encode(seeds.tokenProgram),\n            (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)().encode(seeds.mint)\n        ]\n    });\n}\n// src/generated/instructions/createAssociatedToken.ts\nvar $c5679bb0a1fb1418$export$b090aed62d28afb8 = 0;\nfunction $c5679bb0a1fb1418$export$d3eb0aa6eba1b39() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$b090aed62d28afb8);\n}\nfunction $c5679bb0a1fb1418$export$b97a0d2934780b61() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$b090aed62d28afb8\n        }));\n}\nfunction $c5679bb0a1fb1418$export$fdf56715eee5c8c2() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$eb6607bf690c8945() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$b97a0d2934780b61(), $c5679bb0a1fb1418$export$fdf56715eee5c8c2());\n}\nasync function $c5679bb0a1fb1418$export$bfb84fb6a4b1aa90(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$97ae793257bad8ba;\n    const originalAccounts = {\n        payer: {\n            value: input.payer ?? null,\n            isWritable: true\n        },\n        ata: {\n            value: input.ata ?? null,\n            isWritable: true\n        },\n        owner: {\n            value: input.owner ?? null,\n            isWritable: false\n        },\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        },\n        systemProgram: {\n            value: input.systemProgram ?? null,\n            isWritable: false\n        },\n        tokenProgram: {\n            value: input.tokenProgram ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    if (!accounts.tokenProgram.value) accounts.tokenProgram.value = \"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\";\n    if (!accounts.ata.value) accounts.ata.value = await $c5679bb0a1fb1418$export$261fb6f487940719({\n        owner: $c5679bb0a1fb1418$var$expectAddress(accounts.owner.value),\n        tokenProgram: $c5679bb0a1fb1418$var$expectAddress(accounts.tokenProgram.value),\n        mint: $c5679bb0a1fb1418$var$expectAddress(accounts.mint.value)\n    });\n    if (!accounts.systemProgram.value) accounts.systemProgram.value = \"11111111111111111111111111111111\";\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.payer),\n            getAccountMeta(accounts.ata),\n            getAccountMeta(accounts.owner),\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.systemProgram),\n            getAccountMeta(accounts.tokenProgram)\n        ],\n        data: $c5679bb0a1fb1418$export$b97a0d2934780b61().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$a862314a96737578(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$97ae793257bad8ba;\n    const originalAccounts = {\n        payer: {\n            value: input.payer ?? null,\n            isWritable: true\n        },\n        ata: {\n            value: input.ata ?? null,\n            isWritable: true\n        },\n        owner: {\n            value: input.owner ?? null,\n            isWritable: false\n        },\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        },\n        systemProgram: {\n            value: input.systemProgram ?? null,\n            isWritable: false\n        },\n        tokenProgram: {\n            value: input.tokenProgram ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    if (!accounts.tokenProgram.value) accounts.tokenProgram.value = \"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\";\n    if (!accounts.systemProgram.value) accounts.systemProgram.value = \"11111111111111111111111111111111\";\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.payer),\n            getAccountMeta(accounts.ata),\n            getAccountMeta(accounts.owner),\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.systemProgram),\n            getAccountMeta(accounts.tokenProgram)\n        ],\n        data: $c5679bb0a1fb1418$export$b97a0d2934780b61().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$68e3bd255351f3ba(instruction) {\n    if (instruction.accounts.length < 6) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            payer: getNextAccount(),\n            ata: getNextAccount(),\n            owner: getNextAccount(),\n            mint: getNextAccount(),\n            systemProgram: getNextAccount(),\n            tokenProgram: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$fdf56715eee5c8c2().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$e2d1a7229e4f269a = 1;\nfunction $c5679bb0a1fb1418$export$363ea0df17052aa4() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$e2d1a7229e4f269a);\n}\nfunction $c5679bb0a1fb1418$export$54e3de3491b8975e() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$e2d1a7229e4f269a\n        }));\n}\nfunction $c5679bb0a1fb1418$export$1e753c92e9ec34() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$845703366594f08a() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$54e3de3491b8975e(), $c5679bb0a1fb1418$export$1e753c92e9ec34());\n}\nasync function $c5679bb0a1fb1418$export$430c43c54af6f554(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$97ae793257bad8ba;\n    const originalAccounts = {\n        payer: {\n            value: input.payer ?? null,\n            isWritable: true\n        },\n        ata: {\n            value: input.ata ?? null,\n            isWritable: true\n        },\n        owner: {\n            value: input.owner ?? null,\n            isWritable: false\n        },\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        },\n        systemProgram: {\n            value: input.systemProgram ?? null,\n            isWritable: false\n        },\n        tokenProgram: {\n            value: input.tokenProgram ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    if (!accounts.tokenProgram.value) accounts.tokenProgram.value = \"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\";\n    if (!accounts.ata.value) accounts.ata.value = await $c5679bb0a1fb1418$export$261fb6f487940719({\n        owner: $c5679bb0a1fb1418$var$expectAddress(accounts.owner.value),\n        tokenProgram: $c5679bb0a1fb1418$var$expectAddress(accounts.tokenProgram.value),\n        mint: $c5679bb0a1fb1418$var$expectAddress(accounts.mint.value)\n    });\n    if (!accounts.systemProgram.value) accounts.systemProgram.value = \"11111111111111111111111111111111\";\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.payer),\n            getAccountMeta(accounts.ata),\n            getAccountMeta(accounts.owner),\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.systemProgram),\n            getAccountMeta(accounts.tokenProgram)\n        ],\n        data: $c5679bb0a1fb1418$export$54e3de3491b8975e().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$438a127b69b45bae(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$97ae793257bad8ba;\n    const originalAccounts = {\n        payer: {\n            value: input.payer ?? null,\n            isWritable: true\n        },\n        ata: {\n            value: input.ata ?? null,\n            isWritable: true\n        },\n        owner: {\n            value: input.owner ?? null,\n            isWritable: false\n        },\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        },\n        systemProgram: {\n            value: input.systemProgram ?? null,\n            isWritable: false\n        },\n        tokenProgram: {\n            value: input.tokenProgram ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    if (!accounts.tokenProgram.value) accounts.tokenProgram.value = \"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\";\n    if (!accounts.systemProgram.value) accounts.systemProgram.value = \"11111111111111111111111111111111\";\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.payer),\n            getAccountMeta(accounts.ata),\n            getAccountMeta(accounts.owner),\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.systemProgram),\n            getAccountMeta(accounts.tokenProgram)\n        ],\n        data: $c5679bb0a1fb1418$export$54e3de3491b8975e().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$ad1e4c34c6a07db7(instruction) {\n    if (instruction.accounts.length < 6) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            payer: getNextAccount(),\n            ata: getNextAccount(),\n            owner: getNextAccount(),\n            mint: getNextAccount(),\n            systemProgram: getNextAccount(),\n            tokenProgram: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$1e753c92e9ec34().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$716c76250764844d = 31;\nfunction $c5679bb0a1fb1418$export$fc7acf7303eea91d() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$716c76250764844d);\n}\nfunction $c5679bb0a1fb1418$export$a661da6d5b09cfeb() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$716c76250764844d\n        }));\n}\nfunction $c5679bb0a1fb1418$export$8e17ce2ddce4908f() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$81bd344b7c65f439() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$a661da6d5b09cfeb(), $c5679bb0a1fb1418$export$8e17ce2ddce4908f());\n}\nfunction $c5679bb0a1fb1418$export$8b891f4a3cb7ed3d(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        payer: {\n            value: input.payer ?? null,\n            isWritable: true\n        },\n        nativeMint: {\n            value: input.nativeMint ?? null,\n            isWritable: true\n        },\n        systemProgram: {\n            value: input.systemProgram ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    if (!accounts.systemProgram.value) accounts.systemProgram.value = \"11111111111111111111111111111111\";\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.payer),\n            getAccountMeta(accounts.nativeMint),\n            getAccountMeta(accounts.systemProgram)\n        ],\n        data: $c5679bb0a1fb1418$export$a661da6d5b09cfeb().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$4258ce356d4242e3(instruction) {\n    if (instruction.accounts.length < 3) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            payer: getNextAccount(),\n            nativeMint: getNextAccount(),\n            systemProgram: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$8e17ce2ddce4908f().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$13bf7fada9982eb7 = 27;\nfunction $c5679bb0a1fb1418$export$970f27b40be72a1() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$13bf7fada9982eb7);\n}\nvar $c5679bb0a1fb1418$export$e6a9d4d4445d72b5 = 10;\nfunction $c5679bb0a1fb1418$export$b2f416872af7626b() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$e6a9d4d4445d72b5);\n}\nfunction $c5679bb0a1fb1418$export$5a4d4f718569f2f5() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$13bf7fada9982eb7,\n            confidentialTransferDiscriminator: $c5679bb0a1fb1418$export$e6a9d4d4445d72b5\n        }));\n}\nfunction $c5679bb0a1fb1418$export$70ff9fe6850e5c4c() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$a0eb5dae39accb7e() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$5a4d4f718569f2f5(), $c5679bb0a1fb1418$export$70ff9fe6850e5c4c());\n}\nfunction $c5679bb0a1fb1418$export$7c1578c4c330b0a9(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        token: {\n            value: input.token ?? null,\n            isWritable: true\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.token),\n            getAccountMeta(accounts.authority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$5a4d4f718569f2f5().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$88f98dec5b0a44d0(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            token: getNextAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$70ff9fe6850e5c4c().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$5eb0e4dc0f15c649 = 34;\nfunction $c5679bb0a1fb1418$export$7892eec815a7e3ef() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$5eb0e4dc0f15c649);\n}\nvar $c5679bb0a1fb1418$export$2030362a93212fe0 = 1;\nfunction $c5679bb0a1fb1418$export$b8a3420b0a2823f7() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$2030362a93212fe0);\n}\nfunction $c5679bb0a1fb1418$export$86ab1bd41c31d188() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"cpiGuardDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$5eb0e4dc0f15c649,\n            cpiGuardDiscriminator: $c5679bb0a1fb1418$export$2030362a93212fe0\n        }));\n}\nfunction $c5679bb0a1fb1418$export$e41e6f3759cef4f7() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"cpiGuardDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$1aaaf00518ea64ee() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$86ab1bd41c31d188(), $c5679bb0a1fb1418$export$e41e6f3759cef4f7());\n}\nfunction $c5679bb0a1fb1418$export$2fe579cccef3cafb(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        token: {\n            value: input.token ?? null,\n            isWritable: true\n        },\n        owner: {\n            value: input.owner ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.token),\n            getAccountMeta(accounts.owner),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$86ab1bd41c31d188().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$91eb845387a75f26(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            token: getNextAccount(),\n            owner: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$e41e6f3759cef4f7().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$de9fabcea482d8d1 = 37;\nfunction $c5679bb0a1fb1418$export$d64f100266c99dc5() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$de9fabcea482d8d1);\n}\nvar $c5679bb0a1fb1418$export$929f1117731d5202 = 5;\nfunction $c5679bb0a1fb1418$export$71f81b4b91b4033c() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$929f1117731d5202);\n}\nfunction $c5679bb0a1fb1418$export$ac325df2e8053ede() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"confidentialTransferFeeDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$de9fabcea482d8d1,\n            confidentialTransferFeeDiscriminator: $c5679bb0a1fb1418$export$929f1117731d5202\n        }));\n}\nfunction $c5679bb0a1fb1418$export$499eb3eb4df5b571() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"confidentialTransferFeeDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$f9f43efb5d090fa0() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$ac325df2e8053ede(), $c5679bb0a1fb1418$export$499eb3eb4df5b571());\n}\nfunction $c5679bb0a1fb1418$export$33e08b9e35cb1063(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.authority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$ac325df2e8053ede().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$8fb319df656763dc(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$499eb3eb4df5b571().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$c114dbfa8395b41f = 30;\nfunction $c5679bb0a1fb1418$export$4e8524c9427441ad() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$c114dbfa8395b41f);\n}\nvar $c5679bb0a1fb1418$export$5b4192ba8a517a11 = 1;\nfunction $c5679bb0a1fb1418$export$610d126378311311() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$5b4192ba8a517a11);\n}\nfunction $c5679bb0a1fb1418$export$c7027ddd7242002f() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"memoTransfersDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$c114dbfa8395b41f,\n            memoTransfersDiscriminator: $c5679bb0a1fb1418$export$5b4192ba8a517a11\n        }));\n}\nfunction $c5679bb0a1fb1418$export$aa0afbc371fa9ac4() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"memoTransfersDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$7a51768af79a340e() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$c7027ddd7242002f(), $c5679bb0a1fb1418$export$aa0afbc371fa9ac4());\n}\nfunction $c5679bb0a1fb1418$export$7a58b03d49f6b3ba(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        token: {\n            value: input.token ?? null,\n            isWritable: true\n        },\n        owner: {\n            value: input.owner ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.token),\n            getAccountMeta(accounts.owner),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$c7027ddd7242002f().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$e7bb5b305d12c03b(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            token: getNextAccount(),\n            owner: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$aa0afbc371fa9ac4().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$7cf83bf4a15d3665 = 27;\nfunction $c5679bb0a1fb1418$export$a1d4f7261bff6fc3() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$7cf83bf4a15d3665);\n}\nvar $c5679bb0a1fb1418$export$b961073d508a0113 = 12;\nfunction $c5679bb0a1fb1418$export$97583d655c9ec651() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$b961073d508a0113);\n}\nfunction $c5679bb0a1fb1418$export$68ee508cc96a95ee() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$7cf83bf4a15d3665,\n            confidentialTransferDiscriminator: $c5679bb0a1fb1418$export$b961073d508a0113\n        }));\n}\nfunction $c5679bb0a1fb1418$export$bf641a548fef3efe() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$3254e2bbdedf1023() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$68ee508cc96a95ee(), $c5679bb0a1fb1418$export$bf641a548fef3efe());\n}\nfunction $c5679bb0a1fb1418$export$92ec86b086892874(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        token: {\n            value: input.token ?? null,\n            isWritable: true\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.token),\n            getAccountMeta(accounts.authority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$68ee508cc96a95ee().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$983ae3a82d03ddfe(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            token: getNextAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$bf641a548fef3efe().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$b6327e097cb9226a = new Uint8Array([\n    250,\n    166,\n    180,\n    250,\n    13,\n    12,\n    184,\n    70\n]);\nfunction $c5679bb0a1fb1418$export$a8c7207d8cfdcebf() {\n    return (0, $991819a0aa439d56$export$636c51ad84d0674a)().encode($c5679bb0a1fb1418$export$b6327e097cb9226a);\n}\nfunction $c5679bb0a1fb1418$export$243543eb80885127() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $991819a0aa439d56$export$636c51ad84d0674a)()\n        ],\n        [\n            \"start\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $b5f941eb9a28d328$export$59d3bc8d559487ec)())\n        ],\n        [\n            \"end\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $b5f941eb9a28d328$export$59d3bc8d559487ec)())\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$b6327e097cb9226a,\n            start: value.start ?? (0, $6e02c1c9c7315aa4$export$f883a24d5edde77c)(),\n            end: value.end ?? (0, $6e02c1c9c7315aa4$export$f883a24d5edde77c)()\n        }));\n}\nfunction $c5679bb0a1fb1418$export$55f46f684dee3595() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $991819a0aa439d56$export$b90e67818b1b3d45)()\n        ],\n        [\n            \"start\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $b5f941eb9a28d328$export$faa05ffebebd465d)())\n        ],\n        [\n            \"end\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $b5f941eb9a28d328$export$faa05ffebebd465d)())\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$3cae83350297d0e6() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$243543eb80885127(), $c5679bb0a1fb1418$export$55f46f684dee3595());\n}\nfunction $c5679bb0a1fb1418$export$bcdf471f6239a24d(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        metadata: {\n            value: input.metadata ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.metadata)\n        ],\n        data: $c5679bb0a1fb1418$export$243543eb80885127().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$a35022490c733377(instruction) {\n    if (instruction.accounts.length < 1) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            metadata: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$55f46f684dee3595().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$2738323bce84de44 = 27;\nfunction $c5679bb0a1fb1418$export$6407b4e5e7a07276() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$2738323bce84de44);\n}\nvar $c5679bb0a1fb1418$export$1cf9e2490d02cea0 = 4;\nfunction $c5679bb0a1fb1418$export$d426f9edc350625b() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$1cf9e2490d02cea0);\n}\nfunction $c5679bb0a1fb1418$export$cdf63370000a6622() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"proofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$44792a8c35b3c0ce)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$2738323bce84de44,\n            confidentialTransferDiscriminator: $c5679bb0a1fb1418$export$1cf9e2490d02cea0\n        }));\n}\nfunction $c5679bb0a1fb1418$export$582ac1da1e7c5d() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"proofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$fdc22c4a59dfe6be)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$e9648a8dce51bdc9() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$cdf63370000a6622(), $c5679bb0a1fb1418$export$582ac1da1e7c5d());\n}\nfunction $c5679bb0a1fb1418$export$1f4e9c2ee1d0015(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        token: {\n            value: input.token ?? null,\n            isWritable: true\n        },\n        instructionsSysvarOrContextState: {\n            value: input.instructionsSysvarOrContextState ?? null,\n            isWritable: false\n        },\n        record: {\n            value: input.record ?? null,\n            isWritable: false\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    if (!accounts.instructionsSysvarOrContextState.value) accounts.instructionsSysvarOrContextState.value = \"Sysvar1nstructions1111111111111111111111111\";\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.token),\n            getAccountMeta(accounts.instructionsSysvarOrContextState),\n            getAccountMeta(accounts.record),\n            getAccountMeta(accounts.authority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$cdf63370000a6622().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$f53f67a28c738655(instruction) {\n    if (instruction.accounts.length < 4) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    const getNextOptionalAccount = ()=>{\n        const accountMeta = getNextAccount();\n        return accountMeta.address === $c5679bb0a1fb1418$export$69a22f9c8498afc2 ? void 0 : accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            token: getNextAccount(),\n            instructionsSysvarOrContextState: getNextAccount(),\n            record: getNextOptionalAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$582ac1da1e7c5d().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$cba129a534fdf9ac = 27;\nfunction $c5679bb0a1fb1418$export$e1d49df519388fb9() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$cba129a534fdf9ac);\n}\nvar $c5679bb0a1fb1418$export$97f09ef9436d0068 = 9;\nfunction $c5679bb0a1fb1418$export$1a0657fc0b139238() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$97f09ef9436d0068);\n}\nfunction $c5679bb0a1fb1418$export$c7edab959fb91e8() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$cba129a534fdf9ac,\n            confidentialTransferDiscriminator: $c5679bb0a1fb1418$export$97f09ef9436d0068\n        }));\n}\nfunction $c5679bb0a1fb1418$export$a20374125dfc06aa() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$fc76dc28db991121() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$c7edab959fb91e8(), $c5679bb0a1fb1418$export$a20374125dfc06aa());\n}\nfunction $c5679bb0a1fb1418$export$1835a61f21cc7b8(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        token: {\n            value: input.token ?? null,\n            isWritable: true\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.token),\n            getAccountMeta(accounts.authority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$c7edab959fb91e8().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$8caa51ff041fc5eb(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            token: getNextAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$a20374125dfc06aa().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$9eee61882ba0905 = 34;\nfunction $c5679bb0a1fb1418$export$b8ad16cd08f5a160() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$9eee61882ba0905);\n}\nvar $c5679bb0a1fb1418$export$61c39c062aee9709 = 0;\nfunction $c5679bb0a1fb1418$export$1815f6221f7a9636() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$61c39c062aee9709);\n}\nfunction $c5679bb0a1fb1418$export$c7b1012c23ad570f() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"cpiGuardDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$9eee61882ba0905,\n            cpiGuardDiscriminator: $c5679bb0a1fb1418$export$61c39c062aee9709\n        }));\n}\nfunction $c5679bb0a1fb1418$export$aaa5b3342b4bb849() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"cpiGuardDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$7d0717dc56d464c2() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$c7b1012c23ad570f(), $c5679bb0a1fb1418$export$aaa5b3342b4bb849());\n}\nfunction $c5679bb0a1fb1418$export$12db32a5c36ebc48(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        token: {\n            value: input.token ?? null,\n            isWritable: true\n        },\n        owner: {\n            value: input.owner ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.token),\n            getAccountMeta(accounts.owner),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$c7b1012c23ad570f().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$f0d9118238dbb1b0(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            token: getNextAccount(),\n            owner: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$aaa5b3342b4bb849().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$71dcdcbc645c33bb = 37;\nfunction $c5679bb0a1fb1418$export$edf6f050644b87e2() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$71dcdcbc645c33bb);\n}\nvar $c5679bb0a1fb1418$export$8cbfb1859f7ae4fc = 4;\nfunction $c5679bb0a1fb1418$export$628786a8252142a6() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$8cbfb1859f7ae4fc);\n}\nfunction $c5679bb0a1fb1418$export$d5d50aa3d5a7d982() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"confidentialTransferFeeDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$71dcdcbc645c33bb,\n            confidentialTransferFeeDiscriminator: $c5679bb0a1fb1418$export$8cbfb1859f7ae4fc\n        }));\n}\nfunction $c5679bb0a1fb1418$export$4e9cea84a1d28e73() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"confidentialTransferFeeDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$2ced9d0736b44e8d() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$d5d50aa3d5a7d982(), $c5679bb0a1fb1418$export$4e9cea84a1d28e73());\n}\nfunction $c5679bb0a1fb1418$export$c2c4667127d7a6e(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.authority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$d5d50aa3d5a7d982().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$5f1e2ca1b75283a7(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$4e9cea84a1d28e73().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$1e5f1260ae7b8b67 = 30;\nfunction $c5679bb0a1fb1418$export$61de8fd62908d658() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$1e5f1260ae7b8b67);\n}\nvar $c5679bb0a1fb1418$export$c1fe5d9639a5d485 = 0;\nfunction $c5679bb0a1fb1418$export$c6c54e135367ba71() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$c1fe5d9639a5d485);\n}\nfunction $c5679bb0a1fb1418$export$f81fb930b9a406ed() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"memoTransfersDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$1e5f1260ae7b8b67,\n            memoTransfersDiscriminator: $c5679bb0a1fb1418$export$c1fe5d9639a5d485\n        }));\n}\nfunction $c5679bb0a1fb1418$export$88494a3f0730dd5f() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"memoTransfersDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$f582502f2468d191() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$f81fb930b9a406ed(), $c5679bb0a1fb1418$export$88494a3f0730dd5f());\n}\nfunction $c5679bb0a1fb1418$export$59eff0fb1c207a5f(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        token: {\n            value: input.token ?? null,\n            isWritable: true\n        },\n        owner: {\n            value: input.owner ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.token),\n            getAccountMeta(accounts.owner),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$f81fb930b9a406ed().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$f302b413618cc639(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            token: getNextAccount(),\n            owner: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$88494a3f0730dd5f().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$a186133456616555 = 27;\nfunction $c5679bb0a1fb1418$export$dde8d9243737593a() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$a186133456616555);\n}\nvar $c5679bb0a1fb1418$export$ad93bfd5de731eb4 = 11;\nfunction $c5679bb0a1fb1418$export$b9e529ffe5215fe() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$ad93bfd5de731eb4);\n}\nfunction $c5679bb0a1fb1418$export$6505e1f45b94c189() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$a186133456616555,\n            confidentialTransferDiscriminator: $c5679bb0a1fb1418$export$ad93bfd5de731eb4\n        }));\n}\nfunction $c5679bb0a1fb1418$export$7009fc8183620f35() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$c999b17774481ce8() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$6505e1f45b94c189(), $c5679bb0a1fb1418$export$7009fc8183620f35());\n}\nfunction $c5679bb0a1fb1418$export$9cd337911eb24f53(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        token: {\n            value: input.token ?? null,\n            isWritable: true\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.token),\n            getAccountMeta(accounts.authority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$6505e1f45b94c189().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$1323924d4902c9b9(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            token: getNextAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$7009fc8183620f35().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$7554e9c653d7cb77 = 10;\nfunction $c5679bb0a1fb1418$export$712493c042a731c8() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$7554e9c653d7cb77);\n}\nfunction $c5679bb0a1fb1418$export$925721b4d14cf28b() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$7554e9c653d7cb77\n        }));\n}\nfunction $c5679bb0a1fb1418$export$120ca173d4cc5876() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$71968b3c40289623() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$925721b4d14cf28b(), $c5679bb0a1fb1418$export$120ca173d4cc5876());\n}\nfunction $c5679bb0a1fb1418$export$811db0d199b9fc63(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        account: {\n            value: input.account ?? null,\n            isWritable: true\n        },\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        },\n        owner: {\n            value: input.owner ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.account),\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.owner),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$925721b4d14cf28b().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$cda30ba7071c9055(instruction) {\n    if (instruction.accounts.length < 3) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            account: getNextAccount(),\n            mint: getNextAccount(),\n            owner: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$120ca173d4cc5876().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$24500d584984c0cd = 21;\nfunction $c5679bb0a1fb1418$export$ca07f6a84eb2fc0a() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$24500d584984c0cd);\n}\nfunction $c5679bb0a1fb1418$export$c71f345fa2aff293() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$24500d584984c0cd\n        }));\n}\nfunction $c5679bb0a1fb1418$export$7213e6f26c59289d() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$1d6c9522e2bb1f84() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$c71f345fa2aff293(), $c5679bb0a1fb1418$export$7213e6f26c59289d());\n}\nfunction $c5679bb0a1fb1418$export$4ba9bd4520fd1676(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint)\n        ],\n        data: $c5679bb0a1fb1418$export$c71f345fa2aff293().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$bd1d17f3c12f41bb(instruction) {\n    if (instruction.accounts.length < 1) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$7213e6f26c59289d().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$7d90d70a15558f66 = 26;\nfunction $c5679bb0a1fb1418$export$f07073527bca327e() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$7d90d70a15558f66);\n}\nvar $c5679bb0a1fb1418$export$b742bdef21540a7a = 4;\nfunction $c5679bb0a1fb1418$export$10dcfa438be9851b() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$b742bdef21540a7a);\n}\nfunction $c5679bb0a1fb1418$export$cdf8e79128253f8() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"transferFeeDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$7d90d70a15558f66,\n            transferFeeDiscriminator: $c5679bb0a1fb1418$export$b742bdef21540a7a\n        }));\n}\nfunction $c5679bb0a1fb1418$export$49f4dfd95ade39ce() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"transferFeeDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$12f623ff6817cf9e() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$cdf8e79128253f8(), $c5679bb0a1fb1418$export$49f4dfd95ade39ce());\n}\nfunction $c5679bb0a1fb1418$export$cf099b33dd40af1f(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = args.sources.map((address)=>({\n            address: address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).WRITABLE\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$cdf8e79128253f8().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$ce5bcac379ab36d(instruction) {\n    if (instruction.accounts.length < 1) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$49f4dfd95ade39ce().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$ecb1f73ed6f95619 = 37;\nfunction $c5679bb0a1fb1418$export$46cfb76e6f4d9794() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$ecb1f73ed6f95619);\n}\nvar $c5679bb0a1fb1418$export$545d525b1279f999 = 3;\nfunction $c5679bb0a1fb1418$export$1856289eb34cf232() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$545d525b1279f999);\n}\nfunction $c5679bb0a1fb1418$export$183329ce32596549() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"confidentialTransferFeeDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$ecb1f73ed6f95619,\n            confidentialTransferFeeDiscriminator: $c5679bb0a1fb1418$export$545d525b1279f999\n        }));\n}\nfunction $c5679bb0a1fb1418$export$64c1f9cdf2f21ebf() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"confidentialTransferFeeDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$23df9ee1368d6741() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$183329ce32596549(), $c5679bb0a1fb1418$export$64c1f9cdf2f21ebf());\n}\nfunction $c5679bb0a1fb1418$export$594e7176a7ac3b1c(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.sources ?? []).map((address)=>({\n            address: address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).WRITABLE\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$183329ce32596549().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$fea775d6d6114646(instruction) {\n    if (instruction.accounts.length < 1) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$64c1f9cdf2f21ebf().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$eb63c402aacc7dce = 1;\nfunction $c5679bb0a1fb1418$export$941df0a7bf83d740() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$eb63c402aacc7dce);\n}\nfunction $c5679bb0a1fb1418$export$69a378752a33f57f() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$eb63c402aacc7dce\n        }));\n}\nfunction $c5679bb0a1fb1418$export$163f74ed5554ad51() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$215afa883507f102() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$69a378752a33f57f(), $c5679bb0a1fb1418$export$163f74ed5554ad51());\n}\nfunction $c5679bb0a1fb1418$export$c83ad89e70511ce2(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        account: {\n            value: input.account ?? null,\n            isWritable: true\n        },\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        },\n        owner: {\n            value: input.owner ?? null,\n            isWritable: false\n        },\n        rent: {\n            value: input.rent ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    if (!accounts.rent.value) accounts.rent.value = \"SysvarRent111111111111111111111111111111111\";\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.account),\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.owner),\n            getAccountMeta(accounts.rent)\n        ],\n        data: $c5679bb0a1fb1418$export$69a378752a33f57f().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$7e111523076fa9a0(instruction) {\n    if (instruction.accounts.length < 4) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            account: getNextAccount(),\n            mint: getNextAccount(),\n            owner: getNextAccount(),\n            rent: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$163f74ed5554ad51().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$c033d437f69ebdbf = 16;\nfunction $c5679bb0a1fb1418$export$9bbbdae0a723282d() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$c033d437f69ebdbf);\n}\nfunction $c5679bb0a1fb1418$export$4f1fed20ac580a39() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"owner\",\n            (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$c033d437f69ebdbf\n        }));\n}\nfunction $c5679bb0a1fb1418$export$1ff3759775adb5bc() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"owner\",\n            (0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$187dda2c8d5f5de0() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$4f1fed20ac580a39(), $c5679bb0a1fb1418$export$1ff3759775adb5bc());\n}\nfunction $c5679bb0a1fb1418$export$7d0d5ffe49e62a59(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        account: {\n            value: input.account ?? null,\n            isWritable: true\n        },\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        },\n        rent: {\n            value: input.rent ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    if (!accounts.rent.value) accounts.rent.value = \"SysvarRent111111111111111111111111111111111\";\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.account),\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.rent)\n        ],\n        data: $c5679bb0a1fb1418$export$4f1fed20ac580a39().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$876436d05abfc463(instruction) {\n    if (instruction.accounts.length < 3) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            account: getNextAccount(),\n            mint: getNextAccount(),\n            rent: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$1ff3759775adb5bc().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$15ce81ff9b5cad52 = 18;\nfunction $c5679bb0a1fb1418$export$70c3d40814c1b38a() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$15ce81ff9b5cad52);\n}\nfunction $c5679bb0a1fb1418$export$9aff030f64adafe3() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"owner\",\n            (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$15ce81ff9b5cad52\n        }));\n}\nfunction $c5679bb0a1fb1418$export$2613971f8649c0a() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"owner\",\n            (0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$3a14ce99d515f1b8() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$9aff030f64adafe3(), $c5679bb0a1fb1418$export$2613971f8649c0a());\n}\nfunction $c5679bb0a1fb1418$export$9d1798b12fbc2a97(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        account: {\n            value: input.account ?? null,\n            isWritable: true\n        },\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.account),\n            getAccountMeta(accounts.mint)\n        ],\n        data: $c5679bb0a1fb1418$export$9aff030f64adafe3().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$f0f61cd78cb721d1(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            account: getNextAccount(),\n            mint: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$2613971f8649c0a().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$11a5d7a8210e5f65 = 37;\nfunction $c5679bb0a1fb1418$export$cc187c799d1145b3() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$11a5d7a8210e5f65);\n}\nvar $c5679bb0a1fb1418$export$2e05b2e8d1868518 = 0;\nfunction $c5679bb0a1fb1418$export$8dac718e70fc7b03() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$2e05b2e8d1868518);\n}\nfunction $c5679bb0a1fb1418$export$9a56c99f6f309993() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"confidentialTransferFeeDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"authority\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"withdrawWithheldAuthorityElGamalPubkey\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$11a5d7a8210e5f65,\n            confidentialTransferFeeDiscriminator: $c5679bb0a1fb1418$export$2e05b2e8d1868518\n        }));\n}\nfunction $c5679bb0a1fb1418$export$444bd21ed1423b3e() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"confidentialTransferFeeDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"authority\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"withdrawWithheldAuthorityElGamalPubkey\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$7a8cf690181652e1() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$9a56c99f6f309993(), $c5679bb0a1fb1418$export$444bd21ed1423b3e());\n}\nfunction $c5679bb0a1fb1418$export$aa445251c7ee9e1b(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint)\n        ],\n        data: $c5679bb0a1fb1418$export$9a56c99f6f309993().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$5e73af4e6f1b2513(instruction) {\n    if (instruction.accounts.length < 1) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$444bd21ed1423b3e().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$a7ed9e21b0cfe1d6 = 27;\nfunction $c5679bb0a1fb1418$export$80e2fe1ee55c95c1() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$a7ed9e21b0cfe1d6);\n}\nvar $c5679bb0a1fb1418$export$e04f30feab4e3848 = 0;\nfunction $c5679bb0a1fb1418$export$4b636282ab6af4a1() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$e04f30feab4e3848);\n}\nfunction $c5679bb0a1fb1418$export$f8e49456d6196682() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"authority\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"autoApproveNewAccounts\",\n            (0, $991819a0aa439d56$export$4a518d3f98f842eb)()\n        ],\n        [\n            \"auditorElgamalPubkey\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$a7ed9e21b0cfe1d6,\n            confidentialTransferDiscriminator: $c5679bb0a1fb1418$export$e04f30feab4e3848\n        }));\n}\nfunction $c5679bb0a1fb1418$export$e11ee0c2476142fa() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"authority\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"autoApproveNewAccounts\",\n            (0, $991819a0aa439d56$export$43a73c742ad521e1)()\n        ],\n        [\n            \"auditorElgamalPubkey\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$5cfe5a4d01cffe45() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$f8e49456d6196682(), $c5679bb0a1fb1418$export$e11ee0c2476142fa());\n}\nfunction $c5679bb0a1fb1418$export$634202b834563c0f(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint)\n        ],\n        data: $c5679bb0a1fb1418$export$f8e49456d6196682().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$8a693d72124759f7(instruction) {\n    if (instruction.accounts.length < 1) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$e11ee0c2476142fa().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$9dfb6bfcc2472b02 = 28;\nfunction $c5679bb0a1fb1418$export$a5624fdcb13ed055() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$9dfb6bfcc2472b02);\n}\nvar $c5679bb0a1fb1418$export$37b324df8bfb1d9e = 0;\nfunction $c5679bb0a1fb1418$export$c1068519ab23875f() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$37b324df8bfb1d9e);\n}\nfunction $c5679bb0a1fb1418$export$fdb3c8fd65a29489() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"defaultAccountStateDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"state\",\n            $c5679bb0a1fb1418$export$f9e14159fc53d3a0()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$9dfb6bfcc2472b02,\n            defaultAccountStateDiscriminator: $c5679bb0a1fb1418$export$37b324df8bfb1d9e\n        }));\n}\nfunction $c5679bb0a1fb1418$export$816c216f30015f8() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"defaultAccountStateDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"state\",\n            $c5679bb0a1fb1418$export$29eadaa90b440d19()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$1ffd5c11f7b84dfc() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$fdb3c8fd65a29489(), $c5679bb0a1fb1418$export$816c216f30015f8());\n}\nfunction $c5679bb0a1fb1418$export$a8ea1c3438c55128(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint)\n        ],\n        data: $c5679bb0a1fb1418$export$fdb3c8fd65a29489().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$e4ff9c91c2b05f7(instruction) {\n    if (instruction.accounts.length < 1) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$816c216f30015f8().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$1461e564abb8491f = 41;\nfunction $c5679bb0a1fb1418$export$4b3a7813ecef11b8() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$1461e564abb8491f);\n}\nvar $c5679bb0a1fb1418$export$fc23656a2a25333b = 0;\nfunction $c5679bb0a1fb1418$export$38421b42957288d4() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$fc23656a2a25333b);\n}\nfunction $c5679bb0a1fb1418$export$92583fdbd034e8c9() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"groupMemberPointerDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"authority\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"memberAddress\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$1461e564abb8491f,\n            groupMemberPointerDiscriminator: $c5679bb0a1fb1418$export$fc23656a2a25333b\n        }));\n}\nfunction $c5679bb0a1fb1418$export$44f2379d79417999() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"groupMemberPointerDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"authority\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"memberAddress\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$242948ded413bb94() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$92583fdbd034e8c9(), $c5679bb0a1fb1418$export$44f2379d79417999());\n}\nfunction $c5679bb0a1fb1418$export$75abb159f3515b7e(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint)\n        ],\n        data: $c5679bb0a1fb1418$export$92583fdbd034e8c9().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$fde571b36d99ca91(instruction) {\n    if (instruction.accounts.length < 1) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$44f2379d79417999().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$31bfc583ddc5614f = 40;\nfunction $c5679bb0a1fb1418$export$f78c477e9a11546e() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$31bfc583ddc5614f);\n}\nvar $c5679bb0a1fb1418$export$b6af0ec3b6903a24 = 0;\nfunction $c5679bb0a1fb1418$export$796758d904f285ef() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$b6af0ec3b6903a24);\n}\nfunction $c5679bb0a1fb1418$export$51109dd3bf4aefba() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"groupPointerDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"authority\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"groupAddress\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$31bfc583ddc5614f,\n            groupPointerDiscriminator: $c5679bb0a1fb1418$export$b6af0ec3b6903a24\n        }));\n}\nfunction $c5679bb0a1fb1418$export$cddf16480316b648() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"groupPointerDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"authority\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"groupAddress\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$9bb97a8e1182590() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$51109dd3bf4aefba(), $c5679bb0a1fb1418$export$cddf16480316b648());\n}\nfunction $c5679bb0a1fb1418$export$a4a60f2639d19029(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint)\n        ],\n        data: $c5679bb0a1fb1418$export$51109dd3bf4aefba().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$4708b4346e1536e(instruction) {\n    if (instruction.accounts.length < 1) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$cddf16480316b648().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$c07d403f4ca271bf = 22;\nfunction $c5679bb0a1fb1418$export$e1bd61c79e7129d7() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$c07d403f4ca271bf);\n}\nfunction $c5679bb0a1fb1418$export$a6e91a21d369ec50() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$c07d403f4ca271bf\n        }));\n}\nfunction $c5679bb0a1fb1418$export$f9bc8f5bf28284d8() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$23e56de3c3ee1b52() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$a6e91a21d369ec50(), $c5679bb0a1fb1418$export$f9bc8f5bf28284d8());\n}\nfunction $c5679bb0a1fb1418$export$f220a643d90b5eea(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        account: {\n            value: input.account ?? null,\n            isWritable: true\n        }\n    };\n    const accounts = originalAccounts;\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.account)\n        ],\n        data: $c5679bb0a1fb1418$export$a6e91a21d369ec50().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$383466597da19baf(instruction) {\n    if (instruction.accounts.length < 1) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            account: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$f9bc8f5bf28284d8().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$93a99243524513f1 = 33;\nfunction $c5679bb0a1fb1418$export$5b4814a7b14ff742() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$93a99243524513f1);\n}\nvar $c5679bb0a1fb1418$export$95d190b615b5b17a = 0;\nfunction $c5679bb0a1fb1418$export$b73b01608c67a924() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$95d190b615b5b17a);\n}\nfunction $c5679bb0a1fb1418$export$6a907f7fdabe01e9() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"interestBearingMintDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"rateAuthority\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"rate\",\n            (0, $b5f941eb9a28d328$export$45d575c12b2bb6a5)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$93a99243524513f1,\n            interestBearingMintDiscriminator: $c5679bb0a1fb1418$export$95d190b615b5b17a\n        }));\n}\nfunction $c5679bb0a1fb1418$export$efc7919269b3ffbf() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"interestBearingMintDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"rateAuthority\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"rate\",\n            (0, $b5f941eb9a28d328$export$4617ff1e22909f4)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$63a30dbb32442c42() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$6a907f7fdabe01e9(), $c5679bb0a1fb1418$export$efc7919269b3ffbf());\n}\nfunction $c5679bb0a1fb1418$export$abccf7436549cfec(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint)\n        ],\n        data: $c5679bb0a1fb1418$export$6a907f7fdabe01e9().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$13f6f9b21e5d82ab(instruction) {\n    if (instruction.accounts.length < 1) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$efc7919269b3ffbf().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$37fae7ded109653e = 39;\nfunction $c5679bb0a1fb1418$export$8087f591b0452163() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$37fae7ded109653e);\n}\nvar $c5679bb0a1fb1418$export$bcb9a62547154a2c = 0;\nfunction $c5679bb0a1fb1418$export$fbdea791bd6f31aa() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$bcb9a62547154a2c);\n}\nfunction $c5679bb0a1fb1418$export$b37b6b2097c0b6a4() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"metadataPointerDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"authority\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"metadataAddress\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$37fae7ded109653e,\n            metadataPointerDiscriminator: $c5679bb0a1fb1418$export$bcb9a62547154a2c\n        }));\n}\nfunction $c5679bb0a1fb1418$export$57d8efc8d86cf05d() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"metadataPointerDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"authority\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"metadataAddress\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$ceb8d3be1095f478() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$b37b6b2097c0b6a4(), $c5679bb0a1fb1418$export$57d8efc8d86cf05d());\n}\nfunction $c5679bb0a1fb1418$export$98091d89edb1c896(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint)\n        ],\n        data: $c5679bb0a1fb1418$export$b37b6b2097c0b6a4().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$673dfc184605c3ee(instruction) {\n    if (instruction.accounts.length < 1) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$57d8efc8d86cf05d().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$eeb6a46a41af8072 = 0;\nfunction $c5679bb0a1fb1418$export$a0345859c845d428() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$eeb6a46a41af8072);\n}\nfunction $c5679bb0a1fb1418$export$9e6b91e53a8cf1a5() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"decimals\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"mintAuthority\",\n            (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)()\n        ],\n        [\n            \"freezeAuthority\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)())\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$eeb6a46a41af8072,\n            freezeAuthority: value.freezeAuthority ?? (0, $6e02c1c9c7315aa4$export$f883a24d5edde77c)()\n        }));\n}\nfunction $c5679bb0a1fb1418$export$52f4795d1e97ffc1() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"decimals\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"mintAuthority\",\n            (0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)()\n        ],\n        [\n            \"freezeAuthority\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)())\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$338adaa8f1b525ff() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$9e6b91e53a8cf1a5(), $c5679bb0a1fb1418$export$52f4795d1e97ffc1());\n}\nfunction $c5679bb0a1fb1418$export$905dc2514f50ada6(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        },\n        rent: {\n            value: input.rent ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    if (!accounts.rent.value) accounts.rent.value = \"SysvarRent111111111111111111111111111111111\";\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.rent)\n        ],\n        data: $c5679bb0a1fb1418$export$9e6b91e53a8cf1a5().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$ec19bfef33214ddc(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount(),\n            rent: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$52f4795d1e97ffc1().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$d3e32494467b0313 = 20;\nfunction $c5679bb0a1fb1418$export$6657f7e084d11f09() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$d3e32494467b0313);\n}\nfunction $c5679bb0a1fb1418$export$deb5f5a789572773() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"decimals\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"mintAuthority\",\n            (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)()\n        ],\n        [\n            \"freezeAuthority\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)())\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$d3e32494467b0313,\n            freezeAuthority: value.freezeAuthority ?? (0, $6e02c1c9c7315aa4$export$f883a24d5edde77c)()\n        }));\n}\nfunction $c5679bb0a1fb1418$export$de8805680b9259ce() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"decimals\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"mintAuthority\",\n            (0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)()\n        ],\n        [\n            \"freezeAuthority\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)())\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$50890a5ac59141d() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$deb5f5a789572773(), $c5679bb0a1fb1418$export$de8805680b9259ce());\n}\nfunction $c5679bb0a1fb1418$export$55c095aedf2f483f(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint)\n        ],\n        data: $c5679bb0a1fb1418$export$deb5f5a789572773().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$1396a85756f0fdd4(instruction) {\n    if (instruction.accounts.length < 1) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$de8805680b9259ce().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$ba8e07a1c9c8d498 = 25;\nfunction $c5679bb0a1fb1418$export$a2971c6d2cf27693() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$ba8e07a1c9c8d498);\n}\nfunction $c5679bb0a1fb1418$export$58daaf5ef22e4b1a() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"closeAuthority\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)())\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$ba8e07a1c9c8d498\n        }));\n}\nfunction $c5679bb0a1fb1418$export$cf45da914fb05eec() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"closeAuthority\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)())\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$a39f94328f792a2f() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$58daaf5ef22e4b1a(), $c5679bb0a1fb1418$export$cf45da914fb05eec());\n}\nfunction $c5679bb0a1fb1418$export$6614c4db099c7ca5(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint)\n        ],\n        data: $c5679bb0a1fb1418$export$58daaf5ef22e4b1a().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$54314a52c5ac90d0(instruction) {\n    if (instruction.accounts.length < 1) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$cf45da914fb05eec().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$114d5342835dee0a = 2;\nfunction $c5679bb0a1fb1418$export$bfa3643db7edf1b2() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$114d5342835dee0a);\n}\nfunction $c5679bb0a1fb1418$export$f7b83b11310ae30a() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"m\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$114d5342835dee0a\n        }));\n}\nfunction $c5679bb0a1fb1418$export$5df451c48e8f1095() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"m\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$22ddc6c66e6628eb() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$f7b83b11310ae30a(), $c5679bb0a1fb1418$export$5df451c48e8f1095());\n}\nfunction $c5679bb0a1fb1418$export$14312710ee030af1(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        multisig: {\n            value: input.multisig ?? null,\n            isWritable: true\n        },\n        rent: {\n            value: input.rent ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    if (!accounts.rent.value) accounts.rent.value = \"SysvarRent111111111111111111111111111111111\";\n    const remainingAccounts = args.signers.map((address)=>({\n            address: address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.multisig),\n            getAccountMeta(accounts.rent),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$f7b83b11310ae30a().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$c9fd539e709ca12b(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            multisig: getNextAccount(),\n            rent: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$5df451c48e8f1095().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$632589b67f314890 = 19;\nfunction $c5679bb0a1fb1418$export$4416ec5a1bf9fe2c() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$632589b67f314890);\n}\nfunction $c5679bb0a1fb1418$export$91d5d26aef3219a4() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"m\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$632589b67f314890\n        }));\n}\nfunction $c5679bb0a1fb1418$export$98b5a041ae502787() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"m\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$69b85bb07ffd017a() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$91d5d26aef3219a4(), $c5679bb0a1fb1418$export$98b5a041ae502787());\n}\nfunction $c5679bb0a1fb1418$export$f1cbf31571229d65(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        multisig: {\n            value: input.multisig ?? null,\n            isWritable: true\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = args.signers.map((address)=>({\n            address: address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.multisig),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$91d5d26aef3219a4().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$50003f54c495ed6b(instruction) {\n    if (instruction.accounts.length < 1) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            multisig: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$98b5a041ae502787().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$948c34079fabb73 = 32;\nfunction $c5679bb0a1fb1418$export$f1d501841bb3cddd() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$948c34079fabb73);\n}\nfunction $c5679bb0a1fb1418$export$3006b6fcb4fda374() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$948c34079fabb73\n        }));\n}\nfunction $c5679bb0a1fb1418$export$b2188c182d6b9de3() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$f5acd3655f0f56e0() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$3006b6fcb4fda374(), $c5679bb0a1fb1418$export$b2188c182d6b9de3());\n}\nfunction $c5679bb0a1fb1418$export$ac1a58f62963653a(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        }\n    };\n    const accounts = originalAccounts;\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint)\n        ],\n        data: $c5679bb0a1fb1418$export$3006b6fcb4fda374().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$d794131637e419a6(instruction) {\n    if (instruction.accounts.length < 1) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$b2188c182d6b9de3().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$e7032fd75a4720aa = 44;\nfunction $c5679bb0a1fb1418$export$e23bb45725087044() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$e7032fd75a4720aa);\n}\nvar $c5679bb0a1fb1418$export$6b997c6e229365e9 = 0;\nfunction $c5679bb0a1fb1418$export$593f54a9e27fc860() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$6b997c6e229365e9);\n}\nfunction $c5679bb0a1fb1418$export$313ce42ff03e828e() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"pausableDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"authority\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$e7032fd75a4720aa,\n            pausableDiscriminator: $c5679bb0a1fb1418$export$6b997c6e229365e9\n        }));\n}\nfunction $c5679bb0a1fb1418$export$9080df3210bb831c() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"pausableDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"authority\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$cf08f358ba1e6065() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$313ce42ff03e828e(), $c5679bb0a1fb1418$export$9080df3210bb831c());\n}\nfunction $c5679bb0a1fb1418$export$b2e98ec3a47e1c0(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint)\n        ],\n        data: $c5679bb0a1fb1418$export$313ce42ff03e828e().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$c3e895b66ba75023(instruction) {\n    if (instruction.accounts.length < 1) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$9080df3210bb831c().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$7798f6d2622d77f4 = 35;\nfunction $c5679bb0a1fb1418$export$3a0c1e3b8e388722() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$7798f6d2622d77f4);\n}\nfunction $c5679bb0a1fb1418$export$5ed21b30f7617117() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"delegate\",\n            (0, $fadd3f4c7539d2fa$export$796121a945d5c29b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$7798f6d2622d77f4\n        }));\n}\nfunction $c5679bb0a1fb1418$export$13f206749bed2d14() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"delegate\",\n            (0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$bf0bd5f78dd43d63() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$5ed21b30f7617117(), $c5679bb0a1fb1418$export$13f206749bed2d14());\n}\nfunction $c5679bb0a1fb1418$export$6153a362f05db84e(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint)\n        ],\n        data: $c5679bb0a1fb1418$export$5ed21b30f7617117().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$5bbd52069831af93(instruction) {\n    if (instruction.accounts.length < 1) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$13f206749bed2d14().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$f3b1e7a21490baa7 = 43;\nfunction $c5679bb0a1fb1418$export$6269780a06b05f96() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$f3b1e7a21490baa7);\n}\nvar $c5679bb0a1fb1418$export$87e69fc825ecd475 = 0;\nfunction $c5679bb0a1fb1418$export$4140c5f99dac390e() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$87e69fc825ecd475);\n}\nfunction $c5679bb0a1fb1418$export$c9bfa6956cf3d24e() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"scaledUiAmountMintDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"authority\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"multiplier\",\n            (0, $b5f941eb9a28d328$export$551368d522177b99)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$f3b1e7a21490baa7,\n            scaledUiAmountMintDiscriminator: $c5679bb0a1fb1418$export$87e69fc825ecd475\n        }));\n}\nfunction $c5679bb0a1fb1418$export$96b465b2933f2659() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"scaledUiAmountMintDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"authority\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"multiplier\",\n            (0, $b5f941eb9a28d328$export$9475ae45ddf86dec)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$70d3e9f81d81baca() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$c9bfa6956cf3d24e(), $c5679bb0a1fb1418$export$96b465b2933f2659());\n}\nfunction $c5679bb0a1fb1418$export$68eb84d84fe02bce(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint)\n        ],\n        data: $c5679bb0a1fb1418$export$c9bfa6956cf3d24e().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$616d97bb034ba93(instruction) {\n    if (instruction.accounts.length < 1) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$96b465b2933f2659().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$e4ca7922b165b7aa = new Uint8Array([\n    121,\n    113,\n    108,\n    39,\n    54,\n    51,\n    0,\n    4\n]);\nfunction $c5679bb0a1fb1418$export$9063beed8ec43a64() {\n    return (0, $991819a0aa439d56$export$636c51ad84d0674a)().encode($c5679bb0a1fb1418$export$e4ca7922b165b7aa);\n}\nfunction $c5679bb0a1fb1418$export$a6c5e40b29dad6eb() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $991819a0aa439d56$export$636c51ad84d0674a)()\n        ],\n        [\n            \"updateAuthority\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"maxSize\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$e4ca7922b165b7aa\n        }));\n}\nfunction $c5679bb0a1fb1418$export$a8fb71db72f27ba2() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $991819a0aa439d56$export$b90e67818b1b3d45)()\n        ],\n        [\n            \"updateAuthority\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"maxSize\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$14cdcb2b48a26b2d() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$a6c5e40b29dad6eb(), $c5679bb0a1fb1418$export$a8fb71db72f27ba2());\n}\nfunction $c5679bb0a1fb1418$export$238224b885f6d1b1(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        group: {\n            value: input.group ?? null,\n            isWritable: true\n        },\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        },\n        mintAuthority: {\n            value: input.mintAuthority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.group),\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.mintAuthority)\n        ],\n        data: $c5679bb0a1fb1418$export$a6c5e40b29dad6eb().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$3b304397765380c0(instruction) {\n    if (instruction.accounts.length < 3) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            group: getNextAccount(),\n            mint: getNextAccount(),\n            mintAuthority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$a8fb71db72f27ba2().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$7314a84624d5ca4c = new Uint8Array([\n    152,\n    32,\n    222,\n    176,\n    223,\n    237,\n    116,\n    134\n]);\nfunction $c5679bb0a1fb1418$export$a507dcea83d3ffca() {\n    return (0, $991819a0aa439d56$export$636c51ad84d0674a)().encode($c5679bb0a1fb1418$export$7314a84624d5ca4c);\n}\nfunction $c5679bb0a1fb1418$export$1d095b16cf43efff() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $991819a0aa439d56$export$636c51ad84d0674a)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$7314a84624d5ca4c\n        }));\n}\nfunction $c5679bb0a1fb1418$export$11073440b92b20c3() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $991819a0aa439d56$export$b90e67818b1b3d45)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$474d3f3d4ec897e6() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$1d095b16cf43efff(), $c5679bb0a1fb1418$export$11073440b92b20c3());\n}\nfunction $c5679bb0a1fb1418$export$cbbab14691f457f1(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        member: {\n            value: input.member ?? null,\n            isWritable: true\n        },\n        memberMint: {\n            value: input.memberMint ?? null,\n            isWritable: false\n        },\n        memberMintAuthority: {\n            value: input.memberMintAuthority ?? null,\n            isWritable: false\n        },\n        group: {\n            value: input.group ?? null,\n            isWritable: true\n        },\n        groupUpdateAuthority: {\n            value: input.groupUpdateAuthority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.member),\n            getAccountMeta(accounts.memberMint),\n            getAccountMeta(accounts.memberMintAuthority),\n            getAccountMeta(accounts.group),\n            getAccountMeta(accounts.groupUpdateAuthority)\n        ],\n        data: $c5679bb0a1fb1418$export$1d095b16cf43efff().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$2c894a770eb97f62(instruction) {\n    if (instruction.accounts.length < 5) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            member: getNextAccount(),\n            memberMint: getNextAccount(),\n            memberMintAuthority: getNextAccount(),\n            group: getNextAccount(),\n            groupUpdateAuthority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$11073440b92b20c3().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$38ee9e303861d057 = new Uint8Array([\n    210,\n    225,\n    30,\n    162,\n    88,\n    184,\n    77,\n    141\n]);\nfunction $c5679bb0a1fb1418$export$e8c25ee0921962a7() {\n    return (0, $991819a0aa439d56$export$636c51ad84d0674a)().encode($c5679bb0a1fb1418$export$38ee9e303861d057);\n}\nfunction $c5679bb0a1fb1418$export$6ffeef34aad72dc3() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $991819a0aa439d56$export$636c51ad84d0674a)()\n        ],\n        [\n            \"name\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $278ae65923ee60f5$export$9a335ef9e29610a7)(), (0, $b5f941eb9a28d328$export$3e3136013a349951)())\n        ],\n        [\n            \"symbol\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $278ae65923ee60f5$export$9a335ef9e29610a7)(), (0, $b5f941eb9a28d328$export$3e3136013a349951)())\n        ],\n        [\n            \"uri\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $278ae65923ee60f5$export$9a335ef9e29610a7)(), (0, $b5f941eb9a28d328$export$3e3136013a349951)())\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$38ee9e303861d057\n        }));\n}\nfunction $c5679bb0a1fb1418$export$b2219990de332801() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $991819a0aa439d56$export$b90e67818b1b3d45)()\n        ],\n        [\n            \"name\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $278ae65923ee60f5$export$3cdd8a41d7d6b55d)(), (0, $b5f941eb9a28d328$export$ddc26825031b1ac9)())\n        ],\n        [\n            \"symbol\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $278ae65923ee60f5$export$3cdd8a41d7d6b55d)(), (0, $b5f941eb9a28d328$export$ddc26825031b1ac9)())\n        ],\n        [\n            \"uri\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $278ae65923ee60f5$export$3cdd8a41d7d6b55d)(), (0, $b5f941eb9a28d328$export$ddc26825031b1ac9)())\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$6afe38743bc48737() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$6ffeef34aad72dc3(), $c5679bb0a1fb1418$export$b2219990de332801());\n}\nfunction $c5679bb0a1fb1418$export$7ef0f7bf81d67d5d(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        metadata: {\n            value: input.metadata ?? null,\n            isWritable: true\n        },\n        updateAuthority: {\n            value: input.updateAuthority ?? null,\n            isWritable: false\n        },\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        },\n        mintAuthority: {\n            value: input.mintAuthority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.metadata),\n            getAccountMeta(accounts.updateAuthority),\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.mintAuthority)\n        ],\n        data: $c5679bb0a1fb1418$export$6ffeef34aad72dc3().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$d389f7a5fd37868d(instruction) {\n    if (instruction.accounts.length < 4) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            metadata: getNextAccount(),\n            updateAuthority: getNextAccount(),\n            mint: getNextAccount(),\n            mintAuthority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$b2219990de332801().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$134c66ffb472bf15 = 26;\nfunction $c5679bb0a1fb1418$export$8476eb7082e89cfe() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$134c66ffb472bf15);\n}\nvar $c5679bb0a1fb1418$export$b2d27916c2d42c01 = 0;\nfunction $c5679bb0a1fb1418$export$e24517f7df5af93a() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$b2d27916c2d42c01);\n}\nfunction $c5679bb0a1fb1418$export$8a24b11477626aa6() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"transferFeeDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"transferFeeConfigAuthority\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)())\n        ],\n        [\n            \"withdrawWithheldAuthority\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)())\n        ],\n        [\n            \"transferFeeBasisPoints\",\n            (0, $b5f941eb9a28d328$export$e156211d06496a2f)()\n        ],\n        [\n            \"maximumFee\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$134c66ffb472bf15,\n            transferFeeDiscriminator: $c5679bb0a1fb1418$export$b2d27916c2d42c01\n        }));\n}\nfunction $c5679bb0a1fb1418$export$ed900df85f764630() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"transferFeeDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"transferFeeConfigAuthority\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)())\n        ],\n        [\n            \"withdrawWithheldAuthority\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)())\n        ],\n        [\n            \"transferFeeBasisPoints\",\n            (0, $b5f941eb9a28d328$export$1a649eb0055ac058)()\n        ],\n        [\n            \"maximumFee\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$a8226d5219a40ef1() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$8a24b11477626aa6(), $c5679bb0a1fb1418$export$ed900df85f764630());\n}\nfunction $c5679bb0a1fb1418$export$8899a815a341ab7c(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint)\n        ],\n        data: $c5679bb0a1fb1418$export$8a24b11477626aa6().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$99edd2b41f72085(instruction) {\n    if (instruction.accounts.length < 1) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$ed900df85f764630().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$53fc68580489daaa = 36;\nfunction $c5679bb0a1fb1418$export$f05c25ab5536eb05() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$53fc68580489daaa);\n}\nvar $c5679bb0a1fb1418$export$8d6d54234e2a1096 = 0;\nfunction $c5679bb0a1fb1418$export$48060558b48825d() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$8d6d54234e2a1096);\n}\nfunction $c5679bb0a1fb1418$export$1d3be5e9fe4e8e8f() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"transferHookDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"authority\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"programId\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$53fc68580489daaa,\n            transferHookDiscriminator: $c5679bb0a1fb1418$export$8d6d54234e2a1096\n        }));\n}\nfunction $c5679bb0a1fb1418$export$232f8dadcbb9cfab() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"transferHookDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"authority\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ],\n        [\n            \"programId\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$d52707865d0cc0c5() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$1d3be5e9fe4e8e8f(), $c5679bb0a1fb1418$export$232f8dadcbb9cfab());\n}\nfunction $c5679bb0a1fb1418$export$a108bc5213efc88(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint)\n        ],\n        data: $c5679bb0a1fb1418$export$1d3be5e9fe4e8e8f().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$91a2477b253b7d(instruction) {\n    if (instruction.accounts.length < 1) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$232f8dadcbb9cfab().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$c53a65c18221096f = 7;\nfunction $c5679bb0a1fb1418$export$6f45722ecd8b1388() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$c53a65c18221096f);\n}\nfunction $c5679bb0a1fb1418$export$c8f8d3938aab3370() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$c53a65c18221096f\n        }));\n}\nfunction $c5679bb0a1fb1418$export$e461a6981d259d58() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$226e7a67cbb851c4() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$c8f8d3938aab3370(), $c5679bb0a1fb1418$export$e461a6981d259d58());\n}\nfunction $c5679bb0a1fb1418$export$86c33f2f05f293ee(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        },\n        token: {\n            value: input.token ?? null,\n            isWritable: true\n        },\n        mintAuthority: {\n            value: input.mintAuthority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.token),\n            getAccountMeta(accounts.mintAuthority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$c8f8d3938aab3370().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$a62f0a68b5c69eb7(instruction) {\n    if (instruction.accounts.length < 3) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount(),\n            token: getNextAccount(),\n            mintAuthority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$e461a6981d259d58().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$9506b72cc9311a6 = 14;\nfunction $c5679bb0a1fb1418$export$377cd422fc46f263() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$9506b72cc9311a6);\n}\nfunction $c5679bb0a1fb1418$export$20af08864f3ac9e1() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ],\n        [\n            \"decimals\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$9506b72cc9311a6\n        }));\n}\nfunction $c5679bb0a1fb1418$export$b5964604a0baf613() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ],\n        [\n            \"decimals\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$f1e85f1f5dac0c2a() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$20af08864f3ac9e1(), $c5679bb0a1fb1418$export$b5964604a0baf613());\n}\nfunction $c5679bb0a1fb1418$export$f296d4a2c50d19b6(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        },\n        token: {\n            value: input.token ?? null,\n            isWritable: true\n        },\n        mintAuthority: {\n            value: input.mintAuthority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.token),\n            getAccountMeta(accounts.mintAuthority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$20af08864f3ac9e1().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$43f3ebab2ba3a1d9(instruction) {\n    if (instruction.accounts.length < 3) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount(),\n            token: getNextAccount(),\n            mintAuthority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$b5964604a0baf613().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$429839ef3b4d1692 = 44;\nfunction $c5679bb0a1fb1418$export$281f7fea10b2b443() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$429839ef3b4d1692);\n}\nvar $c5679bb0a1fb1418$export$a6986c59f5f7b4e7 = 1;\nfunction $c5679bb0a1fb1418$export$a2723dd71cd5c96d() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$a6986c59f5f7b4e7);\n}\nfunction $c5679bb0a1fb1418$export$377d138650f8c6() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"pausableDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$429839ef3b4d1692,\n            pausableDiscriminator: $c5679bb0a1fb1418$export$a6986c59f5f7b4e7\n        }));\n}\nfunction $c5679bb0a1fb1418$export$ba1f27e21b4450d2() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"pausableDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$e246d6f4d22da848() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$377d138650f8c6(), $c5679bb0a1fb1418$export$ba1f27e21b4450d2());\n}\nfunction $c5679bb0a1fb1418$export$ae3b22c43a0ee955(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.authority)\n        ],\n        data: $c5679bb0a1fb1418$export$377d138650f8c6().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$c32babef7a63539a(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$ba1f27e21b4450d2().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$24bc70ab682f24d = 29;\nfunction $c5679bb0a1fb1418$export$33a03b06d6ef40b6() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$24bc70ab682f24d);\n}\nfunction $c5679bb0a1fb1418$export$e5222f1b06cf9620() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"newExtensionTypes\",\n            (0, $991819a0aa439d56$export$415199198053c0b)($c5679bb0a1fb1418$export$7c1483c3b497276b(), {\n                size: \"remainder\"\n            })\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$24bc70ab682f24d\n        }));\n}\nfunction $c5679bb0a1fb1418$export$f388da4da9726508() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"newExtensionTypes\",\n            (0, $991819a0aa439d56$export$9016038b2e3b0c2f)($c5679bb0a1fb1418$export$269c0b898b017d4e(), {\n                size: \"remainder\"\n            })\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$aff3a43a4f6e3f52() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$e5222f1b06cf9620(), $c5679bb0a1fb1418$export$f388da4da9726508());\n}\nfunction $c5679bb0a1fb1418$export$37e2f4a884961928(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        token: {\n            value: input.token ?? null,\n            isWritable: true\n        },\n        payer: {\n            value: input.payer ?? null,\n            isWritable: true\n        },\n        systemProgram: {\n            value: input.systemProgram ?? null,\n            isWritable: false\n        },\n        owner: {\n            value: input.owner ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    if (!accounts.systemProgram.value) accounts.systemProgram.value = \"11111111111111111111111111111111\";\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.token),\n            getAccountMeta(accounts.payer),\n            getAccountMeta(accounts.systemProgram),\n            getAccountMeta(accounts.owner),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$e5222f1b06cf9620().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$b44e81e6df750d74(instruction) {\n    if (instruction.accounts.length < 4) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            token: getNextAccount(),\n            payer: getNextAccount(),\n            systemProgram: getNextAccount(),\n            owner: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$f388da4da9726508().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$138e1c88679479d0 = 2;\nfunction $c5679bb0a1fb1418$export$7df14a7e68cef419() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$138e1c88679479d0);\n}\nfunction $c5679bb0a1fb1418$export$82cf012d1af018a5() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$138e1c88679479d0\n        }));\n}\nfunction $c5679bb0a1fb1418$export$608233622ba43b8() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$9c3d7486c0b875d3() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$82cf012d1af018a5(), $c5679bb0a1fb1418$export$608233622ba43b8());\n}\nasync function $c5679bb0a1fb1418$export$5c23941d1cfdfbe6(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$97ae793257bad8ba;\n    const originalAccounts = {\n        nestedAssociatedAccountAddress: {\n            value: input.nestedAssociatedAccountAddress ?? null,\n            isWritable: true\n        },\n        nestedTokenMintAddress: {\n            value: input.nestedTokenMintAddress ?? null,\n            isWritable: false\n        },\n        destinationAssociatedAccountAddress: {\n            value: input.destinationAssociatedAccountAddress ?? null,\n            isWritable: true\n        },\n        ownerAssociatedAccountAddress: {\n            value: input.ownerAssociatedAccountAddress ?? null,\n            isWritable: false\n        },\n        ownerTokenMintAddress: {\n            value: input.ownerTokenMintAddress ?? null,\n            isWritable: false\n        },\n        walletAddress: {\n            value: input.walletAddress ?? null,\n            isWritable: true\n        },\n        tokenProgram: {\n            value: input.tokenProgram ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    if (!accounts.tokenProgram.value) accounts.tokenProgram.value = \"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\";\n    if (!accounts.ownerAssociatedAccountAddress.value) accounts.ownerAssociatedAccountAddress.value = await $c5679bb0a1fb1418$export$261fb6f487940719({\n        owner: $c5679bb0a1fb1418$var$expectAddress(accounts.walletAddress.value),\n        tokenProgram: $c5679bb0a1fb1418$var$expectAddress(accounts.tokenProgram.value),\n        mint: $c5679bb0a1fb1418$var$expectAddress(accounts.ownerTokenMintAddress.value)\n    });\n    if (!accounts.nestedAssociatedAccountAddress.value) accounts.nestedAssociatedAccountAddress.value = await $c5679bb0a1fb1418$export$261fb6f487940719({\n        owner: $c5679bb0a1fb1418$var$expectAddress(accounts.ownerAssociatedAccountAddress.value),\n        tokenProgram: $c5679bb0a1fb1418$var$expectAddress(accounts.tokenProgram.value),\n        mint: $c5679bb0a1fb1418$var$expectAddress(accounts.nestedTokenMintAddress.value)\n    });\n    if (!accounts.destinationAssociatedAccountAddress.value) accounts.destinationAssociatedAccountAddress.value = await $c5679bb0a1fb1418$export$261fb6f487940719({\n        owner: $c5679bb0a1fb1418$var$expectAddress(accounts.walletAddress.value),\n        tokenProgram: $c5679bb0a1fb1418$var$expectAddress(accounts.tokenProgram.value),\n        mint: $c5679bb0a1fb1418$var$expectAddress(accounts.nestedTokenMintAddress.value)\n    });\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.nestedAssociatedAccountAddress),\n            getAccountMeta(accounts.nestedTokenMintAddress),\n            getAccountMeta(accounts.destinationAssociatedAccountAddress),\n            getAccountMeta(accounts.ownerAssociatedAccountAddress),\n            getAccountMeta(accounts.ownerTokenMintAddress),\n            getAccountMeta(accounts.walletAddress),\n            getAccountMeta(accounts.tokenProgram)\n        ],\n        data: $c5679bb0a1fb1418$export$82cf012d1af018a5().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$cef2f2255f24684b(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$97ae793257bad8ba;\n    const originalAccounts = {\n        nestedAssociatedAccountAddress: {\n            value: input.nestedAssociatedAccountAddress ?? null,\n            isWritable: true\n        },\n        nestedTokenMintAddress: {\n            value: input.nestedTokenMintAddress ?? null,\n            isWritable: false\n        },\n        destinationAssociatedAccountAddress: {\n            value: input.destinationAssociatedAccountAddress ?? null,\n            isWritable: true\n        },\n        ownerAssociatedAccountAddress: {\n            value: input.ownerAssociatedAccountAddress ?? null,\n            isWritable: false\n        },\n        ownerTokenMintAddress: {\n            value: input.ownerTokenMintAddress ?? null,\n            isWritable: false\n        },\n        walletAddress: {\n            value: input.walletAddress ?? null,\n            isWritable: true\n        },\n        tokenProgram: {\n            value: input.tokenProgram ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    if (!accounts.tokenProgram.value) accounts.tokenProgram.value = \"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\";\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.nestedAssociatedAccountAddress),\n            getAccountMeta(accounts.nestedTokenMintAddress),\n            getAccountMeta(accounts.destinationAssociatedAccountAddress),\n            getAccountMeta(accounts.ownerAssociatedAccountAddress),\n            getAccountMeta(accounts.ownerTokenMintAddress),\n            getAccountMeta(accounts.walletAddress),\n            getAccountMeta(accounts.tokenProgram)\n        ],\n        data: $c5679bb0a1fb1418$export$82cf012d1af018a5().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$5c7ea4c45b3da00d(instruction) {\n    if (instruction.accounts.length < 7) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            nestedAssociatedAccountAddress: getNextAccount(),\n            nestedTokenMintAddress: getNextAccount(),\n            destinationAssociatedAccountAddress: getNextAccount(),\n            ownerAssociatedAccountAddress: getNextAccount(),\n            ownerTokenMintAddress: getNextAccount(),\n            walletAddress: getNextAccount(),\n            tokenProgram: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$608233622ba43b8().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$5d7d3bef8c4bc9f7 = new Uint8Array([\n    234,\n    18,\n    32,\n    56,\n    89,\n    141,\n    37,\n    181\n]);\nfunction $c5679bb0a1fb1418$export$b736bd72dc7ccde9() {\n    return (0, $991819a0aa439d56$export$636c51ad84d0674a)().encode($c5679bb0a1fb1418$export$5d7d3bef8c4bc9f7);\n}\nfunction $c5679bb0a1fb1418$export$9cd50536557424f2() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $991819a0aa439d56$export$636c51ad84d0674a)()\n        ],\n        [\n            \"idempotent\",\n            (0, $991819a0aa439d56$export$4a518d3f98f842eb)()\n        ],\n        [\n            \"key\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $278ae65923ee60f5$export$9a335ef9e29610a7)(), (0, $b5f941eb9a28d328$export$3e3136013a349951)())\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$5d7d3bef8c4bc9f7,\n            idempotent: value.idempotent ?? false\n        }));\n}\nfunction $c5679bb0a1fb1418$export$c47ad5006d1d51d8() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $991819a0aa439d56$export$b90e67818b1b3d45)()\n        ],\n        [\n            \"idempotent\",\n            (0, $991819a0aa439d56$export$43a73c742ad521e1)()\n        ],\n        [\n            \"key\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $278ae65923ee60f5$export$3cdd8a41d7d6b55d)(), (0, $b5f941eb9a28d328$export$ddc26825031b1ac9)())\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$2d5ad19085ce06e1() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$9cd50536557424f2(), $c5679bb0a1fb1418$export$c47ad5006d1d51d8());\n}\nfunction $c5679bb0a1fb1418$export$5285c4a1358d56a1(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        metadata: {\n            value: input.metadata ?? null,\n            isWritable: true\n        },\n        updateAuthority: {\n            value: input.updateAuthority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.metadata),\n            getAccountMeta(accounts.updateAuthority)\n        ],\n        data: $c5679bb0a1fb1418$export$9cd50536557424f2().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$8837d0bb3f609bc2(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            metadata: getNextAccount(),\n            updateAuthority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$c47ad5006d1d51d8().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$2c839e6445918a51 = 44;\nfunction $c5679bb0a1fb1418$export$f2af5cc1a76fd105() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$2c839e6445918a51);\n}\nvar $c5679bb0a1fb1418$export$79fe81fa56941f51 = 2;\nfunction $c5679bb0a1fb1418$export$bbb85cf2a5768401() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$79fe81fa56941f51);\n}\nfunction $c5679bb0a1fb1418$export$af91a9138c8f558e() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"pausableDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$2c839e6445918a51,\n            pausableDiscriminator: $c5679bb0a1fb1418$export$79fe81fa56941f51\n        }));\n}\nfunction $c5679bb0a1fb1418$export$9c96ec34f561f836() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"pausableDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$1b1fbe06cce13f56() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$af91a9138c8f558e(), $c5679bb0a1fb1418$export$9c96ec34f561f836());\n}\nfunction $c5679bb0a1fb1418$export$f4b5d04e6062bfee(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.authority)\n        ],\n        data: $c5679bb0a1fb1418$export$af91a9138c8f558e().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$9bdae54cc81aa9f0(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$9c96ec34f561f836().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$109791c219bb5f2a = 5;\nfunction $c5679bb0a1fb1418$export$46d4a8b7debdfb9d() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$109791c219bb5f2a);\n}\nfunction $c5679bb0a1fb1418$export$5118139fbcffb40e() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$109791c219bb5f2a\n        }));\n}\nfunction $c5679bb0a1fb1418$export$8ff2bdc7df9073a5() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$20967c84b17c950b() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$5118139fbcffb40e(), $c5679bb0a1fb1418$export$8ff2bdc7df9073a5());\n}\nfunction $c5679bb0a1fb1418$export$bc02b2c2b3ef1047(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        source: {\n            value: input.source ?? null,\n            isWritable: true\n        },\n        owner: {\n            value: input.owner ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.source),\n            getAccountMeta(accounts.owner),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$5118139fbcffb40e().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$8055a07a7947499a(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            source: getNextAccount(),\n            owner: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$8ff2bdc7df9073a5().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$2b9817bc054f4a60 = 6;\nfunction $c5679bb0a1fb1418$export$7c9a1a768e90d91e() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$2b9817bc054f4a60);\n}\nfunction $c5679bb0a1fb1418$export$c708dcdb6ae68879() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"authorityType\",\n            $c5679bb0a1fb1418$export$f6d1e14b900ddfd1()\n        ],\n        [\n            \"newAuthority\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)())\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$2b9817bc054f4a60\n        }));\n}\nfunction $c5679bb0a1fb1418$export$4e7604b8a43cbe15() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"authorityType\",\n            $c5679bb0a1fb1418$export$a03cb29b3edd2426()\n        ],\n        [\n            \"newAuthority\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)())\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$a35f2815d335a71d() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$c708dcdb6ae68879(), $c5679bb0a1fb1418$export$4e7604b8a43cbe15());\n}\nfunction $c5679bb0a1fb1418$export$67fd321c883fbe9d(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        owned: {\n            value: input.owned ?? null,\n            isWritable: true\n        },\n        owner: {\n            value: input.owner ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.owned),\n            getAccountMeta(accounts.owner),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$c708dcdb6ae68879().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$db391774a2cb353(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            owned: getNextAccount(),\n            owner: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$4e7604b8a43cbe15().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$578533e631d5ae0e = 26;\nfunction $c5679bb0a1fb1418$export$25a3416ad9d60d73() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$578533e631d5ae0e);\n}\nvar $c5679bb0a1fb1418$export$acd46ed4507e7906 = 5;\nfunction $c5679bb0a1fb1418$export$d8d421921e2681ed() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$acd46ed4507e7906);\n}\nfunction $c5679bb0a1fb1418$export$485b73fc36ff26ca() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"transferFeeDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"transferFeeBasisPoints\",\n            (0, $b5f941eb9a28d328$export$e156211d06496a2f)()\n        ],\n        [\n            \"maximumFee\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$578533e631d5ae0e,\n            transferFeeDiscriminator: $c5679bb0a1fb1418$export$acd46ed4507e7906\n        }));\n}\nfunction $c5679bb0a1fb1418$export$e887b40020a63c88() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"transferFeeDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"transferFeeBasisPoints\",\n            (0, $b5f941eb9a28d328$export$1a649eb0055ac058)()\n        ],\n        [\n            \"maximumFee\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$d141cdbe667302b8() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$485b73fc36ff26ca(), $c5679bb0a1fb1418$export$e887b40020a63c88());\n}\nfunction $c5679bb0a1fb1418$export$37386e084f73aa42(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        },\n        transferFeeConfigAuthority: {\n            value: input.transferFeeConfigAuthority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.transferFeeConfigAuthority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$485b73fc36ff26ca().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$f8726aedb421a293(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount(),\n            transferFeeConfigAuthority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$e887b40020a63c88().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$b858fe2a9f01487b = 17;\nfunction $c5679bb0a1fb1418$export$f406412bb0b16f68() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$b858fe2a9f01487b);\n}\nfunction $c5679bb0a1fb1418$export$abe725211565d840() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$b858fe2a9f01487b\n        }));\n}\nfunction $c5679bb0a1fb1418$export$5484edf95425f58d() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$70bab8e83ebcc534() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$abe725211565d840(), $c5679bb0a1fb1418$export$5484edf95425f58d());\n}\nfunction $c5679bb0a1fb1418$export$30a62f9a62a08500(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        account: {\n            value: input.account ?? null,\n            isWritable: true\n        }\n    };\n    const accounts = originalAccounts;\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.account)\n        ],\n        data: $c5679bb0a1fb1418$export$abe725211565d840().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$7dd2b839c916c307(instruction) {\n    if (instruction.accounts.length < 1) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            account: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$5484edf95425f58d().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$762f3fbd8afd0cd4 = 11;\nfunction $c5679bb0a1fb1418$export$239cfd997c879686() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$762f3fbd8afd0cd4);\n}\nfunction $c5679bb0a1fb1418$export$274daa9d6ba37e5() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$762f3fbd8afd0cd4\n        }));\n}\nfunction $c5679bb0a1fb1418$export$616d03ea89b2ccb6() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$1e9255c04b29a064() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$274daa9d6ba37e5(), $c5679bb0a1fb1418$export$616d03ea89b2ccb6());\n}\nfunction $c5679bb0a1fb1418$export$188ee3ee8c12625b(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        account: {\n            value: input.account ?? null,\n            isWritable: true\n        },\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        },\n        owner: {\n            value: input.owner ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.account),\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.owner),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$274daa9d6ba37e5().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$fabb1f7fb365de45(instruction) {\n    if (instruction.accounts.length < 3) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            account: getNextAccount(),\n            mint: getNextAccount(),\n            owner: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$616d03ea89b2ccb6().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$75b98419cdf4afa5 = 3;\nfunction $c5679bb0a1fb1418$export$3eda9a122e3829c3() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$75b98419cdf4afa5);\n}\nfunction $c5679bb0a1fb1418$export$295d0ee8581ec258() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$75b98419cdf4afa5\n        }));\n}\nfunction $c5679bb0a1fb1418$export$3613a07d2d3c9579() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$5f005e8ee0a28e63() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$295d0ee8581ec258(), $c5679bb0a1fb1418$export$3613a07d2d3c9579());\n}\nfunction $c5679bb0a1fb1418$export$b9e679d86cd108df(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        source: {\n            value: input.source ?? null,\n            isWritable: true\n        },\n        destination: {\n            value: input.destination ?? null,\n            isWritable: true\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.source),\n            getAccountMeta(accounts.destination),\n            getAccountMeta(accounts.authority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$295d0ee8581ec258().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$9154912551f8df09(instruction) {\n    if (instruction.accounts.length < 3) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            source: getNextAccount(),\n            destination: getNextAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$3613a07d2d3c9579().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$c15ae7fe6c775ec5 = 12;\nfunction $c5679bb0a1fb1418$export$c95f4cb40439d9b5() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$c15ae7fe6c775ec5);\n}\nfunction $c5679bb0a1fb1418$export$355a8a69841b0dce() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ],\n        [\n            \"decimals\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$c15ae7fe6c775ec5\n        }));\n}\nfunction $c5679bb0a1fb1418$export$17cf44f1224cb959() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ],\n        [\n            \"decimals\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$fd9f4ec867cc8092() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$355a8a69841b0dce(), $c5679bb0a1fb1418$export$17cf44f1224cb959());\n}\nfunction $c5679bb0a1fb1418$export$ffcdb0514087cfb6(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        source: {\n            value: input.source ?? null,\n            isWritable: true\n        },\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        },\n        destination: {\n            value: input.destination ?? null,\n            isWritable: true\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.source),\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.destination),\n            getAccountMeta(accounts.authority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$355a8a69841b0dce().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$76ca3c30acba68c5(instruction) {\n    if (instruction.accounts.length < 4) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            source: getNextAccount(),\n            mint: getNextAccount(),\n            destination: getNextAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$17cf44f1224cb959().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$8d9b6c8487f0588b = 26;\nfunction $c5679bb0a1fb1418$export$38c3fabfdfe8549c() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$8d9b6c8487f0588b);\n}\nvar $c5679bb0a1fb1418$export$85e24a4435d7b3af = 1;\nfunction $c5679bb0a1fb1418$export$d2a916e6dc4dc312() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$85e24a4435d7b3af);\n}\nfunction $c5679bb0a1fb1418$export$b02d622dd3a8ce48() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"transferFeeDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ],\n        [\n            \"decimals\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"fee\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$8d9b6c8487f0588b,\n            transferFeeDiscriminator: $c5679bb0a1fb1418$export$85e24a4435d7b3af\n        }));\n}\nfunction $c5679bb0a1fb1418$export$614468538860beab() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"transferFeeDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"amount\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ],\n        [\n            \"decimals\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"fee\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$b8bfbd9636d97b0c() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$b02d622dd3a8ce48(), $c5679bb0a1fb1418$export$614468538860beab());\n}\nfunction $c5679bb0a1fb1418$export$8808001b84b59289(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        source: {\n            value: input.source ?? null,\n            isWritable: true\n        },\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        },\n        destination: {\n            value: input.destination ?? null,\n            isWritable: true\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.source),\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.destination),\n            getAccountMeta(accounts.authority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$b02d622dd3a8ce48().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$b7028b249bae3c8f(instruction) {\n    if (instruction.accounts.length < 4) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            source: getNextAccount(),\n            mint: getNextAccount(),\n            destination: getNextAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$614468538860beab().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$8635f315581e1dde = 24;\nfunction $c5679bb0a1fb1418$export$1a14520e1c88975a() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$8635f315581e1dde);\n}\nfunction $c5679bb0a1fb1418$export$c294cfc93b50b2fd() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"uiAmount\",\n            (0, $278ae65923ee60f5$export$9a335ef9e29610a7)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$8635f315581e1dde\n        }));\n}\nfunction $c5679bb0a1fb1418$export$114dd3a034b64abd() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"uiAmount\",\n            (0, $278ae65923ee60f5$export$3cdd8a41d7d6b55d)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$779b4a072b667512() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$c294cfc93b50b2fd(), $c5679bb0a1fb1418$export$114dd3a034b64abd());\n}\nfunction $c5679bb0a1fb1418$export$1bc66bec525bf3a7(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint)\n        ],\n        data: $c5679bb0a1fb1418$export$c294cfc93b50b2fd().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$4bc2a4709221b61f(instruction) {\n    if (instruction.accounts.length < 1) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$114dd3a034b64abd().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$2d2f98d679f1460a = 27;\nfunction $c5679bb0a1fb1418$export$536f4884608d4d38() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$2d2f98d679f1460a);\n}\nvar $c5679bb0a1fb1418$export$ec02b37b2c7c6c26 = 1;\nfunction $c5679bb0a1fb1418$export$d0eb30d6df0d3c68() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$ec02b37b2c7c6c26);\n}\nfunction $c5679bb0a1fb1418$export$769f57d361aaaeef() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"autoApproveNewAccounts\",\n            (0, $991819a0aa439d56$export$4a518d3f98f842eb)()\n        ],\n        [\n            \"auditorElgamalPubkey\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$2d2f98d679f1460a,\n            confidentialTransferDiscriminator: $c5679bb0a1fb1418$export$ec02b37b2c7c6c26\n        }));\n}\nfunction $c5679bb0a1fb1418$export$351d33b81a858de() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"confidentialTransferDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"autoApproveNewAccounts\",\n            (0, $991819a0aa439d56$export$43a73c742ad521e1)()\n        ],\n        [\n            \"auditorElgamalPubkey\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$391ff3d9b493729d() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$769f57d361aaaeef(), $c5679bb0a1fb1418$export$351d33b81a858de());\n}\nfunction $c5679bb0a1fb1418$export$1962a737dd5b1c5f(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.authority)\n        ],\n        data: $c5679bb0a1fb1418$export$769f57d361aaaeef().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$5743046be4f53c8d(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$351d33b81a858de().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$a45154c9844f3df3 = 28;\nfunction $c5679bb0a1fb1418$export$14cb5db96668283f() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$a45154c9844f3df3);\n}\nvar $c5679bb0a1fb1418$export$e562d9203c292edc = 1;\nfunction $c5679bb0a1fb1418$export$e32ecb751603f789() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$e562d9203c292edc);\n}\nfunction $c5679bb0a1fb1418$export$9710248e60079f9b() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"defaultAccountStateDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"state\",\n            $c5679bb0a1fb1418$export$f9e14159fc53d3a0()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$a45154c9844f3df3,\n            defaultAccountStateDiscriminator: $c5679bb0a1fb1418$export$e562d9203c292edc\n        }));\n}\nfunction $c5679bb0a1fb1418$export$48f895099f212994() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"defaultAccountStateDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"state\",\n            $c5679bb0a1fb1418$export$29eadaa90b440d19()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$3b35ea7604ad3365() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$9710248e60079f9b(), $c5679bb0a1fb1418$export$48f895099f212994());\n}\nfunction $c5679bb0a1fb1418$export$15af408de97e12e5(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        },\n        freezeAuthority: {\n            value: input.freezeAuthority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.freezeAuthority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$9710248e60079f9b().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$3555b76329e005ba(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount(),\n            freezeAuthority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$48f895099f212994().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$109759bdfa2bdcbb = 41;\nfunction $c5679bb0a1fb1418$export$38e382904eec6734() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$109759bdfa2bdcbb);\n}\nvar $c5679bb0a1fb1418$export$2a9679e2bd243a9f = 1;\nfunction $c5679bb0a1fb1418$export$18046691acac83a8() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$2a9679e2bd243a9f);\n}\nfunction $c5679bb0a1fb1418$export$56bb7161ff13b59d() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"groupMemberPointerDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"memberAddress\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$109759bdfa2bdcbb,\n            groupMemberPointerDiscriminator: $c5679bb0a1fb1418$export$2a9679e2bd243a9f\n        }));\n}\nfunction $c5679bb0a1fb1418$export$c6f9331aef5a7bb4() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"groupMemberPointerDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"memberAddress\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$75fd4202ea05f57b() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$56bb7161ff13b59d(), $c5679bb0a1fb1418$export$c6f9331aef5a7bb4());\n}\nfunction $c5679bb0a1fb1418$export$c587628b430e24a1(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        },\n        groupMemberPointerAuthority: {\n            value: input.groupMemberPointerAuthority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.groupMemberPointerAuthority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$56bb7161ff13b59d().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$d771b6074ac5f086(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount(),\n            groupMemberPointerAuthority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$c6f9331aef5a7bb4().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$681691126c8ecacd = 40;\nfunction $c5679bb0a1fb1418$export$ce6e5ad532d89af5() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$681691126c8ecacd);\n}\nvar $c5679bb0a1fb1418$export$18791a6471bc373c = 1;\nfunction $c5679bb0a1fb1418$export$c57493143fe49eba() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$18791a6471bc373c);\n}\nfunction $c5679bb0a1fb1418$export$7a451209d61c3322() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"groupPointerDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"groupAddress\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$681691126c8ecacd,\n            groupPointerDiscriminator: $c5679bb0a1fb1418$export$18791a6471bc373c\n        }));\n}\nfunction $c5679bb0a1fb1418$export$6ccf71051eb78788() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"groupPointerDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"groupAddress\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$de77f6793a4f234a() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$7a451209d61c3322(), $c5679bb0a1fb1418$export$6ccf71051eb78788());\n}\nfunction $c5679bb0a1fb1418$export$298d0e2591770352(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        },\n        groupPointerAuthority: {\n            value: input.groupPointerAuthority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.groupPointerAuthority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$7a451209d61c3322().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$1922044e15d46eae(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount(),\n            groupPointerAuthority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$6ccf71051eb78788().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$b4683cffd6acffdd = 39;\nfunction $c5679bb0a1fb1418$export$9049a44a41fe912b() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$b4683cffd6acffdd);\n}\nvar $c5679bb0a1fb1418$export$905623c4ead2c973 = 1;\nfunction $c5679bb0a1fb1418$export$b71301120249aa5b() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$905623c4ead2c973);\n}\nfunction $c5679bb0a1fb1418$export$e2d4788f3287ed59() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"metadataPointerDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"metadataAddress\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$b4683cffd6acffdd,\n            metadataPointerDiscriminator: $c5679bb0a1fb1418$export$905623c4ead2c973\n        }));\n}\nfunction $c5679bb0a1fb1418$export$287436b0304f6c4e() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"metadataPointerDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"metadataAddress\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$574df5098c70d826() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$e2d4788f3287ed59(), $c5679bb0a1fb1418$export$287436b0304f6c4e());\n}\nfunction $c5679bb0a1fb1418$export$5d086ba3e79837fc(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        },\n        metadataPointerAuthority: {\n            value: input.metadataPointerAuthority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.metadataPointerAuthority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$e2d4788f3287ed59().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$899c1dd6ba14afbe(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount(),\n            metadataPointerAuthority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$287436b0304f6c4e().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$80e284be563455e1 = 43;\nfunction $c5679bb0a1fb1418$export$7fc77ddffe62ef12() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$80e284be563455e1);\n}\nvar $c5679bb0a1fb1418$export$c1d1552a87a79a75 = 1;\nfunction $c5679bb0a1fb1418$export$d8b24e0205021e71() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$c1d1552a87a79a75);\n}\nfunction $c5679bb0a1fb1418$export$960ca77d9f99d05b() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"scaledUiAmountMintDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"multiplier\",\n            (0, $b5f941eb9a28d328$export$551368d522177b99)()\n        ],\n        [\n            \"effectiveTimestamp\",\n            (0, $b5f941eb9a28d328$export$42b58a304e7edd67)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$80e284be563455e1,\n            scaledUiAmountMintDiscriminator: $c5679bb0a1fb1418$export$c1d1552a87a79a75\n        }));\n}\nfunction $c5679bb0a1fb1418$export$a26495e42190d25a() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"scaledUiAmountMintDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"multiplier\",\n            (0, $b5f941eb9a28d328$export$9475ae45ddf86dec)()\n        ],\n        [\n            \"effectiveTimestamp\",\n            (0, $b5f941eb9a28d328$export$6f14c9b3a349f404)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$d2190951d038ae0c() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$960ca77d9f99d05b(), $c5679bb0a1fb1418$export$a26495e42190d25a());\n}\nfunction $c5679bb0a1fb1418$export$3539b647dd209d16(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: true\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.authority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$960ca77d9f99d05b().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$8ce9bed7103cd66(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$a26495e42190d25a().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$56428b5fd632676f = 33;\nfunction $c5679bb0a1fb1418$export$e4a4e94b9f26ce02() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$56428b5fd632676f);\n}\nvar $c5679bb0a1fb1418$export$f54dacfe48d5d8bd = 1;\nfunction $c5679bb0a1fb1418$export$d4224d711aa2d289() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$f54dacfe48d5d8bd);\n}\nfunction $c5679bb0a1fb1418$export$5598bdcd7649548b() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"interestBearingMintDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"rate\",\n            (0, $b5f941eb9a28d328$export$45d575c12b2bb6a5)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$56428b5fd632676f,\n            interestBearingMintDiscriminator: $c5679bb0a1fb1418$export$f54dacfe48d5d8bd\n        }));\n}\nfunction $c5679bb0a1fb1418$export$a9fa6fb923269795() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"interestBearingMintDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"rate\",\n            (0, $b5f941eb9a28d328$export$4617ff1e22909f4)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$662508f7b84f9182() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$5598bdcd7649548b(), $c5679bb0a1fb1418$export$a9fa6fb923269795());\n}\nfunction $c5679bb0a1fb1418$export$46e5b5118a0bf925(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        },\n        rateAuthority: {\n            value: input.rateAuthority ?? null,\n            isWritable: true\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.rateAuthority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$5598bdcd7649548b().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$b0e21a2a8be7b51c(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount(),\n            rateAuthority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$a9fa6fb923269795().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$f2185c992656b17d = new Uint8Array([\n    108,\n    37,\n    171,\n    143,\n    248,\n    30,\n    18,\n    110\n]);\nfunction $c5679bb0a1fb1418$export$b923b5c5b3b0266e() {\n    return (0, $991819a0aa439d56$export$636c51ad84d0674a)().encode($c5679bb0a1fb1418$export$f2185c992656b17d);\n}\nfunction $c5679bb0a1fb1418$export$409cef0f0b46456e() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $991819a0aa439d56$export$636c51ad84d0674a)()\n        ],\n        [\n            \"maxSize\",\n            (0, $b5f941eb9a28d328$export$59d3bc8d559487ec)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$f2185c992656b17d\n        }));\n}\nfunction $c5679bb0a1fb1418$export$7dc0839ebf862b01() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $991819a0aa439d56$export$b90e67818b1b3d45)()\n        ],\n        [\n            \"maxSize\",\n            (0, $b5f941eb9a28d328$export$faa05ffebebd465d)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$b2853b79e1b261fc() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$409cef0f0b46456e(), $c5679bb0a1fb1418$export$7dc0839ebf862b01());\n}\nfunction $c5679bb0a1fb1418$export$27566f84aaaa4c8f(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        group: {\n            value: input.group ?? null,\n            isWritable: true\n        },\n        updateAuthority: {\n            value: input.updateAuthority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.group),\n            getAccountMeta(accounts.updateAuthority)\n        ],\n        data: $c5679bb0a1fb1418$export$409cef0f0b46456e().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$93993e7cf1de6694(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            group: getNextAccount(),\n            updateAuthority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$7dc0839ebf862b01().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$147386516ae3428 = new Uint8Array([\n    161,\n    105,\n    88,\n    1,\n    237,\n    221,\n    216,\n    203\n]);\nfunction $c5679bb0a1fb1418$export$8f5b58b499a4921c() {\n    return (0, $991819a0aa439d56$export$636c51ad84d0674a)().encode($c5679bb0a1fb1418$export$147386516ae3428);\n}\nfunction $c5679bb0a1fb1418$export$67ab23b12f79b36f() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $991819a0aa439d56$export$636c51ad84d0674a)()\n        ],\n        [\n            \"newUpdateAuthority\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$147386516ae3428\n        }));\n}\nfunction $c5679bb0a1fb1418$export$c9cf221862c64733() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $991819a0aa439d56$export$b90e67818b1b3d45)()\n        ],\n        [\n            \"newUpdateAuthority\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$18107cbfd2b670ca() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$67ab23b12f79b36f(), $c5679bb0a1fb1418$export$c9cf221862c64733());\n}\nfunction $c5679bb0a1fb1418$export$78a123c083d3791f(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        group: {\n            value: input.group ?? null,\n            isWritable: true\n        },\n        updateAuthority: {\n            value: input.updateAuthority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.group),\n            getAccountMeta(accounts.updateAuthority)\n        ],\n        data: $c5679bb0a1fb1418$export$67ab23b12f79b36f().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$b94a81ff6dcd636d(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            group: getNextAccount(),\n            updateAuthority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$c9cf221862c64733().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$40cac473101387a3 = new Uint8Array([\n    221,\n    233,\n    49,\n    45,\n    181,\n    202,\n    220,\n    200\n]);\nfunction $c5679bb0a1fb1418$export$fbbb6ef82b297261() {\n    return (0, $991819a0aa439d56$export$636c51ad84d0674a)().encode($c5679bb0a1fb1418$export$40cac473101387a3);\n}\nfunction $c5679bb0a1fb1418$export$4e4e9d03b016ac4e() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $991819a0aa439d56$export$636c51ad84d0674a)()\n        ],\n        [\n            \"field\",\n            $c5679bb0a1fb1418$export$e5db494efe819c74()\n        ],\n        [\n            \"value\",\n            (0, $b9bc3aaa401ff82b$export$37e5b12cb5a8d560)((0, $278ae65923ee60f5$export$9a335ef9e29610a7)(), (0, $b5f941eb9a28d328$export$3e3136013a349951)())\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$40cac473101387a3\n        }));\n}\nfunction $c5679bb0a1fb1418$export$f85317fb46e3b42f() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $991819a0aa439d56$export$b90e67818b1b3d45)()\n        ],\n        [\n            \"field\",\n            $c5679bb0a1fb1418$export$24bf2a22886c19e0()\n        ],\n        [\n            \"value\",\n            (0, $b9bc3aaa401ff82b$export$fe2b33c81523b294)((0, $278ae65923ee60f5$export$3cdd8a41d7d6b55d)(), (0, $b5f941eb9a28d328$export$ddc26825031b1ac9)())\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$bc7dca74c7980e91() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$4e4e9d03b016ac4e(), $c5679bb0a1fb1418$export$f85317fb46e3b42f());\n}\nfunction $c5679bb0a1fb1418$export$1446fe25a6d8010f(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        metadata: {\n            value: input.metadata ?? null,\n            isWritable: true\n        },\n        updateAuthority: {\n            value: input.updateAuthority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.metadata),\n            getAccountMeta(accounts.updateAuthority)\n        ],\n        data: $c5679bb0a1fb1418$export$4e4e9d03b016ac4e().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$2dabd45c3f68a8fb(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            metadata: getNextAccount(),\n            updateAuthority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$f85317fb46e3b42f().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$764ef7ff6f304bfd = new Uint8Array([\n    215,\n    228,\n    166,\n    228,\n    84,\n    100,\n    86,\n    123\n]);\nfunction $c5679bb0a1fb1418$export$729050ecfb5650a1() {\n    return (0, $991819a0aa439d56$export$636c51ad84d0674a)().encode($c5679bb0a1fb1418$export$764ef7ff6f304bfd);\n}\nfunction $c5679bb0a1fb1418$export$ab4c318d52090959() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $991819a0aa439d56$export$636c51ad84d0674a)()\n        ],\n        [\n            \"newUpdateAuthority\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$764ef7ff6f304bfd\n        }));\n}\nfunction $c5679bb0a1fb1418$export$3a904d3a2f3711aa() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $991819a0aa439d56$export$b90e67818b1b3d45)()\n        ],\n        [\n            \"newUpdateAuthority\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$abb82841df5f3c3f() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$ab4c318d52090959(), $c5679bb0a1fb1418$export$3a904d3a2f3711aa());\n}\nfunction $c5679bb0a1fb1418$export$1676eedb680e812a(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        metadata: {\n            value: input.metadata ?? null,\n            isWritable: true\n        },\n        updateAuthority: {\n            value: input.updateAuthority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.metadata),\n            getAccountMeta(accounts.updateAuthority)\n        ],\n        data: $c5679bb0a1fb1418$export$ab4c318d52090959().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$ad1ac73eec411630(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            metadata: getNextAccount(),\n            updateAuthority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$3a904d3a2f3711aa().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$fc04c21cb328cb37 = 36;\nfunction $c5679bb0a1fb1418$export$e6fc0087d831d9a7() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$fc04c21cb328cb37);\n}\nvar $c5679bb0a1fb1418$export$9c1c73e3543e4a61 = 1;\nfunction $c5679bb0a1fb1418$export$f92691c43a8c95a8() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$9c1c73e3543e4a61);\n}\nfunction $c5679bb0a1fb1418$export$f0aa09850843c2cd() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"transferHookDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"programId\",\n            (0, $6e02c1c9c7315aa4$export$99f28d5468429524)((0, $fadd3f4c7539d2fa$export$796121a945d5c29b)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$fc04c21cb328cb37,\n            transferHookDiscriminator: $c5679bb0a1fb1418$export$9c1c73e3543e4a61\n        }));\n}\nfunction $c5679bb0a1fb1418$export$aa6ca63f7707a876() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"transferHookDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"programId\",\n            (0, $6e02c1c9c7315aa4$export$9e19f3834a721c2f)((0, $fadd3f4c7539d2fa$export$5fd6a09ea9008295)(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n            })\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$9d88af100b965dbb() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$f0aa09850843c2cd(), $c5679bb0a1fb1418$export$aa6ca63f7707a876());\n}\nfunction $c5679bb0a1fb1418$export$5ba9c0cb98fa3e71(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.authority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$f0aa09850843c2cd().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$44d2f260a5867560(instruction) {\n    if (instruction.accounts.length < 2) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$aa6ca63f7707a876().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$c4d14caace497cd4 = 38;\nfunction $c5679bb0a1fb1418$export$de99e6f4d207060c() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$c4d14caace497cd4);\n}\nfunction $c5679bb0a1fb1418$export$fabc2cf96230adcf() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$c4d14caace497cd4\n        }));\n}\nfunction $c5679bb0a1fb1418$export$120187f9a9b4fc1c() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$78b7fd454feee4b9() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$fabc2cf96230adcf(), $c5679bb0a1fb1418$export$120187f9a9b4fc1c());\n}\nfunction $c5679bb0a1fb1418$export$e3a14b45c6154a5c(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        sourceAccount: {\n            value: input.sourceAccount ?? null,\n            isWritable: true\n        },\n        destinationAccount: {\n            value: input.destinationAccount ?? null,\n            isWritable: true\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.sourceAccount),\n            getAccountMeta(accounts.destinationAccount),\n            getAccountMeta(accounts.authority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$fabc2cf96230adcf().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$4b2e652185c392e4(instruction) {\n    if (instruction.accounts.length < 3) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            sourceAccount: getNextAccount(),\n            destinationAccount: getNextAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$120187f9a9b4fc1c().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$7f3b5473ae6ea2ed = 26;\nfunction $c5679bb0a1fb1418$export$2f9230d4f1b5acc5() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$7f3b5473ae6ea2ed);\n}\nvar $c5679bb0a1fb1418$export$b6d4f99a9b8a8e13 = 3;\nfunction $c5679bb0a1fb1418$export$af56d8ac4d960b56() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$b6d4f99a9b8a8e13);\n}\nfunction $c5679bb0a1fb1418$export$551fe8eee1e6a74e() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"transferFeeDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"numTokenAccounts\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$7f3b5473ae6ea2ed,\n            transferFeeDiscriminator: $c5679bb0a1fb1418$export$b6d4f99a9b8a8e13\n        }));\n}\nfunction $c5679bb0a1fb1418$export$9749017fb349aff7() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"transferFeeDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"numTokenAccounts\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$42d2655797877f3b() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$551fe8eee1e6a74e(), $c5679bb0a1fb1418$export$9749017fb349aff7());\n}\nfunction $c5679bb0a1fb1418$export$fd7c254fa602cd91(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        },\n        feeReceiver: {\n            value: input.feeReceiver ?? null,\n            isWritable: true\n        },\n        withdrawWithheldAuthority: {\n            value: input.withdrawWithheldAuthority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = [\n        ...(args.multiSigners ?? []).map((signer)=>({\n                address: signer.address,\n                role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n                signer: signer\n            })),\n        ...args.sources.map((address)=>({\n                address: address,\n                role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).WRITABLE\n            }))\n    ];\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.feeReceiver),\n            getAccountMeta(accounts.withdrawWithheldAuthority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$551fe8eee1e6a74e().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$18fff1fda531ea3b(instruction) {\n    if (instruction.accounts.length < 3) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount(),\n            feeReceiver: getNextAccount(),\n            withdrawWithheldAuthority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$9749017fb349aff7().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$d7acfe7e58bf4e79 = 37;\nfunction $c5679bb0a1fb1418$export$3efd672c027b358c() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$d7acfe7e58bf4e79);\n}\nvar $c5679bb0a1fb1418$export$841cce58b76428a5 = 2;\nfunction $c5679bb0a1fb1418$export$3c699a960043ca02() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$841cce58b76428a5);\n}\nfunction $c5679bb0a1fb1418$export$d885d9af91fc458b() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"confidentialTransferFeeDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"numTokenAccounts\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"proofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$44792a8c35b3c0ce)()\n        ],\n        [\n            \"newDecryptableAvailableBalance\",\n            $c5679bb0a1fb1418$export$81b4437e7425f22a()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$d7acfe7e58bf4e79,\n            confidentialTransferFeeDiscriminator: $c5679bb0a1fb1418$export$841cce58b76428a5\n        }));\n}\nfunction $c5679bb0a1fb1418$export$f37c4d92ba854a7a() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"confidentialTransferFeeDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"numTokenAccounts\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"proofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$fdc22c4a59dfe6be)()\n        ],\n        [\n            \"newDecryptableAvailableBalance\",\n            $c5679bb0a1fb1418$export$2dde3d52f3fe8173()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$b708ce3b8c357f70() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$d885d9af91fc458b(), $c5679bb0a1fb1418$export$f37c4d92ba854a7a());\n}\nfunction $c5679bb0a1fb1418$export$305a590436f201eb(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: false\n        },\n        destination: {\n            value: input.destination ?? null,\n            isWritable: true\n        },\n        instructionsSysvarOrContextState: {\n            value: input.instructionsSysvarOrContextState ?? null,\n            isWritable: false\n        },\n        record: {\n            value: input.record ?? null,\n            isWritable: false\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.destination),\n            getAccountMeta(accounts.instructionsSysvarOrContextState),\n            getAccountMeta(accounts.record),\n            getAccountMeta(accounts.authority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$d885d9af91fc458b().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$1c3e9a53d35d85b3(instruction) {\n    if (instruction.accounts.length < 5) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    const getNextOptionalAccount = ()=>{\n        const accountMeta = getNextAccount();\n        return accountMeta.address === $c5679bb0a1fb1418$export$69a22f9c8498afc2 ? void 0 : accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount(),\n            destination: getNextAccount(),\n            instructionsSysvarOrContextState: getNextAccount(),\n            record: getNextOptionalAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$f37c4d92ba854a7a().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$aae167bce0cf9d1c = 26;\nfunction $c5679bb0a1fb1418$export$9011106a4fb3a7ad() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$aae167bce0cf9d1c);\n}\nvar $c5679bb0a1fb1418$export$aef3f67e2ed3a9b3 = 2;\nfunction $c5679bb0a1fb1418$export$20729caa1a41d2f3() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$aef3f67e2ed3a9b3);\n}\nfunction $c5679bb0a1fb1418$export$d67a8cdbc3c2b64f() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"transferFeeDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$aae167bce0cf9d1c,\n            transferFeeDiscriminator: $c5679bb0a1fb1418$export$aef3f67e2ed3a9b3\n        }));\n}\nfunction $c5679bb0a1fb1418$export$6529138fe9f55add() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"transferFeeDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$bbc1139c8267f540() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$d67a8cdbc3c2b64f(), $c5679bb0a1fb1418$export$6529138fe9f55add());\n}\nfunction $c5679bb0a1fb1418$export$df61b76b9445e422(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        },\n        feeReceiver: {\n            value: input.feeReceiver ?? null,\n            isWritable: true\n        },\n        withdrawWithheldAuthority: {\n            value: input.withdrawWithheldAuthority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.feeReceiver),\n            getAccountMeta(accounts.withdrawWithheldAuthority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$d67a8cdbc3c2b64f().encode({}),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$d500648cd9a81bc7(instruction) {\n    if (instruction.accounts.length < 3) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount(),\n            feeReceiver: getNextAccount(),\n            withdrawWithheldAuthority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$6529138fe9f55add().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$export$5072cbccdddde4df = 37;\nfunction $c5679bb0a1fb1418$export$e84543c2e0cbf1c5() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$5072cbccdddde4df);\n}\nvar $c5679bb0a1fb1418$export$68f92f58627d6949 = 1;\nfunction $c5679bb0a1fb1418$export$3844acd467020c57() {\n    return (0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode($c5679bb0a1fb1418$export$68f92f58627d6949);\n}\nfunction $c5679bb0a1fb1418$export$d170cab0f56f6264() {\n    return (0, $b9bc3aaa401ff82b$export$30169aca64409a56)((0, $991819a0aa439d56$export$64024546a32014b8)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"confidentialTransferFeeDiscriminator\",\n            (0, $b5f941eb9a28d328$export$dc9732115561fb4b)()\n        ],\n        [\n            \"proofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$44792a8c35b3c0ce)()\n        ],\n        [\n            \"newDecryptableAvailableBalance\",\n            $c5679bb0a1fb1418$export$81b4437e7425f22a()\n        ]\n    ]), (value)=>({\n            ...value,\n            discriminator: $c5679bb0a1fb1418$export$5072cbccdddde4df,\n            confidentialTransferFeeDiscriminator: $c5679bb0a1fb1418$export$68f92f58627d6949\n        }));\n}\nfunction $c5679bb0a1fb1418$export$2fe825661968b77d() {\n    return (0, $991819a0aa439d56$export$7070fbe048971470)([\n        [\n            \"discriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"confidentialTransferFeeDiscriminator\",\n            (0, $b5f941eb9a28d328$export$edadf68f5f1a8bc6)()\n        ],\n        [\n            \"proofInstructionOffset\",\n            (0, $b5f941eb9a28d328$export$fdc22c4a59dfe6be)()\n        ],\n        [\n            \"newDecryptableAvailableBalance\",\n            $c5679bb0a1fb1418$export$2dde3d52f3fe8173()\n        ]\n    ]);\n}\nfunction $c5679bb0a1fb1418$export$2d4e7565c51f9979() {\n    return (0, $b9bc3aaa401ff82b$export$b88681b853abde79)($c5679bb0a1fb1418$export$d170cab0f56f6264(), $c5679bb0a1fb1418$export$2fe825661968b77d());\n}\nfunction $c5679bb0a1fb1418$export$be00f8326c59f95e(input, config) {\n    const programAddress = config?.programAddress ?? $c5679bb0a1fb1418$export$69a22f9c8498afc2;\n    const originalAccounts = {\n        mint: {\n            value: input.mint ?? null,\n            isWritable: true\n        },\n        destination: {\n            value: input.destination ?? null,\n            isWritable: true\n        },\n        instructionsSysvarOrContextState: {\n            value: input.instructionsSysvarOrContextState ?? null,\n            isWritable: false\n        },\n        record: {\n            value: input.record ?? null,\n            isWritable: false\n        },\n        authority: {\n            value: input.authority ?? null,\n            isWritable: false\n        }\n    };\n    const accounts = originalAccounts;\n    const args = {\n        ...input\n    };\n    const remainingAccounts = (args.multiSigners ?? []).map((signer)=>({\n            address: signer.address,\n            role: (0, $bc6d449c2ea12356$export$ee58f0c89e8fce3b).READONLY_SIGNER,\n            signer: signer\n        }));\n    const getAccountMeta = $c5679bb0a1fb1418$var$getAccountMetaFactory(programAddress);\n    return Object.freeze({\n        accounts: [\n            getAccountMeta(accounts.mint),\n            getAccountMeta(accounts.destination),\n            getAccountMeta(accounts.instructionsSysvarOrContextState),\n            getAccountMeta(accounts.record),\n            getAccountMeta(accounts.authority),\n            ...remainingAccounts\n        ],\n        data: $c5679bb0a1fb1418$export$d170cab0f56f6264().encode(args),\n        programAddress: programAddress\n    });\n}\nfunction $c5679bb0a1fb1418$export$cdef91d872a1c8ab(instruction) {\n    if (instruction.accounts.length < 5) throw new Error(\"Not enough accounts\");\n    let accountIndex = 0;\n    const getNextAccount = ()=>{\n        const accountMeta = instruction.accounts[accountIndex];\n        accountIndex += 1;\n        return accountMeta;\n    };\n    const getNextOptionalAccount = ()=>{\n        const accountMeta = getNextAccount();\n        return accountMeta.address === $c5679bb0a1fb1418$export$69a22f9c8498afc2 ? void 0 : accountMeta;\n    };\n    return {\n        programAddress: instruction.programAddress,\n        accounts: {\n            mint: getNextAccount(),\n            destination: getNextAccount(),\n            instructionsSysvarOrContextState: getNextAccount(),\n            record: getNextOptionalAccount(),\n            authority: getNextAccount()\n        },\n        data: $c5679bb0a1fb1418$export$2fe825661968b77d().decode(instruction.data)\n    };\n}\nvar $c5679bb0a1fb1418$var$ONE_IN_BASIS_POINTS = 1e4;\nvar $c5679bb0a1fb1418$var$SECONDS_PER_YEAR = 31556736;\nfunction $c5679bb0a1fb1418$var$calculateExponentForTimesAndRate(t1, t2, r) {\n    const timespan = t2 - t1;\n    if (timespan < 0) throw new Error(\"Invalid timespan: end time before start time\");\n    const numerator = r * timespan;\n    const exponent = numerator / ($c5679bb0a1fb1418$var$SECONDS_PER_YEAR * $c5679bb0a1fb1418$var$ONE_IN_BASIS_POINTS);\n    return Math.exp(exponent);\n}\nfunction $c5679bb0a1fb1418$var$calculateTotalScale({ currentTimestamp: currentTimestamp, lastUpdateTimestamp: lastUpdateTimestamp, initializationTimestamp: initializationTimestamp, preUpdateAverageRate: preUpdateAverageRate, currentRate: currentRate }) {\n    const preUpdateExp = $c5679bb0a1fb1418$var$calculateExponentForTimesAndRate(initializationTimestamp, lastUpdateTimestamp, preUpdateAverageRate);\n    const postUpdateExp = $c5679bb0a1fb1418$var$calculateExponentForTimesAndRate(lastUpdateTimestamp, currentTimestamp, currentRate);\n    return preUpdateExp * postUpdateExp;\n}\nfunction $c5679bb0a1fb1418$var$getDecimalFactor(decimals) {\n    return Math.pow(10, decimals);\n}\nasync function $c5679bb0a1fb1418$var$getSysvarClockTimestamp(rpc) {\n    const info = await (0, $ea79aff0bcfab408$export$7a194c048c5290ae)(rpc);\n    if (!info) throw new Error(\"Failed to fetch sysvar clock\");\n    return info.unixTimestamp;\n}\nfunction $c5679bb0a1fb1418$export$e2f836438acfd4f5(amount, decimals, currentTimestamp, lastUpdateTimestamp, initializationTimestamp, preUpdateAverageRate, currentRate) {\n    const totalScale = $c5679bb0a1fb1418$var$calculateTotalScale({\n        currentTimestamp: currentTimestamp,\n        lastUpdateTimestamp: lastUpdateTimestamp,\n        initializationTimestamp: initializationTimestamp,\n        preUpdateAverageRate: preUpdateAverageRate,\n        currentRate: currentRate\n    });\n    const scaledAmount = Number(amount) * totalScale;\n    const decimalFactor = $c5679bb0a1fb1418$var$getDecimalFactor(decimals);\n    return (Math.trunc(scaledAmount) / decimalFactor).toString();\n}\nfunction $c5679bb0a1fb1418$export$4b37b866f31364c7(uiAmount, decimals, currentTimestamp, lastUpdateTimestamp, initializationTimestamp, preUpdateAverageRate, currentRate) {\n    const uiAmountNumber = parseFloat(uiAmount);\n    const decimalsFactor = $c5679bb0a1fb1418$var$getDecimalFactor(decimals);\n    const uiAmountScaled = uiAmountNumber * decimalsFactor;\n    const totalScale = $c5679bb0a1fb1418$var$calculateTotalScale({\n        currentTimestamp: currentTimestamp,\n        lastUpdateTimestamp: lastUpdateTimestamp,\n        initializationTimestamp: initializationTimestamp,\n        preUpdateAverageRate: preUpdateAverageRate,\n        currentRate: currentRate\n    });\n    const originalPrincipal = uiAmountScaled / totalScale;\n    return BigInt(Math.trunc(originalPrincipal));\n}\nfunction $c5679bb0a1fb1418$export$939bcff2a9c7239b(amount, decimals, multiplier) {\n    const scaledAmount = Number(amount) * multiplier;\n    const decimalFactor = $c5679bb0a1fb1418$var$getDecimalFactor(decimals);\n    return (Math.trunc(scaledAmount) / decimalFactor).toString();\n}\nfunction $c5679bb0a1fb1418$export$29ef2ef9c3150a24(uiAmount, decimals, multiplier) {\n    const uiAmountNumber = parseFloat(uiAmount);\n    const decimalsFactor = $c5679bb0a1fb1418$var$getDecimalFactor(decimals);\n    const uiAmountScaled = uiAmountNumber * decimalsFactor;\n    const rawAmount = uiAmountScaled / multiplier;\n    return BigInt(Math.trunc(rawAmount));\n}\nasync function $c5679bb0a1fb1418$export$b1eb2fa9ec3b2878(rpc, mint, amount) {\n    const accountInfo = await $c5679bb0a1fb1418$export$b7c99361c5bcd3c4(rpc, mint);\n    const extensions = (0, $6e02c1c9c7315aa4$export$48e5a1ea856d8959)(accountInfo.data.extensions);\n    const interestBearingMintConfigState = extensions?.find((ext)=>ext.__kind === \"InterestBearingConfig\");\n    const scaledUiAmountConfig = extensions?.find((ext)=>ext.__kind === \"ScaledUiAmountConfig\");\n    if (!interestBearingMintConfigState && !scaledUiAmountConfig) {\n        const amountNumber = Number(amount);\n        const decimalsFactor = $c5679bb0a1fb1418$var$getDecimalFactor(accountInfo.data.decimals);\n        return (amountNumber / decimalsFactor).toString();\n    }\n    const timestamp = await $c5679bb0a1fb1418$var$getSysvarClockTimestamp(rpc);\n    if (interestBearingMintConfigState) return $c5679bb0a1fb1418$export$e2f836438acfd4f5(amount, accountInfo.data.decimals, Number(timestamp), Number(interestBearingMintConfigState.lastUpdateTimestamp), Number(interestBearingMintConfigState.initializationTimestamp), interestBearingMintConfigState.preUpdateAverageRate, interestBearingMintConfigState.currentRate);\n    if (scaledUiAmountConfig) {\n        let multiplier = scaledUiAmountConfig.multiplier;\n        if (timestamp >= scaledUiAmountConfig.newMultiplierEffectiveTimestamp) multiplier = scaledUiAmountConfig.newMultiplier;\n        return $c5679bb0a1fb1418$export$939bcff2a9c7239b(amount, accountInfo.data.decimals, multiplier);\n    }\n    throw new Error(\"Unknown mint extension type\");\n}\nasync function $c5679bb0a1fb1418$export$cb4bcaba0adacfe1(rpc, mint, uiAmount) {\n    const accountInfo = await $c5679bb0a1fb1418$export$b7c99361c5bcd3c4(rpc, mint);\n    const extensions = (0, $6e02c1c9c7315aa4$export$48e5a1ea856d8959)(accountInfo.data.extensions);\n    const interestBearingMintConfigState = extensions?.find((ext)=>ext.__kind === \"InterestBearingConfig\");\n    const scaledUiAmountConfig = extensions?.find((ext)=>ext.__kind === \"ScaledUiAmountConfig\");\n    if (!interestBearingMintConfigState && !scaledUiAmountConfig) {\n        const uiAmountScaled = parseFloat(uiAmount) * $c5679bb0a1fb1418$var$getDecimalFactor(accountInfo.data.decimals);\n        return BigInt(Math.trunc(uiAmountScaled));\n    }\n    const timestamp = await $c5679bb0a1fb1418$var$getSysvarClockTimestamp(rpc);\n    if (interestBearingMintConfigState) return $c5679bb0a1fb1418$export$4b37b866f31364c7(uiAmount, accountInfo.data.decimals, Number(timestamp), Number(interestBearingMintConfigState.lastUpdateTimestamp), Number(interestBearingMintConfigState.initializationTimestamp), interestBearingMintConfigState.preUpdateAverageRate, interestBearingMintConfigState.currentRate);\n    if (scaledUiAmountConfig) {\n        let multiplier = scaledUiAmountConfig.multiplier;\n        if (timestamp >= scaledUiAmountConfig.newMultiplierEffectiveTimestamp) multiplier = scaledUiAmountConfig.newMultiplier;\n        return $c5679bb0a1fb1418$export$29ef2ef9c3150a24(uiAmount, accountInfo.data.decimals, multiplier);\n    }\n    throw new Error(\"Unknown mint extension type\");\n}\nfunction $c5679bb0a1fb1418$export$e512e1f738360c74(mint, extensions) {\n    return extensions.flatMap((extension2)=>{\n        switch(extension2.__kind){\n            case \"ConfidentialTransferMint\":\n                return [\n                    $c5679bb0a1fb1418$export$634202b834563c0f({\n                        mint: mint,\n                        ...extension2\n                    })\n                ];\n            case \"DefaultAccountState\":\n                return [\n                    $c5679bb0a1fb1418$export$a8ea1c3438c55128({\n                        mint: mint,\n                        state: extension2.state\n                    })\n                ];\n            case \"TransferFeeConfig\":\n                return [\n                    $c5679bb0a1fb1418$export$8899a815a341ab7c({\n                        mint: mint,\n                        transferFeeConfigAuthority: extension2.transferFeeConfigAuthority,\n                        withdrawWithheldAuthority: extension2.withdrawWithheldAuthority,\n                        transferFeeBasisPoints: extension2.newerTransferFee.transferFeeBasisPoints,\n                        maximumFee: extension2.newerTransferFee.maximumFee\n                    })\n                ];\n            case \"MetadataPointer\":\n                return [\n                    $c5679bb0a1fb1418$export$98091d89edb1c896({\n                        mint: mint,\n                        authority: extension2.authority,\n                        metadataAddress: extension2.metadataAddress\n                    })\n                ];\n            case \"InterestBearingConfig\":\n                return [\n                    $c5679bb0a1fb1418$export$abccf7436549cfec({\n                        mint: mint,\n                        rateAuthority: extension2.rateAuthority,\n                        rate: extension2.currentRate\n                    })\n                ];\n            case \"ScaledUiAmountConfig\":\n                return [\n                    $c5679bb0a1fb1418$export$68eb84d84fe02bce({\n                        mint: mint,\n                        authority: extension2.authority,\n                        multiplier: extension2.multiplier\n                    })\n                ];\n            case \"PausableConfig\":\n                return [\n                    $c5679bb0a1fb1418$export$b2e98ec3a47e1c0({\n                        mint: mint,\n                        authority: extension2.authority\n                    })\n                ];\n            case \"GroupPointer\":\n                return [\n                    $c5679bb0a1fb1418$export$a4a60f2639d19029({\n                        mint: mint,\n                        authority: extension2.authority,\n                        groupAddress: extension2.groupAddress\n                    })\n                ];\n            case \"GroupMemberPointer\":\n                return [\n                    $c5679bb0a1fb1418$export$75abb159f3515b7e({\n                        mint: mint,\n                        authority: extension2.authority,\n                        memberAddress: extension2.memberAddress\n                    })\n                ];\n            case \"NonTransferable\":\n                return $c5679bb0a1fb1418$export$ac1a58f62963653a({\n                    mint: mint\n                });\n            case \"TransferHook\":\n                return [\n                    $c5679bb0a1fb1418$export$a108bc5213efc88({\n                        mint: mint,\n                        authority: extension2.authority,\n                        programId: extension2.programId\n                    })\n                ];\n            case \"PermanentDelegate\":\n                return $c5679bb0a1fb1418$export$6153a362f05db84e({\n                    mint: mint,\n                    delegate: extension2.delegate\n                });\n            case \"ConfidentialTransferFee\":\n                return [\n                    $c5679bb0a1fb1418$export$aa445251c7ee9e1b({\n                        mint: mint,\n                        authority: extension2.authority,\n                        withdrawWithheldAuthorityElGamalPubkey: extension2.elgamalPubkey\n                    })\n                ];\n            case \"MintCloseAuthority\":\n                return $c5679bb0a1fb1418$export$6614c4db099c7ca5({\n                    closeAuthority: extension2.closeAuthority,\n                    mint: mint\n                });\n            default:\n                return [];\n        }\n    });\n}\nfunction $c5679bb0a1fb1418$export$24d04793bceca37c(mint, authority, extensions) {\n    return extensions.flatMap((extension2)=>{\n        switch(extension2.__kind){\n            case \"TokenMetadata\":\n                const tokenMetadataUpdateAuthority = (0, $6e02c1c9c7315aa4$export$707cacfe2982dfac)(extension2.updateAuthority) ? extension2.updateAuthority : (0, $6e02c1c9c7315aa4$export$44ac850edddcd9ae)(extension2.updateAuthority);\n                if ((0, $6e02c1c9c7315aa4$export$e56af863d5645d5f)(tokenMetadataUpdateAuthority)) return [];\n                return [\n                    $c5679bb0a1fb1418$export$7ef0f7bf81d67d5d({\n                        metadata: mint,\n                        updateAuthority: tokenMetadataUpdateAuthority.value,\n                        mint: mint,\n                        mintAuthority: authority,\n                        name: extension2.name,\n                        symbol: extension2.symbol,\n                        uri: extension2.uri\n                    })\n                ];\n            case \"TokenGroup\":\n                return [\n                    $c5679bb0a1fb1418$export$238224b885f6d1b1({\n                        group: mint,\n                        updateAuthority: (0, $6e02c1c9c7315aa4$export$707cacfe2982dfac)(extension2.updateAuthority) ? extension2.updateAuthority : (0, $6e02c1c9c7315aa4$export$44ac850edddcd9ae)(extension2.updateAuthority),\n                        mint: mint,\n                        mintAuthority: authority,\n                        maxSize: extension2.maxSize\n                    })\n                ];\n            default:\n                return [];\n        }\n    });\n}\nfunction $c5679bb0a1fb1418$export$a048c1400d9550cd(token, owner, extensions, multiSigners) {\n    return extensions.flatMap((extension2)=>{\n        switch(extension2.__kind){\n            case \"MemoTransfer\":\n                return [\n                    extension2.requireIncomingTransferMemos ? $c5679bb0a1fb1418$export$59eff0fb1c207a5f({\n                        owner: owner,\n                        token: token,\n                        multiSigners: multiSigners\n                    }) : $c5679bb0a1fb1418$export$7a58b03d49f6b3ba({\n                        owner: owner,\n                        token: token,\n                        multiSigners: multiSigners\n                    })\n                ];\n            case \"CpiGuard\":\n                return [\n                    extension2.lockCpi ? $c5679bb0a1fb1418$export$12db32a5c36ebc48({\n                        owner: owner,\n                        token: token,\n                        multiSigners: multiSigners\n                    }) : $c5679bb0a1fb1418$export$2fe579cccef3cafb({\n                        owner: owner,\n                        token: token,\n                        multiSigners: multiSigners\n                    })\n                ];\n            default:\n                return [];\n        }\n    });\n}\nvar $c5679bb0a1fb1418$var$TOKEN_BASE_SIZE = 165;\nfunction $c5679bb0a1fb1418$export$a77a95e33e4ff316(extensions) {\n    if (extensions == null) return $c5679bb0a1fb1418$var$TOKEN_BASE_SIZE;\n    const tvlEncoder = (0, $991819a0aa439d56$export$e68e10087ec64330)((0, $991819a0aa439d56$export$415199198053c0b)($c5679bb0a1fb1418$export$554cb049ed2dcdf0(), {\n        size: \"remainder\"\n    }), [\n        (0, $991819a0aa439d56$export$23a212060029ca97)((0, $b5f941eb9a28d328$export$dc9732115561fb4b)().encode(2))\n    ]);\n    return $c5679bb0a1fb1418$var$TOKEN_BASE_SIZE + tvlEncoder.encode(extensions).length;\n}\nvar $c5679bb0a1fb1418$var$MINT_BASE_SIZE = 82;\nfunction $c5679bb0a1fb1418$export$15836f9b2a1ed332(extensions) {\n    if (extensions == null) return $c5679bb0a1fb1418$var$MINT_BASE_SIZE;\n    const tvlEncoder = (0, $991819a0aa439d56$export$e68e10087ec64330)((0, $991819a0aa439d56$export$415199198053c0b)($c5679bb0a1fb1418$export$554cb049ed2dcdf0(), {\n        size: \"remainder\"\n    }), [\n        (0, $991819a0aa439d56$export$23a212060029ca97)((0, $b9bc3aaa401ff82b$export$66b1746799cd3030)((0, $b5f941eb9a28d328$export$dc9732115561fb4b)(), 83).encode(1))\n    ]);\n    return $c5679bb0a1fb1418$var$MINT_BASE_SIZE + tvlEncoder.encode(extensions).length;\n}\n //# sourceMappingURL=index.mjs.map\n\n\n\ndocument.addEventListener(\"DOMContentLoaded\", ()=>{\n    const ownerAddressInput = document.getElementById(\"ownerAddress\");\n    const mintIdInput = document.getElementById(\"mintId\");\n    const resultsDiv = document.getElementById(\"results\");\n    const errorDiv = document.getElementById(\"error\");\n    const tokenAtaDiv = document.getElementById(\"tokenAta\");\n    const token2022AtaDiv = document.getElementById(\"token2022Ata\");\n    const container = document.querySelector(\".container\");\n    console.log(\"ATA Utils initialized\");\n    // Function to compute and display results\n    const updateResults = async ()=>{\n        const ownerAddress = ownerAddressInput.value.trim();\n        const mintId = mintIdInput.value.trim();\n        // Hide results and errors\n        resultsDiv.style.display = \"none\";\n        errorDiv.style.display = \"none\";\n        // Only proceed if both fields are filled\n        if (!ownerAddress || !mintId) return;\n        try {\n            // Add loading state\n            container.classList.add(\"loading\");\n            // Compute ATAs\n            const result = await $b4e14b6b8da86996$var$computeAllAta(ownerAddress, mintId);\n            // Display results (handling Promise.allSettled results)\n            if (result.associatedTokenAddress?.status === \"fulfilled\") tokenAtaDiv.textContent = result.associatedTokenAddress.value[0];\n            else tokenAtaDiv.textContent = `Error: ${result.associatedTokenAddress?.reason}`;\n            if (result.associatedTokenAddress2022?.status === \"fulfilled\") token2022AtaDiv.textContent = result.associatedTokenAddress2022.value[0];\n            else token2022AtaDiv.textContent = `Error: ${result.associatedTokenAddress2022?.reason}`;\n            resultsDiv.style.display = \"block\";\n            console.log(\"Results:\", result);\n        } catch (error) {\n            // Display error\n            errorDiv.textContent = `Error: ${error instanceof Error ? error.message : String(error)}`;\n            errorDiv.style.display = \"block\";\n            console.error(\"Error computing ATAs:\", error);\n        } finally{\n            // Remove loading state\n            container.classList.remove(\"loading\");\n        }\n    };\n    // Add event listeners for both inputs\n    ownerAddressInput.addEventListener(\"input\", updateResults);\n    mintIdInput.addEventListener(\"input\", updateResults);\n});\nconst $b4e14b6b8da86996$var$computeAllAta = async (ownerAddress, mintId)=>{\n    try {\n        const [associatedTokenAddress, associatedTokenAddress2022] = await Promise.allSettled([\n            (0, $c5679bb0a1fb1418$export$261fb6f487940719)({\n                mint: (0, $fadd3f4c7539d2fa$export$f7d3c097ceca6c15)(mintId),\n                owner: (0, $fadd3f4c7539d2fa$export$f7d3c097ceca6c15)(ownerAddress),\n                tokenProgram: (0, $fadd3f4c7539d2fa$export$f7d3c097ceca6c15)($b4e14b6b8da86996$var$TOKEN_PROGRAM_ID)\n            }),\n            (0, $c5679bb0a1fb1418$export$261fb6f487940719)({\n                mint: (0, $fadd3f4c7539d2fa$export$f7d3c097ceca6c15)(mintId),\n                owner: (0, $fadd3f4c7539d2fa$export$f7d3c097ceca6c15)(ownerAddress),\n                tokenProgram: (0, $fadd3f4c7539d2fa$export$f7d3c097ceca6c15)($b4e14b6b8da86996$var$TOKEN_2022_PROGRAM_ID)\n            })\n        ]);\n        return {\n            associatedTokenAddress: associatedTokenAddress,\n            associatedTokenAddress2022: associatedTokenAddress2022\n        };\n    } catch (error) {\n        console.error(\"Error computing ATAs:\", error);\n        return {\n            associatedTokenAddress: null,\n            associatedTokenAddress2022: null\n        };\n    }\n};\n/** Address of the SPL Token program */ const $b4e14b6b8da86996$var$TOKEN_PROGRAM_ID = \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\";\n/** Address of the SPL Token 2022 program */ const $b4e14b6b8da86996$var$TOKEN_2022_PROGRAM_ID = \"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\";\n\n\n//# sourceMappingURL=index.16e179e5.js.map\n","// Entry point for the application\n// Logic will be added here later\n\nimport { findAssociatedTokenPda } from \"@solana-program/token-2022\";\nimport { address } from \"@solana/kit\";\n\ndocument.addEventListener(\"DOMContentLoaded\", () => {\n  const ownerAddressInput = document.getElementById(\n    \"ownerAddress\"\n  ) as HTMLInputElement;\n  const mintIdInput = document.getElementById(\"mintId\") as HTMLInputElement;\n  const resultsDiv = document.getElementById(\"results\") as HTMLDivElement;\n  const errorDiv = document.getElementById(\"error\") as HTMLDivElement;\n  const tokenAtaDiv = document.getElementById(\"tokenAta\") as HTMLDivElement;\n  const token2022AtaDiv = document.getElementById(\n    \"token2022Ata\"\n  ) as HTMLDivElement;\n  const container = document.querySelector(\".container\") as HTMLDivElement;\n\n  console.log(\"ATA Utils initialized\");\n\n  // Function to compute and display results\n  const updateResults = async () => {\n    const ownerAddress = ownerAddressInput.value.trim();\n    const mintId = mintIdInput.value.trim();\n\n    // Hide results and errors\n    resultsDiv.style.display = \"none\";\n    errorDiv.style.display = \"none\";\n\n    // Only proceed if both fields are filled\n    if (!ownerAddress || !mintId) {\n      return;\n    }\n\n    try {\n      // Add loading state\n      container.classList.add(\"loading\");\n\n      // Compute ATAs\n      const result = await computeAllAta(ownerAddress, mintId);\n\n      // Display results (handling Promise.allSettled results)\n      if (result.associatedTokenAddress?.status === \"fulfilled\") {\n        tokenAtaDiv.textContent = result.associatedTokenAddress.value[0];\n      } else {\n        tokenAtaDiv.textContent = `Error: ${result.associatedTokenAddress?.reason}`;\n      }\n\n      if (result.associatedTokenAddress2022?.status === \"fulfilled\") {\n        token2022AtaDiv.textContent =\n          result.associatedTokenAddress2022.value[0];\n      } else {\n        token2022AtaDiv.textContent = `Error: ${result.associatedTokenAddress2022?.reason}`;\n      }\n\n      resultsDiv.style.display = \"block\";\n\n      console.log(\"Results:\", result);\n    } catch (error) {\n      // Display error\n      errorDiv.textContent = `Error: ${\n        error instanceof Error ? error.message : String(error)\n      }`;\n      errorDiv.style.display = \"block\";\n      console.error(\"Error computing ATAs:\", error);\n    } finally {\n      // Remove loading state\n      container.classList.remove(\"loading\");\n    }\n  };\n\n  // Add event listeners for both inputs\n  ownerAddressInput.addEventListener(\"input\", updateResults);\n  mintIdInput.addEventListener(\"input\", updateResults);\n});\n\nconst computeAllAta = async (ownerAddress: string, mintId: string) => {\n  try {\n    const [associatedTokenAddress, associatedTokenAddress2022] =\n      await Promise.allSettled([\n        findAssociatedTokenPda({\n          mint: address(mintId),\n          owner: address(ownerAddress),\n          tokenProgram: address(TOKEN_PROGRAM_ID),\n        }),\n        findAssociatedTokenPda({\n          mint: address(mintId),\n          owner: address(ownerAddress),\n          tokenProgram: address(TOKEN_2022_PROGRAM_ID),\n        }),\n        // findAssociatedTokenPda({\n        //   mint: address(mintId),\n        //   owner: address(ownerAddress),\n        //   tokenProgram: address(programId),\n        // }),\n      ]);\n    return { associatedTokenAddress, associatedTokenAddress2022 };\n  } catch (error) {\n    console.error(\"Error computing ATAs:\", error);\n    return { associatedTokenAddress: null, associatedTokenAddress2022: null };\n  }\n};\n\n/** Address of the SPL Token program */\nconst TOKEN_PROGRAM_ID = \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\";\n\n/** Address of the SPL Token 2022 program */\nconst TOKEN_2022_PROGRAM_ID = \"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\";\n","import { getEnumEncoder, getEnumDecoder, combineCodec, fixEncoderSize, getBytesEncoder, fixDecoderSize, getBytesDecoder, getDiscriminatedUnionEncoder, getUnitEncoder, addEncoderSizePrefix, getStructEncoder, getAddressEncoder, getU64Encoder, getU16Encoder, getOptionEncoder, getBooleanEncoder, getI16Encoder, getMapEncoder, getUtf8Encoder, getU32Encoder, getF64Encoder, getDiscriminatedUnionDecoder, getUnitDecoder, addDecoderSizePrefix, getStructDecoder, getAddressDecoder, getU64Decoder, getU16Decoder, getOptionDecoder, getBooleanDecoder, getI16Decoder, getMapDecoder, getUtf8Decoder, getU32Decoder, getF64Decoder, getTupleEncoder, getTupleDecoder, getU8Encoder, getHiddenPrefixEncoder, getArrayEncoder, getConstantEncoder, padLeftEncoder, getU8Decoder, getHiddenPrefixDecoder, getArrayDecoder, getConstantDecoder, decodeAccount, assertAccountExists, fetchEncodedAccount, assertAccountsExist, fetchEncodedAccounts, containsBytes, isProgramError, transformEncoder, AccountRole, getI8Encoder, getI8Decoder, getProgramDerivedAddress, none, getI64Encoder, getI64Decoder, unwrapOption, wrapNullable, isOption, isNone, upgradeRoleToSigner, isTransactionSigner as isTransactionSigner$1 } from '@solana/kit';\nimport { fetchSysvarClock } from '@solana/sysvars';\n\n// src/generated/accounts/mint.ts\nvar AccountState = /* @__PURE__ */ ((AccountState2) => {\n  AccountState2[AccountState2[\"Uninitialized\"] = 0] = \"Uninitialized\";\n  AccountState2[AccountState2[\"Initialized\"] = 1] = \"Initialized\";\n  AccountState2[AccountState2[\"Frozen\"] = 2] = \"Frozen\";\n  return AccountState2;\n})(AccountState || {});\nfunction getAccountStateEncoder() {\n  return getEnumEncoder(AccountState);\n}\nfunction getAccountStateDecoder() {\n  return getEnumDecoder(AccountState);\n}\nfunction getAccountStateCodec() {\n  return combineCodec(getAccountStateEncoder(), getAccountStateDecoder());\n}\nvar AuthorityType = /* @__PURE__ */ ((AuthorityType2) => {\n  AuthorityType2[AuthorityType2[\"MintTokens\"] = 0] = \"MintTokens\";\n  AuthorityType2[AuthorityType2[\"FreezeAccount\"] = 1] = \"FreezeAccount\";\n  AuthorityType2[AuthorityType2[\"AccountOwner\"] = 2] = \"AccountOwner\";\n  AuthorityType2[AuthorityType2[\"CloseAccount\"] = 3] = \"CloseAccount\";\n  AuthorityType2[AuthorityType2[\"TransferFeeConfig\"] = 4] = \"TransferFeeConfig\";\n  AuthorityType2[AuthorityType2[\"WithheldWithdraw\"] = 5] = \"WithheldWithdraw\";\n  AuthorityType2[AuthorityType2[\"CloseMint\"] = 6] = \"CloseMint\";\n  AuthorityType2[AuthorityType2[\"InterestRate\"] = 7] = \"InterestRate\";\n  AuthorityType2[AuthorityType2[\"PermanentDelegate\"] = 8] = \"PermanentDelegate\";\n  AuthorityType2[AuthorityType2[\"ConfidentialTransferMint\"] = 9] = \"ConfidentialTransferMint\";\n  AuthorityType2[AuthorityType2[\"TransferHookProgramId\"] = 10] = \"TransferHookProgramId\";\n  AuthorityType2[AuthorityType2[\"ConfidentialTransferFeeConfig\"] = 11] = \"ConfidentialTransferFeeConfig\";\n  AuthorityType2[AuthorityType2[\"MetadataPointer\"] = 12] = \"MetadataPointer\";\n  AuthorityType2[AuthorityType2[\"GroupPointer\"] = 13] = \"GroupPointer\";\n  AuthorityType2[AuthorityType2[\"GroupMemberPointer\"] = 14] = \"GroupMemberPointer\";\n  AuthorityType2[AuthorityType2[\"ScaledUiAmount\"] = 15] = \"ScaledUiAmount\";\n  AuthorityType2[AuthorityType2[\"Pause\"] = 16] = \"Pause\";\n  return AuthorityType2;\n})(AuthorityType || {});\nfunction getAuthorityTypeEncoder() {\n  return getEnumEncoder(AuthorityType);\n}\nfunction getAuthorityTypeDecoder() {\n  return getEnumDecoder(AuthorityType);\n}\nfunction getAuthorityTypeCodec() {\n  return combineCodec(getAuthorityTypeEncoder(), getAuthorityTypeDecoder());\n}\nfunction getDecryptableBalanceEncoder() {\n  return fixEncoderSize(getBytesEncoder(), 36);\n}\nfunction getDecryptableBalanceDecoder() {\n  return fixDecoderSize(getBytesDecoder(), 36);\n}\nfunction getDecryptableBalanceCodec() {\n  return combineCodec(\n    getDecryptableBalanceEncoder(),\n    getDecryptableBalanceDecoder()\n  );\n}\nfunction getEncryptedBalanceEncoder() {\n  return fixEncoderSize(getBytesEncoder(), 64);\n}\nfunction getEncryptedBalanceDecoder() {\n  return fixDecoderSize(getBytesDecoder(), 64);\n}\nfunction getEncryptedBalanceCodec() {\n  return combineCodec(\n    getEncryptedBalanceEncoder(),\n    getEncryptedBalanceDecoder()\n  );\n}\nfunction getExtensionEncoder() {\n  return getDiscriminatedUnionEncoder(\n    [\n      [\"Uninitialized\", getUnitEncoder()],\n      [\n        \"TransferFeeConfig\",\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\"transferFeeConfigAuthority\", getAddressEncoder()],\n            [\"withdrawWithheldAuthority\", getAddressEncoder()],\n            [\"withheldAmount\", getU64Encoder()],\n            [\"olderTransferFee\", getTransferFeeEncoder()],\n            [\"newerTransferFee\", getTransferFeeEncoder()]\n          ]),\n          getU16Encoder()\n        )\n      ],\n      [\n        \"TransferFeeAmount\",\n        addEncoderSizePrefix(\n          getStructEncoder([[\"withheldAmount\", getU64Encoder()]]),\n          getU16Encoder()\n        )\n      ],\n      [\n        \"MintCloseAuthority\",\n        addEncoderSizePrefix(\n          getStructEncoder([[\"closeAuthority\", getAddressEncoder()]]),\n          getU16Encoder()\n        )\n      ],\n      [\n        \"ConfidentialTransferMint\",\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              \"authority\",\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n              })\n            ],\n            [\"autoApproveNewAccounts\", getBooleanEncoder()],\n            [\n              \"auditorElgamalPubkey\",\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n              })\n            ]\n          ]),\n          getU16Encoder()\n        )\n      ],\n      [\n        \"ConfidentialTransferAccount\",\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\"approved\", getBooleanEncoder()],\n            [\"elgamalPubkey\", getAddressEncoder()],\n            [\"pendingBalanceLow\", getEncryptedBalanceEncoder()],\n            [\"pendingBalanceHigh\", getEncryptedBalanceEncoder()],\n            [\"availableBalance\", getEncryptedBalanceEncoder()],\n            [\"decryptableAvailableBalance\", getDecryptableBalanceEncoder()],\n            [\"allowConfidentialCredits\", getBooleanEncoder()],\n            [\"allowNonConfidentialCredits\", getBooleanEncoder()],\n            [\"pendingBalanceCreditCounter\", getU64Encoder()],\n            [\"maximumPendingBalanceCreditCounter\", getU64Encoder()],\n            [\"expectedPendingBalanceCreditCounter\", getU64Encoder()],\n            [\"actualPendingBalanceCreditCounter\", getU64Encoder()]\n          ]),\n          getU16Encoder()\n        )\n      ],\n      [\n        \"DefaultAccountState\",\n        addEncoderSizePrefix(\n          getStructEncoder([[\"state\", getAccountStateEncoder()]]),\n          getU16Encoder()\n        )\n      ],\n      [\n        \"ImmutableOwner\",\n        addEncoderSizePrefix(getStructEncoder([]), getU16Encoder())\n      ],\n      [\n        \"MemoTransfer\",\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\"requireIncomingTransferMemos\", getBooleanEncoder()]\n          ]),\n          getU16Encoder()\n        )\n      ],\n      [\n        \"NonTransferable\",\n        addEncoderSizePrefix(getStructEncoder([]), getU16Encoder())\n      ],\n      [\n        \"InterestBearingConfig\",\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\"rateAuthority\", getAddressEncoder()],\n            [\"initializationTimestamp\", getU64Encoder()],\n            [\"preUpdateAverageRate\", getI16Encoder()],\n            [\"lastUpdateTimestamp\", getU64Encoder()],\n            [\"currentRate\", getI16Encoder()]\n          ]),\n          getU16Encoder()\n        )\n      ],\n      [\n        \"CpiGuard\",\n        addEncoderSizePrefix(\n          getStructEncoder([[\"lockCpi\", getBooleanEncoder()]]),\n          getU16Encoder()\n        )\n      ],\n      [\n        \"PermanentDelegate\",\n        addEncoderSizePrefix(\n          getStructEncoder([[\"delegate\", getAddressEncoder()]]),\n          getU16Encoder()\n        )\n      ],\n      [\n        \"NonTransferableAccount\",\n        addEncoderSizePrefix(getStructEncoder([]), getU16Encoder())\n      ],\n      [\n        \"TransferHook\",\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\"authority\", getAddressEncoder()],\n            [\"programId\", getAddressEncoder()]\n          ]),\n          getU16Encoder()\n        )\n      ],\n      [\n        \"TransferHookAccount\",\n        addEncoderSizePrefix(\n          getStructEncoder([[\"transferring\", getBooleanEncoder()]]),\n          getU16Encoder()\n        )\n      ],\n      [\n        \"ConfidentialTransferFee\",\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              \"authority\",\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n              })\n            ],\n            [\"elgamalPubkey\", getAddressEncoder()],\n            [\"harvestToMintEnabled\", getBooleanEncoder()],\n            [\"withheldAmount\", getEncryptedBalanceEncoder()]\n          ]),\n          getU16Encoder()\n        )\n      ],\n      [\n        \"ConfidentialTransferFeeAmount\",\n        addEncoderSizePrefix(\n          getStructEncoder([[\"withheldAmount\", getEncryptedBalanceEncoder()]]),\n          getU16Encoder()\n        )\n      ],\n      [\n        \"MetadataPointer\",\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              \"authority\",\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n              })\n            ],\n            [\n              \"metadataAddress\",\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n              })\n            ]\n          ]),\n          getU16Encoder()\n        )\n      ],\n      [\n        \"TokenMetadata\",\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              \"updateAuthority\",\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n              })\n            ],\n            [\"mint\", getAddressEncoder()],\n            [\"name\", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n            [\"symbol\", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n            [\"uri\", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n            [\n              \"additionalMetadata\",\n              getMapEncoder(\n                addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),\n                addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())\n              )\n            ]\n          ]),\n          getU16Encoder()\n        )\n      ],\n      [\n        \"GroupPointer\",\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              \"authority\",\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n              })\n            ],\n            [\n              \"groupAddress\",\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n              })\n            ]\n          ]),\n          getU16Encoder()\n        )\n      ],\n      [\n        \"TokenGroup\",\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              \"updateAuthority\",\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n              })\n            ],\n            [\"mint\", getAddressEncoder()],\n            [\"size\", getU64Encoder()],\n            [\"maxSize\", getU64Encoder()]\n          ]),\n          getU16Encoder()\n        )\n      ],\n      [\n        \"GroupMemberPointer\",\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              \"authority\",\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n              })\n            ],\n            [\n              \"memberAddress\",\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n              })\n            ]\n          ]),\n          getU16Encoder()\n        )\n      ],\n      [\n        \"TokenGroupMember\",\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\"mint\", getAddressEncoder()],\n            [\"group\", getAddressEncoder()],\n            [\"memberNumber\", getU64Encoder()]\n          ]),\n          getU16Encoder()\n        )\n      ],\n      [\"ConfidentialMintBurn\", getUnitEncoder()],\n      [\n        \"ScaledUiAmountConfig\",\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\"authority\", getAddressEncoder()],\n            [\"multiplier\", getF64Encoder()],\n            [\"newMultiplierEffectiveTimestamp\", getU64Encoder()],\n            [\"newMultiplier\", getF64Encoder()]\n          ]),\n          getU16Encoder()\n        )\n      ],\n      [\n        \"PausableConfig\",\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              \"authority\",\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n              })\n            ],\n            [\"paused\", getBooleanEncoder()]\n          ]),\n          getU16Encoder()\n        )\n      ],\n      [\"PausableAccount\", getUnitEncoder()]\n    ],\n    { size: getU16Encoder() }\n  );\n}\nfunction getExtensionDecoder() {\n  return getDiscriminatedUnionDecoder(\n    [\n      [\"Uninitialized\", getUnitDecoder()],\n      [\n        \"TransferFeeConfig\",\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\"transferFeeConfigAuthority\", getAddressDecoder()],\n            [\"withdrawWithheldAuthority\", getAddressDecoder()],\n            [\"withheldAmount\", getU64Decoder()],\n            [\"olderTransferFee\", getTransferFeeDecoder()],\n            [\"newerTransferFee\", getTransferFeeDecoder()]\n          ]),\n          getU16Decoder()\n        )\n      ],\n      [\n        \"TransferFeeAmount\",\n        addDecoderSizePrefix(\n          getStructDecoder([[\"withheldAmount\", getU64Decoder()]]),\n          getU16Decoder()\n        )\n      ],\n      [\n        \"MintCloseAuthority\",\n        addDecoderSizePrefix(\n          getStructDecoder([[\"closeAuthority\", getAddressDecoder()]]),\n          getU16Decoder()\n        )\n      ],\n      [\n        \"ConfidentialTransferMint\",\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              \"authority\",\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n              })\n            ],\n            [\"autoApproveNewAccounts\", getBooleanDecoder()],\n            [\n              \"auditorElgamalPubkey\",\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n              })\n            ]\n          ]),\n          getU16Decoder()\n        )\n      ],\n      [\n        \"ConfidentialTransferAccount\",\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\"approved\", getBooleanDecoder()],\n            [\"elgamalPubkey\", getAddressDecoder()],\n            [\"pendingBalanceLow\", getEncryptedBalanceDecoder()],\n            [\"pendingBalanceHigh\", getEncryptedBalanceDecoder()],\n            [\"availableBalance\", getEncryptedBalanceDecoder()],\n            [\"decryptableAvailableBalance\", getDecryptableBalanceDecoder()],\n            [\"allowConfidentialCredits\", getBooleanDecoder()],\n            [\"allowNonConfidentialCredits\", getBooleanDecoder()],\n            [\"pendingBalanceCreditCounter\", getU64Decoder()],\n            [\"maximumPendingBalanceCreditCounter\", getU64Decoder()],\n            [\"expectedPendingBalanceCreditCounter\", getU64Decoder()],\n            [\"actualPendingBalanceCreditCounter\", getU64Decoder()]\n          ]),\n          getU16Decoder()\n        )\n      ],\n      [\n        \"DefaultAccountState\",\n        addDecoderSizePrefix(\n          getStructDecoder([[\"state\", getAccountStateDecoder()]]),\n          getU16Decoder()\n        )\n      ],\n      [\n        \"ImmutableOwner\",\n        addDecoderSizePrefix(getStructDecoder([]), getU16Decoder())\n      ],\n      [\n        \"MemoTransfer\",\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\"requireIncomingTransferMemos\", getBooleanDecoder()]\n          ]),\n          getU16Decoder()\n        )\n      ],\n      [\n        \"NonTransferable\",\n        addDecoderSizePrefix(getStructDecoder([]), getU16Decoder())\n      ],\n      [\n        \"InterestBearingConfig\",\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\"rateAuthority\", getAddressDecoder()],\n            [\"initializationTimestamp\", getU64Decoder()],\n            [\"preUpdateAverageRate\", getI16Decoder()],\n            [\"lastUpdateTimestamp\", getU64Decoder()],\n            [\"currentRate\", getI16Decoder()]\n          ]),\n          getU16Decoder()\n        )\n      ],\n      [\n        \"CpiGuard\",\n        addDecoderSizePrefix(\n          getStructDecoder([[\"lockCpi\", getBooleanDecoder()]]),\n          getU16Decoder()\n        )\n      ],\n      [\n        \"PermanentDelegate\",\n        addDecoderSizePrefix(\n          getStructDecoder([[\"delegate\", getAddressDecoder()]]),\n          getU16Decoder()\n        )\n      ],\n      [\n        \"NonTransferableAccount\",\n        addDecoderSizePrefix(getStructDecoder([]), getU16Decoder())\n      ],\n      [\n        \"TransferHook\",\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\"authority\", getAddressDecoder()],\n            [\"programId\", getAddressDecoder()]\n          ]),\n          getU16Decoder()\n        )\n      ],\n      [\n        \"TransferHookAccount\",\n        addDecoderSizePrefix(\n          getStructDecoder([[\"transferring\", getBooleanDecoder()]]),\n          getU16Decoder()\n        )\n      ],\n      [\n        \"ConfidentialTransferFee\",\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              \"authority\",\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n              })\n            ],\n            [\"elgamalPubkey\", getAddressDecoder()],\n            [\"harvestToMintEnabled\", getBooleanDecoder()],\n            [\"withheldAmount\", getEncryptedBalanceDecoder()]\n          ]),\n          getU16Decoder()\n        )\n      ],\n      [\n        \"ConfidentialTransferFeeAmount\",\n        addDecoderSizePrefix(\n          getStructDecoder([[\"withheldAmount\", getEncryptedBalanceDecoder()]]),\n          getU16Decoder()\n        )\n      ],\n      [\n        \"MetadataPointer\",\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              \"authority\",\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n              })\n            ],\n            [\n              \"metadataAddress\",\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n              })\n            ]\n          ]),\n          getU16Decoder()\n        )\n      ],\n      [\n        \"TokenMetadata\",\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              \"updateAuthority\",\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n              })\n            ],\n            [\"mint\", getAddressDecoder()],\n            [\"name\", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n            [\"symbol\", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n            [\"uri\", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n            [\n              \"additionalMetadata\",\n              getMapDecoder(\n                addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()),\n                addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())\n              )\n            ]\n          ]),\n          getU16Decoder()\n        )\n      ],\n      [\n        \"GroupPointer\",\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              \"authority\",\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n              })\n            ],\n            [\n              \"groupAddress\",\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n              })\n            ]\n          ]),\n          getU16Decoder()\n        )\n      ],\n      [\n        \"TokenGroup\",\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              \"updateAuthority\",\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n              })\n            ],\n            [\"mint\", getAddressDecoder()],\n            [\"size\", getU64Decoder()],\n            [\"maxSize\", getU64Decoder()]\n          ]),\n          getU16Decoder()\n        )\n      ],\n      [\n        \"GroupMemberPointer\",\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              \"authority\",\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n              })\n            ],\n            [\n              \"memberAddress\",\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n              })\n            ]\n          ]),\n          getU16Decoder()\n        )\n      ],\n      [\n        \"TokenGroupMember\",\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\"mint\", getAddressDecoder()],\n            [\"group\", getAddressDecoder()],\n            [\"memberNumber\", getU64Decoder()]\n          ]),\n          getU16Decoder()\n        )\n      ],\n      [\"ConfidentialMintBurn\", getUnitDecoder()],\n      [\n        \"ScaledUiAmountConfig\",\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\"authority\", getAddressDecoder()],\n            [\"multiplier\", getF64Decoder()],\n            [\"newMultiplierEffectiveTimestamp\", getU64Decoder()],\n            [\"newMultiplier\", getF64Decoder()]\n          ]),\n          getU16Decoder()\n        )\n      ],\n      [\n        \"PausableConfig\",\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              \"authority\",\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: \"zeroes\"\n              })\n            ],\n            [\"paused\", getBooleanDecoder()]\n          ]),\n          getU16Decoder()\n        )\n      ],\n      [\"PausableAccount\", getUnitDecoder()]\n    ],\n    { size: getU16Decoder() }\n  );\n}\nfunction getExtensionCodec() {\n  return combineCodec(getExtensionEncoder(), getExtensionDecoder());\n}\nfunction extension(kind, data) {\n  return Array.isArray(data) ? { __kind: kind, fields: data } : { __kind: kind, ...data ?? {} };\n}\nfunction isExtension(kind, value) {\n  return value.__kind === kind;\n}\nvar ExtensionType = /* @__PURE__ */ ((ExtensionType2) => {\n  ExtensionType2[ExtensionType2[\"Uninitialized\"] = 0] = \"Uninitialized\";\n  ExtensionType2[ExtensionType2[\"TransferFeeConfig\"] = 1] = \"TransferFeeConfig\";\n  ExtensionType2[ExtensionType2[\"TransferFeeAmount\"] = 2] = \"TransferFeeAmount\";\n  ExtensionType2[ExtensionType2[\"MintCloseAuthority\"] = 3] = \"MintCloseAuthority\";\n  ExtensionType2[ExtensionType2[\"ConfidentialTransferMint\"] = 4] = \"ConfidentialTransferMint\";\n  ExtensionType2[ExtensionType2[\"ConfidentialTransferAccount\"] = 5] = \"ConfidentialTransferAccount\";\n  ExtensionType2[ExtensionType2[\"DefaultAccountState\"] = 6] = \"DefaultAccountState\";\n  ExtensionType2[ExtensionType2[\"ImmutableOwner\"] = 7] = \"ImmutableOwner\";\n  ExtensionType2[ExtensionType2[\"MemoTransfer\"] = 8] = \"MemoTransfer\";\n  ExtensionType2[ExtensionType2[\"NonTransferable\"] = 9] = \"NonTransferable\";\n  ExtensionType2[ExtensionType2[\"InterestBearingConfig\"] = 10] = \"InterestBearingConfig\";\n  ExtensionType2[ExtensionType2[\"CpiGuard\"] = 11] = \"CpiGuard\";\n  ExtensionType2[ExtensionType2[\"PermanentDelegate\"] = 12] = \"PermanentDelegate\";\n  ExtensionType2[ExtensionType2[\"NonTransferableAccount\"] = 13] = \"NonTransferableAccount\";\n  ExtensionType2[ExtensionType2[\"TransferHook\"] = 14] = \"TransferHook\";\n  ExtensionType2[ExtensionType2[\"TransferHookAccount\"] = 15] = \"TransferHookAccount\";\n  ExtensionType2[ExtensionType2[\"ConfidentialTransferFee\"] = 16] = \"ConfidentialTransferFee\";\n  ExtensionType2[ExtensionType2[\"ConfidentialTransferFeeAmount\"] = 17] = \"ConfidentialTransferFeeAmount\";\n  ExtensionType2[ExtensionType2[\"ScaledUiAmountConfig\"] = 18] = \"ScaledUiAmountConfig\";\n  ExtensionType2[ExtensionType2[\"PausableConfig\"] = 19] = \"PausableConfig\";\n  ExtensionType2[ExtensionType2[\"PausableAccount\"] = 20] = \"PausableAccount\";\n  ExtensionType2[ExtensionType2[\"MetadataPointer\"] = 21] = \"MetadataPointer\";\n  ExtensionType2[ExtensionType2[\"TokenMetadata\"] = 22] = \"TokenMetadata\";\n  ExtensionType2[ExtensionType2[\"GroupPointer\"] = 23] = \"GroupPointer\";\n  ExtensionType2[ExtensionType2[\"TokenGroup\"] = 24] = \"TokenGroup\";\n  ExtensionType2[ExtensionType2[\"GroupMemberPointer\"] = 25] = \"GroupMemberPointer\";\n  ExtensionType2[ExtensionType2[\"TokenGroupMember\"] = 26] = \"TokenGroupMember\";\n  return ExtensionType2;\n})(ExtensionType || {});\nfunction getExtensionTypeEncoder() {\n  return getEnumEncoder(ExtensionType, { size: getU16Encoder() });\n}\nfunction getExtensionTypeDecoder() {\n  return getEnumDecoder(ExtensionType, { size: getU16Decoder() });\n}\nfunction getExtensionTypeCodec() {\n  return combineCodec(getExtensionTypeEncoder(), getExtensionTypeDecoder());\n}\nfunction getTokenMetadataFieldEncoder() {\n  return getDiscriminatedUnionEncoder([\n    [\"Name\", getUnitEncoder()],\n    [\"Symbol\", getUnitEncoder()],\n    [\"Uri\", getUnitEncoder()],\n    [\n      \"Key\",\n      getStructEncoder([\n        [\n          \"fields\",\n          getTupleEncoder([\n            addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())\n          ])\n        ]\n      ])\n    ]\n  ]);\n}\nfunction getTokenMetadataFieldDecoder() {\n  return getDiscriminatedUnionDecoder([\n    [\"Name\", getUnitDecoder()],\n    [\"Symbol\", getUnitDecoder()],\n    [\"Uri\", getUnitDecoder()],\n    [\n      \"Key\",\n      getStructDecoder([\n        [\n          \"fields\",\n          getTupleDecoder([\n            addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())\n          ])\n        ]\n      ])\n    ]\n  ]);\n}\nfunction getTokenMetadataFieldCodec() {\n  return combineCodec(\n    getTokenMetadataFieldEncoder(),\n    getTokenMetadataFieldDecoder()\n  );\n}\nfunction tokenMetadataField(kind, data) {\n  return Array.isArray(data) ? { __kind: kind, fields: data } : { __kind: kind, ...data ?? {} };\n}\nfunction isTokenMetadataField(kind, value) {\n  return value.__kind === kind;\n}\nfunction getTransferFeeEncoder() {\n  return getStructEncoder([\n    [\"epoch\", getU64Encoder()],\n    [\"maximumFee\", getU64Encoder()],\n    [\"transferFeeBasisPoints\", getU16Encoder()]\n  ]);\n}\nfunction getTransferFeeDecoder() {\n  return getStructDecoder([\n    [\"epoch\", getU64Decoder()],\n    [\"maximumFee\", getU64Decoder()],\n    [\"transferFeeBasisPoints\", getU16Decoder()]\n  ]);\n}\nfunction getTransferFeeCodec() {\n  return combineCodec(getTransferFeeEncoder(), getTransferFeeDecoder());\n}\n\n// src/generated/accounts/mint.ts\nfunction getMintEncoder() {\n  return getStructEncoder([\n    [\n      \"mintAuthority\",\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: \"zeroes\"\n      })\n    ],\n    [\"supply\", getU64Encoder()],\n    [\"decimals\", getU8Encoder()],\n    [\"isInitialized\", getBooleanEncoder()],\n    [\n      \"freezeAuthority\",\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: \"zeroes\"\n      })\n    ],\n    [\n      \"extensions\",\n      getOptionEncoder(\n        getHiddenPrefixEncoder(\n          getArrayEncoder(getExtensionEncoder(), { size: \"remainder\" }),\n          [getConstantEncoder(padLeftEncoder(getU8Encoder(), 83).encode(1))]\n        ),\n        { prefix: null }\n      )\n    ]\n  ]);\n}\nfunction getMintDecoder() {\n  return getStructDecoder([\n    [\n      \"mintAuthority\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: \"zeroes\"\n      })\n    ],\n    [\"supply\", getU64Decoder()],\n    [\"decimals\", getU8Decoder()],\n    [\"isInitialized\", getBooleanDecoder()],\n    [\n      \"freezeAuthority\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: \"zeroes\"\n      })\n    ],\n    [\n      \"extensions\",\n      getOptionDecoder(\n        getHiddenPrefixDecoder(\n          getArrayDecoder(getExtensionDecoder(), { size: \"remainder\" }),\n          [getConstantDecoder(padLeftEncoder(getU8Encoder(), 83).encode(1))]\n        ),\n        { prefix: null }\n      )\n    ]\n  ]);\n}\nfunction getMintCodec() {\n  return combineCodec(getMintEncoder(), getMintDecoder());\n}\nfunction decodeMint(encodedAccount) {\n  return decodeAccount(\n    encodedAccount,\n    getMintDecoder()\n  );\n}\nasync function fetchMint(rpc, address, config) {\n  const maybeAccount = await fetchMaybeMint(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\nasync function fetchMaybeMint(rpc, address, config) {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeMint(maybeAccount);\n}\nasync function fetchAllMint(rpc, addresses, config) {\n  const maybeAccounts = await fetchAllMaybeMint(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\nasync function fetchAllMaybeMint(rpc, addresses, config) {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeMint(maybeAccount));\n}\nfunction getMultisigEncoder() {\n  return getStructEncoder([\n    [\"m\", getU8Encoder()],\n    [\"n\", getU8Encoder()],\n    [\"isInitialized\", getBooleanEncoder()],\n    [\"signers\", getArrayEncoder(getAddressEncoder(), { size: 11 })]\n  ]);\n}\nfunction getMultisigDecoder() {\n  return getStructDecoder([\n    [\"m\", getU8Decoder()],\n    [\"n\", getU8Decoder()],\n    [\"isInitialized\", getBooleanDecoder()],\n    [\"signers\", getArrayDecoder(getAddressDecoder(), { size: 11 })]\n  ]);\n}\nfunction getMultisigCodec() {\n  return combineCodec(getMultisigEncoder(), getMultisigDecoder());\n}\nfunction decodeMultisig(encodedAccount) {\n  return decodeAccount(\n    encodedAccount,\n    getMultisigDecoder()\n  );\n}\nasync function fetchMultisig(rpc, address, config) {\n  const maybeAccount = await fetchMaybeMultisig(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\nasync function fetchMaybeMultisig(rpc, address, config) {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeMultisig(maybeAccount);\n}\nasync function fetchAllMultisig(rpc, addresses, config) {\n  const maybeAccounts = await fetchAllMaybeMultisig(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\nasync function fetchAllMaybeMultisig(rpc, addresses, config) {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeMultisig(maybeAccount));\n}\nfunction getMultisigSize() {\n  return 355;\n}\nfunction getTokenEncoder() {\n  return getStructEncoder([\n    [\"mint\", getAddressEncoder()],\n    [\"owner\", getAddressEncoder()],\n    [\"amount\", getU64Encoder()],\n    [\n      \"delegate\",\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: \"zeroes\"\n      })\n    ],\n    [\"state\", getAccountStateEncoder()],\n    [\n      \"isNative\",\n      getOptionEncoder(getU64Encoder(), {\n        prefix: getU32Encoder(),\n        noneValue: \"zeroes\"\n      })\n    ],\n    [\"delegatedAmount\", getU64Encoder()],\n    [\n      \"closeAuthority\",\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: \"zeroes\"\n      })\n    ],\n    [\n      \"extensions\",\n      getOptionEncoder(\n        getHiddenPrefixEncoder(\n          getArrayEncoder(getExtensionEncoder(), { size: \"remainder\" }),\n          [getConstantEncoder(getU8Encoder().encode(2))]\n        ),\n        { prefix: null }\n      )\n    ]\n  ]);\n}\nfunction getTokenDecoder() {\n  return getStructDecoder([\n    [\"mint\", getAddressDecoder()],\n    [\"owner\", getAddressDecoder()],\n    [\"amount\", getU64Decoder()],\n    [\n      \"delegate\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: \"zeroes\"\n      })\n    ],\n    [\"state\", getAccountStateDecoder()],\n    [\n      \"isNative\",\n      getOptionDecoder(getU64Decoder(), {\n        prefix: getU32Decoder(),\n        noneValue: \"zeroes\"\n      })\n    ],\n    [\"delegatedAmount\", getU64Decoder()],\n    [\n      \"closeAuthority\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: \"zeroes\"\n      })\n    ],\n    [\n      \"extensions\",\n      getOptionDecoder(\n        getHiddenPrefixDecoder(\n          getArrayDecoder(getExtensionDecoder(), { size: \"remainder\" }),\n          [getConstantDecoder(getU8Encoder().encode(2))]\n        ),\n        { prefix: null }\n      )\n    ]\n  ]);\n}\nfunction getTokenCodec() {\n  return combineCodec(getTokenEncoder(), getTokenDecoder());\n}\nfunction decodeToken(encodedAccount) {\n  return decodeAccount(\n    encodedAccount,\n    getTokenDecoder()\n  );\n}\nasync function fetchToken(rpc, address, config) {\n  const maybeAccount = await fetchMaybeToken(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\nasync function fetchMaybeToken(rpc, address, config) {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeToken(maybeAccount);\n}\nasync function fetchAllToken(rpc, addresses, config) {\n  const maybeAccounts = await fetchAllMaybeToken(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\nasync function fetchAllMaybeToken(rpc, addresses, config) {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeToken(maybeAccount));\n}\nvar ASSOCIATED_TOKEN_PROGRAM_ADDRESS = \"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\";\nvar AssociatedTokenInstruction = /* @__PURE__ */ ((AssociatedTokenInstruction2) => {\n  AssociatedTokenInstruction2[AssociatedTokenInstruction2[\"CreateAssociatedToken\"] = 0] = \"CreateAssociatedToken\";\n  AssociatedTokenInstruction2[AssociatedTokenInstruction2[\"CreateAssociatedTokenIdempotent\"] = 1] = \"CreateAssociatedTokenIdempotent\";\n  AssociatedTokenInstruction2[AssociatedTokenInstruction2[\"RecoverNestedAssociatedToken\"] = 2] = \"RecoverNestedAssociatedToken\";\n  return AssociatedTokenInstruction2;\n})(AssociatedTokenInstruction || {});\nfunction identifyAssociatedTokenInstruction(instruction) {\n  const data = \"data\" in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU8Encoder().encode(0), 0)) {\n    return 0 /* CreateAssociatedToken */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(1), 0)) {\n    return 1 /* CreateAssociatedTokenIdempotent */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(2), 0)) {\n    return 2 /* RecoverNestedAssociatedToken */;\n  }\n  throw new Error(\n    \"The provided instruction could not be identified as a associatedToken instruction.\"\n  );\n}\nvar TOKEN_2022_PROGRAM_ADDRESS = \"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\";\nvar Token2022Account = /* @__PURE__ */ ((Token2022Account2) => {\n  Token2022Account2[Token2022Account2[\"Mint\"] = 0] = \"Mint\";\n  Token2022Account2[Token2022Account2[\"Token\"] = 1] = \"Token\";\n  Token2022Account2[Token2022Account2[\"Multisig\"] = 2] = \"Multisig\";\n  return Token2022Account2;\n})(Token2022Account || {});\nfunction identifyToken2022Account(account) {\n  const data = \"data\" in account ? account.data : account;\n  if (data.length === 82) {\n    return 0 /* Mint */;\n  }\n  if (data.length === 165) {\n    return 1 /* Token */;\n  }\n  if (data.length === 355) {\n    return 2 /* Multisig */;\n  }\n  throw new Error(\n    \"The provided account could not be identified as a token-2022 account.\"\n  );\n}\nvar Token2022Instruction = /* @__PURE__ */ ((Token2022Instruction2) => {\n  Token2022Instruction2[Token2022Instruction2[\"InitializeMint\"] = 0] = \"InitializeMint\";\n  Token2022Instruction2[Token2022Instruction2[\"InitializeAccount\"] = 1] = \"InitializeAccount\";\n  Token2022Instruction2[Token2022Instruction2[\"InitializeMultisig\"] = 2] = \"InitializeMultisig\";\n  Token2022Instruction2[Token2022Instruction2[\"Transfer\"] = 3] = \"Transfer\";\n  Token2022Instruction2[Token2022Instruction2[\"Approve\"] = 4] = \"Approve\";\n  Token2022Instruction2[Token2022Instruction2[\"Revoke\"] = 5] = \"Revoke\";\n  Token2022Instruction2[Token2022Instruction2[\"SetAuthority\"] = 6] = \"SetAuthority\";\n  Token2022Instruction2[Token2022Instruction2[\"MintTo\"] = 7] = \"MintTo\";\n  Token2022Instruction2[Token2022Instruction2[\"Burn\"] = 8] = \"Burn\";\n  Token2022Instruction2[Token2022Instruction2[\"CloseAccount\"] = 9] = \"CloseAccount\";\n  Token2022Instruction2[Token2022Instruction2[\"FreezeAccount\"] = 10] = \"FreezeAccount\";\n  Token2022Instruction2[Token2022Instruction2[\"ThawAccount\"] = 11] = \"ThawAccount\";\n  Token2022Instruction2[Token2022Instruction2[\"TransferChecked\"] = 12] = \"TransferChecked\";\n  Token2022Instruction2[Token2022Instruction2[\"ApproveChecked\"] = 13] = \"ApproveChecked\";\n  Token2022Instruction2[Token2022Instruction2[\"MintToChecked\"] = 14] = \"MintToChecked\";\n  Token2022Instruction2[Token2022Instruction2[\"BurnChecked\"] = 15] = \"BurnChecked\";\n  Token2022Instruction2[Token2022Instruction2[\"InitializeAccount2\"] = 16] = \"InitializeAccount2\";\n  Token2022Instruction2[Token2022Instruction2[\"SyncNative\"] = 17] = \"SyncNative\";\n  Token2022Instruction2[Token2022Instruction2[\"InitializeAccount3\"] = 18] = \"InitializeAccount3\";\n  Token2022Instruction2[Token2022Instruction2[\"InitializeMultisig2\"] = 19] = \"InitializeMultisig2\";\n  Token2022Instruction2[Token2022Instruction2[\"InitializeMint2\"] = 20] = \"InitializeMint2\";\n  Token2022Instruction2[Token2022Instruction2[\"GetAccountDataSize\"] = 21] = \"GetAccountDataSize\";\n  Token2022Instruction2[Token2022Instruction2[\"InitializeImmutableOwner\"] = 22] = \"InitializeImmutableOwner\";\n  Token2022Instruction2[Token2022Instruction2[\"AmountToUiAmount\"] = 23] = \"AmountToUiAmount\";\n  Token2022Instruction2[Token2022Instruction2[\"UiAmountToAmount\"] = 24] = \"UiAmountToAmount\";\n  Token2022Instruction2[Token2022Instruction2[\"InitializeMintCloseAuthority\"] = 25] = \"InitializeMintCloseAuthority\";\n  Token2022Instruction2[Token2022Instruction2[\"InitializeTransferFeeConfig\"] = 26] = \"InitializeTransferFeeConfig\";\n  Token2022Instruction2[Token2022Instruction2[\"TransferCheckedWithFee\"] = 27] = \"TransferCheckedWithFee\";\n  Token2022Instruction2[Token2022Instruction2[\"WithdrawWithheldTokensFromMint\"] = 28] = \"WithdrawWithheldTokensFromMint\";\n  Token2022Instruction2[Token2022Instruction2[\"WithdrawWithheldTokensFromAccounts\"] = 29] = \"WithdrawWithheldTokensFromAccounts\";\n  Token2022Instruction2[Token2022Instruction2[\"HarvestWithheldTokensToMint\"] = 30] = \"HarvestWithheldTokensToMint\";\n  Token2022Instruction2[Token2022Instruction2[\"SetTransferFee\"] = 31] = \"SetTransferFee\";\n  Token2022Instruction2[Token2022Instruction2[\"InitializeConfidentialTransferMint\"] = 32] = \"InitializeConfidentialTransferMint\";\n  Token2022Instruction2[Token2022Instruction2[\"UpdateConfidentialTransferMint\"] = 33] = \"UpdateConfidentialTransferMint\";\n  Token2022Instruction2[Token2022Instruction2[\"ConfigureConfidentialTransferAccount\"] = 34] = \"ConfigureConfidentialTransferAccount\";\n  Token2022Instruction2[Token2022Instruction2[\"ApproveConfidentialTransferAccount\"] = 35] = \"ApproveConfidentialTransferAccount\";\n  Token2022Instruction2[Token2022Instruction2[\"EmptyConfidentialTransferAccount\"] = 36] = \"EmptyConfidentialTransferAccount\";\n  Token2022Instruction2[Token2022Instruction2[\"ConfidentialDeposit\"] = 37] = \"ConfidentialDeposit\";\n  Token2022Instruction2[Token2022Instruction2[\"ConfidentialWithdraw\"] = 38] = \"ConfidentialWithdraw\";\n  Token2022Instruction2[Token2022Instruction2[\"ConfidentialTransfer\"] = 39] = \"ConfidentialTransfer\";\n  Token2022Instruction2[Token2022Instruction2[\"ApplyConfidentialPendingBalance\"] = 40] = \"ApplyConfidentialPendingBalance\";\n  Token2022Instruction2[Token2022Instruction2[\"EnableConfidentialCredits\"] = 41] = \"EnableConfidentialCredits\";\n  Token2022Instruction2[Token2022Instruction2[\"DisableConfidentialCredits\"] = 42] = \"DisableConfidentialCredits\";\n  Token2022Instruction2[Token2022Instruction2[\"EnableNonConfidentialCredits\"] = 43] = \"EnableNonConfidentialCredits\";\n  Token2022Instruction2[Token2022Instruction2[\"DisableNonConfidentialCredits\"] = 44] = \"DisableNonConfidentialCredits\";\n  Token2022Instruction2[Token2022Instruction2[\"ConfidentialTransferWithFee\"] = 45] = \"ConfidentialTransferWithFee\";\n  Token2022Instruction2[Token2022Instruction2[\"InitializeDefaultAccountState\"] = 46] = \"InitializeDefaultAccountState\";\n  Token2022Instruction2[Token2022Instruction2[\"UpdateDefaultAccountState\"] = 47] = \"UpdateDefaultAccountState\";\n  Token2022Instruction2[Token2022Instruction2[\"Reallocate\"] = 48] = \"Reallocate\";\n  Token2022Instruction2[Token2022Instruction2[\"EnableMemoTransfers\"] = 49] = \"EnableMemoTransfers\";\n  Token2022Instruction2[Token2022Instruction2[\"DisableMemoTransfers\"] = 50] = \"DisableMemoTransfers\";\n  Token2022Instruction2[Token2022Instruction2[\"CreateNativeMint\"] = 51] = \"CreateNativeMint\";\n  Token2022Instruction2[Token2022Instruction2[\"InitializeNonTransferableMint\"] = 52] = \"InitializeNonTransferableMint\";\n  Token2022Instruction2[Token2022Instruction2[\"InitializeInterestBearingMint\"] = 53] = \"InitializeInterestBearingMint\";\n  Token2022Instruction2[Token2022Instruction2[\"UpdateRateInterestBearingMint\"] = 54] = \"UpdateRateInterestBearingMint\";\n  Token2022Instruction2[Token2022Instruction2[\"EnableCpiGuard\"] = 55] = \"EnableCpiGuard\";\n  Token2022Instruction2[Token2022Instruction2[\"DisableCpiGuard\"] = 56] = \"DisableCpiGuard\";\n  Token2022Instruction2[Token2022Instruction2[\"InitializePermanentDelegate\"] = 57] = \"InitializePermanentDelegate\";\n  Token2022Instruction2[Token2022Instruction2[\"InitializeTransferHook\"] = 58] = \"InitializeTransferHook\";\n  Token2022Instruction2[Token2022Instruction2[\"UpdateTransferHook\"] = 59] = \"UpdateTransferHook\";\n  Token2022Instruction2[Token2022Instruction2[\"InitializeConfidentialTransferFee\"] = 60] = \"InitializeConfidentialTransferFee\";\n  Token2022Instruction2[Token2022Instruction2[\"WithdrawWithheldTokensFromMintForConfidentialTransferFee\"] = 61] = \"WithdrawWithheldTokensFromMintForConfidentialTransferFee\";\n  Token2022Instruction2[Token2022Instruction2[\"WithdrawWithheldTokensFromAccountsForConfidentialTransferFee\"] = 62] = \"WithdrawWithheldTokensFromAccountsForConfidentialTransferFee\";\n  Token2022Instruction2[Token2022Instruction2[\"HarvestWithheldTokensToMintForConfidentialTransferFee\"] = 63] = \"HarvestWithheldTokensToMintForConfidentialTransferFee\";\n  Token2022Instruction2[Token2022Instruction2[\"EnableHarvestToMint\"] = 64] = \"EnableHarvestToMint\";\n  Token2022Instruction2[Token2022Instruction2[\"DisableHarvestToMint\"] = 65] = \"DisableHarvestToMint\";\n  Token2022Instruction2[Token2022Instruction2[\"WithdrawExcessLamports\"] = 66] = \"WithdrawExcessLamports\";\n  Token2022Instruction2[Token2022Instruction2[\"InitializeMetadataPointer\"] = 67] = \"InitializeMetadataPointer\";\n  Token2022Instruction2[Token2022Instruction2[\"UpdateMetadataPointer\"] = 68] = \"UpdateMetadataPointer\";\n  Token2022Instruction2[Token2022Instruction2[\"InitializeGroupPointer\"] = 69] = \"InitializeGroupPointer\";\n  Token2022Instruction2[Token2022Instruction2[\"UpdateGroupPointer\"] = 70] = \"UpdateGroupPointer\";\n  Token2022Instruction2[Token2022Instruction2[\"InitializeGroupMemberPointer\"] = 71] = \"InitializeGroupMemberPointer\";\n  Token2022Instruction2[Token2022Instruction2[\"UpdateGroupMemberPointer\"] = 72] = \"UpdateGroupMemberPointer\";\n  Token2022Instruction2[Token2022Instruction2[\"InitializeScaledUiAmountMint\"] = 73] = \"InitializeScaledUiAmountMint\";\n  Token2022Instruction2[Token2022Instruction2[\"UpdateMultiplierScaledUiMint\"] = 74] = \"UpdateMultiplierScaledUiMint\";\n  Token2022Instruction2[Token2022Instruction2[\"InitializePausableConfig\"] = 75] = \"InitializePausableConfig\";\n  Token2022Instruction2[Token2022Instruction2[\"Pause\"] = 76] = \"Pause\";\n  Token2022Instruction2[Token2022Instruction2[\"Resume\"] = 77] = \"Resume\";\n  Token2022Instruction2[Token2022Instruction2[\"InitializeTokenMetadata\"] = 78] = \"InitializeTokenMetadata\";\n  Token2022Instruction2[Token2022Instruction2[\"UpdateTokenMetadataField\"] = 79] = \"UpdateTokenMetadataField\";\n  Token2022Instruction2[Token2022Instruction2[\"RemoveTokenMetadataKey\"] = 80] = \"RemoveTokenMetadataKey\";\n  Token2022Instruction2[Token2022Instruction2[\"UpdateTokenMetadataUpdateAuthority\"] = 81] = \"UpdateTokenMetadataUpdateAuthority\";\n  Token2022Instruction2[Token2022Instruction2[\"EmitTokenMetadata\"] = 82] = \"EmitTokenMetadata\";\n  Token2022Instruction2[Token2022Instruction2[\"InitializeTokenGroup\"] = 83] = \"InitializeTokenGroup\";\n  Token2022Instruction2[Token2022Instruction2[\"UpdateTokenGroupMaxSize\"] = 84] = \"UpdateTokenGroupMaxSize\";\n  Token2022Instruction2[Token2022Instruction2[\"UpdateTokenGroupUpdateAuthority\"] = 85] = \"UpdateTokenGroupUpdateAuthority\";\n  Token2022Instruction2[Token2022Instruction2[\"InitializeTokenGroupMember\"] = 86] = \"InitializeTokenGroupMember\";\n  return Token2022Instruction2;\n})(Token2022Instruction || {});\nfunction identifyToken2022Instruction(instruction) {\n  const data = \"data\" in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU8Encoder().encode(0), 0)) {\n    return 0 /* InitializeMint */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(1), 0)) {\n    return 1 /* InitializeAccount */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(2), 0)) {\n    return 2 /* InitializeMultisig */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(3), 0)) {\n    return 3 /* Transfer */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(4), 0)) {\n    return 4 /* Approve */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(5), 0)) {\n    return 5 /* Revoke */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(6), 0)) {\n    return 6 /* SetAuthority */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(7), 0)) {\n    return 7 /* MintTo */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(8), 0)) {\n    return 8 /* Burn */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(9), 0)) {\n    return 9 /* CloseAccount */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(10), 0)) {\n    return 10 /* FreezeAccount */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(11), 0)) {\n    return 11 /* ThawAccount */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(12), 0)) {\n    return 12 /* TransferChecked */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(13), 0)) {\n    return 13 /* ApproveChecked */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(14), 0)) {\n    return 14 /* MintToChecked */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(15), 0)) {\n    return 15 /* BurnChecked */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(16), 0)) {\n    return 16 /* InitializeAccount2 */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(17), 0)) {\n    return 17 /* SyncNative */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(18), 0)) {\n    return 18 /* InitializeAccount3 */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(19), 0)) {\n    return 19 /* InitializeMultisig2 */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(20), 0)) {\n    return 20 /* InitializeMint2 */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(21), 0)) {\n    return 21 /* GetAccountDataSize */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(22), 0)) {\n    return 22 /* InitializeImmutableOwner */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(23), 0)) {\n    return 23 /* AmountToUiAmount */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(24), 0)) {\n    return 24 /* UiAmountToAmount */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(25), 0)) {\n    return 25 /* InitializeMintCloseAuthority */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(26), 0) && containsBytes(data, getU8Encoder().encode(0), 1)) {\n    return 26 /* InitializeTransferFeeConfig */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(26), 0) && containsBytes(data, getU8Encoder().encode(1), 1)) {\n    return 27 /* TransferCheckedWithFee */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(26), 0) && containsBytes(data, getU8Encoder().encode(2), 1)) {\n    return 28 /* WithdrawWithheldTokensFromMint */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(26), 0) && containsBytes(data, getU8Encoder().encode(3), 1)) {\n    return 29 /* WithdrawWithheldTokensFromAccounts */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(26), 0) && containsBytes(data, getU8Encoder().encode(4), 1)) {\n    return 30 /* HarvestWithheldTokensToMint */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(26), 0) && containsBytes(data, getU8Encoder().encode(5), 1)) {\n    return 31 /* SetTransferFee */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(27), 0) && containsBytes(data, getU8Encoder().encode(0), 1)) {\n    return 32 /* InitializeConfidentialTransferMint */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(27), 0) && containsBytes(data, getU8Encoder().encode(1), 1)) {\n    return 33 /* UpdateConfidentialTransferMint */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(27), 0) && containsBytes(data, getU8Encoder().encode(2), 1)) {\n    return 34 /* ConfigureConfidentialTransferAccount */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(27), 0) && containsBytes(data, getU8Encoder().encode(3), 1)) {\n    return 35 /* ApproveConfidentialTransferAccount */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(27), 0) && containsBytes(data, getU8Encoder().encode(4), 1)) {\n    return 36 /* EmptyConfidentialTransferAccount */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(27), 0) && containsBytes(data, getU8Encoder().encode(5), 1)) {\n    return 37 /* ConfidentialDeposit */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(27), 0) && containsBytes(data, getU8Encoder().encode(6), 1)) {\n    return 38 /* ConfidentialWithdraw */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(27), 0) && containsBytes(data, getU8Encoder().encode(7), 1)) {\n    return 39 /* ConfidentialTransfer */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(27), 0) && containsBytes(data, getU8Encoder().encode(8), 1)) {\n    return 40 /* ApplyConfidentialPendingBalance */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(27), 0) && containsBytes(data, getU8Encoder().encode(9), 1)) {\n    return 41 /* EnableConfidentialCredits */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(27), 0) && containsBytes(data, getU8Encoder().encode(10), 1)) {\n    return 42 /* DisableConfidentialCredits */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(27), 0) && containsBytes(data, getU8Encoder().encode(11), 1)) {\n    return 43 /* EnableNonConfidentialCredits */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(27), 0) && containsBytes(data, getU8Encoder().encode(12), 1)) {\n    return 44 /* DisableNonConfidentialCredits */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(27), 0) && containsBytes(data, getU8Encoder().encode(13), 1)) {\n    return 45 /* ConfidentialTransferWithFee */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(28), 0) && containsBytes(data, getU8Encoder().encode(0), 1)) {\n    return 46 /* InitializeDefaultAccountState */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(28), 0) && containsBytes(data, getU8Encoder().encode(1), 1)) {\n    return 47 /* UpdateDefaultAccountState */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(29), 0)) {\n    return 48 /* Reallocate */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(30), 0) && containsBytes(data, getU8Encoder().encode(0), 1)) {\n    return 49 /* EnableMemoTransfers */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(30), 0) && containsBytes(data, getU8Encoder().encode(1), 1)) {\n    return 50 /* DisableMemoTransfers */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(31), 0)) {\n    return 51 /* CreateNativeMint */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(32), 0)) {\n    return 52 /* InitializeNonTransferableMint */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(33), 0) && containsBytes(data, getU8Encoder().encode(0), 1)) {\n    return 53 /* InitializeInterestBearingMint */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(33), 0) && containsBytes(data, getU8Encoder().encode(1), 1)) {\n    return 54 /* UpdateRateInterestBearingMint */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(34), 0) && containsBytes(data, getU8Encoder().encode(0), 1)) {\n    return 55 /* EnableCpiGuard */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(34), 0) && containsBytes(data, getU8Encoder().encode(1), 1)) {\n    return 56 /* DisableCpiGuard */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(35), 0)) {\n    return 57 /* InitializePermanentDelegate */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(36), 0) && containsBytes(data, getU8Encoder().encode(0), 1)) {\n    return 58 /* InitializeTransferHook */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(36), 0) && containsBytes(data, getU8Encoder().encode(1), 1)) {\n    return 59 /* UpdateTransferHook */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(37), 0) && containsBytes(data, getU8Encoder().encode(0), 1)) {\n    return 60 /* InitializeConfidentialTransferFee */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(37), 0) && containsBytes(data, getU8Encoder().encode(1), 1)) {\n    return 61 /* WithdrawWithheldTokensFromMintForConfidentialTransferFee */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(37), 0) && containsBytes(data, getU8Encoder().encode(2), 1)) {\n    return 62 /* WithdrawWithheldTokensFromAccountsForConfidentialTransferFee */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(37), 0) && containsBytes(data, getU8Encoder().encode(3), 1)) {\n    return 63 /* HarvestWithheldTokensToMintForConfidentialTransferFee */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(37), 0) && containsBytes(data, getU8Encoder().encode(4), 1)) {\n    return 64 /* EnableHarvestToMint */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(37), 0) && containsBytes(data, getU8Encoder().encode(5), 1)) {\n    return 65 /* DisableHarvestToMint */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(38), 0)) {\n    return 66 /* WithdrawExcessLamports */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(39), 0) && containsBytes(data, getU8Encoder().encode(0), 1)) {\n    return 67 /* InitializeMetadataPointer */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(39), 0) && containsBytes(data, getU8Encoder().encode(1), 1)) {\n    return 68 /* UpdateMetadataPointer */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(40), 0) && containsBytes(data, getU8Encoder().encode(0), 1)) {\n    return 69 /* InitializeGroupPointer */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(40), 0) && containsBytes(data, getU8Encoder().encode(1), 1)) {\n    return 70 /* UpdateGroupPointer */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(41), 0) && containsBytes(data, getU8Encoder().encode(0), 1)) {\n    return 71 /* InitializeGroupMemberPointer */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(41), 0) && containsBytes(data, getU8Encoder().encode(1), 1)) {\n    return 72 /* UpdateGroupMemberPointer */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(43), 0) && containsBytes(data, getU8Encoder().encode(0), 1)) {\n    return 73 /* InitializeScaledUiAmountMint */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(43), 0) && containsBytes(data, getU8Encoder().encode(1), 1)) {\n    return 74 /* UpdateMultiplierScaledUiMint */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(44), 0) && containsBytes(data, getU8Encoder().encode(0), 1)) {\n    return 75 /* InitializePausableConfig */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(44), 0) && containsBytes(data, getU8Encoder().encode(1), 1)) {\n    return 76 /* Pause */;\n  }\n  if (containsBytes(data, getU8Encoder().encode(44), 0) && containsBytes(data, getU8Encoder().encode(2), 1)) {\n    return 77 /* Resume */;\n  }\n  if (containsBytes(\n    data,\n    new Uint8Array([210, 225, 30, 162, 88, 184, 77, 141]),\n    0\n  )) {\n    return 78 /* InitializeTokenMetadata */;\n  }\n  if (containsBytes(\n    data,\n    new Uint8Array([221, 233, 49, 45, 181, 202, 220, 200]),\n    0\n  )) {\n    return 79 /* UpdateTokenMetadataField */;\n  }\n  if (containsBytes(data, new Uint8Array([234, 18, 32, 56, 89, 141, 37, 181]), 0)) {\n    return 80 /* RemoveTokenMetadataKey */;\n  }\n  if (containsBytes(\n    data,\n    new Uint8Array([215, 228, 166, 228, 84, 100, 86, 123]),\n    0\n  )) {\n    return 81 /* UpdateTokenMetadataUpdateAuthority */;\n  }\n  if (containsBytes(\n    data,\n    new Uint8Array([250, 166, 180, 250, 13, 12, 184, 70]),\n    0\n  )) {\n    return 82 /* EmitTokenMetadata */;\n  }\n  if (containsBytes(data, new Uint8Array([121, 113, 108, 39, 54, 51, 0, 4]), 0)) {\n    return 83 /* InitializeTokenGroup */;\n  }\n  if (containsBytes(\n    data,\n    new Uint8Array([108, 37, 171, 143, 248, 30, 18, 110]),\n    0\n  )) {\n    return 84 /* UpdateTokenGroupMaxSize */;\n  }\n  if (containsBytes(\n    data,\n    new Uint8Array([161, 105, 88, 1, 237, 221, 216, 203]),\n    0\n  )) {\n    return 85 /* UpdateTokenGroupUpdateAuthority */;\n  }\n  if (containsBytes(\n    data,\n    new Uint8Array([152, 32, 222, 176, 223, 237, 116, 134]),\n    0\n  )) {\n    return 86 /* InitializeTokenGroupMember */;\n  }\n  throw new Error(\n    \"The provided instruction could not be identified as a token-2022 instruction.\"\n  );\n}\n\n// src/generated/errors/associatedToken.ts\nvar ASSOCIATED_TOKEN_ERROR__INVALID_OWNER = 0;\nvar associatedTokenErrorMessages;\nif (process.env.NODE_ENV !== \"production\") {\n  associatedTokenErrorMessages = {\n    [ASSOCIATED_TOKEN_ERROR__INVALID_OWNER]: `Associated token account owner does not match address derivation`\n  };\n}\nfunction getAssociatedTokenErrorMessage(code) {\n  if (process.env.NODE_ENV !== \"production\") {\n    return associatedTokenErrorMessages[code];\n  }\n  return \"Error message not available in production bundles.\";\n}\nfunction isAssociatedTokenError(error, transactionMessage, code) {\n  return isProgramError(\n    error,\n    transactionMessage,\n    ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n    code\n  );\n}\nvar TOKEN_2022_ERROR__NOT_RENT_EXEMPT = 0;\nvar TOKEN_2022_ERROR__INSUFFICIENT_FUNDS = 1;\nvar TOKEN_2022_ERROR__INVALID_MINT = 2;\nvar TOKEN_2022_ERROR__MINT_MISMATCH = 3;\nvar TOKEN_2022_ERROR__OWNER_MISMATCH = 4;\nvar TOKEN_2022_ERROR__FIXED_SUPPLY = 5;\nvar TOKEN_2022_ERROR__ALREADY_IN_USE = 6;\nvar TOKEN_2022_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS = 7;\nvar TOKEN_2022_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS = 8;\nvar TOKEN_2022_ERROR__UNINITIALIZED_STATE = 9;\nvar TOKEN_2022_ERROR__NATIVE_NOT_SUPPORTED = 10;\nvar TOKEN_2022_ERROR__NON_NATIVE_HAS_BALANCE = 11;\nvar TOKEN_2022_ERROR__INVALID_INSTRUCTION = 12;\nvar TOKEN_2022_ERROR__INVALID_STATE = 13;\nvar TOKEN_2022_ERROR__OVERFLOW = 14;\nvar TOKEN_2022_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED = 15;\nvar TOKEN_2022_ERROR__MINT_CANNOT_FREEZE = 16;\nvar TOKEN_2022_ERROR__ACCOUNT_FROZEN = 17;\nvar TOKEN_2022_ERROR__MINT_DECIMALS_MISMATCH = 18;\nvar TOKEN_2022_ERROR__NON_NATIVE_NOT_SUPPORTED = 19;\nvar token2022ErrorMessages;\nif (process.env.NODE_ENV !== \"production\") {\n  token2022ErrorMessages = {\n    [TOKEN_2022_ERROR__ACCOUNT_FROZEN]: `Account is frozen`,\n    [TOKEN_2022_ERROR__ALREADY_IN_USE]: `Already in use`,\n    [TOKEN_2022_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED]: `Account does not support specified authority type`,\n    [TOKEN_2022_ERROR__FIXED_SUPPLY]: `Fixed supply`,\n    [TOKEN_2022_ERROR__INSUFFICIENT_FUNDS]: `Insufficient funds`,\n    [TOKEN_2022_ERROR__INVALID_INSTRUCTION]: `Invalid instruction`,\n    [TOKEN_2022_ERROR__INVALID_MINT]: `Invalid Mint`,\n    [TOKEN_2022_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS]: `Invalid number of provided signers`,\n    [TOKEN_2022_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS]: `Invalid number of required signers`,\n    [TOKEN_2022_ERROR__INVALID_STATE]: `State is invalid for requested operation`,\n    [TOKEN_2022_ERROR__MINT_CANNOT_FREEZE]: `This token mint cannot freeze accounts`,\n    [TOKEN_2022_ERROR__MINT_DECIMALS_MISMATCH]: `The provided decimals value different from the Mint decimals`,\n    [TOKEN_2022_ERROR__MINT_MISMATCH]: `Account not associated with this Mint`,\n    [TOKEN_2022_ERROR__NATIVE_NOT_SUPPORTED]: `Instruction does not support native tokens`,\n    [TOKEN_2022_ERROR__NON_NATIVE_HAS_BALANCE]: `Non-native account can only be closed if its balance is zero`,\n    [TOKEN_2022_ERROR__NON_NATIVE_NOT_SUPPORTED]: `Instruction does not support non-native tokens`,\n    [TOKEN_2022_ERROR__NOT_RENT_EXEMPT]: `Lamport balance below rent-exempt threshold`,\n    [TOKEN_2022_ERROR__OVERFLOW]: `Operation overflowed`,\n    [TOKEN_2022_ERROR__OWNER_MISMATCH]: `Owner does not match`,\n    [TOKEN_2022_ERROR__UNINITIALIZED_STATE]: `State is unititialized`\n  };\n}\nfunction getToken2022ErrorMessage(code) {\n  if (process.env.NODE_ENV !== \"production\") {\n    return token2022ErrorMessages[code];\n  }\n  return \"Error message not available in production bundles.\";\n}\nfunction isToken2022Error(error, transactionMessage, code) {\n  return isProgramError(\n    error,\n    transactionMessage,\n    TOKEN_2022_PROGRAM_ADDRESS,\n    code\n  );\n}\nfunction expectAddress(value) {\n  if (!value) {\n    throw new Error(\"Expected a Address.\");\n  }\n  if (typeof value === \"object\" && \"address\" in value) {\n    return value.address;\n  }\n  if (Array.isArray(value)) {\n    return value[0];\n  }\n  return value;\n}\nfunction getAccountMetaFactory(programAddress, optionalAccountStrategy) {\n  return (account) => {\n    if (!account.value) {\n      return Object.freeze({\n        address: programAddress,\n        role: AccountRole.READONLY\n      });\n    }\n    const writableRole = account.isWritable ? AccountRole.WRITABLE : AccountRole.READONLY;\n    return Object.freeze({\n      address: expectAddress(account.value),\n      role: isTransactionSigner(account.value) ? upgradeRoleToSigner(writableRole) : writableRole,\n      ...isTransactionSigner(account.value) ? { signer: account.value } : {}\n    });\n  };\n}\nfunction isTransactionSigner(value) {\n  return !!value && typeof value === \"object\" && \"address\" in value && isTransactionSigner$1(value);\n}\n\n// src/generated/instructions/amountToUiAmount.ts\nvar AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR = 23;\nfunction getAmountToUiAmountDiscriminatorBytes() {\n  return getU8Encoder().encode(AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR);\n}\nfunction getAmountToUiAmountInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"amount\", getU64Encoder()]\n    ]),\n    (value) => ({ ...value, discriminator: AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR })\n  );\n}\nfunction getAmountToUiAmountInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"amount\", getU64Decoder()]\n  ]);\n}\nfunction getAmountToUiAmountInstructionDataCodec() {\n  return combineCodec(\n    getAmountToUiAmountInstructionDataEncoder(),\n    getAmountToUiAmountInstructionDataDecoder()\n  );\n}\nfunction getAmountToUiAmountInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getAmountToUiAmountInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseAmountToUiAmountInstruction(instruction) {\n  if (instruction.accounts.length < 1) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getAmountToUiAmountInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar APPLY_CONFIDENTIAL_PENDING_BALANCE_DISCRIMINATOR = 27;\nfunction getApplyConfidentialPendingBalanceDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    APPLY_CONFIDENTIAL_PENDING_BALANCE_DISCRIMINATOR\n  );\n}\nvar APPLY_CONFIDENTIAL_PENDING_BALANCE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 8;\nfunction getApplyConfidentialPendingBalanceConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    APPLY_CONFIDENTIAL_PENDING_BALANCE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\nfunction getApplyConfidentialPendingBalanceInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"confidentialTransferDiscriminator\", getU8Encoder()],\n      [\"expectedPendingBalanceCreditCounter\", getU64Encoder()],\n      [\"newDecryptableAvailableBalance\", getDecryptableBalanceEncoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: APPLY_CONFIDENTIAL_PENDING_BALANCE_DISCRIMINATOR,\n      confidentialTransferDiscriminator: APPLY_CONFIDENTIAL_PENDING_BALANCE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n    })\n  );\n}\nfunction getApplyConfidentialPendingBalanceInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"confidentialTransferDiscriminator\", getU8Decoder()],\n    [\"expectedPendingBalanceCreditCounter\", getU64Decoder()],\n    [\"newDecryptableAvailableBalance\", getDecryptableBalanceDecoder()]\n  ]);\n}\nfunction getApplyConfidentialPendingBalanceInstructionDataCodec() {\n  return combineCodec(\n    getApplyConfidentialPendingBalanceInstructionDataEncoder(),\n    getApplyConfidentialPendingBalanceInstructionDataDecoder()\n  );\n}\nfunction getApplyConfidentialPendingBalanceInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts\n    ],\n    data: getApplyConfidentialPendingBalanceInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseApplyConfidentialPendingBalanceInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), authority: getNextAccount() },\n    data: getApplyConfidentialPendingBalanceInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar APPROVE_DISCRIMINATOR = 4;\nfunction getApproveDiscriminatorBytes() {\n  return getU8Encoder().encode(APPROVE_DISCRIMINATOR);\n}\nfunction getApproveInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"amount\", getU64Encoder()]\n    ]),\n    (value) => ({ ...value, discriminator: APPROVE_DISCRIMINATOR })\n  );\n}\nfunction getApproveInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"amount\", getU64Decoder()]\n  ]);\n}\nfunction getApproveInstructionDataCodec() {\n  return combineCodec(\n    getApproveInstructionDataEncoder(),\n    getApproveInstructionDataDecoder()\n  );\n}\nfunction getApproveInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    delegate: { value: input.delegate ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.delegate),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts\n    ],\n    data: getApproveInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseApproveInstruction(instruction) {\n  if (instruction.accounts.length < 3) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      delegate: getNextAccount(),\n      owner: getNextAccount()\n    },\n    data: getApproveInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar APPROVE_CHECKED_DISCRIMINATOR = 13;\nfunction getApproveCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(APPROVE_CHECKED_DISCRIMINATOR);\n}\nfunction getApproveCheckedInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"amount\", getU64Encoder()],\n      [\"decimals\", getU8Encoder()]\n    ]),\n    (value) => ({ ...value, discriminator: APPROVE_CHECKED_DISCRIMINATOR })\n  );\n}\nfunction getApproveCheckedInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"amount\", getU64Decoder()],\n    [\"decimals\", getU8Decoder()]\n  ]);\n}\nfunction getApproveCheckedInstructionDataCodec() {\n  return combineCodec(\n    getApproveCheckedInstructionDataEncoder(),\n    getApproveCheckedInstructionDataDecoder()\n  );\n}\nfunction getApproveCheckedInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    delegate: { value: input.delegate ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.delegate),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts\n    ],\n    data: getApproveCheckedInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseApproveCheckedInstruction(instruction) {\n  if (instruction.accounts.length < 4) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      mint: getNextAccount(),\n      delegate: getNextAccount(),\n      owner: getNextAccount()\n    },\n    data: getApproveCheckedInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR = 27;\nfunction getApproveConfidentialTransferAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR\n  );\n}\nvar APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 3;\nfunction getApproveConfidentialTransferAccountConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\nfunction getApproveConfidentialTransferAccountInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"confidentialTransferDiscriminator\", getU8Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR,\n      confidentialTransferDiscriminator: APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n    })\n  );\n}\nfunction getApproveConfidentialTransferAccountInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"confidentialTransferDiscriminator\", getU8Decoder()]\n  ]);\n}\nfunction getApproveConfidentialTransferAccountInstructionDataCodec() {\n  return combineCodec(\n    getApproveConfidentialTransferAccountInstructionDataEncoder(),\n    getApproveConfidentialTransferAccountInstructionDataDecoder()\n  );\n}\nfunction getApproveConfidentialTransferAccountInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority)\n    ],\n    data: getApproveConfidentialTransferAccountInstructionDataEncoder().encode(\n      {}\n    ),\n    programAddress\n  });\n}\nfunction parseApproveConfidentialTransferAccountInstruction(instruction) {\n  if (instruction.accounts.length < 3) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount()\n    },\n    data: getApproveConfidentialTransferAccountInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar BURN_DISCRIMINATOR = 8;\nfunction getBurnDiscriminatorBytes() {\n  return getU8Encoder().encode(BURN_DISCRIMINATOR);\n}\nfunction getBurnInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"amount\", getU64Encoder()]\n    ]),\n    (value) => ({ ...value, discriminator: BURN_DISCRIMINATOR })\n  );\n}\nfunction getBurnInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"amount\", getU64Decoder()]\n  ]);\n}\nfunction getBurnInstructionDataCodec() {\n  return combineCodec(\n    getBurnInstructionDataEncoder(),\n    getBurnInstructionDataDecoder()\n  );\n}\nfunction getBurnInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts\n    ],\n    data: getBurnInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseBurnInstruction(instruction) {\n  if (instruction.accounts.length < 3) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount()\n    },\n    data: getBurnInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar BURN_CHECKED_DISCRIMINATOR = 15;\nfunction getBurnCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(BURN_CHECKED_DISCRIMINATOR);\n}\nfunction getBurnCheckedInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"amount\", getU64Encoder()],\n      [\"decimals\", getU8Encoder()]\n    ]),\n    (value) => ({ ...value, discriminator: BURN_CHECKED_DISCRIMINATOR })\n  );\n}\nfunction getBurnCheckedInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"amount\", getU64Decoder()],\n    [\"decimals\", getU8Decoder()]\n  ]);\n}\nfunction getBurnCheckedInstructionDataCodec() {\n  return combineCodec(\n    getBurnCheckedInstructionDataEncoder(),\n    getBurnCheckedInstructionDataDecoder()\n  );\n}\nfunction getBurnCheckedInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts\n    ],\n    data: getBurnCheckedInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseBurnCheckedInstruction(instruction) {\n  if (instruction.accounts.length < 3) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount()\n    },\n    data: getBurnCheckedInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar CLOSE_ACCOUNT_DISCRIMINATOR = 9;\nfunction getCloseAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(CLOSE_ACCOUNT_DISCRIMINATOR);\n}\nfunction getCloseAccountInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([[\"discriminator\", getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: CLOSE_ACCOUNT_DISCRIMINATOR })\n  );\n}\nfunction getCloseAccountInstructionDataDecoder() {\n  return getStructDecoder([[\"discriminator\", getU8Decoder()]]);\n}\nfunction getCloseAccountInstructionDataCodec() {\n  return combineCodec(\n    getCloseAccountInstructionDataEncoder(),\n    getCloseAccountInstructionDataDecoder()\n  );\n}\nfunction getCloseAccountInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts\n    ],\n    data: getCloseAccountInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseCloseAccountInstruction(instruction) {\n  if (instruction.accounts.length < 3) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      destination: getNextAccount(),\n      owner: getNextAccount()\n    },\n    data: getCloseAccountInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar CONFIDENTIAL_DEPOSIT_DISCRIMINATOR = 27;\nfunction getConfidentialDepositDiscriminatorBytes() {\n  return getU8Encoder().encode(CONFIDENTIAL_DEPOSIT_DISCRIMINATOR);\n}\nvar CONFIDENTIAL_DEPOSIT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 5;\nfunction getConfidentialDepositConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIDENTIAL_DEPOSIT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\nfunction getConfidentialDepositInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"confidentialTransferDiscriminator\", getU8Encoder()],\n      [\"amount\", getU64Encoder()],\n      [\"decimals\", getU8Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIDENTIAL_DEPOSIT_DISCRIMINATOR,\n      confidentialTransferDiscriminator: CONFIDENTIAL_DEPOSIT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n    })\n  );\n}\nfunction getConfidentialDepositInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"confidentialTransferDiscriminator\", getU8Decoder()],\n    [\"amount\", getU64Decoder()],\n    [\"decimals\", getU8Decoder()]\n  ]);\n}\nfunction getConfidentialDepositInstructionDataCodec() {\n  return combineCodec(\n    getConfidentialDepositInstructionDataEncoder(),\n    getConfidentialDepositInstructionDataDecoder()\n  );\n}\nfunction getConfidentialDepositInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts\n    ],\n    data: getConfidentialDepositInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseConfidentialDepositInstruction(instruction) {\n  if (instruction.accounts.length < 3) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount()\n    },\n    data: getConfidentialDepositInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 27;\nfunction getConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(CONFIDENTIAL_TRANSFER_DISCRIMINATOR);\n}\nvar CONFIDENTIAL_TRANSFER_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 7;\nfunction getConfidentialTransferConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIDENTIAL_TRANSFER_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\nfunction getConfidentialTransferInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"confidentialTransferDiscriminator\", getU8Encoder()],\n      [\"newSourceDecryptableAvailableBalance\", getDecryptableBalanceEncoder()],\n      [\"equalityProofInstructionOffset\", getI8Encoder()],\n      [\"ciphertextValidityProofInstructionOffset\", getI8Encoder()],\n      [\"rangeProofInstructionOffset\", getI8Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n      confidentialTransferDiscriminator: CONFIDENTIAL_TRANSFER_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n    })\n  );\n}\nfunction getConfidentialTransferInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"confidentialTransferDiscriminator\", getU8Decoder()],\n    [\"newSourceDecryptableAvailableBalance\", getDecryptableBalanceDecoder()],\n    [\"equalityProofInstructionOffset\", getI8Decoder()],\n    [\"ciphertextValidityProofInstructionOffset\", getI8Decoder()],\n    [\"rangeProofInstructionOffset\", getI8Decoder()]\n  ]);\n}\nfunction getConfidentialTransferInstructionDataCodec() {\n  return combineCodec(\n    getConfidentialTransferInstructionDataEncoder(),\n    getConfidentialTransferInstructionDataDecoder()\n  );\n}\nfunction getConfidentialTransferInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    sourceToken: { value: input.sourceToken ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    destinationToken: {\n      value: input.destinationToken ?? null,\n      isWritable: true\n    },\n    instructionsSysvar: {\n      value: input.instructionsSysvar ?? null,\n      isWritable: false\n    },\n    equalityRecord: { value: input.equalityRecord ?? null, isWritable: false },\n    ciphertextValidityRecord: {\n      value: input.ciphertextValidityRecord ?? null,\n      isWritable: false\n    },\n    rangeRecord: { value: input.rangeRecord ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.sourceToken),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destinationToken),\n      getAccountMeta(accounts.instructionsSysvar),\n      getAccountMeta(accounts.equalityRecord),\n      getAccountMeta(accounts.ciphertextValidityRecord),\n      getAccountMeta(accounts.rangeRecord),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts\n    ],\n    data: getConfidentialTransferInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseConfidentialTransferInstruction(instruction) {\n  if (instruction.accounts.length < 8) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS ? void 0 : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      sourceToken: getNextAccount(),\n      mint: getNextAccount(),\n      destinationToken: getNextAccount(),\n      instructionsSysvar: getNextOptionalAccount(),\n      equalityRecord: getNextOptionalAccount(),\n      ciphertextValidityRecord: getNextOptionalAccount(),\n      rangeRecord: getNextOptionalAccount(),\n      authority: getNextAccount()\n    },\n    data: getConfidentialTransferInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar CONFIDENTIAL_TRANSFER_WITH_FEE_DISCRIMINATOR = 27;\nfunction getConfidentialTransferWithFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(CONFIDENTIAL_TRANSFER_WITH_FEE_DISCRIMINATOR);\n}\nvar CONFIDENTIAL_TRANSFER_WITH_FEE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 13;\nfunction getConfidentialTransferWithFeeConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIDENTIAL_TRANSFER_WITH_FEE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\nfunction getConfidentialTransferWithFeeInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"confidentialTransferDiscriminator\", getU8Encoder()],\n      [\"newSourceDecryptableAvailableBalance\", getDecryptableBalanceEncoder()],\n      [\"equalityProofInstructionOffset\", getI8Encoder()],\n      [\n        \"transferAmountCiphertextValidityProofInstructionOffset\",\n        getI8Encoder()\n      ],\n      [\"feeSigmaProofInstructionOffset\", getI8Encoder()],\n      [\"feeCiphertextValidityProofInstructionOffset\", getI8Encoder()],\n      [\"rangeProofInstructionOffset\", getI8Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIDENTIAL_TRANSFER_WITH_FEE_DISCRIMINATOR,\n      confidentialTransferDiscriminator: CONFIDENTIAL_TRANSFER_WITH_FEE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n    })\n  );\n}\nfunction getConfidentialTransferWithFeeInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"confidentialTransferDiscriminator\", getU8Decoder()],\n    [\"newSourceDecryptableAvailableBalance\", getDecryptableBalanceDecoder()],\n    [\"equalityProofInstructionOffset\", getI8Decoder()],\n    [\"transferAmountCiphertextValidityProofInstructionOffset\", getI8Decoder()],\n    [\"feeSigmaProofInstructionOffset\", getI8Decoder()],\n    [\"feeCiphertextValidityProofInstructionOffset\", getI8Decoder()],\n    [\"rangeProofInstructionOffset\", getI8Decoder()]\n  ]);\n}\nfunction getConfidentialTransferWithFeeInstructionDataCodec() {\n  return combineCodec(\n    getConfidentialTransferWithFeeInstructionDataEncoder(),\n    getConfidentialTransferWithFeeInstructionDataDecoder()\n  );\n}\nfunction getConfidentialTransferWithFeeInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    sourceToken: { value: input.sourceToken ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    destinationToken: {\n      value: input.destinationToken ?? null,\n      isWritable: true\n    },\n    instructionsSysvar: {\n      value: input.instructionsSysvar ?? null,\n      isWritable: false\n    },\n    equalityRecord: { value: input.equalityRecord ?? null, isWritable: false },\n    transferAmountCiphertextValidityRecord: {\n      value: input.transferAmountCiphertextValidityRecord ?? null,\n      isWritable: false\n    },\n    feeSigmaRecord: { value: input.feeSigmaRecord ?? null, isWritable: false },\n    feeCiphertextValidityRecord: {\n      value: input.feeCiphertextValidityRecord ?? null,\n      isWritable: false\n    },\n    rangeRecord: { value: input.rangeRecord ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.sourceToken),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destinationToken),\n      getAccountMeta(accounts.instructionsSysvar),\n      getAccountMeta(accounts.equalityRecord),\n      getAccountMeta(accounts.transferAmountCiphertextValidityRecord),\n      getAccountMeta(accounts.feeSigmaRecord),\n      getAccountMeta(accounts.feeCiphertextValidityRecord),\n      getAccountMeta(accounts.rangeRecord),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts\n    ],\n    data: getConfidentialTransferWithFeeInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseConfidentialTransferWithFeeInstruction(instruction) {\n  if (instruction.accounts.length < 10) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS ? void 0 : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      sourceToken: getNextAccount(),\n      mint: getNextAccount(),\n      destinationToken: getNextAccount(),\n      instructionsSysvar: getNextOptionalAccount(),\n      equalityRecord: getNextOptionalAccount(),\n      transferAmountCiphertextValidityRecord: getNextOptionalAccount(),\n      feeSigmaRecord: getNextOptionalAccount(),\n      feeCiphertextValidityRecord: getNextOptionalAccount(),\n      rangeRecord: getNextOptionalAccount(),\n      authority: getNextAccount()\n    },\n    data: getConfidentialTransferWithFeeInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar CONFIDENTIAL_WITHDRAW_DISCRIMINATOR = 27;\nfunction getConfidentialWithdrawDiscriminatorBytes() {\n  return getU8Encoder().encode(CONFIDENTIAL_WITHDRAW_DISCRIMINATOR);\n}\nvar CONFIDENTIAL_WITHDRAW_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 6;\nfunction getConfidentialWithdrawConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIDENTIAL_WITHDRAW_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\nfunction getConfidentialWithdrawInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"confidentialTransferDiscriminator\", getU8Encoder()],\n      [\"amount\", getU64Encoder()],\n      [\"decimals\", getU8Encoder()],\n      [\"newDecryptableAvailableBalance\", getDecryptableBalanceEncoder()],\n      [\"equalityProofInstructionOffset\", getI8Encoder()],\n      [\"rangeProofInstructionOffset\", getI8Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIDENTIAL_WITHDRAW_DISCRIMINATOR,\n      confidentialTransferDiscriminator: CONFIDENTIAL_WITHDRAW_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n    })\n  );\n}\nfunction getConfidentialWithdrawInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"confidentialTransferDiscriminator\", getU8Decoder()],\n    [\"amount\", getU64Decoder()],\n    [\"decimals\", getU8Decoder()],\n    [\"newDecryptableAvailableBalance\", getDecryptableBalanceDecoder()],\n    [\"equalityProofInstructionOffset\", getI8Decoder()],\n    [\"rangeProofInstructionOffset\", getI8Decoder()]\n  ]);\n}\nfunction getConfidentialWithdrawInstructionDataCodec() {\n  return combineCodec(\n    getConfidentialWithdrawInstructionDataEncoder(),\n    getConfidentialWithdrawInstructionDataDecoder()\n  );\n}\nfunction getConfidentialWithdrawInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    instructionsSysvar: {\n      value: input.instructionsSysvar ?? null,\n      isWritable: false\n    },\n    equalityRecord: { value: input.equalityRecord ?? null, isWritable: false },\n    rangeRecord: { value: input.rangeRecord ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.instructionsSysvar),\n      getAccountMeta(accounts.equalityRecord),\n      getAccountMeta(accounts.rangeRecord),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts\n    ],\n    data: getConfidentialWithdrawInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseConfidentialWithdrawInstruction(instruction) {\n  if (instruction.accounts.length < 6) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS ? void 0 : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      mint: getNextAccount(),\n      instructionsSysvar: getNextOptionalAccount(),\n      equalityRecord: getNextOptionalAccount(),\n      rangeRecord: getNextOptionalAccount(),\n      authority: getNextAccount()\n    },\n    data: getConfidentialWithdrawInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR = 27;\nfunction getConfigureConfidentialTransferAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR\n  );\n}\nvar CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 2;\nfunction getConfigureConfidentialTransferAccountConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\nfunction getConfigureConfidentialTransferAccountInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"confidentialTransferDiscriminator\", getU8Encoder()],\n      [\"decryptableZeroBalance\", getDecryptableBalanceEncoder()],\n      [\"maximumPendingBalanceCreditCounter\", getU64Encoder()],\n      [\"proofInstructionOffset\", getI8Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR,\n      confidentialTransferDiscriminator: CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n    })\n  );\n}\nfunction getConfigureConfidentialTransferAccountInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"confidentialTransferDiscriminator\", getU8Decoder()],\n    [\"decryptableZeroBalance\", getDecryptableBalanceDecoder()],\n    [\"maximumPendingBalanceCreditCounter\", getU64Decoder()],\n    [\"proofInstructionOffset\", getI8Decoder()]\n  ]);\n}\nfunction getConfigureConfidentialTransferAccountInstructionDataCodec() {\n  return combineCodec(\n    getConfigureConfidentialTransferAccountInstructionDataEncoder(),\n    getConfigureConfidentialTransferAccountInstructionDataDecoder()\n  );\n}\nfunction getConfigureConfidentialTransferAccountInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    instructionsSysvarOrContextState: {\n      value: input.instructionsSysvarOrContextState ?? null,\n      isWritable: false\n    },\n    record: { value: input.record ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  if (!accounts.instructionsSysvarOrContextState.value) {\n    accounts.instructionsSysvarOrContextState.value = \"Sysvar1nstructions1111111111111111111111111\";\n  }\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.instructionsSysvarOrContextState),\n      getAccountMeta(accounts.record),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts\n    ],\n    data: getConfigureConfidentialTransferAccountInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseConfigureConfidentialTransferAccountInstruction(instruction) {\n  if (instruction.accounts.length < 5) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS ? void 0 : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      mint: getNextAccount(),\n      instructionsSysvarOrContextState: getNextAccount(),\n      record: getNextOptionalAccount(),\n      authority: getNextAccount()\n    },\n    data: getConfigureConfidentialTransferAccountInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nasync function findAssociatedTokenPda(seeds, config = {}) {\n  const {\n    programAddress = \"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\"\n  } = config;\n  return await getProgramDerivedAddress({\n    programAddress,\n    seeds: [\n      getAddressEncoder().encode(seeds.owner),\n      getAddressEncoder().encode(seeds.tokenProgram),\n      getAddressEncoder().encode(seeds.mint)\n    ]\n  });\n}\n\n// src/generated/instructions/createAssociatedToken.ts\nvar CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR = 0;\nfunction getCreateAssociatedTokenDiscriminatorBytes() {\n  return getU8Encoder().encode(CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR);\n}\nfunction getCreateAssociatedTokenInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([[\"discriminator\", getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR\n    })\n  );\n}\nfunction getCreateAssociatedTokenInstructionDataDecoder() {\n  return getStructDecoder([[\"discriminator\", getU8Decoder()]]);\n}\nfunction getCreateAssociatedTokenInstructionDataCodec() {\n  return combineCodec(\n    getCreateAssociatedTokenInstructionDataEncoder(),\n    getCreateAssociatedTokenInstructionDataDecoder()\n  );\n}\nasync function getCreateAssociatedTokenInstructionAsync(input, config) {\n  const programAddress = config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value = \"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\";\n  }\n  if (!accounts.ata.value) {\n    accounts.ata.value = await findAssociatedTokenPda({\n      owner: expectAddress(accounts.owner.value),\n      tokenProgram: expectAddress(accounts.tokenProgram.value),\n      mint: expectAddress(accounts.mint.value)\n    });\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value = \"11111111111111111111111111111111\";\n  }\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram)\n    ],\n    data: getCreateAssociatedTokenInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction getCreateAssociatedTokenInstruction(input, config) {\n  const programAddress = config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value = \"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\";\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value = \"11111111111111111111111111111111\";\n  }\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram)\n    ],\n    data: getCreateAssociatedTokenInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseCreateAssociatedTokenInstruction(instruction) {\n  if (instruction.accounts.length < 6) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      ata: getNextAccount(),\n      owner: getNextAccount(),\n      mint: getNextAccount(),\n      systemProgram: getNextAccount(),\n      tokenProgram: getNextAccount()\n    },\n    data: getCreateAssociatedTokenInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR = 1;\nfunction getCreateAssociatedTokenIdempotentDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR\n  );\n}\nfunction getCreateAssociatedTokenIdempotentInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([[\"discriminator\", getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR\n    })\n  );\n}\nfunction getCreateAssociatedTokenIdempotentInstructionDataDecoder() {\n  return getStructDecoder([[\"discriminator\", getU8Decoder()]]);\n}\nfunction getCreateAssociatedTokenIdempotentInstructionDataCodec() {\n  return combineCodec(\n    getCreateAssociatedTokenIdempotentInstructionDataEncoder(),\n    getCreateAssociatedTokenIdempotentInstructionDataDecoder()\n  );\n}\nasync function getCreateAssociatedTokenIdempotentInstructionAsync(input, config) {\n  const programAddress = config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value = \"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\";\n  }\n  if (!accounts.ata.value) {\n    accounts.ata.value = await findAssociatedTokenPda({\n      owner: expectAddress(accounts.owner.value),\n      tokenProgram: expectAddress(accounts.tokenProgram.value),\n      mint: expectAddress(accounts.mint.value)\n    });\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value = \"11111111111111111111111111111111\";\n  }\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram)\n    ],\n    data: getCreateAssociatedTokenIdempotentInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction getCreateAssociatedTokenIdempotentInstruction(input, config) {\n  const programAddress = config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value = \"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\";\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value = \"11111111111111111111111111111111\";\n  }\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram)\n    ],\n    data: getCreateAssociatedTokenIdempotentInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseCreateAssociatedTokenIdempotentInstruction(instruction) {\n  if (instruction.accounts.length < 6) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      ata: getNextAccount(),\n      owner: getNextAccount(),\n      mint: getNextAccount(),\n      systemProgram: getNextAccount(),\n      tokenProgram: getNextAccount()\n    },\n    data: getCreateAssociatedTokenIdempotentInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar CREATE_NATIVE_MINT_DISCRIMINATOR = 31;\nfunction getCreateNativeMintDiscriminatorBytes() {\n  return getU8Encoder().encode(CREATE_NATIVE_MINT_DISCRIMINATOR);\n}\nfunction getCreateNativeMintInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([[\"discriminator\", getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: CREATE_NATIVE_MINT_DISCRIMINATOR })\n  );\n}\nfunction getCreateNativeMintInstructionDataDecoder() {\n  return getStructDecoder([[\"discriminator\", getU8Decoder()]]);\n}\nfunction getCreateNativeMintInstructionDataCodec() {\n  return combineCodec(\n    getCreateNativeMintInstructionDataEncoder(),\n    getCreateNativeMintInstructionDataDecoder()\n  );\n}\nfunction getCreateNativeMintInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    nativeMint: { value: input.nativeMint ?? null, isWritable: true },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value = \"11111111111111111111111111111111\";\n  }\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.nativeMint),\n      getAccountMeta(accounts.systemProgram)\n    ],\n    data: getCreateNativeMintInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseCreateNativeMintInstruction(instruction) {\n  if (instruction.accounts.length < 3) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      nativeMint: getNextAccount(),\n      systemProgram: getNextAccount()\n    },\n    data: getCreateNativeMintInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar DISABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR = 27;\nfunction getDisableConfidentialCreditsDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR);\n}\nvar DISABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 10;\nfunction getDisableConfidentialCreditsConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    DISABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\nfunction getDisableConfidentialCreditsInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"confidentialTransferDiscriminator\", getU8Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR,\n      confidentialTransferDiscriminator: DISABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n    })\n  );\n}\nfunction getDisableConfidentialCreditsInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"confidentialTransferDiscriminator\", getU8Decoder()]\n  ]);\n}\nfunction getDisableConfidentialCreditsInstructionDataCodec() {\n  return combineCodec(\n    getDisableConfidentialCreditsInstructionDataEncoder(),\n    getDisableConfidentialCreditsInstructionDataDecoder()\n  );\n}\nfunction getDisableConfidentialCreditsInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts\n    ],\n    data: getDisableConfidentialCreditsInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseDisableConfidentialCreditsInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), authority: getNextAccount() },\n    data: getDisableConfidentialCreditsInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar DISABLE_CPI_GUARD_DISCRIMINATOR = 34;\nfunction getDisableCpiGuardDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_CPI_GUARD_DISCRIMINATOR);\n}\nvar DISABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR = 1;\nfunction getDisableCpiGuardCpiGuardDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR);\n}\nfunction getDisableCpiGuardInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"cpiGuardDiscriminator\", getU8Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_CPI_GUARD_DISCRIMINATOR,\n      cpiGuardDiscriminator: DISABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR\n    })\n  );\n}\nfunction getDisableCpiGuardInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"cpiGuardDiscriminator\", getU8Decoder()]\n  ]);\n}\nfunction getDisableCpiGuardInstructionDataCodec() {\n  return combineCodec(\n    getDisableCpiGuardInstructionDataEncoder(),\n    getDisableCpiGuardInstructionDataDecoder()\n  );\n}\nfunction getDisableCpiGuardInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts\n    ],\n    data: getDisableCpiGuardInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseDisableCpiGuardInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), owner: getNextAccount() },\n    data: getDisableCpiGuardInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar DISABLE_HARVEST_TO_MINT_DISCRIMINATOR = 37;\nfunction getDisableHarvestToMintDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_HARVEST_TO_MINT_DISCRIMINATOR);\n}\nvar DISABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 5;\nfunction getDisableHarvestToMintConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    DISABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\nfunction getDisableHarvestToMintInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"confidentialTransferFeeDiscriminator\", getU8Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_HARVEST_TO_MINT_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator: DISABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n    })\n  );\n}\nfunction getDisableHarvestToMintInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"confidentialTransferFeeDiscriminator\", getU8Decoder()]\n  ]);\n}\nfunction getDisableHarvestToMintInstructionDataCodec() {\n  return combineCodec(\n    getDisableHarvestToMintInstructionDataEncoder(),\n    getDisableHarvestToMintInstructionDataDecoder()\n  );\n}\nfunction getDisableHarvestToMintInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts\n    ],\n    data: getDisableHarvestToMintInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseDisableHarvestToMintInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), authority: getNextAccount() },\n    data: getDisableHarvestToMintInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar DISABLE_MEMO_TRANSFERS_DISCRIMINATOR = 30;\nfunction getDisableMemoTransfersDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_MEMO_TRANSFERS_DISCRIMINATOR);\n}\nvar DISABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR = 1;\nfunction getDisableMemoTransfersMemoTransfersDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    DISABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR\n  );\n}\nfunction getDisableMemoTransfersInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"memoTransfersDiscriminator\", getU8Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_MEMO_TRANSFERS_DISCRIMINATOR,\n      memoTransfersDiscriminator: DISABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR\n    })\n  );\n}\nfunction getDisableMemoTransfersInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"memoTransfersDiscriminator\", getU8Decoder()]\n  ]);\n}\nfunction getDisableMemoTransfersInstructionDataCodec() {\n  return combineCodec(\n    getDisableMemoTransfersInstructionDataEncoder(),\n    getDisableMemoTransfersInstructionDataDecoder()\n  );\n}\nfunction getDisableMemoTransfersInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts\n    ],\n    data: getDisableMemoTransfersInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseDisableMemoTransfersInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), owner: getNextAccount() },\n    data: getDisableMemoTransfersInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar DISABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR = 27;\nfunction getDisableNonConfidentialCreditsDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR);\n}\nvar DISABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 12;\nfunction getDisableNonConfidentialCreditsConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    DISABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\nfunction getDisableNonConfidentialCreditsInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"confidentialTransferDiscriminator\", getU8Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR,\n      confidentialTransferDiscriminator: DISABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n    })\n  );\n}\nfunction getDisableNonConfidentialCreditsInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"confidentialTransferDiscriminator\", getU8Decoder()]\n  ]);\n}\nfunction getDisableNonConfidentialCreditsInstructionDataCodec() {\n  return combineCodec(\n    getDisableNonConfidentialCreditsInstructionDataEncoder(),\n    getDisableNonConfidentialCreditsInstructionDataDecoder()\n  );\n}\nfunction getDisableNonConfidentialCreditsInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts\n    ],\n    data: getDisableNonConfidentialCreditsInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseDisableNonConfidentialCreditsInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), authority: getNextAccount() },\n    data: getDisableNonConfidentialCreditsInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar EMIT_TOKEN_METADATA_DISCRIMINATOR = new Uint8Array([\n  250,\n  166,\n  180,\n  250,\n  13,\n  12,\n  184,\n  70\n]);\nfunction getEmitTokenMetadataDiscriminatorBytes() {\n  return getBytesEncoder().encode(EMIT_TOKEN_METADATA_DISCRIMINATOR);\n}\nfunction getEmitTokenMetadataInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getBytesEncoder()],\n      [\"start\", getOptionEncoder(getU64Encoder())],\n      [\"end\", getOptionEncoder(getU64Encoder())]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: EMIT_TOKEN_METADATA_DISCRIMINATOR,\n      start: value.start ?? none(),\n      end: value.end ?? none()\n    })\n  );\n}\nfunction getEmitTokenMetadataInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getBytesDecoder()],\n    [\"start\", getOptionDecoder(getU64Decoder())],\n    [\"end\", getOptionDecoder(getU64Decoder())]\n  ]);\n}\nfunction getEmitTokenMetadataInstructionDataCodec() {\n  return combineCodec(\n    getEmitTokenMetadataInstructionDataEncoder(),\n    getEmitTokenMetadataInstructionDataDecoder()\n  );\n}\nfunction getEmitTokenMetadataInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.metadata)],\n    data: getEmitTokenMetadataInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseEmitTokenMetadataInstruction(instruction) {\n  if (instruction.accounts.length < 1) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { metadata: getNextAccount() },\n    data: getEmitTokenMetadataInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR = 27;\nfunction getEmptyConfidentialTransferAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR\n  );\n}\nvar EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 4;\nfunction getEmptyConfidentialTransferAccountConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\nfunction getEmptyConfidentialTransferAccountInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"confidentialTransferDiscriminator\", getU8Encoder()],\n      [\"proofInstructionOffset\", getI8Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR,\n      confidentialTransferDiscriminator: EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n    })\n  );\n}\nfunction getEmptyConfidentialTransferAccountInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"confidentialTransferDiscriminator\", getU8Decoder()],\n    [\"proofInstructionOffset\", getI8Decoder()]\n  ]);\n}\nfunction getEmptyConfidentialTransferAccountInstructionDataCodec() {\n  return combineCodec(\n    getEmptyConfidentialTransferAccountInstructionDataEncoder(),\n    getEmptyConfidentialTransferAccountInstructionDataDecoder()\n  );\n}\nfunction getEmptyConfidentialTransferAccountInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    instructionsSysvarOrContextState: {\n      value: input.instructionsSysvarOrContextState ?? null,\n      isWritable: false\n    },\n    record: { value: input.record ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  if (!accounts.instructionsSysvarOrContextState.value) {\n    accounts.instructionsSysvarOrContextState.value = \"Sysvar1nstructions1111111111111111111111111\";\n  }\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.instructionsSysvarOrContextState),\n      getAccountMeta(accounts.record),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts\n    ],\n    data: getEmptyConfidentialTransferAccountInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseEmptyConfidentialTransferAccountInstruction(instruction) {\n  if (instruction.accounts.length < 4) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS ? void 0 : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      instructionsSysvarOrContextState: getNextAccount(),\n      record: getNextOptionalAccount(),\n      authority: getNextAccount()\n    },\n    data: getEmptyConfidentialTransferAccountInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar ENABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR = 27;\nfunction getEnableConfidentialCreditsDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR);\n}\nvar ENABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 9;\nfunction getEnableConfidentialCreditsConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    ENABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\nfunction getEnableConfidentialCreditsInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"confidentialTransferDiscriminator\", getU8Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR,\n      confidentialTransferDiscriminator: ENABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n    })\n  );\n}\nfunction getEnableConfidentialCreditsInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"confidentialTransferDiscriminator\", getU8Decoder()]\n  ]);\n}\nfunction getEnableConfidentialCreditsInstructionDataCodec() {\n  return combineCodec(\n    getEnableConfidentialCreditsInstructionDataEncoder(),\n    getEnableConfidentialCreditsInstructionDataDecoder()\n  );\n}\nfunction getEnableConfidentialCreditsInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts\n    ],\n    data: getEnableConfidentialCreditsInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseEnableConfidentialCreditsInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), authority: getNextAccount() },\n    data: getEnableConfidentialCreditsInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar ENABLE_CPI_GUARD_DISCRIMINATOR = 34;\nfunction getEnableCpiGuardDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_CPI_GUARD_DISCRIMINATOR);\n}\nvar ENABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR = 0;\nfunction getEnableCpiGuardCpiGuardDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR);\n}\nfunction getEnableCpiGuardInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"cpiGuardDiscriminator\", getU8Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_CPI_GUARD_DISCRIMINATOR,\n      cpiGuardDiscriminator: ENABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR\n    })\n  );\n}\nfunction getEnableCpiGuardInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"cpiGuardDiscriminator\", getU8Decoder()]\n  ]);\n}\nfunction getEnableCpiGuardInstructionDataCodec() {\n  return combineCodec(\n    getEnableCpiGuardInstructionDataEncoder(),\n    getEnableCpiGuardInstructionDataDecoder()\n  );\n}\nfunction getEnableCpiGuardInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts\n    ],\n    data: getEnableCpiGuardInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseEnableCpiGuardInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), owner: getNextAccount() },\n    data: getEnableCpiGuardInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar ENABLE_HARVEST_TO_MINT_DISCRIMINATOR = 37;\nfunction getEnableHarvestToMintDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_HARVEST_TO_MINT_DISCRIMINATOR);\n}\nvar ENABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 4;\nfunction getEnableHarvestToMintConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    ENABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\nfunction getEnableHarvestToMintInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"confidentialTransferFeeDiscriminator\", getU8Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_HARVEST_TO_MINT_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator: ENABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n    })\n  );\n}\nfunction getEnableHarvestToMintInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"confidentialTransferFeeDiscriminator\", getU8Decoder()]\n  ]);\n}\nfunction getEnableHarvestToMintInstructionDataCodec() {\n  return combineCodec(\n    getEnableHarvestToMintInstructionDataEncoder(),\n    getEnableHarvestToMintInstructionDataDecoder()\n  );\n}\nfunction getEnableHarvestToMintInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts\n    ],\n    data: getEnableHarvestToMintInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseEnableHarvestToMintInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), authority: getNextAccount() },\n    data: getEnableHarvestToMintInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar ENABLE_MEMO_TRANSFERS_DISCRIMINATOR = 30;\nfunction getEnableMemoTransfersDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_MEMO_TRANSFERS_DISCRIMINATOR);\n}\nvar ENABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR = 0;\nfunction getEnableMemoTransfersMemoTransfersDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    ENABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR\n  );\n}\nfunction getEnableMemoTransfersInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"memoTransfersDiscriminator\", getU8Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_MEMO_TRANSFERS_DISCRIMINATOR,\n      memoTransfersDiscriminator: ENABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR\n    })\n  );\n}\nfunction getEnableMemoTransfersInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"memoTransfersDiscriminator\", getU8Decoder()]\n  ]);\n}\nfunction getEnableMemoTransfersInstructionDataCodec() {\n  return combineCodec(\n    getEnableMemoTransfersInstructionDataEncoder(),\n    getEnableMemoTransfersInstructionDataDecoder()\n  );\n}\nfunction getEnableMemoTransfersInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts\n    ],\n    data: getEnableMemoTransfersInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseEnableMemoTransfersInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), owner: getNextAccount() },\n    data: getEnableMemoTransfersInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar ENABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR = 27;\nfunction getEnableNonConfidentialCreditsDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR);\n}\nvar ENABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 11;\nfunction getEnableNonConfidentialCreditsConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    ENABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\nfunction getEnableNonConfidentialCreditsInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"confidentialTransferDiscriminator\", getU8Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR,\n      confidentialTransferDiscriminator: ENABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n    })\n  );\n}\nfunction getEnableNonConfidentialCreditsInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"confidentialTransferDiscriminator\", getU8Decoder()]\n  ]);\n}\nfunction getEnableNonConfidentialCreditsInstructionDataCodec() {\n  return combineCodec(\n    getEnableNonConfidentialCreditsInstructionDataEncoder(),\n    getEnableNonConfidentialCreditsInstructionDataDecoder()\n  );\n}\nfunction getEnableNonConfidentialCreditsInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts\n    ],\n    data: getEnableNonConfidentialCreditsInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseEnableNonConfidentialCreditsInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), authority: getNextAccount() },\n    data: getEnableNonConfidentialCreditsInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar FREEZE_ACCOUNT_DISCRIMINATOR = 10;\nfunction getFreezeAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(FREEZE_ACCOUNT_DISCRIMINATOR);\n}\nfunction getFreezeAccountInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([[\"discriminator\", getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: FREEZE_ACCOUNT_DISCRIMINATOR })\n  );\n}\nfunction getFreezeAccountInstructionDataDecoder() {\n  return getStructDecoder([[\"discriminator\", getU8Decoder()]]);\n}\nfunction getFreezeAccountInstructionDataCodec() {\n  return combineCodec(\n    getFreezeAccountInstructionDataEncoder(),\n    getFreezeAccountInstructionDataDecoder()\n  );\n}\nfunction getFreezeAccountInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts\n    ],\n    data: getFreezeAccountInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseFreezeAccountInstruction(instruction) {\n  if (instruction.accounts.length < 3) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      owner: getNextAccount()\n    },\n    data: getFreezeAccountInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR = 21;\nfunction getGetAccountDataSizeDiscriminatorBytes() {\n  return getU8Encoder().encode(GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR);\n}\nfunction getGetAccountDataSizeInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([[\"discriminator\", getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR\n    })\n  );\n}\nfunction getGetAccountDataSizeInstructionDataDecoder() {\n  return getStructDecoder([[\"discriminator\", getU8Decoder()]]);\n}\nfunction getGetAccountDataSizeInstructionDataCodec() {\n  return combineCodec(\n    getGetAccountDataSizeInstructionDataEncoder(),\n    getGetAccountDataSizeInstructionDataDecoder()\n  );\n}\nfunction getGetAccountDataSizeInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getGetAccountDataSizeInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseGetAccountDataSizeInstruction(instruction) {\n  if (instruction.accounts.length < 1) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getGetAccountDataSizeInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar HARVEST_WITHHELD_TOKENS_TO_MINT_DISCRIMINATOR = 26;\nfunction getHarvestWithheldTokensToMintDiscriminatorBytes() {\n  return getU8Encoder().encode(HARVEST_WITHHELD_TOKENS_TO_MINT_DISCRIMINATOR);\n}\nvar HARVEST_WITHHELD_TOKENS_TO_MINT_TRANSFER_FEE_DISCRIMINATOR = 4;\nfunction getHarvestWithheldTokensToMintTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    HARVEST_WITHHELD_TOKENS_TO_MINT_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\nfunction getHarvestWithheldTokensToMintInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"transferFeeDiscriminator\", getU8Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: HARVEST_WITHHELD_TOKENS_TO_MINT_DISCRIMINATOR,\n      transferFeeDiscriminator: HARVEST_WITHHELD_TOKENS_TO_MINT_TRANSFER_FEE_DISCRIMINATOR\n    })\n  );\n}\nfunction getHarvestWithheldTokensToMintInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"transferFeeDiscriminator\", getU8Decoder()]\n  ]);\n}\nfunction getHarvestWithheldTokensToMintInstructionDataCodec() {\n  return combineCodec(\n    getHarvestWithheldTokensToMintInstructionDataEncoder(),\n    getHarvestWithheldTokensToMintInstructionDataDecoder()\n  );\n}\nfunction getHarvestWithheldTokensToMintInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = args.sources.map((address) => ({\n    address,\n    role: AccountRole.WRITABLE\n  }));\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint), ...remainingAccounts],\n    data: getHarvestWithheldTokensToMintInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseHarvestWithheldTokensToMintInstruction(instruction) {\n  if (instruction.accounts.length < 1) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getHarvestWithheldTokensToMintInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 37;\nfunction getHarvestWithheldTokensToMintForConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\nvar HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 3;\nfunction getHarvestWithheldTokensToMintForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\nfunction getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"confidentialTransferFeeDiscriminator\", getU8Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator: HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n    })\n  );\n}\nfunction getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"confidentialTransferFeeDiscriminator\", getU8Decoder()]\n  ]);\n}\nfunction getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataCodec() {\n  return combineCodec(\n    getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataEncoder(),\n    getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataDecoder()\n  );\n}\nfunction getHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.sources ?? []).map(\n    (address) => ({ address, role: AccountRole.WRITABLE })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint), ...remainingAccounts],\n    data: getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataEncoder().encode(\n      {}\n    ),\n    programAddress\n  });\n}\nfunction parseHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction(instruction) {\n  if (instruction.accounts.length < 1) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar INITIALIZE_ACCOUNT_DISCRIMINATOR = 1;\nfunction getInitializeAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_ACCOUNT_DISCRIMINATOR);\n}\nfunction getInitializeAccountInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([[\"discriminator\", getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT_DISCRIMINATOR })\n  );\n}\nfunction getInitializeAccountInstructionDataDecoder() {\n  return getStructDecoder([[\"discriminator\", getU8Decoder()]]);\n}\nfunction getInitializeAccountInstructionDataCodec() {\n  return combineCodec(\n    getInitializeAccountInstructionDataEncoder(),\n    getInitializeAccountInstructionDataDecoder()\n  );\n}\nfunction getInitializeAccountInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  if (!accounts.rent.value) {\n    accounts.rent.value = \"SysvarRent111111111111111111111111111111111\";\n  }\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.rent)\n    ],\n    data: getInitializeAccountInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseInitializeAccountInstruction(instruction) {\n  if (instruction.accounts.length < 4) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      owner: getNextAccount(),\n      rent: getNextAccount()\n    },\n    data: getInitializeAccountInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar INITIALIZE_ACCOUNT2_DISCRIMINATOR = 16;\nfunction getInitializeAccount2DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_ACCOUNT2_DISCRIMINATOR);\n}\nfunction getInitializeAccount2InstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"owner\", getAddressEncoder()]\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT2_DISCRIMINATOR })\n  );\n}\nfunction getInitializeAccount2InstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"owner\", getAddressDecoder()]\n  ]);\n}\nfunction getInitializeAccount2InstructionDataCodec() {\n  return combineCodec(\n    getInitializeAccount2InstructionDataEncoder(),\n    getInitializeAccount2InstructionDataDecoder()\n  );\n}\nfunction getInitializeAccount2Instruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  if (!accounts.rent.value) {\n    accounts.rent.value = \"SysvarRent111111111111111111111111111111111\";\n  }\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.rent)\n    ],\n    data: getInitializeAccount2InstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseInitializeAccount2Instruction(instruction) {\n  if (instruction.accounts.length < 3) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      rent: getNextAccount()\n    },\n    data: getInitializeAccount2InstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar INITIALIZE_ACCOUNT3_DISCRIMINATOR = 18;\nfunction getInitializeAccount3DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_ACCOUNT3_DISCRIMINATOR);\n}\nfunction getInitializeAccount3InstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"owner\", getAddressEncoder()]\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT3_DISCRIMINATOR })\n  );\n}\nfunction getInitializeAccount3InstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"owner\", getAddressDecoder()]\n  ]);\n}\nfunction getInitializeAccount3InstructionDataCodec() {\n  return combineCodec(\n    getInitializeAccount3InstructionDataEncoder(),\n    getInitializeAccount3InstructionDataDecoder()\n  );\n}\nfunction getInitializeAccount3Instruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.account), getAccountMeta(accounts.mint)],\n    data: getInitializeAccount3InstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseInitializeAccount3Instruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { account: getNextAccount(), mint: getNextAccount() },\n    data: getInitializeAccount3InstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 37;\nfunction getInitializeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\nvar INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 0;\nfunction getInitializeConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\nfunction getInitializeConfidentialTransferFeeInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"confidentialTransferFeeDiscriminator\", getU8Encoder()],\n      [\n        \"authority\",\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: \"zeroes\"\n        })\n      ],\n      [\n        \"withdrawWithheldAuthorityElGamalPubkey\",\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: \"zeroes\"\n        })\n      ]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator: INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n    })\n  );\n}\nfunction getInitializeConfidentialTransferFeeInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"confidentialTransferFeeDiscriminator\", getU8Decoder()],\n    [\n      \"authority\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: \"zeroes\"\n      })\n    ],\n    [\n      \"withdrawWithheldAuthorityElGamalPubkey\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: \"zeroes\"\n      })\n    ]\n  ]);\n}\nfunction getInitializeConfidentialTransferFeeInstructionDataCodec() {\n  return combineCodec(\n    getInitializeConfidentialTransferFeeInstructionDataEncoder(),\n    getInitializeConfidentialTransferFeeInstructionDataDecoder()\n  );\n}\nfunction getInitializeConfidentialTransferFeeInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeConfidentialTransferFeeInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseInitializeConfidentialTransferFeeInstruction(instruction) {\n  if (instruction.accounts.length < 1) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeConfidentialTransferFeeInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR = 27;\nfunction getInitializeConfidentialTransferMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR\n  );\n}\nvar INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 0;\nfunction getInitializeConfidentialTransferMintConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\nfunction getInitializeConfidentialTransferMintInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"confidentialTransferDiscriminator\", getU8Encoder()],\n      [\n        \"authority\",\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: \"zeroes\"\n        })\n      ],\n      [\"autoApproveNewAccounts\", getBooleanEncoder()],\n      [\n        \"auditorElgamalPubkey\",\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: \"zeroes\"\n        })\n      ]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR,\n      confidentialTransferDiscriminator: INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n    })\n  );\n}\nfunction getInitializeConfidentialTransferMintInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"confidentialTransferDiscriminator\", getU8Decoder()],\n    [\n      \"authority\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: \"zeroes\"\n      })\n    ],\n    [\"autoApproveNewAccounts\", getBooleanDecoder()],\n    [\n      \"auditorElgamalPubkey\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: \"zeroes\"\n      })\n    ]\n  ]);\n}\nfunction getInitializeConfidentialTransferMintInstructionDataCodec() {\n  return combineCodec(\n    getInitializeConfidentialTransferMintInstructionDataEncoder(),\n    getInitializeConfidentialTransferMintInstructionDataDecoder()\n  );\n}\nfunction getInitializeConfidentialTransferMintInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeConfidentialTransferMintInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseInitializeConfidentialTransferMintInstruction(instruction) {\n  if (instruction.accounts.length < 1) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeConfidentialTransferMintInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar INITIALIZE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = 28;\nfunction getInitializeDefaultAccountStateDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR);\n}\nvar INITIALIZE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = 0;\nfunction getInitializeDefaultAccountStateDefaultAccountStateDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR\n  );\n}\nfunction getInitializeDefaultAccountStateInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"defaultAccountStateDiscriminator\", getU8Encoder()],\n      [\"state\", getAccountStateEncoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR,\n      defaultAccountStateDiscriminator: INITIALIZE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR\n    })\n  );\n}\nfunction getInitializeDefaultAccountStateInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"defaultAccountStateDiscriminator\", getU8Decoder()],\n    [\"state\", getAccountStateDecoder()]\n  ]);\n}\nfunction getInitializeDefaultAccountStateInstructionDataCodec() {\n  return combineCodec(\n    getInitializeDefaultAccountStateInstructionDataEncoder(),\n    getInitializeDefaultAccountStateInstructionDataDecoder()\n  );\n}\nfunction getInitializeDefaultAccountStateInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeDefaultAccountStateInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseInitializeDefaultAccountStateInstruction(instruction) {\n  if (instruction.accounts.length < 1) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeDefaultAccountStateInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar INITIALIZE_GROUP_MEMBER_POINTER_DISCRIMINATOR = 41;\nfunction getInitializeGroupMemberPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_GROUP_MEMBER_POINTER_DISCRIMINATOR);\n}\nvar INITIALIZE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR = 0;\nfunction getInitializeGroupMemberPointerGroupMemberPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR\n  );\n}\nfunction getInitializeGroupMemberPointerInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"groupMemberPointerDiscriminator\", getU8Encoder()],\n      [\n        \"authority\",\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: \"zeroes\"\n        })\n      ],\n      [\n        \"memberAddress\",\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: \"zeroes\"\n        })\n      ]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_GROUP_MEMBER_POINTER_DISCRIMINATOR,\n      groupMemberPointerDiscriminator: INITIALIZE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR\n    })\n  );\n}\nfunction getInitializeGroupMemberPointerInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"groupMemberPointerDiscriminator\", getU8Decoder()],\n    [\n      \"authority\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: \"zeroes\"\n      })\n    ],\n    [\n      \"memberAddress\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: \"zeroes\"\n      })\n    ]\n  ]);\n}\nfunction getInitializeGroupMemberPointerInstructionDataCodec() {\n  return combineCodec(\n    getInitializeGroupMemberPointerInstructionDataEncoder(),\n    getInitializeGroupMemberPointerInstructionDataDecoder()\n  );\n}\nfunction getInitializeGroupMemberPointerInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeGroupMemberPointerInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseInitializeGroupMemberPointerInstruction(instruction) {\n  if (instruction.accounts.length < 1) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeGroupMemberPointerInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar INITIALIZE_GROUP_POINTER_DISCRIMINATOR = 40;\nfunction getInitializeGroupPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_GROUP_POINTER_DISCRIMINATOR);\n}\nvar INITIALIZE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR = 0;\nfunction getInitializeGroupPointerGroupPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR\n  );\n}\nfunction getInitializeGroupPointerInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"groupPointerDiscriminator\", getU8Encoder()],\n      [\n        \"authority\",\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: \"zeroes\"\n        })\n      ],\n      [\n        \"groupAddress\",\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: \"zeroes\"\n        })\n      ]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_GROUP_POINTER_DISCRIMINATOR,\n      groupPointerDiscriminator: INITIALIZE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR\n    })\n  );\n}\nfunction getInitializeGroupPointerInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"groupPointerDiscriminator\", getU8Decoder()],\n    [\n      \"authority\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: \"zeroes\"\n      })\n    ],\n    [\n      \"groupAddress\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: \"zeroes\"\n      })\n    ]\n  ]);\n}\nfunction getInitializeGroupPointerInstructionDataCodec() {\n  return combineCodec(\n    getInitializeGroupPointerInstructionDataEncoder(),\n    getInitializeGroupPointerInstructionDataDecoder()\n  );\n}\nfunction getInitializeGroupPointerInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeGroupPointerInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseInitializeGroupPointerInstruction(instruction) {\n  if (instruction.accounts.length < 1) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeGroupPointerInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR = 22;\nfunction getInitializeImmutableOwnerDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR);\n}\nfunction getInitializeImmutableOwnerInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([[\"discriminator\", getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR\n    })\n  );\n}\nfunction getInitializeImmutableOwnerInstructionDataDecoder() {\n  return getStructDecoder([[\"discriminator\", getU8Decoder()]]);\n}\nfunction getInitializeImmutableOwnerInstructionDataCodec() {\n  return combineCodec(\n    getInitializeImmutableOwnerInstructionDataEncoder(),\n    getInitializeImmutableOwnerInstructionDataDecoder()\n  );\n}\nfunction getInitializeImmutableOwnerInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true }\n  };\n  const accounts = originalAccounts;\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.account)],\n    data: getInitializeImmutableOwnerInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseInitializeImmutableOwnerInstruction(instruction) {\n  if (instruction.accounts.length < 1) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { account: getNextAccount() },\n    data: getInitializeImmutableOwnerInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar INITIALIZE_INTEREST_BEARING_MINT_DISCRIMINATOR = 33;\nfunction getInitializeInterestBearingMintDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_INTEREST_BEARING_MINT_DISCRIMINATOR);\n}\nvar INITIALIZE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR = 0;\nfunction getInitializeInterestBearingMintInterestBearingMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR\n  );\n}\nfunction getInitializeInterestBearingMintInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"interestBearingMintDiscriminator\", getU8Encoder()],\n      [\n        \"rateAuthority\",\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: \"zeroes\"\n        })\n      ],\n      [\"rate\", getI16Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_INTEREST_BEARING_MINT_DISCRIMINATOR,\n      interestBearingMintDiscriminator: INITIALIZE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR\n    })\n  );\n}\nfunction getInitializeInterestBearingMintInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"interestBearingMintDiscriminator\", getU8Decoder()],\n    [\n      \"rateAuthority\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: \"zeroes\"\n      })\n    ],\n    [\"rate\", getI16Decoder()]\n  ]);\n}\nfunction getInitializeInterestBearingMintInstructionDataCodec() {\n  return combineCodec(\n    getInitializeInterestBearingMintInstructionDataEncoder(),\n    getInitializeInterestBearingMintInstructionDataDecoder()\n  );\n}\nfunction getInitializeInterestBearingMintInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeInterestBearingMintInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseInitializeInterestBearingMintInstruction(instruction) {\n  if (instruction.accounts.length < 1) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeInterestBearingMintInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar INITIALIZE_METADATA_POINTER_DISCRIMINATOR = 39;\nfunction getInitializeMetadataPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_METADATA_POINTER_DISCRIMINATOR);\n}\nvar INITIALIZE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR = 0;\nfunction getInitializeMetadataPointerMetadataPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR\n  );\n}\nfunction getInitializeMetadataPointerInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"metadataPointerDiscriminator\", getU8Encoder()],\n      [\n        \"authority\",\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: \"zeroes\"\n        })\n      ],\n      [\n        \"metadataAddress\",\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: \"zeroes\"\n        })\n      ]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_METADATA_POINTER_DISCRIMINATOR,\n      metadataPointerDiscriminator: INITIALIZE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR\n    })\n  );\n}\nfunction getInitializeMetadataPointerInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"metadataPointerDiscriminator\", getU8Decoder()],\n    [\n      \"authority\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: \"zeroes\"\n      })\n    ],\n    [\n      \"metadataAddress\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: \"zeroes\"\n      })\n    ]\n  ]);\n}\nfunction getInitializeMetadataPointerInstructionDataCodec() {\n  return combineCodec(\n    getInitializeMetadataPointerInstructionDataEncoder(),\n    getInitializeMetadataPointerInstructionDataDecoder()\n  );\n}\nfunction getInitializeMetadataPointerInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeMetadataPointerInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseInitializeMetadataPointerInstruction(instruction) {\n  if (instruction.accounts.length < 1) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeMetadataPointerInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar INITIALIZE_MINT_DISCRIMINATOR = 0;\nfunction getInitializeMintDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MINT_DISCRIMINATOR);\n}\nfunction getInitializeMintInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"decimals\", getU8Encoder()],\n      [\"mintAuthority\", getAddressEncoder()],\n      [\"freezeAuthority\", getOptionEncoder(getAddressEncoder())]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_MINT_DISCRIMINATOR,\n      freezeAuthority: value.freezeAuthority ?? none()\n    })\n  );\n}\nfunction getInitializeMintInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"decimals\", getU8Decoder()],\n    [\"mintAuthority\", getAddressDecoder()],\n    [\"freezeAuthority\", getOptionDecoder(getAddressDecoder())]\n  ]);\n}\nfunction getInitializeMintInstructionDataCodec() {\n  return combineCodec(\n    getInitializeMintInstructionDataEncoder(),\n    getInitializeMintInstructionDataDecoder()\n  );\n}\nfunction getInitializeMintInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    rent: { value: input.rent ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  if (!accounts.rent.value) {\n    accounts.rent.value = \"SysvarRent111111111111111111111111111111111\";\n  }\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint), getAccountMeta(accounts.rent)],\n    data: getInitializeMintInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseInitializeMintInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), rent: getNextAccount() },\n    data: getInitializeMintInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar INITIALIZE_MINT2_DISCRIMINATOR = 20;\nfunction getInitializeMint2DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MINT2_DISCRIMINATOR);\n}\nfunction getInitializeMint2InstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"decimals\", getU8Encoder()],\n      [\"mintAuthority\", getAddressEncoder()],\n      [\"freezeAuthority\", getOptionEncoder(getAddressEncoder())]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_MINT2_DISCRIMINATOR,\n      freezeAuthority: value.freezeAuthority ?? none()\n    })\n  );\n}\nfunction getInitializeMint2InstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"decimals\", getU8Decoder()],\n    [\"mintAuthority\", getAddressDecoder()],\n    [\"freezeAuthority\", getOptionDecoder(getAddressDecoder())]\n  ]);\n}\nfunction getInitializeMint2InstructionDataCodec() {\n  return combineCodec(\n    getInitializeMint2InstructionDataEncoder(),\n    getInitializeMint2InstructionDataDecoder()\n  );\n}\nfunction getInitializeMint2Instruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeMint2InstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseInitializeMint2Instruction(instruction) {\n  if (instruction.accounts.length < 1) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeMint2InstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar INITIALIZE_MINT_CLOSE_AUTHORITY_DISCRIMINATOR = 25;\nfunction getInitializeMintCloseAuthorityDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MINT_CLOSE_AUTHORITY_DISCRIMINATOR);\n}\nfunction getInitializeMintCloseAuthorityInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"closeAuthority\", getOptionEncoder(getAddressEncoder())]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_MINT_CLOSE_AUTHORITY_DISCRIMINATOR\n    })\n  );\n}\nfunction getInitializeMintCloseAuthorityInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"closeAuthority\", getOptionDecoder(getAddressDecoder())]\n  ]);\n}\nfunction getInitializeMintCloseAuthorityInstructionDataCodec() {\n  return combineCodec(\n    getInitializeMintCloseAuthorityInstructionDataEncoder(),\n    getInitializeMintCloseAuthorityInstructionDataDecoder()\n  );\n}\nfunction getInitializeMintCloseAuthorityInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeMintCloseAuthorityInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseInitializeMintCloseAuthorityInstruction(instruction) {\n  if (instruction.accounts.length < 1) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeMintCloseAuthorityInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar INITIALIZE_MULTISIG_DISCRIMINATOR = 2;\nfunction getInitializeMultisigDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MULTISIG_DISCRIMINATOR);\n}\nfunction getInitializeMultisigInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"m\", getU8Encoder()]\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_MULTISIG_DISCRIMINATOR })\n  );\n}\nfunction getInitializeMultisigInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"m\", getU8Decoder()]\n  ]);\n}\nfunction getInitializeMultisigInstructionDataCodec() {\n  return combineCodec(\n    getInitializeMultisigInstructionDataEncoder(),\n    getInitializeMultisigInstructionDataDecoder()\n  );\n}\nfunction getInitializeMultisigInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    multisig: { value: input.multisig ?? null, isWritable: true },\n    rent: { value: input.rent ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  if (!accounts.rent.value) {\n    accounts.rent.value = \"SysvarRent111111111111111111111111111111111\";\n  }\n  const remainingAccounts = args.signers.map((address) => ({\n    address,\n    role: AccountRole.READONLY\n  }));\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.multisig),\n      getAccountMeta(accounts.rent),\n      ...remainingAccounts\n    ],\n    data: getInitializeMultisigInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseInitializeMultisigInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { multisig: getNextAccount(), rent: getNextAccount() },\n    data: getInitializeMultisigInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar INITIALIZE_MULTISIG2_DISCRIMINATOR = 19;\nfunction getInitializeMultisig2DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MULTISIG2_DISCRIMINATOR);\n}\nfunction getInitializeMultisig2InstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"m\", getU8Encoder()]\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_MULTISIG2_DISCRIMINATOR })\n  );\n}\nfunction getInitializeMultisig2InstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"m\", getU8Decoder()]\n  ]);\n}\nfunction getInitializeMultisig2InstructionDataCodec() {\n  return combineCodec(\n    getInitializeMultisig2InstructionDataEncoder(),\n    getInitializeMultisig2InstructionDataDecoder()\n  );\n}\nfunction getInitializeMultisig2Instruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    multisig: { value: input.multisig ?? null, isWritable: true }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = args.signers.map((address) => ({\n    address,\n    role: AccountRole.READONLY\n  }));\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.multisig), ...remainingAccounts],\n    data: getInitializeMultisig2InstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseInitializeMultisig2Instruction(instruction) {\n  if (instruction.accounts.length < 1) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { multisig: getNextAccount() },\n    data: getInitializeMultisig2InstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar INITIALIZE_NON_TRANSFERABLE_MINT_DISCRIMINATOR = 32;\nfunction getInitializeNonTransferableMintDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_NON_TRANSFERABLE_MINT_DISCRIMINATOR);\n}\nfunction getInitializeNonTransferableMintInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([[\"discriminator\", getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_NON_TRANSFERABLE_MINT_DISCRIMINATOR\n    })\n  );\n}\nfunction getInitializeNonTransferableMintInstructionDataDecoder() {\n  return getStructDecoder([[\"discriminator\", getU8Decoder()]]);\n}\nfunction getInitializeNonTransferableMintInstructionDataCodec() {\n  return combineCodec(\n    getInitializeNonTransferableMintInstructionDataEncoder(),\n    getInitializeNonTransferableMintInstructionDataDecoder()\n  );\n}\nfunction getInitializeNonTransferableMintInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true }\n  };\n  const accounts = originalAccounts;\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeNonTransferableMintInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseInitializeNonTransferableMintInstruction(instruction) {\n  if (instruction.accounts.length < 1) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeNonTransferableMintInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar INITIALIZE_PAUSABLE_CONFIG_DISCRIMINATOR = 44;\nfunction getInitializePausableConfigDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_PAUSABLE_CONFIG_DISCRIMINATOR);\n}\nvar INITIALIZE_PAUSABLE_CONFIG_PAUSABLE_DISCRIMINATOR = 0;\nfunction getInitializePausableConfigPausableDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_PAUSABLE_CONFIG_PAUSABLE_DISCRIMINATOR\n  );\n}\nfunction getInitializePausableConfigInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"pausableDiscriminator\", getU8Encoder()],\n      [\n        \"authority\",\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: \"zeroes\"\n        })\n      ]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_PAUSABLE_CONFIG_DISCRIMINATOR,\n      pausableDiscriminator: INITIALIZE_PAUSABLE_CONFIG_PAUSABLE_DISCRIMINATOR\n    })\n  );\n}\nfunction getInitializePausableConfigInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"pausableDiscriminator\", getU8Decoder()],\n    [\n      \"authority\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: \"zeroes\"\n      })\n    ]\n  ]);\n}\nfunction getInitializePausableConfigInstructionDataCodec() {\n  return combineCodec(\n    getInitializePausableConfigInstructionDataEncoder(),\n    getInitializePausableConfigInstructionDataDecoder()\n  );\n}\nfunction getInitializePausableConfigInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializePausableConfigInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseInitializePausableConfigInstruction(instruction) {\n  if (instruction.accounts.length < 1) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializePausableConfigInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar INITIALIZE_PERMANENT_DELEGATE_DISCRIMINATOR = 35;\nfunction getInitializePermanentDelegateDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_PERMANENT_DELEGATE_DISCRIMINATOR);\n}\nfunction getInitializePermanentDelegateInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"delegate\", getAddressEncoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_PERMANENT_DELEGATE_DISCRIMINATOR\n    })\n  );\n}\nfunction getInitializePermanentDelegateInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"delegate\", getAddressDecoder()]\n  ]);\n}\nfunction getInitializePermanentDelegateInstructionDataCodec() {\n  return combineCodec(\n    getInitializePermanentDelegateInstructionDataEncoder(),\n    getInitializePermanentDelegateInstructionDataDecoder()\n  );\n}\nfunction getInitializePermanentDelegateInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializePermanentDelegateInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseInitializePermanentDelegateInstruction(instruction) {\n  if (instruction.accounts.length < 1) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializePermanentDelegateInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar INITIALIZE_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR = 43;\nfunction getInitializeScaledUiAmountMintDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR);\n}\nvar INITIALIZE_SCALED_UI_AMOUNT_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR = 0;\nfunction getInitializeScaledUiAmountMintScaledUiAmountMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_SCALED_UI_AMOUNT_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR\n  );\n}\nfunction getInitializeScaledUiAmountMintInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"scaledUiAmountMintDiscriminator\", getU8Encoder()],\n      [\n        \"authority\",\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: \"zeroes\"\n        })\n      ],\n      [\"multiplier\", getF64Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR,\n      scaledUiAmountMintDiscriminator: INITIALIZE_SCALED_UI_AMOUNT_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR\n    })\n  );\n}\nfunction getInitializeScaledUiAmountMintInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"scaledUiAmountMintDiscriminator\", getU8Decoder()],\n    [\n      \"authority\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: \"zeroes\"\n      })\n    ],\n    [\"multiplier\", getF64Decoder()]\n  ]);\n}\nfunction getInitializeScaledUiAmountMintInstructionDataCodec() {\n  return combineCodec(\n    getInitializeScaledUiAmountMintInstructionDataEncoder(),\n    getInitializeScaledUiAmountMintInstructionDataDecoder()\n  );\n}\nfunction getInitializeScaledUiAmountMintInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeScaledUiAmountMintInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseInitializeScaledUiAmountMintInstruction(instruction) {\n  if (instruction.accounts.length < 1) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeScaledUiAmountMintInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar INITIALIZE_TOKEN_GROUP_DISCRIMINATOR = new Uint8Array([\n  121,\n  113,\n  108,\n  39,\n  54,\n  51,\n  0,\n  4\n]);\nfunction getInitializeTokenGroupDiscriminatorBytes() {\n  return getBytesEncoder().encode(INITIALIZE_TOKEN_GROUP_DISCRIMINATOR);\n}\nfunction getInitializeTokenGroupInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getBytesEncoder()],\n      [\n        \"updateAuthority\",\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: \"zeroes\"\n        })\n      ],\n      [\"maxSize\", getU64Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TOKEN_GROUP_DISCRIMINATOR\n    })\n  );\n}\nfunction getInitializeTokenGroupInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getBytesDecoder()],\n    [\n      \"updateAuthority\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: \"zeroes\"\n      })\n    ],\n    [\"maxSize\", getU64Decoder()]\n  ]);\n}\nfunction getInitializeTokenGroupInstructionDataCodec() {\n  return combineCodec(\n    getInitializeTokenGroupInstructionDataEncoder(),\n    getInitializeTokenGroupInstructionDataDecoder()\n  );\n}\nfunction getInitializeTokenGroupInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    group: { value: input.group ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.group),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.mintAuthority)\n    ],\n    data: getInitializeTokenGroupInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseInitializeTokenGroupInstruction(instruction) {\n  if (instruction.accounts.length < 3) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      group: getNextAccount(),\n      mint: getNextAccount(),\n      mintAuthority: getNextAccount()\n    },\n    data: getInitializeTokenGroupInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar INITIALIZE_TOKEN_GROUP_MEMBER_DISCRIMINATOR = new Uint8Array([\n  152,\n  32,\n  222,\n  176,\n  223,\n  237,\n  116,\n  134\n]);\nfunction getInitializeTokenGroupMemberDiscriminatorBytes() {\n  return getBytesEncoder().encode(INITIALIZE_TOKEN_GROUP_MEMBER_DISCRIMINATOR);\n}\nfunction getInitializeTokenGroupMemberInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([[\"discriminator\", getBytesEncoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TOKEN_GROUP_MEMBER_DISCRIMINATOR\n    })\n  );\n}\nfunction getInitializeTokenGroupMemberInstructionDataDecoder() {\n  return getStructDecoder([[\"discriminator\", getBytesDecoder()]]);\n}\nfunction getInitializeTokenGroupMemberInstructionDataCodec() {\n  return combineCodec(\n    getInitializeTokenGroupMemberInstructionDataEncoder(),\n    getInitializeTokenGroupMemberInstructionDataDecoder()\n  );\n}\nfunction getInitializeTokenGroupMemberInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    member: { value: input.member ?? null, isWritable: true },\n    memberMint: { value: input.memberMint ?? null, isWritable: false },\n    memberMintAuthority: {\n      value: input.memberMintAuthority ?? null,\n      isWritable: false\n    },\n    group: { value: input.group ?? null, isWritable: true },\n    groupUpdateAuthority: {\n      value: input.groupUpdateAuthority ?? null,\n      isWritable: false\n    }\n  };\n  const accounts = originalAccounts;\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.member),\n      getAccountMeta(accounts.memberMint),\n      getAccountMeta(accounts.memberMintAuthority),\n      getAccountMeta(accounts.group),\n      getAccountMeta(accounts.groupUpdateAuthority)\n    ],\n    data: getInitializeTokenGroupMemberInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseInitializeTokenGroupMemberInstruction(instruction) {\n  if (instruction.accounts.length < 5) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      member: getNextAccount(),\n      memberMint: getNextAccount(),\n      memberMintAuthority: getNextAccount(),\n      group: getNextAccount(),\n      groupUpdateAuthority: getNextAccount()\n    },\n    data: getInitializeTokenGroupMemberInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar INITIALIZE_TOKEN_METADATA_DISCRIMINATOR = new Uint8Array([\n  210,\n  225,\n  30,\n  162,\n  88,\n  184,\n  77,\n  141\n]);\nfunction getInitializeTokenMetadataDiscriminatorBytes() {\n  return getBytesEncoder().encode(INITIALIZE_TOKEN_METADATA_DISCRIMINATOR);\n}\nfunction getInitializeTokenMetadataInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getBytesEncoder()],\n      [\"name\", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n      [\"symbol\", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n      [\"uri\", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TOKEN_METADATA_DISCRIMINATOR\n    })\n  );\n}\nfunction getInitializeTokenMetadataInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getBytesDecoder()],\n    [\"name\", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    [\"symbol\", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    [\"uri\", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]\n  ]);\n}\nfunction getInitializeTokenMetadataInstructionDataCodec() {\n  return combineCodec(\n    getInitializeTokenMetadataInstructionDataEncoder(),\n    getInitializeTokenMetadataInstructionDataDecoder()\n  );\n}\nfunction getInitializeTokenMetadataInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false\n    },\n    mint: { value: input.mint ?? null, isWritable: false },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.metadata),\n      getAccountMeta(accounts.updateAuthority),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.mintAuthority)\n    ],\n    data: getInitializeTokenMetadataInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseInitializeTokenMetadataInstruction(instruction) {\n  if (instruction.accounts.length < 4) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      metadata: getNextAccount(),\n      updateAuthority: getNextAccount(),\n      mint: getNextAccount(),\n      mintAuthority: getNextAccount()\n    },\n    data: getInitializeTokenMetadataInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar INITIALIZE_TRANSFER_FEE_CONFIG_DISCRIMINATOR = 26;\nfunction getInitializeTransferFeeConfigDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_TRANSFER_FEE_CONFIG_DISCRIMINATOR);\n}\nvar INITIALIZE_TRANSFER_FEE_CONFIG_TRANSFER_FEE_DISCRIMINATOR = 0;\nfunction getInitializeTransferFeeConfigTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_TRANSFER_FEE_CONFIG_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\nfunction getInitializeTransferFeeConfigInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"transferFeeDiscriminator\", getU8Encoder()],\n      [\"transferFeeConfigAuthority\", getOptionEncoder(getAddressEncoder())],\n      [\"withdrawWithheldAuthority\", getOptionEncoder(getAddressEncoder())],\n      [\"transferFeeBasisPoints\", getU16Encoder()],\n      [\"maximumFee\", getU64Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TRANSFER_FEE_CONFIG_DISCRIMINATOR,\n      transferFeeDiscriminator: INITIALIZE_TRANSFER_FEE_CONFIG_TRANSFER_FEE_DISCRIMINATOR\n    })\n  );\n}\nfunction getInitializeTransferFeeConfigInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"transferFeeDiscriminator\", getU8Decoder()],\n    [\"transferFeeConfigAuthority\", getOptionDecoder(getAddressDecoder())],\n    [\"withdrawWithheldAuthority\", getOptionDecoder(getAddressDecoder())],\n    [\"transferFeeBasisPoints\", getU16Decoder()],\n    [\"maximumFee\", getU64Decoder()]\n  ]);\n}\nfunction getInitializeTransferFeeConfigInstructionDataCodec() {\n  return combineCodec(\n    getInitializeTransferFeeConfigInstructionDataEncoder(),\n    getInitializeTransferFeeConfigInstructionDataDecoder()\n  );\n}\nfunction getInitializeTransferFeeConfigInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeTransferFeeConfigInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseInitializeTransferFeeConfigInstruction(instruction) {\n  if (instruction.accounts.length < 1) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeTransferFeeConfigInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar INITIALIZE_TRANSFER_HOOK_DISCRIMINATOR = 36;\nfunction getInitializeTransferHookDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_TRANSFER_HOOK_DISCRIMINATOR);\n}\nvar INITIALIZE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR = 0;\nfunction getInitializeTransferHookTransferHookDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR\n  );\n}\nfunction getInitializeTransferHookInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"transferHookDiscriminator\", getU8Encoder()],\n      [\n        \"authority\",\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: \"zeroes\"\n        })\n      ],\n      [\n        \"programId\",\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: \"zeroes\"\n        })\n      ]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TRANSFER_HOOK_DISCRIMINATOR,\n      transferHookDiscriminator: INITIALIZE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR\n    })\n  );\n}\nfunction getInitializeTransferHookInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"transferHookDiscriminator\", getU8Decoder()],\n    [\n      \"authority\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: \"zeroes\"\n      })\n    ],\n    [\n      \"programId\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: \"zeroes\"\n      })\n    ]\n  ]);\n}\nfunction getInitializeTransferHookInstructionDataCodec() {\n  return combineCodec(\n    getInitializeTransferHookInstructionDataEncoder(),\n    getInitializeTransferHookInstructionDataDecoder()\n  );\n}\nfunction getInitializeTransferHookInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeTransferHookInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseInitializeTransferHookInstruction(instruction) {\n  if (instruction.accounts.length < 1) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeTransferHookInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar MINT_TO_DISCRIMINATOR = 7;\nfunction getMintToDiscriminatorBytes() {\n  return getU8Encoder().encode(MINT_TO_DISCRIMINATOR);\n}\nfunction getMintToInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"amount\", getU64Encoder()]\n    ]),\n    (value) => ({ ...value, discriminator: MINT_TO_DISCRIMINATOR })\n  );\n}\nfunction getMintToInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"amount\", getU64Decoder()]\n  ]);\n}\nfunction getMintToInstructionDataCodec() {\n  return combineCodec(\n    getMintToInstructionDataEncoder(),\n    getMintToInstructionDataDecoder()\n  );\n}\nfunction getMintToInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    token: { value: input.token ?? null, isWritable: true },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mintAuthority),\n      ...remainingAccounts\n    ],\n    data: getMintToInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseMintToInstruction(instruction) {\n  if (instruction.accounts.length < 3) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      token: getNextAccount(),\n      mintAuthority: getNextAccount()\n    },\n    data: getMintToInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar MINT_TO_CHECKED_DISCRIMINATOR = 14;\nfunction getMintToCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(MINT_TO_CHECKED_DISCRIMINATOR);\n}\nfunction getMintToCheckedInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"amount\", getU64Encoder()],\n      [\"decimals\", getU8Encoder()]\n    ]),\n    (value) => ({ ...value, discriminator: MINT_TO_CHECKED_DISCRIMINATOR })\n  );\n}\nfunction getMintToCheckedInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"amount\", getU64Decoder()],\n    [\"decimals\", getU8Decoder()]\n  ]);\n}\nfunction getMintToCheckedInstructionDataCodec() {\n  return combineCodec(\n    getMintToCheckedInstructionDataEncoder(),\n    getMintToCheckedInstructionDataDecoder()\n  );\n}\nfunction getMintToCheckedInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    token: { value: input.token ?? null, isWritable: true },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mintAuthority),\n      ...remainingAccounts\n    ],\n    data: getMintToCheckedInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseMintToCheckedInstruction(instruction) {\n  if (instruction.accounts.length < 3) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      token: getNextAccount(),\n      mintAuthority: getNextAccount()\n    },\n    data: getMintToCheckedInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar PAUSE_DISCRIMINATOR = 44;\nfunction getPauseDiscriminatorBytes() {\n  return getU8Encoder().encode(PAUSE_DISCRIMINATOR);\n}\nvar PAUSE_PAUSABLE_DISCRIMINATOR = 1;\nfunction getPausePausableDiscriminatorBytes() {\n  return getU8Encoder().encode(PAUSE_PAUSABLE_DISCRIMINATOR);\n}\nfunction getPauseInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"pausableDiscriminator\", getU8Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: PAUSE_DISCRIMINATOR,\n      pausableDiscriminator: PAUSE_PAUSABLE_DISCRIMINATOR\n    })\n  );\n}\nfunction getPauseInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"pausableDiscriminator\", getU8Decoder()]\n  ]);\n}\nfunction getPauseInstructionDataCodec() {\n  return combineCodec(\n    getPauseInstructionDataEncoder(),\n    getPauseInstructionDataDecoder()\n  );\n}\nfunction getPauseInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority)\n    ],\n    data: getPauseInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parsePauseInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), authority: getNextAccount() },\n    data: getPauseInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar REALLOCATE_DISCRIMINATOR = 29;\nfunction getReallocateDiscriminatorBytes() {\n  return getU8Encoder().encode(REALLOCATE_DISCRIMINATOR);\n}\nfunction getReallocateInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\n        \"newExtensionTypes\",\n        getArrayEncoder(getExtensionTypeEncoder(), { size: \"remainder\" })\n      ]\n    ]),\n    (value) => ({ ...value, discriminator: REALLOCATE_DISCRIMINATOR })\n  );\n}\nfunction getReallocateInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\n      \"newExtensionTypes\",\n      getArrayDecoder(getExtensionTypeDecoder(), { size: \"remainder\" })\n    ]\n  ]);\n}\nfunction getReallocateInstructionDataCodec() {\n  return combineCodec(\n    getReallocateInstructionDataEncoder(),\n    getReallocateInstructionDataDecoder()\n  );\n}\nfunction getReallocateInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    payer: { value: input.payer ?? null, isWritable: true },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value = \"11111111111111111111111111111111\";\n  }\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts\n    ],\n    data: getReallocateInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseReallocateInstruction(instruction) {\n  if (instruction.accounts.length < 4) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      payer: getNextAccount(),\n      systemProgram: getNextAccount(),\n      owner: getNextAccount()\n    },\n    data: getReallocateInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR = 2;\nfunction getRecoverNestedAssociatedTokenDiscriminatorBytes() {\n  return getU8Encoder().encode(RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR);\n}\nfunction getRecoverNestedAssociatedTokenInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([[\"discriminator\", getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR\n    })\n  );\n}\nfunction getRecoverNestedAssociatedTokenInstructionDataDecoder() {\n  return getStructDecoder([[\"discriminator\", getU8Decoder()]]);\n}\nfunction getRecoverNestedAssociatedTokenInstructionDataCodec() {\n  return combineCodec(\n    getRecoverNestedAssociatedTokenInstructionDataEncoder(),\n    getRecoverNestedAssociatedTokenInstructionDataDecoder()\n  );\n}\nasync function getRecoverNestedAssociatedTokenInstructionAsync(input, config) {\n  const programAddress = config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    nestedAssociatedAccountAddress: {\n      value: input.nestedAssociatedAccountAddress ?? null,\n      isWritable: true\n    },\n    nestedTokenMintAddress: {\n      value: input.nestedTokenMintAddress ?? null,\n      isWritable: false\n    },\n    destinationAssociatedAccountAddress: {\n      value: input.destinationAssociatedAccountAddress ?? null,\n      isWritable: true\n    },\n    ownerAssociatedAccountAddress: {\n      value: input.ownerAssociatedAccountAddress ?? null,\n      isWritable: false\n    },\n    ownerTokenMintAddress: {\n      value: input.ownerTokenMintAddress ?? null,\n      isWritable: false\n    },\n    walletAddress: { value: input.walletAddress ?? null, isWritable: true },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value = \"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\";\n  }\n  if (!accounts.ownerAssociatedAccountAddress.value) {\n    accounts.ownerAssociatedAccountAddress.value = await findAssociatedTokenPda(\n      {\n        owner: expectAddress(accounts.walletAddress.value),\n        tokenProgram: expectAddress(accounts.tokenProgram.value),\n        mint: expectAddress(accounts.ownerTokenMintAddress.value)\n      }\n    );\n  }\n  if (!accounts.nestedAssociatedAccountAddress.value) {\n    accounts.nestedAssociatedAccountAddress.value = await findAssociatedTokenPda({\n      owner: expectAddress(accounts.ownerAssociatedAccountAddress.value),\n      tokenProgram: expectAddress(accounts.tokenProgram.value),\n      mint: expectAddress(accounts.nestedTokenMintAddress.value)\n    });\n  }\n  if (!accounts.destinationAssociatedAccountAddress.value) {\n    accounts.destinationAssociatedAccountAddress.value = await findAssociatedTokenPda({\n      owner: expectAddress(accounts.walletAddress.value),\n      tokenProgram: expectAddress(accounts.tokenProgram.value),\n      mint: expectAddress(accounts.nestedTokenMintAddress.value)\n    });\n  }\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.nestedAssociatedAccountAddress),\n      getAccountMeta(accounts.nestedTokenMintAddress),\n      getAccountMeta(accounts.destinationAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerTokenMintAddress),\n      getAccountMeta(accounts.walletAddress),\n      getAccountMeta(accounts.tokenProgram)\n    ],\n    data: getRecoverNestedAssociatedTokenInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction getRecoverNestedAssociatedTokenInstruction(input, config) {\n  const programAddress = config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    nestedAssociatedAccountAddress: {\n      value: input.nestedAssociatedAccountAddress ?? null,\n      isWritable: true\n    },\n    nestedTokenMintAddress: {\n      value: input.nestedTokenMintAddress ?? null,\n      isWritable: false\n    },\n    destinationAssociatedAccountAddress: {\n      value: input.destinationAssociatedAccountAddress ?? null,\n      isWritable: true\n    },\n    ownerAssociatedAccountAddress: {\n      value: input.ownerAssociatedAccountAddress ?? null,\n      isWritable: false\n    },\n    ownerTokenMintAddress: {\n      value: input.ownerTokenMintAddress ?? null,\n      isWritable: false\n    },\n    walletAddress: { value: input.walletAddress ?? null, isWritable: true },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value = \"TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb\";\n  }\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.nestedAssociatedAccountAddress),\n      getAccountMeta(accounts.nestedTokenMintAddress),\n      getAccountMeta(accounts.destinationAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerTokenMintAddress),\n      getAccountMeta(accounts.walletAddress),\n      getAccountMeta(accounts.tokenProgram)\n    ],\n    data: getRecoverNestedAssociatedTokenInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseRecoverNestedAssociatedTokenInstruction(instruction) {\n  if (instruction.accounts.length < 7) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nestedAssociatedAccountAddress: getNextAccount(),\n      nestedTokenMintAddress: getNextAccount(),\n      destinationAssociatedAccountAddress: getNextAccount(),\n      ownerAssociatedAccountAddress: getNextAccount(),\n      ownerTokenMintAddress: getNextAccount(),\n      walletAddress: getNextAccount(),\n      tokenProgram: getNextAccount()\n    },\n    data: getRecoverNestedAssociatedTokenInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar REMOVE_TOKEN_METADATA_KEY_DISCRIMINATOR = new Uint8Array([\n  234,\n  18,\n  32,\n  56,\n  89,\n  141,\n  37,\n  181\n]);\nfunction getRemoveTokenMetadataKeyDiscriminatorBytes() {\n  return getBytesEncoder().encode(REMOVE_TOKEN_METADATA_KEY_DISCRIMINATOR);\n}\nfunction getRemoveTokenMetadataKeyInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getBytesEncoder()],\n      [\"idempotent\", getBooleanEncoder()],\n      [\"key\", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: REMOVE_TOKEN_METADATA_KEY_DISCRIMINATOR,\n      idempotent: value.idempotent ?? false\n    })\n  );\n}\nfunction getRemoveTokenMetadataKeyInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getBytesDecoder()],\n    [\"idempotent\", getBooleanDecoder()],\n    [\"key\", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]\n  ]);\n}\nfunction getRemoveTokenMetadataKeyInstructionDataCodec() {\n  return combineCodec(\n    getRemoveTokenMetadataKeyInstructionDataEncoder(),\n    getRemoveTokenMetadataKeyInstructionDataDecoder()\n  );\n}\nfunction getRemoveTokenMetadataKeyInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false\n    }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.metadata),\n      getAccountMeta(accounts.updateAuthority)\n    ],\n    data: getRemoveTokenMetadataKeyInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseRemoveTokenMetadataKeyInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { metadata: getNextAccount(), updateAuthority: getNextAccount() },\n    data: getRemoveTokenMetadataKeyInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar RESUME_DISCRIMINATOR = 44;\nfunction getResumeDiscriminatorBytes() {\n  return getU8Encoder().encode(RESUME_DISCRIMINATOR);\n}\nvar RESUME_PAUSABLE_DISCRIMINATOR = 2;\nfunction getResumePausableDiscriminatorBytes() {\n  return getU8Encoder().encode(RESUME_PAUSABLE_DISCRIMINATOR);\n}\nfunction getResumeInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"pausableDiscriminator\", getU8Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: RESUME_DISCRIMINATOR,\n      pausableDiscriminator: RESUME_PAUSABLE_DISCRIMINATOR\n    })\n  );\n}\nfunction getResumeInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"pausableDiscriminator\", getU8Decoder()]\n  ]);\n}\nfunction getResumeInstructionDataCodec() {\n  return combineCodec(\n    getResumeInstructionDataEncoder(),\n    getResumeInstructionDataDecoder()\n  );\n}\nfunction getResumeInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority)\n    ],\n    data: getResumeInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseResumeInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), authority: getNextAccount() },\n    data: getResumeInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar REVOKE_DISCRIMINATOR = 5;\nfunction getRevokeDiscriminatorBytes() {\n  return getU8Encoder().encode(REVOKE_DISCRIMINATOR);\n}\nfunction getRevokeInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([[\"discriminator\", getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: REVOKE_DISCRIMINATOR })\n  );\n}\nfunction getRevokeInstructionDataDecoder() {\n  return getStructDecoder([[\"discriminator\", getU8Decoder()]]);\n}\nfunction getRevokeInstructionDataCodec() {\n  return combineCodec(\n    getRevokeInstructionDataEncoder(),\n    getRevokeInstructionDataDecoder()\n  );\n}\nfunction getRevokeInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts\n    ],\n    data: getRevokeInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseRevokeInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { source: getNextAccount(), owner: getNextAccount() },\n    data: getRevokeInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar SET_AUTHORITY_DISCRIMINATOR = 6;\nfunction getSetAuthorityDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_AUTHORITY_DISCRIMINATOR);\n}\nfunction getSetAuthorityInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"authorityType\", getAuthorityTypeEncoder()],\n      [\"newAuthority\", getOptionEncoder(getAddressEncoder())]\n    ]),\n    (value) => ({ ...value, discriminator: SET_AUTHORITY_DISCRIMINATOR })\n  );\n}\nfunction getSetAuthorityInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"authorityType\", getAuthorityTypeDecoder()],\n    [\"newAuthority\", getOptionDecoder(getAddressDecoder())]\n  ]);\n}\nfunction getSetAuthorityInstructionDataCodec() {\n  return combineCodec(\n    getSetAuthorityInstructionDataEncoder(),\n    getSetAuthorityInstructionDataDecoder()\n  );\n}\nfunction getSetAuthorityInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    owned: { value: input.owned ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.owned),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts\n    ],\n    data: getSetAuthorityInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseSetAuthorityInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { owned: getNextAccount(), owner: getNextAccount() },\n    data: getSetAuthorityInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar SET_TRANSFER_FEE_DISCRIMINATOR = 26;\nfunction getSetTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_TRANSFER_FEE_DISCRIMINATOR);\n}\nvar SET_TRANSFER_FEE_TRANSFER_FEE_DISCRIMINATOR = 5;\nfunction getSetTransferFeeTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_TRANSFER_FEE_TRANSFER_FEE_DISCRIMINATOR);\n}\nfunction getSetTransferFeeInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"transferFeeDiscriminator\", getU8Encoder()],\n      [\"transferFeeBasisPoints\", getU16Encoder()],\n      [\"maximumFee\", getU64Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: SET_TRANSFER_FEE_DISCRIMINATOR,\n      transferFeeDiscriminator: SET_TRANSFER_FEE_TRANSFER_FEE_DISCRIMINATOR\n    })\n  );\n}\nfunction getSetTransferFeeInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"transferFeeDiscriminator\", getU8Decoder()],\n    [\"transferFeeBasisPoints\", getU16Decoder()],\n    [\"maximumFee\", getU64Decoder()]\n  ]);\n}\nfunction getSetTransferFeeInstructionDataCodec() {\n  return combineCodec(\n    getSetTransferFeeInstructionDataEncoder(),\n    getSetTransferFeeInstructionDataDecoder()\n  );\n}\nfunction getSetTransferFeeInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    transferFeeConfigAuthority: {\n      value: input.transferFeeConfigAuthority ?? null,\n      isWritable: false\n    }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.transferFeeConfigAuthority),\n      ...remainingAccounts\n    ],\n    data: getSetTransferFeeInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseSetTransferFeeInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      transferFeeConfigAuthority: getNextAccount()\n    },\n    data: getSetTransferFeeInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar SYNC_NATIVE_DISCRIMINATOR = 17;\nfunction getSyncNativeDiscriminatorBytes() {\n  return getU8Encoder().encode(SYNC_NATIVE_DISCRIMINATOR);\n}\nfunction getSyncNativeInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([[\"discriminator\", getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: SYNC_NATIVE_DISCRIMINATOR })\n  );\n}\nfunction getSyncNativeInstructionDataDecoder() {\n  return getStructDecoder([[\"discriminator\", getU8Decoder()]]);\n}\nfunction getSyncNativeInstructionDataCodec() {\n  return combineCodec(\n    getSyncNativeInstructionDataEncoder(),\n    getSyncNativeInstructionDataDecoder()\n  );\n}\nfunction getSyncNativeInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true }\n  };\n  const accounts = originalAccounts;\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.account)],\n    data: getSyncNativeInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseSyncNativeInstruction(instruction) {\n  if (instruction.accounts.length < 1) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { account: getNextAccount() },\n    data: getSyncNativeInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar THAW_ACCOUNT_DISCRIMINATOR = 11;\nfunction getThawAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(THAW_ACCOUNT_DISCRIMINATOR);\n}\nfunction getThawAccountInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([[\"discriminator\", getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: THAW_ACCOUNT_DISCRIMINATOR })\n  );\n}\nfunction getThawAccountInstructionDataDecoder() {\n  return getStructDecoder([[\"discriminator\", getU8Decoder()]]);\n}\nfunction getThawAccountInstructionDataCodec() {\n  return combineCodec(\n    getThawAccountInstructionDataEncoder(),\n    getThawAccountInstructionDataDecoder()\n  );\n}\nfunction getThawAccountInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts\n    ],\n    data: getThawAccountInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseThawAccountInstruction(instruction) {\n  if (instruction.accounts.length < 3) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      owner: getNextAccount()\n    },\n    data: getThawAccountInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar TRANSFER_DISCRIMINATOR = 3;\nfunction getTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(TRANSFER_DISCRIMINATOR);\n}\nfunction getTransferInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"amount\", getU64Encoder()]\n    ]),\n    (value) => ({ ...value, discriminator: TRANSFER_DISCRIMINATOR })\n  );\n}\nfunction getTransferInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"amount\", getU64Decoder()]\n  ]);\n}\nfunction getTransferInstructionDataCodec() {\n  return combineCodec(\n    getTransferInstructionDataEncoder(),\n    getTransferInstructionDataDecoder()\n  );\n}\nfunction getTransferInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts\n    ],\n    data: getTransferInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseTransferInstruction(instruction) {\n  if (instruction.accounts.length < 3) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      destination: getNextAccount(),\n      authority: getNextAccount()\n    },\n    data: getTransferInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar TRANSFER_CHECKED_DISCRIMINATOR = 12;\nfunction getTransferCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(TRANSFER_CHECKED_DISCRIMINATOR);\n}\nfunction getTransferCheckedInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"amount\", getU64Encoder()],\n      [\"decimals\", getU8Encoder()]\n    ]),\n    (value) => ({ ...value, discriminator: TRANSFER_CHECKED_DISCRIMINATOR })\n  );\n}\nfunction getTransferCheckedInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"amount\", getU64Decoder()],\n    [\"decimals\", getU8Decoder()]\n  ]);\n}\nfunction getTransferCheckedInstructionDataCodec() {\n  return combineCodec(\n    getTransferCheckedInstructionDataEncoder(),\n    getTransferCheckedInstructionDataDecoder()\n  );\n}\nfunction getTransferCheckedInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    destination: { value: input.destination ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts\n    ],\n    data: getTransferCheckedInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseTransferCheckedInstruction(instruction) {\n  if (instruction.accounts.length < 4) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      mint: getNextAccount(),\n      destination: getNextAccount(),\n      authority: getNextAccount()\n    },\n    data: getTransferCheckedInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar TRANSFER_CHECKED_WITH_FEE_DISCRIMINATOR = 26;\nfunction getTransferCheckedWithFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(TRANSFER_CHECKED_WITH_FEE_DISCRIMINATOR);\n}\nvar TRANSFER_CHECKED_WITH_FEE_TRANSFER_FEE_DISCRIMINATOR = 1;\nfunction getTransferCheckedWithFeeTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    TRANSFER_CHECKED_WITH_FEE_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\nfunction getTransferCheckedWithFeeInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"transferFeeDiscriminator\", getU8Encoder()],\n      [\"amount\", getU64Encoder()],\n      [\"decimals\", getU8Encoder()],\n      [\"fee\", getU64Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: TRANSFER_CHECKED_WITH_FEE_DISCRIMINATOR,\n      transferFeeDiscriminator: TRANSFER_CHECKED_WITH_FEE_TRANSFER_FEE_DISCRIMINATOR\n    })\n  );\n}\nfunction getTransferCheckedWithFeeInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"transferFeeDiscriminator\", getU8Decoder()],\n    [\"amount\", getU64Decoder()],\n    [\"decimals\", getU8Decoder()],\n    [\"fee\", getU64Decoder()]\n  ]);\n}\nfunction getTransferCheckedWithFeeInstructionDataCodec() {\n  return combineCodec(\n    getTransferCheckedWithFeeInstructionDataEncoder(),\n    getTransferCheckedWithFeeInstructionDataDecoder()\n  );\n}\nfunction getTransferCheckedWithFeeInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    destination: { value: input.destination ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts\n    ],\n    data: getTransferCheckedWithFeeInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseTransferCheckedWithFeeInstruction(instruction) {\n  if (instruction.accounts.length < 4) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      mint: getNextAccount(),\n      destination: getNextAccount(),\n      authority: getNextAccount()\n    },\n    data: getTransferCheckedWithFeeInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR = 24;\nfunction getUiAmountToAmountDiscriminatorBytes() {\n  return getU8Encoder().encode(UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR);\n}\nfunction getUiAmountToAmountInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"uiAmount\", getUtf8Encoder()]\n    ]),\n    (value) => ({ ...value, discriminator: UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR })\n  );\n}\nfunction getUiAmountToAmountInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"uiAmount\", getUtf8Decoder()]\n  ]);\n}\nfunction getUiAmountToAmountInstructionDataCodec() {\n  return combineCodec(\n    getUiAmountToAmountInstructionDataEncoder(),\n    getUiAmountToAmountInstructionDataDecoder()\n  );\n}\nfunction getUiAmountToAmountInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getUiAmountToAmountInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseUiAmountToAmountInstruction(instruction) {\n  if (instruction.accounts.length < 1) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getUiAmountToAmountInstructionDataDecoder().decode(instruction.data)\n  };\n}\nvar UPDATE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR = 27;\nfunction getUpdateConfidentialTransferMintDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR);\n}\nvar UPDATE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 1;\nfunction getUpdateConfidentialTransferMintConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\nfunction getUpdateConfidentialTransferMintInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"confidentialTransferDiscriminator\", getU8Encoder()],\n      [\"autoApproveNewAccounts\", getBooleanEncoder()],\n      [\n        \"auditorElgamalPubkey\",\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: \"zeroes\"\n        })\n      ]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR,\n      confidentialTransferDiscriminator: UPDATE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n    })\n  );\n}\nfunction getUpdateConfidentialTransferMintInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"confidentialTransferDiscriminator\", getU8Decoder()],\n    [\"autoApproveNewAccounts\", getBooleanDecoder()],\n    [\n      \"auditorElgamalPubkey\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: \"zeroes\"\n      })\n    ]\n  ]);\n}\nfunction getUpdateConfidentialTransferMintInstructionDataCodec() {\n  return combineCodec(\n    getUpdateConfidentialTransferMintInstructionDataEncoder(),\n    getUpdateConfidentialTransferMintInstructionDataDecoder()\n  );\n}\nfunction getUpdateConfidentialTransferMintInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority)\n    ],\n    data: getUpdateConfidentialTransferMintInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseUpdateConfidentialTransferMintInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), authority: getNextAccount() },\n    data: getUpdateConfidentialTransferMintInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar UPDATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = 28;\nfunction getUpdateDefaultAccountStateDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR);\n}\nvar UPDATE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = 1;\nfunction getUpdateDefaultAccountStateDefaultAccountStateDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR\n  );\n}\nfunction getUpdateDefaultAccountStateInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"defaultAccountStateDiscriminator\", getU8Encoder()],\n      [\"state\", getAccountStateEncoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR,\n      defaultAccountStateDiscriminator: UPDATE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR\n    })\n  );\n}\nfunction getUpdateDefaultAccountStateInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"defaultAccountStateDiscriminator\", getU8Decoder()],\n    [\"state\", getAccountStateDecoder()]\n  ]);\n}\nfunction getUpdateDefaultAccountStateInstructionDataCodec() {\n  return combineCodec(\n    getUpdateDefaultAccountStateInstructionDataEncoder(),\n    getUpdateDefaultAccountStateInstructionDataDecoder()\n  );\n}\nfunction getUpdateDefaultAccountStateInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    freezeAuthority: {\n      value: input.freezeAuthority ?? null,\n      isWritable: false\n    }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.freezeAuthority),\n      ...remainingAccounts\n    ],\n    data: getUpdateDefaultAccountStateInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseUpdateDefaultAccountStateInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), freezeAuthority: getNextAccount() },\n    data: getUpdateDefaultAccountStateInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar UPDATE_GROUP_MEMBER_POINTER_DISCRIMINATOR = 41;\nfunction getUpdateGroupMemberPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_GROUP_MEMBER_POINTER_DISCRIMINATOR);\n}\nvar UPDATE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR = 1;\nfunction getUpdateGroupMemberPointerGroupMemberPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR\n  );\n}\nfunction getUpdateGroupMemberPointerInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"groupMemberPointerDiscriminator\", getU8Encoder()],\n      [\n        \"memberAddress\",\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: \"zeroes\"\n        })\n      ]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_GROUP_MEMBER_POINTER_DISCRIMINATOR,\n      groupMemberPointerDiscriminator: UPDATE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR\n    })\n  );\n}\nfunction getUpdateGroupMemberPointerInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"groupMemberPointerDiscriminator\", getU8Decoder()],\n    [\n      \"memberAddress\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: \"zeroes\"\n      })\n    ]\n  ]);\n}\nfunction getUpdateGroupMemberPointerInstructionDataCodec() {\n  return combineCodec(\n    getUpdateGroupMemberPointerInstructionDataEncoder(),\n    getUpdateGroupMemberPointerInstructionDataDecoder()\n  );\n}\nfunction getUpdateGroupMemberPointerInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    groupMemberPointerAuthority: {\n      value: input.groupMemberPointerAuthority ?? null,\n      isWritable: false\n    }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.groupMemberPointerAuthority),\n      ...remainingAccounts\n    ],\n    data: getUpdateGroupMemberPointerInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseUpdateGroupMemberPointerInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      groupMemberPointerAuthority: getNextAccount()\n    },\n    data: getUpdateGroupMemberPointerInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar UPDATE_GROUP_POINTER_DISCRIMINATOR = 40;\nfunction getUpdateGroupPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_GROUP_POINTER_DISCRIMINATOR);\n}\nvar UPDATE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR = 1;\nfunction getUpdateGroupPointerGroupPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR\n  );\n}\nfunction getUpdateGroupPointerInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"groupPointerDiscriminator\", getU8Encoder()],\n      [\n        \"groupAddress\",\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: \"zeroes\"\n        })\n      ]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_GROUP_POINTER_DISCRIMINATOR,\n      groupPointerDiscriminator: UPDATE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR\n    })\n  );\n}\nfunction getUpdateGroupPointerInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"groupPointerDiscriminator\", getU8Decoder()],\n    [\n      \"groupAddress\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: \"zeroes\"\n      })\n    ]\n  ]);\n}\nfunction getUpdateGroupPointerInstructionDataCodec() {\n  return combineCodec(\n    getUpdateGroupPointerInstructionDataEncoder(),\n    getUpdateGroupPointerInstructionDataDecoder()\n  );\n}\nfunction getUpdateGroupPointerInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    groupPointerAuthority: {\n      value: input.groupPointerAuthority ?? null,\n      isWritable: false\n    }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.groupPointerAuthority),\n      ...remainingAccounts\n    ],\n    data: getUpdateGroupPointerInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseUpdateGroupPointerInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      groupPointerAuthority: getNextAccount()\n    },\n    data: getUpdateGroupPointerInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar UPDATE_METADATA_POINTER_DISCRIMINATOR = 39;\nfunction getUpdateMetadataPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_METADATA_POINTER_DISCRIMINATOR);\n}\nvar UPDATE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR = 1;\nfunction getUpdateMetadataPointerMetadataPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR\n  );\n}\nfunction getUpdateMetadataPointerInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"metadataPointerDiscriminator\", getU8Encoder()],\n      [\n        \"metadataAddress\",\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: \"zeroes\"\n        })\n      ]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_METADATA_POINTER_DISCRIMINATOR,\n      metadataPointerDiscriminator: UPDATE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR\n    })\n  );\n}\nfunction getUpdateMetadataPointerInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"metadataPointerDiscriminator\", getU8Decoder()],\n    [\n      \"metadataAddress\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: \"zeroes\"\n      })\n    ]\n  ]);\n}\nfunction getUpdateMetadataPointerInstructionDataCodec() {\n  return combineCodec(\n    getUpdateMetadataPointerInstructionDataEncoder(),\n    getUpdateMetadataPointerInstructionDataDecoder()\n  );\n}\nfunction getUpdateMetadataPointerInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    metadataPointerAuthority: {\n      value: input.metadataPointerAuthority ?? null,\n      isWritable: false\n    }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.metadataPointerAuthority),\n      ...remainingAccounts\n    ],\n    data: getUpdateMetadataPointerInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseUpdateMetadataPointerInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      metadataPointerAuthority: getNextAccount()\n    },\n    data: getUpdateMetadataPointerInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar UPDATE_MULTIPLIER_SCALED_UI_MINT_DISCRIMINATOR = 43;\nfunction getUpdateMultiplierScaledUiMintDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_MULTIPLIER_SCALED_UI_MINT_DISCRIMINATOR);\n}\nvar UPDATE_MULTIPLIER_SCALED_UI_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR = 1;\nfunction getUpdateMultiplierScaledUiMintScaledUiAmountMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_MULTIPLIER_SCALED_UI_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR\n  );\n}\nfunction getUpdateMultiplierScaledUiMintInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"scaledUiAmountMintDiscriminator\", getU8Encoder()],\n      [\"multiplier\", getF64Encoder()],\n      [\"effectiveTimestamp\", getI64Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_MULTIPLIER_SCALED_UI_MINT_DISCRIMINATOR,\n      scaledUiAmountMintDiscriminator: UPDATE_MULTIPLIER_SCALED_UI_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR\n    })\n  );\n}\nfunction getUpdateMultiplierScaledUiMintInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"scaledUiAmountMintDiscriminator\", getU8Decoder()],\n    [\"multiplier\", getF64Decoder()],\n    [\"effectiveTimestamp\", getI64Decoder()]\n  ]);\n}\nfunction getUpdateMultiplierScaledUiMintInstructionDataCodec() {\n  return combineCodec(\n    getUpdateMultiplierScaledUiMintInstructionDataEncoder(),\n    getUpdateMultiplierScaledUiMintInstructionDataDecoder()\n  );\n}\nfunction getUpdateMultiplierScaledUiMintInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: true }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts\n    ],\n    data: getUpdateMultiplierScaledUiMintInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseUpdateMultiplierScaledUiMintInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), authority: getNextAccount() },\n    data: getUpdateMultiplierScaledUiMintInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar UPDATE_RATE_INTEREST_BEARING_MINT_DISCRIMINATOR = 33;\nfunction getUpdateRateInterestBearingMintDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_RATE_INTEREST_BEARING_MINT_DISCRIMINATOR);\n}\nvar UPDATE_RATE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR = 1;\nfunction getUpdateRateInterestBearingMintInterestBearingMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_RATE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR\n  );\n}\nfunction getUpdateRateInterestBearingMintInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"interestBearingMintDiscriminator\", getU8Encoder()],\n      [\"rate\", getI16Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_RATE_INTEREST_BEARING_MINT_DISCRIMINATOR,\n      interestBearingMintDiscriminator: UPDATE_RATE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR\n    })\n  );\n}\nfunction getUpdateRateInterestBearingMintInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"interestBearingMintDiscriminator\", getU8Decoder()],\n    [\"rate\", getI16Decoder()]\n  ]);\n}\nfunction getUpdateRateInterestBearingMintInstructionDataCodec() {\n  return combineCodec(\n    getUpdateRateInterestBearingMintInstructionDataEncoder(),\n    getUpdateRateInterestBearingMintInstructionDataDecoder()\n  );\n}\nfunction getUpdateRateInterestBearingMintInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    rateAuthority: { value: input.rateAuthority ?? null, isWritable: true }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.rateAuthority),\n      ...remainingAccounts\n    ],\n    data: getUpdateRateInterestBearingMintInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseUpdateRateInterestBearingMintInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), rateAuthority: getNextAccount() },\n    data: getUpdateRateInterestBearingMintInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar UPDATE_TOKEN_GROUP_MAX_SIZE_DISCRIMINATOR = new Uint8Array([\n  108,\n  37,\n  171,\n  143,\n  248,\n  30,\n  18,\n  110\n]);\nfunction getUpdateTokenGroupMaxSizeDiscriminatorBytes() {\n  return getBytesEncoder().encode(UPDATE_TOKEN_GROUP_MAX_SIZE_DISCRIMINATOR);\n}\nfunction getUpdateTokenGroupMaxSizeInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getBytesEncoder()],\n      [\"maxSize\", getU64Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TOKEN_GROUP_MAX_SIZE_DISCRIMINATOR\n    })\n  );\n}\nfunction getUpdateTokenGroupMaxSizeInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getBytesDecoder()],\n    [\"maxSize\", getU64Decoder()]\n  ]);\n}\nfunction getUpdateTokenGroupMaxSizeInstructionDataCodec() {\n  return combineCodec(\n    getUpdateTokenGroupMaxSizeInstructionDataEncoder(),\n    getUpdateTokenGroupMaxSizeInstructionDataDecoder()\n  );\n}\nfunction getUpdateTokenGroupMaxSizeInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    group: { value: input.group ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false\n    }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.group),\n      getAccountMeta(accounts.updateAuthority)\n    ],\n    data: getUpdateTokenGroupMaxSizeInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseUpdateTokenGroupMaxSizeInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { group: getNextAccount(), updateAuthority: getNextAccount() },\n    data: getUpdateTokenGroupMaxSizeInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar UPDATE_TOKEN_GROUP_UPDATE_AUTHORITY_DISCRIMINATOR = new Uint8Array(\n  [161, 105, 88, 1, 237, 221, 216, 203]\n);\nfunction getUpdateTokenGroupUpdateAuthorityDiscriminatorBytes() {\n  return getBytesEncoder().encode(\n    UPDATE_TOKEN_GROUP_UPDATE_AUTHORITY_DISCRIMINATOR\n  );\n}\nfunction getUpdateTokenGroupUpdateAuthorityInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getBytesEncoder()],\n      [\n        \"newUpdateAuthority\",\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: \"zeroes\"\n        })\n      ]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TOKEN_GROUP_UPDATE_AUTHORITY_DISCRIMINATOR\n    })\n  );\n}\nfunction getUpdateTokenGroupUpdateAuthorityInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getBytesDecoder()],\n    [\n      \"newUpdateAuthority\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: \"zeroes\"\n      })\n    ]\n  ]);\n}\nfunction getUpdateTokenGroupUpdateAuthorityInstructionDataCodec() {\n  return combineCodec(\n    getUpdateTokenGroupUpdateAuthorityInstructionDataEncoder(),\n    getUpdateTokenGroupUpdateAuthorityInstructionDataDecoder()\n  );\n}\nfunction getUpdateTokenGroupUpdateAuthorityInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    group: { value: input.group ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false\n    }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.group),\n      getAccountMeta(accounts.updateAuthority)\n    ],\n    data: getUpdateTokenGroupUpdateAuthorityInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseUpdateTokenGroupUpdateAuthorityInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { group: getNextAccount(), updateAuthority: getNextAccount() },\n    data: getUpdateTokenGroupUpdateAuthorityInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar UPDATE_TOKEN_METADATA_FIELD_DISCRIMINATOR = new Uint8Array([\n  221,\n  233,\n  49,\n  45,\n  181,\n  202,\n  220,\n  200\n]);\nfunction getUpdateTokenMetadataFieldDiscriminatorBytes() {\n  return getBytesEncoder().encode(UPDATE_TOKEN_METADATA_FIELD_DISCRIMINATOR);\n}\nfunction getUpdateTokenMetadataFieldInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getBytesEncoder()],\n      [\"field\", getTokenMetadataFieldEncoder()],\n      [\"value\", addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TOKEN_METADATA_FIELD_DISCRIMINATOR\n    })\n  );\n}\nfunction getUpdateTokenMetadataFieldInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getBytesDecoder()],\n    [\"field\", getTokenMetadataFieldDecoder()],\n    [\"value\", addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())]\n  ]);\n}\nfunction getUpdateTokenMetadataFieldInstructionDataCodec() {\n  return combineCodec(\n    getUpdateTokenMetadataFieldInstructionDataEncoder(),\n    getUpdateTokenMetadataFieldInstructionDataDecoder()\n  );\n}\nfunction getUpdateTokenMetadataFieldInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false\n    }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.metadata),\n      getAccountMeta(accounts.updateAuthority)\n    ],\n    data: getUpdateTokenMetadataFieldInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseUpdateTokenMetadataFieldInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { metadata: getNextAccount(), updateAuthority: getNextAccount() },\n    data: getUpdateTokenMetadataFieldInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar UPDATE_TOKEN_METADATA_UPDATE_AUTHORITY_DISCRIMINATOR = new Uint8Array([215, 228, 166, 228, 84, 100, 86, 123]);\nfunction getUpdateTokenMetadataUpdateAuthorityDiscriminatorBytes() {\n  return getBytesEncoder().encode(\n    UPDATE_TOKEN_METADATA_UPDATE_AUTHORITY_DISCRIMINATOR\n  );\n}\nfunction getUpdateTokenMetadataUpdateAuthorityInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getBytesEncoder()],\n      [\n        \"newUpdateAuthority\",\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: \"zeroes\"\n        })\n      ]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TOKEN_METADATA_UPDATE_AUTHORITY_DISCRIMINATOR\n    })\n  );\n}\nfunction getUpdateTokenMetadataUpdateAuthorityInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getBytesDecoder()],\n    [\n      \"newUpdateAuthority\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: \"zeroes\"\n      })\n    ]\n  ]);\n}\nfunction getUpdateTokenMetadataUpdateAuthorityInstructionDataCodec() {\n  return combineCodec(\n    getUpdateTokenMetadataUpdateAuthorityInstructionDataEncoder(),\n    getUpdateTokenMetadataUpdateAuthorityInstructionDataDecoder()\n  );\n}\nfunction getUpdateTokenMetadataUpdateAuthorityInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false\n    }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.metadata),\n      getAccountMeta(accounts.updateAuthority)\n    ],\n    data: getUpdateTokenMetadataUpdateAuthorityInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseUpdateTokenMetadataUpdateAuthorityInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { metadata: getNextAccount(), updateAuthority: getNextAccount() },\n    data: getUpdateTokenMetadataUpdateAuthorityInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar UPDATE_TRANSFER_HOOK_DISCRIMINATOR = 36;\nfunction getUpdateTransferHookDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_TRANSFER_HOOK_DISCRIMINATOR);\n}\nvar UPDATE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR = 1;\nfunction getUpdateTransferHookTransferHookDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR\n  );\n}\nfunction getUpdateTransferHookInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"transferHookDiscriminator\", getU8Encoder()],\n      [\n        \"programId\",\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: \"zeroes\"\n        })\n      ]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TRANSFER_HOOK_DISCRIMINATOR,\n      transferHookDiscriminator: UPDATE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR\n    })\n  );\n}\nfunction getUpdateTransferHookInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"transferHookDiscriminator\", getU8Decoder()],\n    [\n      \"programId\",\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: \"zeroes\"\n      })\n    ]\n  ]);\n}\nfunction getUpdateTransferHookInstructionDataCodec() {\n  return combineCodec(\n    getUpdateTransferHookInstructionDataEncoder(),\n    getUpdateTransferHookInstructionDataDecoder()\n  );\n}\nfunction getUpdateTransferHookInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts\n    ],\n    data: getUpdateTransferHookInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseUpdateTransferHookInstruction(instruction) {\n  if (instruction.accounts.length < 2) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), authority: getNextAccount() },\n    data: getUpdateTransferHookInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar WITHDRAW_EXCESS_LAMPORTS_DISCRIMINATOR = 38;\nfunction getWithdrawExcessLamportsDiscriminatorBytes() {\n  return getU8Encoder().encode(WITHDRAW_EXCESS_LAMPORTS_DISCRIMINATOR);\n}\nfunction getWithdrawExcessLamportsInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([[\"discriminator\", getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: WITHDRAW_EXCESS_LAMPORTS_DISCRIMINATOR\n    })\n  );\n}\nfunction getWithdrawExcessLamportsInstructionDataDecoder() {\n  return getStructDecoder([[\"discriminator\", getU8Decoder()]]);\n}\nfunction getWithdrawExcessLamportsInstructionDataCodec() {\n  return combineCodec(\n    getWithdrawExcessLamportsInstructionDataEncoder(),\n    getWithdrawExcessLamportsInstructionDataDecoder()\n  );\n}\nfunction getWithdrawExcessLamportsInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    sourceAccount: { value: input.sourceAccount ?? null, isWritable: true },\n    destinationAccount: {\n      value: input.destinationAccount ?? null,\n      isWritable: true\n    },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.sourceAccount),\n      getAccountMeta(accounts.destinationAccount),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts\n    ],\n    data: getWithdrawExcessLamportsInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseWithdrawExcessLamportsInstruction(instruction) {\n  if (instruction.accounts.length < 3) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      sourceAccount: getNextAccount(),\n      destinationAccount: getNextAccount(),\n      authority: getNextAccount()\n    },\n    data: getWithdrawExcessLamportsInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_DISCRIMINATOR = 26;\nfunction getWithdrawWithheldTokensFromAccountsDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_DISCRIMINATOR\n  );\n}\nvar WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_TRANSFER_FEE_DISCRIMINATOR = 3;\nfunction getWithdrawWithheldTokensFromAccountsTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\nfunction getWithdrawWithheldTokensFromAccountsInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"transferFeeDiscriminator\", getU8Encoder()],\n      [\"numTokenAccounts\", getU8Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_DISCRIMINATOR,\n      transferFeeDiscriminator: WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_TRANSFER_FEE_DISCRIMINATOR\n    })\n  );\n}\nfunction getWithdrawWithheldTokensFromAccountsInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"transferFeeDiscriminator\", getU8Decoder()],\n    [\"numTokenAccounts\", getU8Decoder()]\n  ]);\n}\nfunction getWithdrawWithheldTokensFromAccountsInstructionDataCodec() {\n  return combineCodec(\n    getWithdrawWithheldTokensFromAccountsInstructionDataEncoder(),\n    getWithdrawWithheldTokensFromAccountsInstructionDataDecoder()\n  );\n}\nfunction getWithdrawWithheldTokensFromAccountsInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n    feeReceiver: { value: input.feeReceiver ?? null, isWritable: true },\n    withdrawWithheldAuthority: {\n      value: input.withdrawWithheldAuthority ?? null,\n      isWritable: false\n    }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = [\n    ...(args.multiSigners ?? []).map((signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })),\n    ...args.sources.map((address) => ({ address, role: AccountRole.WRITABLE }))\n  ];\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.feeReceiver),\n      getAccountMeta(accounts.withdrawWithheldAuthority),\n      ...remainingAccounts\n    ],\n    data: getWithdrawWithheldTokensFromAccountsInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseWithdrawWithheldTokensFromAccountsInstruction(instruction) {\n  if (instruction.accounts.length < 3) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      feeReceiver: getNextAccount(),\n      withdrawWithheldAuthority: getNextAccount()\n    },\n    data: getWithdrawWithheldTokensFromAccountsInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 37;\nfunction getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\nvar WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 2;\nfunction getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\nfunction getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"confidentialTransferFeeDiscriminator\", getU8Encoder()],\n      [\"numTokenAccounts\", getU8Encoder()],\n      [\"proofInstructionOffset\", getI8Encoder()],\n      [\"newDecryptableAvailableBalance\", getDecryptableBalanceEncoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator: WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n    })\n  );\n}\nfunction getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"confidentialTransferFeeDiscriminator\", getU8Decoder()],\n    [\"numTokenAccounts\", getU8Decoder()],\n    [\"proofInstructionOffset\", getI8Decoder()],\n    [\"newDecryptableAvailableBalance\", getDecryptableBalanceDecoder()]\n  ]);\n}\nfunction getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataCodec() {\n  return combineCodec(\n    getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataEncoder(),\n    getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataDecoder()\n  );\n}\nfunction getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n    destination: { value: input.destination ?? null, isWritable: true },\n    instructionsSysvarOrContextState: {\n      value: input.instructionsSysvarOrContextState ?? null,\n      isWritable: false\n    },\n    record: { value: input.record ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.instructionsSysvarOrContextState),\n      getAccountMeta(accounts.record),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts\n    ],\n    data: getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction(instruction) {\n  if (instruction.accounts.length < 5) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS ? void 0 : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      destination: getNextAccount(),\n      instructionsSysvarOrContextState: getNextAccount(),\n      record: getNextOptionalAccount(),\n      authority: getNextAccount()\n    },\n    data: getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar WITHDRAW_WITHHELD_TOKENS_FROM_MINT_DISCRIMINATOR = 26;\nfunction getWithdrawWithheldTokensFromMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_MINT_DISCRIMINATOR\n  );\n}\nvar WITHDRAW_WITHHELD_TOKENS_FROM_MINT_TRANSFER_FEE_DISCRIMINATOR = 2;\nfunction getWithdrawWithheldTokensFromMintTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_MINT_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\nfunction getWithdrawWithheldTokensFromMintInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"transferFeeDiscriminator\", getU8Encoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: WITHDRAW_WITHHELD_TOKENS_FROM_MINT_DISCRIMINATOR,\n      transferFeeDiscriminator: WITHDRAW_WITHHELD_TOKENS_FROM_MINT_TRANSFER_FEE_DISCRIMINATOR\n    })\n  );\n}\nfunction getWithdrawWithheldTokensFromMintInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"transferFeeDiscriminator\", getU8Decoder()]\n  ]);\n}\nfunction getWithdrawWithheldTokensFromMintInstructionDataCodec() {\n  return combineCodec(\n    getWithdrawWithheldTokensFromMintInstructionDataEncoder(),\n    getWithdrawWithheldTokensFromMintInstructionDataDecoder()\n  );\n}\nfunction getWithdrawWithheldTokensFromMintInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    feeReceiver: { value: input.feeReceiver ?? null, isWritable: true },\n    withdrawWithheldAuthority: {\n      value: input.withdrawWithheldAuthority ?? null,\n      isWritable: false\n    }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.feeReceiver),\n      getAccountMeta(accounts.withdrawWithheldAuthority),\n      ...remainingAccounts\n    ],\n    data: getWithdrawWithheldTokensFromMintInstructionDataEncoder().encode({}),\n    programAddress\n  });\n}\nfunction parseWithdrawWithheldTokensFromMintInstruction(instruction) {\n  if (instruction.accounts.length < 3) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      feeReceiver: getNextAccount(),\n      withdrawWithheldAuthority: getNextAccount()\n    },\n    data: getWithdrawWithheldTokensFromMintInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 37;\nfunction getWithdrawWithheldTokensFromMintForConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\nvar WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 1;\nfunction getWithdrawWithheldTokensFromMintForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\nfunction getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      [\"discriminator\", getU8Encoder()],\n      [\"confidentialTransferFeeDiscriminator\", getU8Encoder()],\n      [\"proofInstructionOffset\", getI8Encoder()],\n      [\"newDecryptableAvailableBalance\", getDecryptableBalanceEncoder()]\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator: WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n    })\n  );\n}\nfunction getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataDecoder() {\n  return getStructDecoder([\n    [\"discriminator\", getU8Decoder()],\n    [\"confidentialTransferFeeDiscriminator\", getU8Decoder()],\n    [\"proofInstructionOffset\", getI8Decoder()],\n    [\"newDecryptableAvailableBalance\", getDecryptableBalanceDecoder()]\n  ]);\n}\nfunction getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataCodec() {\n  return combineCodec(\n    getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataEncoder(),\n    getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataDecoder()\n  );\n}\nfunction getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction(input, config) {\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n    instructionsSysvarOrContextState: {\n      value: input.instructionsSysvarOrContextState ?? null,\n      isWritable: false\n    },\n    record: { value: input.record ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false }\n  };\n  const accounts = originalAccounts;\n  const args = { ...input };\n  const remainingAccounts = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer\n    })\n  );\n  const getAccountMeta = getAccountMetaFactory(programAddress);\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.instructionsSysvarOrContextState),\n      getAccountMeta(accounts.record),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts\n    ],\n    data: getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataEncoder().encode(\n      args\n    ),\n    programAddress\n  });\n}\nfunction parseWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction(instruction) {\n  if (instruction.accounts.length < 5) {\n    throw new Error(\"Not enough accounts\");\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = instruction.accounts[accountIndex];\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS ? void 0 : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      destination: getNextAccount(),\n      instructionsSysvarOrContextState: getNextAccount(),\n      record: getNextOptionalAccount(),\n      authority: getNextAccount()\n    },\n    data: getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataDecoder().decode(\n      instruction.data\n    )\n  };\n}\nvar ONE_IN_BASIS_POINTS = 1e4;\nvar SECONDS_PER_YEAR = 60 * 60 * 24 * 365.24;\nfunction calculateExponentForTimesAndRate(t1, t2, r) {\n  const timespan = t2 - t1;\n  if (timespan < 0) {\n    throw new Error(\"Invalid timespan: end time before start time\");\n  }\n  const numerator = r * timespan;\n  const exponent = numerator / (SECONDS_PER_YEAR * ONE_IN_BASIS_POINTS);\n  return Math.exp(exponent);\n}\nfunction calculateTotalScale({\n  currentTimestamp,\n  lastUpdateTimestamp,\n  initializationTimestamp,\n  preUpdateAverageRate,\n  currentRate\n}) {\n  const preUpdateExp = calculateExponentForTimesAndRate(\n    initializationTimestamp,\n    lastUpdateTimestamp,\n    preUpdateAverageRate\n  );\n  const postUpdateExp = calculateExponentForTimesAndRate(\n    lastUpdateTimestamp,\n    currentTimestamp,\n    currentRate\n  );\n  return preUpdateExp * postUpdateExp;\n}\nfunction getDecimalFactor(decimals) {\n  return Math.pow(10, decimals);\n}\nasync function getSysvarClockTimestamp(rpc) {\n  const info = await fetchSysvarClock(rpc);\n  if (!info) {\n    throw new Error(\"Failed to fetch sysvar clock\");\n  }\n  return info.unixTimestamp;\n}\nfunction amountToUiAmountForInterestBearingMintWithoutSimulation(amount, decimals, currentTimestamp, lastUpdateTimestamp, initializationTimestamp, preUpdateAverageRate, currentRate) {\n  const totalScale = calculateTotalScale({\n    currentTimestamp,\n    lastUpdateTimestamp,\n    initializationTimestamp,\n    preUpdateAverageRate,\n    currentRate\n  });\n  const scaledAmount = Number(amount) * totalScale;\n  const decimalFactor = getDecimalFactor(decimals);\n  return (Math.trunc(scaledAmount) / decimalFactor).toString();\n}\nfunction uiAmountToAmountForInterestBearingMintWithoutSimulation(uiAmount, decimals, currentTimestamp, lastUpdateTimestamp, initializationTimestamp, preUpdateAverageRate, currentRate) {\n  const uiAmountNumber = parseFloat(uiAmount);\n  const decimalsFactor = getDecimalFactor(decimals);\n  const uiAmountScaled = uiAmountNumber * decimalsFactor;\n  const totalScale = calculateTotalScale({\n    currentTimestamp,\n    lastUpdateTimestamp,\n    initializationTimestamp,\n    preUpdateAverageRate,\n    currentRate\n  });\n  const originalPrincipal = uiAmountScaled / totalScale;\n  return BigInt(Math.trunc(originalPrincipal));\n}\nfunction amountToUiAmountForScaledUiAmountMintWithoutSimulation(amount, decimals, multiplier) {\n  const scaledAmount = Number(amount) * multiplier;\n  const decimalFactor = getDecimalFactor(decimals);\n  return (Math.trunc(scaledAmount) / decimalFactor).toString();\n}\nfunction uiAmountToAmountForScaledUiAmountMintWithoutSimulation(uiAmount, decimals, multiplier) {\n  const uiAmountNumber = parseFloat(uiAmount);\n  const decimalsFactor = getDecimalFactor(decimals);\n  const uiAmountScaled = uiAmountNumber * decimalsFactor;\n  const rawAmount = uiAmountScaled / multiplier;\n  return BigInt(Math.trunc(rawAmount));\n}\nasync function amountToUiAmountForMintWithoutSimulation(rpc, mint, amount) {\n  const accountInfo = await fetchMint(rpc, mint);\n  const extensions = unwrapOption(accountInfo.data.extensions);\n  const interestBearingMintConfigState = extensions?.find(\n    (ext) => ext.__kind === \"InterestBearingConfig\"\n  );\n  const scaledUiAmountConfig = extensions?.find(\n    (ext) => ext.__kind === \"ScaledUiAmountConfig\"\n  );\n  if (!interestBearingMintConfigState && !scaledUiAmountConfig) {\n    const amountNumber = Number(amount);\n    const decimalsFactor = getDecimalFactor(accountInfo.data.decimals);\n    return (amountNumber / decimalsFactor).toString();\n  }\n  const timestamp = await getSysvarClockTimestamp(rpc);\n  if (interestBearingMintConfigState) {\n    return amountToUiAmountForInterestBearingMintWithoutSimulation(\n      amount,\n      accountInfo.data.decimals,\n      Number(timestamp),\n      Number(interestBearingMintConfigState.lastUpdateTimestamp),\n      Number(interestBearingMintConfigState.initializationTimestamp),\n      interestBearingMintConfigState.preUpdateAverageRate,\n      interestBearingMintConfigState.currentRate\n    );\n  }\n  if (scaledUiAmountConfig) {\n    let multiplier = scaledUiAmountConfig.multiplier;\n    if (timestamp >= scaledUiAmountConfig.newMultiplierEffectiveTimestamp) {\n      multiplier = scaledUiAmountConfig.newMultiplier;\n    }\n    return amountToUiAmountForScaledUiAmountMintWithoutSimulation(\n      amount,\n      accountInfo.data.decimals,\n      multiplier\n    );\n  }\n  throw new Error(\"Unknown mint extension type\");\n}\nasync function uiAmountToAmountForMintWithoutSimulation(rpc, mint, uiAmount) {\n  const accountInfo = await fetchMint(rpc, mint);\n  const extensions = unwrapOption(accountInfo.data.extensions);\n  const interestBearingMintConfigState = extensions?.find(\n    (ext) => ext.__kind === \"InterestBearingConfig\"\n  );\n  const scaledUiAmountConfig = extensions?.find(\n    (ext) => ext.__kind === \"ScaledUiAmountConfig\"\n  );\n  if (!interestBearingMintConfigState && !scaledUiAmountConfig) {\n    const uiAmountScaled = parseFloat(uiAmount) * getDecimalFactor(accountInfo.data.decimals);\n    return BigInt(Math.trunc(uiAmountScaled));\n  }\n  const timestamp = await getSysvarClockTimestamp(rpc);\n  if (interestBearingMintConfigState) {\n    return uiAmountToAmountForInterestBearingMintWithoutSimulation(\n      uiAmount,\n      accountInfo.data.decimals,\n      Number(timestamp),\n      Number(interestBearingMintConfigState.lastUpdateTimestamp),\n      Number(interestBearingMintConfigState.initializationTimestamp),\n      interestBearingMintConfigState.preUpdateAverageRate,\n      interestBearingMintConfigState.currentRate\n    );\n  }\n  if (scaledUiAmountConfig) {\n    let multiplier = scaledUiAmountConfig.multiplier;\n    if (timestamp >= scaledUiAmountConfig.newMultiplierEffectiveTimestamp) {\n      multiplier = scaledUiAmountConfig.newMultiplier;\n    }\n    return uiAmountToAmountForScaledUiAmountMintWithoutSimulation(\n      uiAmount,\n      accountInfo.data.decimals,\n      multiplier\n    );\n  }\n  throw new Error(\"Unknown mint extension type\");\n}\nfunction getPreInitializeInstructionsForMintExtensions(mint, extensions) {\n  return extensions.flatMap((extension2) => {\n    switch (extension2.__kind) {\n      case \"ConfidentialTransferMint\":\n        return [\n          getInitializeConfidentialTransferMintInstruction({\n            mint,\n            ...extension2\n          })\n        ];\n      case \"DefaultAccountState\":\n        return [\n          getInitializeDefaultAccountStateInstruction({\n            mint,\n            state: extension2.state\n          })\n        ];\n      case \"TransferFeeConfig\":\n        return [\n          getInitializeTransferFeeConfigInstruction({\n            mint,\n            transferFeeConfigAuthority: extension2.transferFeeConfigAuthority,\n            withdrawWithheldAuthority: extension2.withdrawWithheldAuthority,\n            transferFeeBasisPoints: extension2.newerTransferFee.transferFeeBasisPoints,\n            maximumFee: extension2.newerTransferFee.maximumFee\n          })\n        ];\n      case \"MetadataPointer\":\n        return [\n          getInitializeMetadataPointerInstruction({\n            mint,\n            authority: extension2.authority,\n            metadataAddress: extension2.metadataAddress\n          })\n        ];\n      case \"InterestBearingConfig\":\n        return [\n          getInitializeInterestBearingMintInstruction({\n            mint,\n            rateAuthority: extension2.rateAuthority,\n            rate: extension2.currentRate\n          })\n        ];\n      case \"ScaledUiAmountConfig\":\n        return [\n          getInitializeScaledUiAmountMintInstruction({\n            mint,\n            authority: extension2.authority,\n            multiplier: extension2.multiplier\n          })\n        ];\n      case \"PausableConfig\":\n        return [\n          getInitializePausableConfigInstruction({\n            mint,\n            authority: extension2.authority\n          })\n        ];\n      case \"GroupPointer\":\n        return [\n          getInitializeGroupPointerInstruction({\n            mint,\n            authority: extension2.authority,\n            groupAddress: extension2.groupAddress\n          })\n        ];\n      case \"GroupMemberPointer\":\n        return [\n          getInitializeGroupMemberPointerInstruction({\n            mint,\n            authority: extension2.authority,\n            memberAddress: extension2.memberAddress\n          })\n        ];\n      case \"NonTransferable\":\n        return getInitializeNonTransferableMintInstruction({ mint });\n      case \"TransferHook\":\n        return [\n          getInitializeTransferHookInstruction({\n            mint,\n            authority: extension2.authority,\n            programId: extension2.programId\n          })\n        ];\n      case \"PermanentDelegate\":\n        return getInitializePermanentDelegateInstruction({\n          mint,\n          delegate: extension2.delegate\n        });\n      case \"ConfidentialTransferFee\":\n        return [\n          getInitializeConfidentialTransferFeeInstruction({\n            mint,\n            authority: extension2.authority,\n            withdrawWithheldAuthorityElGamalPubkey: extension2.elgamalPubkey\n          })\n        ];\n      case \"MintCloseAuthority\":\n        return getInitializeMintCloseAuthorityInstruction({\n          closeAuthority: extension2.closeAuthority,\n          mint\n        });\n      default:\n        return [];\n    }\n  });\n}\nfunction getPostInitializeInstructionsForMintExtensions(mint, authority, extensions) {\n  return extensions.flatMap((extension2) => {\n    switch (extension2.__kind) {\n      case \"TokenMetadata\":\n        const tokenMetadataUpdateAuthority = isOption(extension2.updateAuthority) ? extension2.updateAuthority : wrapNullable(extension2.updateAuthority);\n        if (isNone(tokenMetadataUpdateAuthority)) {\n          return [];\n        }\n        return [\n          getInitializeTokenMetadataInstruction({\n            metadata: mint,\n            updateAuthority: tokenMetadataUpdateAuthority.value,\n            mint,\n            mintAuthority: authority,\n            name: extension2.name,\n            symbol: extension2.symbol,\n            uri: extension2.uri\n          })\n        ];\n      case \"TokenGroup\":\n        return [\n          getInitializeTokenGroupInstruction({\n            group: mint,\n            updateAuthority: isOption(extension2.updateAuthority) ? extension2.updateAuthority : wrapNullable(extension2.updateAuthority),\n            mint,\n            mintAuthority: authority,\n            maxSize: extension2.maxSize\n          })\n        ];\n      default:\n        return [];\n    }\n  });\n}\nfunction getPostInitializeInstructionsForTokenExtensions(token, owner, extensions, multiSigners) {\n  return extensions.flatMap((extension2) => {\n    switch (extension2.__kind) {\n      case \"MemoTransfer\":\n        return [\n          extension2.requireIncomingTransferMemos ? getEnableMemoTransfersInstruction({ owner, token, multiSigners }) : getDisableMemoTransfersInstruction({\n            owner,\n            token,\n            multiSigners\n          })\n        ];\n      case \"CpiGuard\":\n        return [\n          extension2.lockCpi ? getEnableCpiGuardInstruction({ owner, token, multiSigners }) : getDisableCpiGuardInstruction({\n            owner,\n            token,\n            multiSigners\n          })\n        ];\n      default:\n        return [];\n    }\n  });\n}\nvar TOKEN_BASE_SIZE = 165;\nfunction getTokenSize(extensions) {\n  if (extensions == null) return TOKEN_BASE_SIZE;\n  const tvlEncoder = getHiddenPrefixEncoder(\n    getArrayEncoder(getExtensionEncoder(), { size: \"remainder\" }),\n    [getConstantEncoder(getU8Encoder().encode(2))]\n  );\n  return TOKEN_BASE_SIZE + tvlEncoder.encode(extensions).length;\n}\nvar MINT_BASE_SIZE = 82;\nfunction getMintSize(extensions) {\n  if (extensions == null) return MINT_BASE_SIZE;\n  const tvlEncoder = getHiddenPrefixEncoder(\n    getArrayEncoder(getExtensionEncoder(), { size: \"remainder\" }),\n    [getConstantEncoder(padLeftEncoder(getU8Encoder(), 83).encode(1))]\n  );\n  return MINT_BASE_SIZE + tvlEncoder.encode(extensions).length;\n}\n\nexport { AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR, APPLY_CONFIDENTIAL_PENDING_BALANCE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, APPLY_CONFIDENTIAL_PENDING_BALANCE_DISCRIMINATOR, APPROVE_CHECKED_DISCRIMINATOR, APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR, APPROVE_DISCRIMINATOR, ASSOCIATED_TOKEN_ERROR__INVALID_OWNER, ASSOCIATED_TOKEN_PROGRAM_ADDRESS, AccountState, AssociatedTokenInstruction, AuthorityType, BURN_CHECKED_DISCRIMINATOR, BURN_DISCRIMINATOR, CLOSE_ACCOUNT_DISCRIMINATOR, CONFIDENTIAL_DEPOSIT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, CONFIDENTIAL_DEPOSIT_DISCRIMINATOR, CONFIDENTIAL_TRANSFER_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, CONFIDENTIAL_TRANSFER_DISCRIMINATOR, CONFIDENTIAL_TRANSFER_WITH_FEE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, CONFIDENTIAL_TRANSFER_WITH_FEE_DISCRIMINATOR, CONFIDENTIAL_WITHDRAW_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, CONFIDENTIAL_WITHDRAW_DISCRIMINATOR, CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR, CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR, CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR, CREATE_NATIVE_MINT_DISCRIMINATOR, DISABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, DISABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR, DISABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR, DISABLE_CPI_GUARD_DISCRIMINATOR, DISABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR, DISABLE_HARVEST_TO_MINT_DISCRIMINATOR, DISABLE_MEMO_TRANSFERS_DISCRIMINATOR, DISABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR, DISABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, DISABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR, EMIT_TOKEN_METADATA_DISCRIMINATOR, EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR, ENABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, ENABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR, ENABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR, ENABLE_CPI_GUARD_DISCRIMINATOR, ENABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR, ENABLE_HARVEST_TO_MINT_DISCRIMINATOR, ENABLE_MEMO_TRANSFERS_DISCRIMINATOR, ENABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR, ENABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, ENABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR, ExtensionType, FREEZE_ACCOUNT_DISCRIMINATOR, GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR, HARVEST_WITHHELD_TOKENS_TO_MINT_DISCRIMINATOR, HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR, HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR, HARVEST_WITHHELD_TOKENS_TO_MINT_TRANSFER_FEE_DISCRIMINATOR, INITIALIZE_ACCOUNT2_DISCRIMINATOR, INITIALIZE_ACCOUNT3_DISCRIMINATOR, INITIALIZE_ACCOUNT_DISCRIMINATOR, INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR, INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR, INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR, INITIALIZE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR, INITIALIZE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR, INITIALIZE_GROUP_MEMBER_POINTER_DISCRIMINATOR, INITIALIZE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR, INITIALIZE_GROUP_POINTER_DISCRIMINATOR, INITIALIZE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR, INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR, INITIALIZE_INTEREST_BEARING_MINT_DISCRIMINATOR, INITIALIZE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR, INITIALIZE_METADATA_POINTER_DISCRIMINATOR, INITIALIZE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR, INITIALIZE_MINT2_DISCRIMINATOR, INITIALIZE_MINT_CLOSE_AUTHORITY_DISCRIMINATOR, INITIALIZE_MINT_DISCRIMINATOR, INITIALIZE_MULTISIG2_DISCRIMINATOR, INITIALIZE_MULTISIG_DISCRIMINATOR, INITIALIZE_NON_TRANSFERABLE_MINT_DISCRIMINATOR, INITIALIZE_PAUSABLE_CONFIG_DISCRIMINATOR, INITIALIZE_PAUSABLE_CONFIG_PAUSABLE_DISCRIMINATOR, INITIALIZE_PERMANENT_DELEGATE_DISCRIMINATOR, INITIALIZE_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR, INITIALIZE_SCALED_UI_AMOUNT_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR, INITIALIZE_TOKEN_GROUP_DISCRIMINATOR, INITIALIZE_TOKEN_GROUP_MEMBER_DISCRIMINATOR, INITIALIZE_TOKEN_METADATA_DISCRIMINATOR, INITIALIZE_TRANSFER_FEE_CONFIG_DISCRIMINATOR, INITIALIZE_TRANSFER_FEE_CONFIG_TRANSFER_FEE_DISCRIMINATOR, INITIALIZE_TRANSFER_HOOK_DISCRIMINATOR, INITIALIZE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR, MINT_TO_CHECKED_DISCRIMINATOR, MINT_TO_DISCRIMINATOR, PAUSE_DISCRIMINATOR, PAUSE_PAUSABLE_DISCRIMINATOR, REALLOCATE_DISCRIMINATOR, RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR, REMOVE_TOKEN_METADATA_KEY_DISCRIMINATOR, RESUME_DISCRIMINATOR, RESUME_PAUSABLE_DISCRIMINATOR, REVOKE_DISCRIMINATOR, SET_AUTHORITY_DISCRIMINATOR, SET_TRANSFER_FEE_DISCRIMINATOR, SET_TRANSFER_FEE_TRANSFER_FEE_DISCRIMINATOR, SYNC_NATIVE_DISCRIMINATOR, THAW_ACCOUNT_DISCRIMINATOR, TOKEN_2022_ERROR__ACCOUNT_FROZEN, TOKEN_2022_ERROR__ALREADY_IN_USE, TOKEN_2022_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED, TOKEN_2022_ERROR__FIXED_SUPPLY, TOKEN_2022_ERROR__INSUFFICIENT_FUNDS, TOKEN_2022_ERROR__INVALID_INSTRUCTION, TOKEN_2022_ERROR__INVALID_MINT, TOKEN_2022_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS, TOKEN_2022_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS, TOKEN_2022_ERROR__INVALID_STATE, TOKEN_2022_ERROR__MINT_CANNOT_FREEZE, TOKEN_2022_ERROR__MINT_DECIMALS_MISMATCH, TOKEN_2022_ERROR__MINT_MISMATCH, TOKEN_2022_ERROR__NATIVE_NOT_SUPPORTED, TOKEN_2022_ERROR__NON_NATIVE_HAS_BALANCE, TOKEN_2022_ERROR__NON_NATIVE_NOT_SUPPORTED, TOKEN_2022_ERROR__NOT_RENT_EXEMPT, TOKEN_2022_ERROR__OVERFLOW, TOKEN_2022_ERROR__OWNER_MISMATCH, TOKEN_2022_ERROR__UNINITIALIZED_STATE, TOKEN_2022_PROGRAM_ADDRESS, TRANSFER_CHECKED_DISCRIMINATOR, TRANSFER_CHECKED_WITH_FEE_DISCRIMINATOR, TRANSFER_CHECKED_WITH_FEE_TRANSFER_FEE_DISCRIMINATOR, TRANSFER_DISCRIMINATOR, Token2022Account, Token2022Instruction, UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR, UPDATE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR, UPDATE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR, UPDATE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR, UPDATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR, UPDATE_GROUP_MEMBER_POINTER_DISCRIMINATOR, UPDATE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR, UPDATE_GROUP_POINTER_DISCRIMINATOR, UPDATE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR, UPDATE_METADATA_POINTER_DISCRIMINATOR, UPDATE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR, UPDATE_MULTIPLIER_SCALED_UI_MINT_DISCRIMINATOR, UPDATE_MULTIPLIER_SCALED_UI_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR, UPDATE_RATE_INTEREST_BEARING_MINT_DISCRIMINATOR, UPDATE_RATE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR, UPDATE_TOKEN_GROUP_MAX_SIZE_DISCRIMINATOR, UPDATE_TOKEN_GROUP_UPDATE_AUTHORITY_DISCRIMINATOR, UPDATE_TOKEN_METADATA_FIELD_DISCRIMINATOR, UPDATE_TOKEN_METADATA_UPDATE_AUTHORITY_DISCRIMINATOR, UPDATE_TRANSFER_HOOK_DISCRIMINATOR, UPDATE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR, WITHDRAW_EXCESS_LAMPORTS_DISCRIMINATOR, WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_DISCRIMINATOR, WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR, WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR, WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_TRANSFER_FEE_DISCRIMINATOR, WITHDRAW_WITHHELD_TOKENS_FROM_MINT_DISCRIMINATOR, WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR, WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR, WITHDRAW_WITHHELD_TOKENS_FROM_MINT_TRANSFER_FEE_DISCRIMINATOR, amountToUiAmountForInterestBearingMintWithoutSimulation, amountToUiAmountForMintWithoutSimulation, amountToUiAmountForScaledUiAmountMintWithoutSimulation, decodeMint, decodeMultisig, decodeToken, extension, fetchAllMaybeMint, fetchAllMaybeMultisig, fetchAllMaybeToken, fetchAllMint, fetchAllMultisig, fetchAllToken, fetchMaybeMint, fetchMaybeMultisig, fetchMaybeToken, fetchMint, fetchMultisig, fetchToken, findAssociatedTokenPda, getAccountStateCodec, getAccountStateDecoder, getAccountStateEncoder, getAmountToUiAmountDiscriminatorBytes, getAmountToUiAmountInstruction, getAmountToUiAmountInstructionDataCodec, getAmountToUiAmountInstructionDataDecoder, getAmountToUiAmountInstructionDataEncoder, getApplyConfidentialPendingBalanceConfidentialTransferDiscriminatorBytes, getApplyConfidentialPendingBalanceDiscriminatorBytes, getApplyConfidentialPendingBalanceInstruction, getApplyConfidentialPendingBalanceInstructionDataCodec, getApplyConfidentialPendingBalanceInstructionDataDecoder, getApplyConfidentialPendingBalanceInstructionDataEncoder, getApproveCheckedDiscriminatorBytes, getApproveCheckedInstruction, getApproveCheckedInstructionDataCodec, getApproveCheckedInstructionDataDecoder, getApproveCheckedInstructionDataEncoder, getApproveConfidentialTransferAccountConfidentialTransferDiscriminatorBytes, getApproveConfidentialTransferAccountDiscriminatorBytes, getApproveConfidentialTransferAccountInstruction, getApproveConfidentialTransferAccountInstructionDataCodec, getApproveConfidentialTransferAccountInstructionDataDecoder, getApproveConfidentialTransferAccountInstructionDataEncoder, getApproveDiscriminatorBytes, getApproveInstruction, getApproveInstructionDataCodec, getApproveInstructionDataDecoder, getApproveInstructionDataEncoder, getAssociatedTokenErrorMessage, getAuthorityTypeCodec, getAuthorityTypeDecoder, getAuthorityTypeEncoder, getBurnCheckedDiscriminatorBytes, getBurnCheckedInstruction, getBurnCheckedInstructionDataCodec, getBurnCheckedInstructionDataDecoder, getBurnCheckedInstructionDataEncoder, getBurnDiscriminatorBytes, getBurnInstruction, getBurnInstructionDataCodec, getBurnInstructionDataDecoder, getBurnInstructionDataEncoder, getCloseAccountDiscriminatorBytes, getCloseAccountInstruction, getCloseAccountInstructionDataCodec, getCloseAccountInstructionDataDecoder, getCloseAccountInstructionDataEncoder, getConfidentialDepositConfidentialTransferDiscriminatorBytes, getConfidentialDepositDiscriminatorBytes, getConfidentialDepositInstruction, getConfidentialDepositInstructionDataCodec, getConfidentialDepositInstructionDataDecoder, getConfidentialDepositInstructionDataEncoder, getConfidentialTransferConfidentialTransferDiscriminatorBytes, getConfidentialTransferDiscriminatorBytes, getConfidentialTransferInstruction, getConfidentialTransferInstructionDataCodec, getConfidentialTransferInstructionDataDecoder, getConfidentialTransferInstructionDataEncoder, getConfidentialTransferWithFeeConfidentialTransferDiscriminatorBytes, getConfidentialTransferWithFeeDiscriminatorBytes, getConfidentialTransferWithFeeInstruction, getConfidentialTransferWithFeeInstructionDataCodec, getConfidentialTransferWithFeeInstructionDataDecoder, getConfidentialTransferWithFeeInstructionDataEncoder, getConfidentialWithdrawConfidentialTransferDiscriminatorBytes, getConfidentialWithdrawDiscriminatorBytes, getConfidentialWithdrawInstruction, getConfidentialWithdrawInstructionDataCodec, getConfidentialWithdrawInstructionDataDecoder, getConfidentialWithdrawInstructionDataEncoder, getConfigureConfidentialTransferAccountConfidentialTransferDiscriminatorBytes, getConfigureConfidentialTransferAccountDiscriminatorBytes, getConfigureConfidentialTransferAccountInstruction, getConfigureConfidentialTransferAccountInstructionDataCodec, getConfigureConfidentialTransferAccountInstructionDataDecoder, getConfigureConfidentialTransferAccountInstructionDataEncoder, getCreateAssociatedTokenDiscriminatorBytes, getCreateAssociatedTokenIdempotentDiscriminatorBytes, getCreateAssociatedTokenIdempotentInstruction, getCreateAssociatedTokenIdempotentInstructionAsync, getCreateAssociatedTokenIdempotentInstructionDataCodec, getCreateAssociatedTokenIdempotentInstructionDataDecoder, getCreateAssociatedTokenIdempotentInstructionDataEncoder, getCreateAssociatedTokenInstruction, getCreateAssociatedTokenInstructionAsync, getCreateAssociatedTokenInstructionDataCodec, getCreateAssociatedTokenInstructionDataDecoder, getCreateAssociatedTokenInstructionDataEncoder, getCreateNativeMintDiscriminatorBytes, getCreateNativeMintInstruction, getCreateNativeMintInstructionDataCodec, getCreateNativeMintInstructionDataDecoder, getCreateNativeMintInstructionDataEncoder, getDecryptableBalanceCodec, getDecryptableBalanceDecoder, getDecryptableBalanceEncoder, getDisableConfidentialCreditsConfidentialTransferDiscriminatorBytes, getDisableConfidentialCreditsDiscriminatorBytes, getDisableConfidentialCreditsInstruction, getDisableConfidentialCreditsInstructionDataCodec, getDisableConfidentialCreditsInstructionDataDecoder, getDisableConfidentialCreditsInstructionDataEncoder, getDisableCpiGuardCpiGuardDiscriminatorBytes, getDisableCpiGuardDiscriminatorBytes, getDisableCpiGuardInstruction, getDisableCpiGuardInstructionDataCodec, getDisableCpiGuardInstructionDataDecoder, getDisableCpiGuardInstructionDataEncoder, getDisableHarvestToMintConfidentialTransferFeeDiscriminatorBytes, getDisableHarvestToMintDiscriminatorBytes, getDisableHarvestToMintInstruction, getDisableHarvestToMintInstructionDataCodec, getDisableHarvestToMintInstructionDataDecoder, getDisableHarvestToMintInstructionDataEncoder, getDisableMemoTransfersDiscriminatorBytes, getDisableMemoTransfersInstruction, getDisableMemoTransfersInstructionDataCodec, getDisableMemoTransfersInstructionDataDecoder, getDisableMemoTransfersInstructionDataEncoder, getDisableMemoTransfersMemoTransfersDiscriminatorBytes, getDisableNonConfidentialCreditsConfidentialTransferDiscriminatorBytes, getDisableNonConfidentialCreditsDiscriminatorBytes, getDisableNonConfidentialCreditsInstruction, getDisableNonConfidentialCreditsInstructionDataCodec, getDisableNonConfidentialCreditsInstructionDataDecoder, getDisableNonConfidentialCreditsInstructionDataEncoder, getEmitTokenMetadataDiscriminatorBytes, getEmitTokenMetadataInstruction, getEmitTokenMetadataInstructionDataCodec, getEmitTokenMetadataInstructionDataDecoder, getEmitTokenMetadataInstructionDataEncoder, getEmptyConfidentialTransferAccountConfidentialTransferDiscriminatorBytes, getEmptyConfidentialTransferAccountDiscriminatorBytes, getEmptyConfidentialTransferAccountInstruction, getEmptyConfidentialTransferAccountInstructionDataCodec, getEmptyConfidentialTransferAccountInstructionDataDecoder, getEmptyConfidentialTransferAccountInstructionDataEncoder, getEnableConfidentialCreditsConfidentialTransferDiscriminatorBytes, getEnableConfidentialCreditsDiscriminatorBytes, getEnableConfidentialCreditsInstruction, getEnableConfidentialCreditsInstructionDataCodec, getEnableConfidentialCreditsInstructionDataDecoder, getEnableConfidentialCreditsInstructionDataEncoder, getEnableCpiGuardCpiGuardDiscriminatorBytes, getEnableCpiGuardDiscriminatorBytes, getEnableCpiGuardInstruction, getEnableCpiGuardInstructionDataCodec, getEnableCpiGuardInstructionDataDecoder, getEnableCpiGuardInstructionDataEncoder, getEnableHarvestToMintConfidentialTransferFeeDiscriminatorBytes, getEnableHarvestToMintDiscriminatorBytes, getEnableHarvestToMintInstruction, getEnableHarvestToMintInstructionDataCodec, getEnableHarvestToMintInstructionDataDecoder, getEnableHarvestToMintInstructionDataEncoder, getEnableMemoTransfersDiscriminatorBytes, getEnableMemoTransfersInstruction, getEnableMemoTransfersInstructionDataCodec, getEnableMemoTransfersInstructionDataDecoder, getEnableMemoTransfersInstructionDataEncoder, getEnableMemoTransfersMemoTransfersDiscriminatorBytes, getEnableNonConfidentialCreditsConfidentialTransferDiscriminatorBytes, getEnableNonConfidentialCreditsDiscriminatorBytes, getEnableNonConfidentialCreditsInstruction, getEnableNonConfidentialCreditsInstructionDataCodec, getEnableNonConfidentialCreditsInstructionDataDecoder, getEnableNonConfidentialCreditsInstructionDataEncoder, getEncryptedBalanceCodec, getEncryptedBalanceDecoder, getEncryptedBalanceEncoder, getExtensionCodec, getExtensionDecoder, getExtensionEncoder, getExtensionTypeCodec, getExtensionTypeDecoder, getExtensionTypeEncoder, getFreezeAccountDiscriminatorBytes, getFreezeAccountInstruction, getFreezeAccountInstructionDataCodec, getFreezeAccountInstructionDataDecoder, getFreezeAccountInstructionDataEncoder, getGetAccountDataSizeDiscriminatorBytes, getGetAccountDataSizeInstruction, getGetAccountDataSizeInstructionDataCodec, getGetAccountDataSizeInstructionDataDecoder, getGetAccountDataSizeInstructionDataEncoder, getHarvestWithheldTokensToMintDiscriminatorBytes, getHarvestWithheldTokensToMintForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes, getHarvestWithheldTokensToMintForConfidentialTransferFeeDiscriminatorBytes, getHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction, getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataCodec, getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataDecoder, getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataEncoder, getHarvestWithheldTokensToMintInstruction, getHarvestWithheldTokensToMintInstructionDataCodec, getHarvestWithheldTokensToMintInstructionDataDecoder, getHarvestWithheldTokensToMintInstructionDataEncoder, getHarvestWithheldTokensToMintTransferFeeDiscriminatorBytes, getInitializeAccount2DiscriminatorBytes, getInitializeAccount2Instruction, getInitializeAccount2InstructionDataCodec, getInitializeAccount2InstructionDataDecoder, getInitializeAccount2InstructionDataEncoder, getInitializeAccount3DiscriminatorBytes, getInitializeAccount3Instruction, getInitializeAccount3InstructionDataCodec, getInitializeAccount3InstructionDataDecoder, getInitializeAccount3InstructionDataEncoder, getInitializeAccountDiscriminatorBytes, getInitializeAccountInstruction, getInitializeAccountInstructionDataCodec, getInitializeAccountInstructionDataDecoder, getInitializeAccountInstructionDataEncoder, getInitializeConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes, getInitializeConfidentialTransferFeeDiscriminatorBytes, getInitializeConfidentialTransferFeeInstruction, getInitializeConfidentialTransferFeeInstructionDataCodec, getInitializeConfidentialTransferFeeInstructionDataDecoder, getInitializeConfidentialTransferFeeInstructionDataEncoder, getInitializeConfidentialTransferMintConfidentialTransferDiscriminatorBytes, getInitializeConfidentialTransferMintDiscriminatorBytes, getInitializeConfidentialTransferMintInstruction, getInitializeConfidentialTransferMintInstructionDataCodec, getInitializeConfidentialTransferMintInstructionDataDecoder, getInitializeConfidentialTransferMintInstructionDataEncoder, getInitializeDefaultAccountStateDefaultAccountStateDiscriminatorBytes, getInitializeDefaultAccountStateDiscriminatorBytes, getInitializeDefaultAccountStateInstruction, getInitializeDefaultAccountStateInstructionDataCodec, getInitializeDefaultAccountStateInstructionDataDecoder, getInitializeDefaultAccountStateInstructionDataEncoder, getInitializeGroupMemberPointerDiscriminatorBytes, getInitializeGroupMemberPointerGroupMemberPointerDiscriminatorBytes, getInitializeGroupMemberPointerInstruction, getInitializeGroupMemberPointerInstructionDataCodec, getInitializeGroupMemberPointerInstructionDataDecoder, getInitializeGroupMemberPointerInstructionDataEncoder, getInitializeGroupPointerDiscriminatorBytes, getInitializeGroupPointerGroupPointerDiscriminatorBytes, getInitializeGroupPointerInstruction, getInitializeGroupPointerInstructionDataCodec, getInitializeGroupPointerInstructionDataDecoder, getInitializeGroupPointerInstructionDataEncoder, getInitializeImmutableOwnerDiscriminatorBytes, getInitializeImmutableOwnerInstruction, getInitializeImmutableOwnerInstructionDataCodec, getInitializeImmutableOwnerInstructionDataDecoder, getInitializeImmutableOwnerInstructionDataEncoder, getInitializeInterestBearingMintDiscriminatorBytes, getInitializeInterestBearingMintInstruction, getInitializeInterestBearingMintInstructionDataCodec, getInitializeInterestBearingMintInstructionDataDecoder, getInitializeInterestBearingMintInstructionDataEncoder, getInitializeInterestBearingMintInterestBearingMintDiscriminatorBytes, getInitializeMetadataPointerDiscriminatorBytes, getInitializeMetadataPointerInstruction, getInitializeMetadataPointerInstructionDataCodec, getInitializeMetadataPointerInstructionDataDecoder, getInitializeMetadataPointerInstructionDataEncoder, getInitializeMetadataPointerMetadataPointerDiscriminatorBytes, getInitializeMint2DiscriminatorBytes, getInitializeMint2Instruction, getInitializeMint2InstructionDataCodec, getInitializeMint2InstructionDataDecoder, getInitializeMint2InstructionDataEncoder, getInitializeMintCloseAuthorityDiscriminatorBytes, getInitializeMintCloseAuthorityInstruction, getInitializeMintCloseAuthorityInstructionDataCodec, getInitializeMintCloseAuthorityInstructionDataDecoder, getInitializeMintCloseAuthorityInstructionDataEncoder, getInitializeMintDiscriminatorBytes, getInitializeMintInstruction, getInitializeMintInstructionDataCodec, getInitializeMintInstructionDataDecoder, getInitializeMintInstructionDataEncoder, getInitializeMultisig2DiscriminatorBytes, getInitializeMultisig2Instruction, getInitializeMultisig2InstructionDataCodec, getInitializeMultisig2InstructionDataDecoder, getInitializeMultisig2InstructionDataEncoder, getInitializeMultisigDiscriminatorBytes, getInitializeMultisigInstruction, getInitializeMultisigInstructionDataCodec, getInitializeMultisigInstructionDataDecoder, getInitializeMultisigInstructionDataEncoder, getInitializeNonTransferableMintDiscriminatorBytes, getInitializeNonTransferableMintInstruction, getInitializeNonTransferableMintInstructionDataCodec, getInitializeNonTransferableMintInstructionDataDecoder, getInitializeNonTransferableMintInstructionDataEncoder, getInitializePausableConfigDiscriminatorBytes, getInitializePausableConfigInstruction, getInitializePausableConfigInstructionDataCodec, getInitializePausableConfigInstructionDataDecoder, getInitializePausableConfigInstructionDataEncoder, getInitializePausableConfigPausableDiscriminatorBytes, getInitializePermanentDelegateDiscriminatorBytes, getInitializePermanentDelegateInstruction, getInitializePermanentDelegateInstructionDataCodec, getInitializePermanentDelegateInstructionDataDecoder, getInitializePermanentDelegateInstructionDataEncoder, getInitializeScaledUiAmountMintDiscriminatorBytes, getInitializeScaledUiAmountMintInstruction, getInitializeScaledUiAmountMintInstructionDataCodec, getInitializeScaledUiAmountMintInstructionDataDecoder, getInitializeScaledUiAmountMintInstructionDataEncoder, getInitializeScaledUiAmountMintScaledUiAmountMintDiscriminatorBytes, getInitializeTokenGroupDiscriminatorBytes, getInitializeTokenGroupInstruction, getInitializeTokenGroupInstructionDataCodec, getInitializeTokenGroupInstructionDataDecoder, getInitializeTokenGroupInstructionDataEncoder, getInitializeTokenGroupMemberDiscriminatorBytes, getInitializeTokenGroupMemberInstruction, getInitializeTokenGroupMemberInstructionDataCodec, getInitializeTokenGroupMemberInstructionDataDecoder, getInitializeTokenGroupMemberInstructionDataEncoder, getInitializeTokenMetadataDiscriminatorBytes, getInitializeTokenMetadataInstruction, getInitializeTokenMetadataInstructionDataCodec, getInitializeTokenMetadataInstructionDataDecoder, getInitializeTokenMetadataInstructionDataEncoder, getInitializeTransferFeeConfigDiscriminatorBytes, getInitializeTransferFeeConfigInstruction, getInitializeTransferFeeConfigInstructionDataCodec, getInitializeTransferFeeConfigInstructionDataDecoder, getInitializeTransferFeeConfigInstructionDataEncoder, getInitializeTransferFeeConfigTransferFeeDiscriminatorBytes, getInitializeTransferHookDiscriminatorBytes, getInitializeTransferHookInstruction, getInitializeTransferHookInstructionDataCodec, getInitializeTransferHookInstructionDataDecoder, getInitializeTransferHookInstructionDataEncoder, getInitializeTransferHookTransferHookDiscriminatorBytes, getMintCodec, getMintDecoder, getMintEncoder, getMintSize, getMintToCheckedDiscriminatorBytes, getMintToCheckedInstruction, getMintToCheckedInstructionDataCodec, getMintToCheckedInstructionDataDecoder, getMintToCheckedInstructionDataEncoder, getMintToDiscriminatorBytes, getMintToInstruction, getMintToInstructionDataCodec, getMintToInstructionDataDecoder, getMintToInstructionDataEncoder, getMultisigCodec, getMultisigDecoder, getMultisigEncoder, getMultisigSize, getPauseDiscriminatorBytes, getPauseInstruction, getPauseInstructionDataCodec, getPauseInstructionDataDecoder, getPauseInstructionDataEncoder, getPausePausableDiscriminatorBytes, getPostInitializeInstructionsForMintExtensions, getPostInitializeInstructionsForTokenExtensions, getPreInitializeInstructionsForMintExtensions, getReallocateDiscriminatorBytes, getReallocateInstruction, getReallocateInstructionDataCodec, getReallocateInstructionDataDecoder, getReallocateInstructionDataEncoder, getRecoverNestedAssociatedTokenDiscriminatorBytes, getRecoverNestedAssociatedTokenInstruction, getRecoverNestedAssociatedTokenInstructionAsync, getRecoverNestedAssociatedTokenInstructionDataCodec, getRecoverNestedAssociatedTokenInstructionDataDecoder, getRecoverNestedAssociatedTokenInstructionDataEncoder, getRemoveTokenMetadataKeyDiscriminatorBytes, getRemoveTokenMetadataKeyInstruction, getRemoveTokenMetadataKeyInstructionDataCodec, getRemoveTokenMetadataKeyInstructionDataDecoder, getRemoveTokenMetadataKeyInstructionDataEncoder, getResumeDiscriminatorBytes, getResumeInstruction, getResumeInstructionDataCodec, getResumeInstructionDataDecoder, getResumeInstructionDataEncoder, getResumePausableDiscriminatorBytes, getRevokeDiscriminatorBytes, getRevokeInstruction, getRevokeInstructionDataCodec, getRevokeInstructionDataDecoder, getRevokeInstructionDataEncoder, getSetAuthorityDiscriminatorBytes, getSetAuthorityInstruction, getSetAuthorityInstructionDataCodec, getSetAuthorityInstructionDataDecoder, getSetAuthorityInstructionDataEncoder, getSetTransferFeeDiscriminatorBytes, getSetTransferFeeInstruction, getSetTransferFeeInstructionDataCodec, getSetTransferFeeInstructionDataDecoder, getSetTransferFeeInstructionDataEncoder, getSetTransferFeeTransferFeeDiscriminatorBytes, getSyncNativeDiscriminatorBytes, getSyncNativeInstruction, getSyncNativeInstructionDataCodec, getSyncNativeInstructionDataDecoder, getSyncNativeInstructionDataEncoder, getThawAccountDiscriminatorBytes, getThawAccountInstruction, getThawAccountInstructionDataCodec, getThawAccountInstructionDataDecoder, getThawAccountInstructionDataEncoder, getToken2022ErrorMessage, getTokenCodec, getTokenDecoder, getTokenEncoder, getTokenMetadataFieldCodec, getTokenMetadataFieldDecoder, getTokenMetadataFieldEncoder, getTokenSize, getTransferCheckedDiscriminatorBytes, getTransferCheckedInstruction, getTransferCheckedInstructionDataCodec, getTransferCheckedInstructionDataDecoder, getTransferCheckedInstructionDataEncoder, getTransferCheckedWithFeeDiscriminatorBytes, getTransferCheckedWithFeeInstruction, getTransferCheckedWithFeeInstructionDataCodec, getTransferCheckedWithFeeInstructionDataDecoder, getTransferCheckedWithFeeInstructionDataEncoder, getTransferCheckedWithFeeTransferFeeDiscriminatorBytes, getTransferDiscriminatorBytes, getTransferFeeCodec, getTransferFeeDecoder, getTransferFeeEncoder, getTransferInstruction, getTransferInstructionDataCodec, getTransferInstructionDataDecoder, getTransferInstructionDataEncoder, getUiAmountToAmountDiscriminatorBytes, getUiAmountToAmountInstruction, getUiAmountToAmountInstructionDataCodec, getUiAmountToAmountInstructionDataDecoder, getUiAmountToAmountInstructionDataEncoder, getUpdateConfidentialTransferMintConfidentialTransferDiscriminatorBytes, getUpdateConfidentialTransferMintDiscriminatorBytes, getUpdateConfidentialTransferMintInstruction, getUpdateConfidentialTransferMintInstructionDataCodec, getUpdateConfidentialTransferMintInstructionDataDecoder, getUpdateConfidentialTransferMintInstructionDataEncoder, getUpdateDefaultAccountStateDefaultAccountStateDiscriminatorBytes, getUpdateDefaultAccountStateDiscriminatorBytes, getUpdateDefaultAccountStateInstruction, getUpdateDefaultAccountStateInstructionDataCodec, getUpdateDefaultAccountStateInstructionDataDecoder, getUpdateDefaultAccountStateInstructionDataEncoder, getUpdateGroupMemberPointerDiscriminatorBytes, getUpdateGroupMemberPointerGroupMemberPointerDiscriminatorBytes, getUpdateGroupMemberPointerInstruction, getUpdateGroupMemberPointerInstructionDataCodec, getUpdateGroupMemberPointerInstructionDataDecoder, getUpdateGroupMemberPointerInstructionDataEncoder, getUpdateGroupPointerDiscriminatorBytes, getUpdateGroupPointerGroupPointerDiscriminatorBytes, getUpdateGroupPointerInstruction, getUpdateGroupPointerInstructionDataCodec, getUpdateGroupPointerInstructionDataDecoder, getUpdateGroupPointerInstructionDataEncoder, getUpdateMetadataPointerDiscriminatorBytes, getUpdateMetadataPointerInstruction, getUpdateMetadataPointerInstructionDataCodec, getUpdateMetadataPointerInstructionDataDecoder, getUpdateMetadataPointerInstructionDataEncoder, getUpdateMetadataPointerMetadataPointerDiscriminatorBytes, getUpdateMultiplierScaledUiMintDiscriminatorBytes, getUpdateMultiplierScaledUiMintInstruction, getUpdateMultiplierScaledUiMintInstructionDataCodec, getUpdateMultiplierScaledUiMintInstructionDataDecoder, getUpdateMultiplierScaledUiMintInstructionDataEncoder, getUpdateMultiplierScaledUiMintScaledUiAmountMintDiscriminatorBytes, getUpdateRateInterestBearingMintDiscriminatorBytes, getUpdateRateInterestBearingMintInstruction, getUpdateRateInterestBearingMintInstructionDataCodec, getUpdateRateInterestBearingMintInstructionDataDecoder, getUpdateRateInterestBearingMintInstructionDataEncoder, getUpdateRateInterestBearingMintInterestBearingMintDiscriminatorBytes, getUpdateTokenGroupMaxSizeDiscriminatorBytes, getUpdateTokenGroupMaxSizeInstruction, getUpdateTokenGroupMaxSizeInstructionDataCodec, getUpdateTokenGroupMaxSizeInstructionDataDecoder, getUpdateTokenGroupMaxSizeInstructionDataEncoder, getUpdateTokenGroupUpdateAuthorityDiscriminatorBytes, getUpdateTokenGroupUpdateAuthorityInstruction, getUpdateTokenGroupUpdateAuthorityInstructionDataCodec, getUpdateTokenGroupUpdateAuthorityInstructionDataDecoder, getUpdateTokenGroupUpdateAuthorityInstructionDataEncoder, getUpdateTokenMetadataFieldDiscriminatorBytes, getUpdateTokenMetadataFieldInstruction, getUpdateTokenMetadataFieldInstructionDataCodec, getUpdateTokenMetadataFieldInstructionDataDecoder, getUpdateTokenMetadataFieldInstructionDataEncoder, getUpdateTokenMetadataUpdateAuthorityDiscriminatorBytes, getUpdateTokenMetadataUpdateAuthorityInstruction, getUpdateTokenMetadataUpdateAuthorityInstructionDataCodec, getUpdateTokenMetadataUpdateAuthorityInstructionDataDecoder, getUpdateTokenMetadataUpdateAuthorityInstructionDataEncoder, getUpdateTransferHookDiscriminatorBytes, getUpdateTransferHookInstruction, getUpdateTransferHookInstructionDataCodec, getUpdateTransferHookInstructionDataDecoder, getUpdateTransferHookInstructionDataEncoder, getUpdateTransferHookTransferHookDiscriminatorBytes, getWithdrawExcessLamportsDiscriminatorBytes, getWithdrawExcessLamportsInstruction, getWithdrawExcessLamportsInstructionDataCodec, getWithdrawExcessLamportsInstructionDataDecoder, getWithdrawExcessLamportsInstructionDataEncoder, getWithdrawWithheldTokensFromAccountsDiscriminatorBytes, getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes, getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeDiscriminatorBytes, getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction, getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataCodec, getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataDecoder, getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataEncoder, getWithdrawWithheldTokensFromAccountsInstruction, getWithdrawWithheldTokensFromAccountsInstructionDataCodec, getWithdrawWithheldTokensFromAccountsInstructionDataDecoder, getWithdrawWithheldTokensFromAccountsInstructionDataEncoder, getWithdrawWithheldTokensFromAccountsTransferFeeDiscriminatorBytes, getWithdrawWithheldTokensFromMintDiscriminatorBytes, getWithdrawWithheldTokensFromMintForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes, getWithdrawWithheldTokensFromMintForConfidentialTransferFeeDiscriminatorBytes, getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction, getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataCodec, getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataDecoder, getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataEncoder, getWithdrawWithheldTokensFromMintInstruction, getWithdrawWithheldTokensFromMintInstructionDataCodec, getWithdrawWithheldTokensFromMintInstructionDataDecoder, getWithdrawWithheldTokensFromMintInstructionDataEncoder, getWithdrawWithheldTokensFromMintTransferFeeDiscriminatorBytes, identifyAssociatedTokenInstruction, identifyToken2022Account, identifyToken2022Instruction, isAssociatedTokenError, isExtension, isToken2022Error, isTokenMetadataField, parseAmountToUiAmountInstruction, parseApplyConfidentialPendingBalanceInstruction, parseApproveCheckedInstruction, parseApproveConfidentialTransferAccountInstruction, parseApproveInstruction, parseBurnCheckedInstruction, parseBurnInstruction, parseCloseAccountInstruction, parseConfidentialDepositInstruction, parseConfidentialTransferInstruction, parseConfidentialTransferWithFeeInstruction, parseConfidentialWithdrawInstruction, parseConfigureConfidentialTransferAccountInstruction, parseCreateAssociatedTokenIdempotentInstruction, parseCreateAssociatedTokenInstruction, parseCreateNativeMintInstruction, parseDisableConfidentialCreditsInstruction, parseDisableCpiGuardInstruction, parseDisableHarvestToMintInstruction, parseDisableMemoTransfersInstruction, parseDisableNonConfidentialCreditsInstruction, parseEmitTokenMetadataInstruction, parseEmptyConfidentialTransferAccountInstruction, parseEnableConfidentialCreditsInstruction, parseEnableCpiGuardInstruction, parseEnableHarvestToMintInstruction, parseEnableMemoTransfersInstruction, parseEnableNonConfidentialCreditsInstruction, parseFreezeAccountInstruction, parseGetAccountDataSizeInstruction, parseHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction, parseHarvestWithheldTokensToMintInstruction, parseInitializeAccount2Instruction, parseInitializeAccount3Instruction, parseInitializeAccountInstruction, parseInitializeConfidentialTransferFeeInstruction, parseInitializeConfidentialTransferMintInstruction, parseInitializeDefaultAccountStateInstruction, parseInitializeGroupMemberPointerInstruction, parseInitializeGroupPointerInstruction, parseInitializeImmutableOwnerInstruction, parseInitializeInterestBearingMintInstruction, parseInitializeMetadataPointerInstruction, parseInitializeMint2Instruction, parseInitializeMintCloseAuthorityInstruction, parseInitializeMintInstruction, parseInitializeMultisig2Instruction, parseInitializeMultisigInstruction, parseInitializeNonTransferableMintInstruction, parseInitializePausableConfigInstruction, parseInitializePermanentDelegateInstruction, parseInitializeScaledUiAmountMintInstruction, parseInitializeTokenGroupInstruction, parseInitializeTokenGroupMemberInstruction, parseInitializeTokenMetadataInstruction, parseInitializeTransferFeeConfigInstruction, parseInitializeTransferHookInstruction, parseMintToCheckedInstruction, parseMintToInstruction, parsePauseInstruction, parseReallocateInstruction, parseRecoverNestedAssociatedTokenInstruction, parseRemoveTokenMetadataKeyInstruction, parseResumeInstruction, parseRevokeInstruction, parseSetAuthorityInstruction, parseSetTransferFeeInstruction, parseSyncNativeInstruction, parseThawAccountInstruction, parseTransferCheckedInstruction, parseTransferCheckedWithFeeInstruction, parseTransferInstruction, parseUiAmountToAmountInstruction, parseUpdateConfidentialTransferMintInstruction, parseUpdateDefaultAccountStateInstruction, parseUpdateGroupMemberPointerInstruction, parseUpdateGroupPointerInstruction, parseUpdateMetadataPointerInstruction, parseUpdateMultiplierScaledUiMintInstruction, parseUpdateRateInterestBearingMintInstruction, parseUpdateTokenGroupMaxSizeInstruction, parseUpdateTokenGroupUpdateAuthorityInstruction, parseUpdateTokenMetadataFieldInstruction, parseUpdateTokenMetadataUpdateAuthorityInstruction, parseUpdateTransferHookInstruction, parseWithdrawExcessLamportsInstruction, parseWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction, parseWithdrawWithheldTokensFromAccountsInstruction, parseWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction, parseWithdrawWithheldTokensFromMintInstruction, tokenMetadataField, uiAmountToAmountForInterestBearingMintWithoutSimulation, uiAmountToAmountForMintWithoutSimulation, uiAmountToAmountForScaledUiAmountMintWithoutSimulation };\n//# sourceMappingURL=index.mjs.map\n//# sourceMappingURL=index.mjs.map","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n} from '@solana/kit';\n\nexport enum AccountState {\n  Uninitialized,\n  Initialized,\n  Frozen,\n}\n\nexport type AccountStateArgs = AccountState;\n\nexport function getAccountStateEncoder(): FixedSizeEncoder<AccountStateArgs> {\n  return getEnumEncoder(AccountState);\n}\n\nexport function getAccountStateDecoder(): FixedSizeDecoder<AccountState> {\n  return getEnumDecoder(AccountState);\n}\n\nexport function getAccountStateCodec(): FixedSizeCodec<\n  AccountStateArgs,\n  AccountState\n> {\n  return combineCodec(getAccountStateEncoder(), getAccountStateDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n} from '@solana/kit';\n\nexport enum AuthorityType {\n  MintTokens,\n  FreezeAccount,\n  AccountOwner,\n  CloseAccount,\n  TransferFeeConfig,\n  WithheldWithdraw,\n  CloseMint,\n  InterestRate,\n  PermanentDelegate,\n  ConfidentialTransferMint,\n  TransferHookProgramId,\n  ConfidentialTransferFeeConfig,\n  MetadataPointer,\n  GroupPointer,\n  GroupMemberPointer,\n  ScaledUiAmount,\n  Pause,\n}\n\nexport type AuthorityTypeArgs = AuthorityType;\n\nexport function getAuthorityTypeEncoder(): FixedSizeEncoder<AuthorityTypeArgs> {\n  return getEnumEncoder(AuthorityType);\n}\n\nexport function getAuthorityTypeDecoder(): FixedSizeDecoder<AuthorityType> {\n  return getEnumDecoder(AuthorityType);\n}\n\nexport function getAuthorityTypeCodec(): FixedSizeCodec<\n  AuthorityTypeArgs,\n  AuthorityType\n> {\n  return combineCodec(getAuthorityTypeEncoder(), getAuthorityTypeDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\n\n/** Authenticated encryption containing an account balance. */\nexport type DecryptableBalance = ReadonlyUint8Array;\n\nexport type DecryptableBalanceArgs = DecryptableBalance;\n\nexport function getDecryptableBalanceEncoder(): FixedSizeEncoder<DecryptableBalanceArgs> {\n  return fixEncoderSize(getBytesEncoder(), 36);\n}\n\nexport function getDecryptableBalanceDecoder(): FixedSizeDecoder<DecryptableBalance> {\n  return fixDecoderSize(getBytesDecoder(), 36);\n}\n\nexport function getDecryptableBalanceCodec(): FixedSizeCodec<\n  DecryptableBalanceArgs,\n  DecryptableBalance\n> {\n  return combineCodec(\n    getDecryptableBalanceEncoder(),\n    getDecryptableBalanceDecoder()\n  );\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  fixDecoderSize,\n  fixEncoderSize,\n  getBytesDecoder,\n  getBytesEncoder,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\n\n/** ElGamal ciphertext containing an account balance. */\nexport type EncryptedBalance = ReadonlyUint8Array;\n\nexport type EncryptedBalanceArgs = EncryptedBalance;\n\nexport function getEncryptedBalanceEncoder(): FixedSizeEncoder<EncryptedBalanceArgs> {\n  return fixEncoderSize(getBytesEncoder(), 64);\n}\n\nexport function getEncryptedBalanceDecoder(): FixedSizeDecoder<EncryptedBalance> {\n  return fixDecoderSize(getBytesDecoder(), 64);\n}\n\nexport function getEncryptedBalanceCodec(): FixedSizeCodec<\n  EncryptedBalanceArgs,\n  EncryptedBalance\n> {\n  return combineCodec(\n    getEncryptedBalanceEncoder(),\n    getEncryptedBalanceDecoder()\n  );\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getDiscriminatedUnionDecoder,\n  getDiscriminatedUnionEncoder,\n  getF64Decoder,\n  getF64Encoder,\n  getI16Decoder,\n  getI16Encoder,\n  getMapDecoder,\n  getMapEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getUnitDecoder,\n  getUnitEncoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type GetDiscriminatedUnionVariant,\n  type GetDiscriminatedUnionVariantContent,\n  type Option,\n  type OptionOrNullable,\n} from '@solana/kit';\nimport {\n  getAccountStateDecoder,\n  getAccountStateEncoder,\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  getEncryptedBalanceDecoder,\n  getEncryptedBalanceEncoder,\n  getTransferFeeDecoder,\n  getTransferFeeEncoder,\n  type AccountState,\n  type AccountStateArgs,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n  type EncryptedBalance,\n  type EncryptedBalanceArgs,\n  type TransferFee,\n  type TransferFeeArgs,\n} from '.';\n\nexport type Extension =\n  | { __kind: 'Uninitialized' }\n  | {\n      __kind: 'TransferFeeConfig';\n      /** Optional authority to set the fee. */\n      transferFeeConfigAuthority: Address;\n      /** Withdraw from mint instructions must be signed by this key. */\n      withdrawWithheldAuthority: Address;\n      /** Withheld transfer fee tokens that have been moved to the mint for withdrawal. */\n      withheldAmount: bigint;\n      /** Older transfer fee, used if the current epoch < newerTransferFee.epoch. */\n      olderTransferFee: TransferFee;\n      /** Newer transfer fee, used if the current epoch >= newerTransferFee.epoch. */\n      newerTransferFee: TransferFee;\n    }\n  | {\n      __kind: 'TransferFeeAmount';\n      /** Withheld transfer fee tokens that can be claimed by the fee authority. */\n      withheldAmount: bigint;\n    }\n  | { __kind: 'MintCloseAuthority'; closeAuthority: Address }\n  | {\n      __kind: 'ConfidentialTransferMint';\n      /**\n       * Authority to modify the `ConfidentialTransferMint` configuration and to\n       * approve new accounts (if `auto_approve_new_accounts` is true).\n       *\n       * The legacy Token Multisig account is not supported as the authority.\n       */\n      authority: Option<Address>;\n      /**\n       * Indicate if newly configured accounts must be approved by the\n       * `authority` before they may be used by the user.\n       *\n       * * If `true`, no approval is required and new accounts may be used immediately.\n       * * If `false`, the authority must approve newly configured accounts (see\n       *   `ConfidentialTransferInstruction::ConfigureAccount`).\n       */\n      autoApproveNewAccounts: boolean;\n      /** Authority to decode any transfer amount in a confidential transfer. */\n      auditorElgamalPubkey: Option<Address>;\n    }\n  | {\n      __kind: 'ConfidentialTransferAccount';\n      /**\n       * `true` if this account has been approved for use. All confidential\n       * transfer operations for the account will fail until approval is granted.\n       */\n      approved: boolean;\n      /** The public key associated with ElGamal encryption. */\n      elgamalPubkey: Address;\n      /** The low 16 bits of the pending balance (encrypted by `elgamal_pubkey`). */\n      pendingBalanceLow: EncryptedBalance;\n      /** The high 32 bits of the pending balance (encrypted by `elgamal_pubkey`). */\n      pendingBalanceHigh: EncryptedBalance;\n      /** The available balance (encrypted by `encrypiton_pubkey`). */\n      availableBalance: EncryptedBalance;\n      /** The decryptable available balance. */\n      decryptableAvailableBalance: DecryptableBalance;\n      /** If `false`, the extended account rejects any incoming confidential transfers. */\n      allowConfidentialCredits: boolean;\n      /** If `false`, the base account rejects any incoming transfers. */\n      allowNonConfidentialCredits: boolean;\n      /** The total number of `Deposit` and `Transfer` instructions that have credited `pending_balance`. */\n      pendingBalanceCreditCounter: bigint;\n      /**\n       * The maximum number of `Deposit` and `Transfer` instructions that can\n       * credit `pending_balance` before the `ApplyPendingBalance`\n       * instruction is executed.\n       */\n      maximumPendingBalanceCreditCounter: bigint;\n      /**\n       * The `expected_pending_balance_credit_counter` value that was included in\n       * the last `ApplyPendingBalance` instruction.\n       */\n      expectedPendingBalanceCreditCounter: bigint;\n      /**\n       * The actual `pending_balance_credit_counter` when the last\n       * `ApplyPendingBalance` instruction was executed.\n       */\n      actualPendingBalanceCreditCounter: bigint;\n    }\n  | { __kind: 'DefaultAccountState'; state: AccountState }\n  | { __kind: 'ImmutableOwner' }\n  | {\n      __kind: 'MemoTransfer';\n      /** Require transfers into this account to be accompanied by a memo. */\n      requireIncomingTransferMemos: boolean;\n    }\n  | { __kind: 'NonTransferable' }\n  | {\n      __kind: 'InterestBearingConfig';\n      rateAuthority: Address;\n      initializationTimestamp: bigint;\n      preUpdateAverageRate: number;\n      lastUpdateTimestamp: bigint;\n      currentRate: number;\n    }\n  | {\n      __kind: 'CpiGuard';\n      /** Lock certain token operations from taking place within CPI for this account. */\n      lockCpi: boolean;\n    }\n  | { __kind: 'PermanentDelegate'; delegate: Address }\n  | { __kind: 'NonTransferableAccount' }\n  | {\n      __kind: 'TransferHook';\n      /** The transfer hook update authority. */\n      authority: Address;\n      /** The transfer hook program account. */\n      programId: Address;\n    }\n  | {\n      __kind: 'TransferHookAccount';\n      /**\n       * Whether or not this account is currently transferring tokens\n       * True during the transfer hook cpi, otherwise false.\n       */\n      transferring: boolean;\n    }\n  | {\n      __kind: 'ConfidentialTransferFee';\n      /** Optional authority to set the withdraw withheld authority ElGamal key. */\n      authority: Option<Address>;\n      /**\n       * Withheld fees from accounts must be encrypted with this ElGamal key.\n       *\n       * Note that whoever holds the ElGamal private key for this ElGamal public\n       * key has the ability to decode any withheld fee amount that are\n       * associated with accounts. When combined with the fee parameters, the\n       * withheld fee amounts can reveal information about transfer amounts.\n       */\n      elgamalPubkey: Address;\n      /** If `false`, the harvest of withheld tokens to mint is rejected. */\n      harvestToMintEnabled: boolean;\n      /**\n       * Withheld confidential transfer fee tokens that have been moved to the\n       * mint for withdrawal.\n       */\n      withheldAmount: EncryptedBalance;\n    }\n  | {\n      __kind: 'ConfidentialTransferFeeAmount';\n      /** Amount withheld during confidential transfers, to be harvest to the mint. */\n      withheldAmount: EncryptedBalance;\n    }\n  | {\n      __kind: 'MetadataPointer';\n      /** Optional authority that can set the metadata address. */\n      authority: Option<Address>;\n      /** Optional Account Address that holds the metadata. */\n      metadataAddress: Option<Address>;\n    }\n  | {\n      __kind: 'TokenMetadata';\n      /** The authority that can sign to update the metadata. */\n      updateAuthority: Option<Address>;\n      /** The associated mint, used to counter spoofing to be sure that metadata belongs to a particular mint. */\n      mint: Address;\n      /** The longer name of the token. */\n      name: string;\n      /** The shortened symbol for the token. */\n      symbol: string;\n      /** The URI pointing to richer metadata. */\n      uri: string;\n      /** Any additional metadata about the token as key-value pairs. */\n      additionalMetadata: Map<string, string>;\n    }\n  | {\n      __kind: 'GroupPointer';\n      /** Optional authority that can set the group address. */\n      authority: Option<Address>;\n      /** Optional account address that holds the group. */\n      groupAddress: Option<Address>;\n    }\n  | {\n      __kind: 'TokenGroup';\n      /** The authority that can sign to update the group. */\n      updateAuthority: Option<Address>;\n      /** The associated mint, used to counter spoofing to be sure that group belongs to a particular mint. */\n      mint: Address;\n      /** The current number of group members. */\n      size: bigint;\n      /** The maximum number of group members. */\n      maxSize: bigint;\n    }\n  | {\n      __kind: 'GroupMemberPointer';\n      /** Optional authority that can set the member address. */\n      authority: Option<Address>;\n      /** Optional account address that holds the member. */\n      memberAddress: Option<Address>;\n    }\n  | {\n      __kind: 'TokenGroupMember';\n      /** The associated mint, used to counter spoofing to be sure that member belongs to a particular mint. */\n      mint: Address;\n      /** The pubkey of the `TokenGroup`. */\n      group: Address;\n      /** The member number. */\n      memberNumber: bigint;\n    }\n  | { __kind: 'ConfidentialMintBurn' }\n  | {\n      __kind: 'ScaledUiAmountConfig';\n      authority: Address;\n      multiplier: number;\n      newMultiplierEffectiveTimestamp: bigint;\n      newMultiplier: number;\n    }\n  | { __kind: 'PausableConfig'; authority: Option<Address>; paused: boolean }\n  | { __kind: 'PausableAccount' };\n\nexport type ExtensionArgs =\n  | { __kind: 'Uninitialized' }\n  | {\n      __kind: 'TransferFeeConfig';\n      /** Optional authority to set the fee. */\n      transferFeeConfigAuthority: Address;\n      /** Withdraw from mint instructions must be signed by this key. */\n      withdrawWithheldAuthority: Address;\n      /** Withheld transfer fee tokens that have been moved to the mint for withdrawal. */\n      withheldAmount: number | bigint;\n      /** Older transfer fee, used if the current epoch < newerTransferFee.epoch. */\n      olderTransferFee: TransferFeeArgs;\n      /** Newer transfer fee, used if the current epoch >= newerTransferFee.epoch. */\n      newerTransferFee: TransferFeeArgs;\n    }\n  | {\n      __kind: 'TransferFeeAmount';\n      /** Withheld transfer fee tokens that can be claimed by the fee authority. */\n      withheldAmount: number | bigint;\n    }\n  | { __kind: 'MintCloseAuthority'; closeAuthority: Address }\n  | {\n      __kind: 'ConfidentialTransferMint';\n      /**\n       * Authority to modify the `ConfidentialTransferMint` configuration and to\n       * approve new accounts (if `auto_approve_new_accounts` is true).\n       *\n       * The legacy Token Multisig account is not supported as the authority.\n       */\n      authority: OptionOrNullable<Address>;\n      /**\n       * Indicate if newly configured accounts must be approved by the\n       * `authority` before they may be used by the user.\n       *\n       * * If `true`, no approval is required and new accounts may be used immediately.\n       * * If `false`, the authority must approve newly configured accounts (see\n       *   `ConfidentialTransferInstruction::ConfigureAccount`).\n       */\n      autoApproveNewAccounts: boolean;\n      /** Authority to decode any transfer amount in a confidential transfer. */\n      auditorElgamalPubkey: OptionOrNullable<Address>;\n    }\n  | {\n      __kind: 'ConfidentialTransferAccount';\n      /**\n       * `true` if this account has been approved for use. All confidential\n       * transfer operations for the account will fail until approval is granted.\n       */\n      approved: boolean;\n      /** The public key associated with ElGamal encryption. */\n      elgamalPubkey: Address;\n      /** The low 16 bits of the pending balance (encrypted by `elgamal_pubkey`). */\n      pendingBalanceLow: EncryptedBalanceArgs;\n      /** The high 32 bits of the pending balance (encrypted by `elgamal_pubkey`). */\n      pendingBalanceHigh: EncryptedBalanceArgs;\n      /** The available balance (encrypted by `encrypiton_pubkey`). */\n      availableBalance: EncryptedBalanceArgs;\n      /** The decryptable available balance. */\n      decryptableAvailableBalance: DecryptableBalanceArgs;\n      /** If `false`, the extended account rejects any incoming confidential transfers. */\n      allowConfidentialCredits: boolean;\n      /** If `false`, the base account rejects any incoming transfers. */\n      allowNonConfidentialCredits: boolean;\n      /** The total number of `Deposit` and `Transfer` instructions that have credited `pending_balance`. */\n      pendingBalanceCreditCounter: number | bigint;\n      /**\n       * The maximum number of `Deposit` and `Transfer` instructions that can\n       * credit `pending_balance` before the `ApplyPendingBalance`\n       * instruction is executed.\n       */\n      maximumPendingBalanceCreditCounter: number | bigint;\n      /**\n       * The `expected_pending_balance_credit_counter` value that was included in\n       * the last `ApplyPendingBalance` instruction.\n       */\n      expectedPendingBalanceCreditCounter: number | bigint;\n      /**\n       * The actual `pending_balance_credit_counter` when the last\n       * `ApplyPendingBalance` instruction was executed.\n       */\n      actualPendingBalanceCreditCounter: number | bigint;\n    }\n  | { __kind: 'DefaultAccountState'; state: AccountStateArgs }\n  | { __kind: 'ImmutableOwner' }\n  | {\n      __kind: 'MemoTransfer';\n      /** Require transfers into this account to be accompanied by a memo. */\n      requireIncomingTransferMemos: boolean;\n    }\n  | { __kind: 'NonTransferable' }\n  | {\n      __kind: 'InterestBearingConfig';\n      rateAuthority: Address;\n      initializationTimestamp: number | bigint;\n      preUpdateAverageRate: number;\n      lastUpdateTimestamp: number | bigint;\n      currentRate: number;\n    }\n  | {\n      __kind: 'CpiGuard';\n      /** Lock certain token operations from taking place within CPI for this account. */\n      lockCpi: boolean;\n    }\n  | { __kind: 'PermanentDelegate'; delegate: Address }\n  | { __kind: 'NonTransferableAccount' }\n  | {\n      __kind: 'TransferHook';\n      /** The transfer hook update authority. */\n      authority: Address;\n      /** The transfer hook program account. */\n      programId: Address;\n    }\n  | {\n      __kind: 'TransferHookAccount';\n      /**\n       * Whether or not this account is currently transferring tokens\n       * True during the transfer hook cpi, otherwise false.\n       */\n      transferring: boolean;\n    }\n  | {\n      __kind: 'ConfidentialTransferFee';\n      /** Optional authority to set the withdraw withheld authority ElGamal key. */\n      authority: OptionOrNullable<Address>;\n      /**\n       * Withheld fees from accounts must be encrypted with this ElGamal key.\n       *\n       * Note that whoever holds the ElGamal private key for this ElGamal public\n       * key has the ability to decode any withheld fee amount that are\n       * associated with accounts. When combined with the fee parameters, the\n       * withheld fee amounts can reveal information about transfer amounts.\n       */\n      elgamalPubkey: Address;\n      /** If `false`, the harvest of withheld tokens to mint is rejected. */\n      harvestToMintEnabled: boolean;\n      /**\n       * Withheld confidential transfer fee tokens that have been moved to the\n       * mint for withdrawal.\n       */\n      withheldAmount: EncryptedBalanceArgs;\n    }\n  | {\n      __kind: 'ConfidentialTransferFeeAmount';\n      /** Amount withheld during confidential transfers, to be harvest to the mint. */\n      withheldAmount: EncryptedBalanceArgs;\n    }\n  | {\n      __kind: 'MetadataPointer';\n      /** Optional authority that can set the metadata address. */\n      authority: OptionOrNullable<Address>;\n      /** Optional Account Address that holds the metadata. */\n      metadataAddress: OptionOrNullable<Address>;\n    }\n  | {\n      __kind: 'TokenMetadata';\n      /** The authority that can sign to update the metadata. */\n      updateAuthority: OptionOrNullable<Address>;\n      /** The associated mint, used to counter spoofing to be sure that metadata belongs to a particular mint. */\n      mint: Address;\n      /** The longer name of the token. */\n      name: string;\n      /** The shortened symbol for the token. */\n      symbol: string;\n      /** The URI pointing to richer metadata. */\n      uri: string;\n      /** Any additional metadata about the token as key-value pairs. */\n      additionalMetadata: Map<string, string>;\n    }\n  | {\n      __kind: 'GroupPointer';\n      /** Optional authority that can set the group address. */\n      authority: OptionOrNullable<Address>;\n      /** Optional account address that holds the group. */\n      groupAddress: OptionOrNullable<Address>;\n    }\n  | {\n      __kind: 'TokenGroup';\n      /** The authority that can sign to update the group. */\n      updateAuthority: OptionOrNullable<Address>;\n      /** The associated mint, used to counter spoofing to be sure that group belongs to a particular mint. */\n      mint: Address;\n      /** The current number of group members. */\n      size: number | bigint;\n      /** The maximum number of group members. */\n      maxSize: number | bigint;\n    }\n  | {\n      __kind: 'GroupMemberPointer';\n      /** Optional authority that can set the member address. */\n      authority: OptionOrNullable<Address>;\n      /** Optional account address that holds the member. */\n      memberAddress: OptionOrNullable<Address>;\n    }\n  | {\n      __kind: 'TokenGroupMember';\n      /** The associated mint, used to counter spoofing to be sure that member belongs to a particular mint. */\n      mint: Address;\n      /** The pubkey of the `TokenGroup`. */\n      group: Address;\n      /** The member number. */\n      memberNumber: number | bigint;\n    }\n  | { __kind: 'ConfidentialMintBurn' }\n  | {\n      __kind: 'ScaledUiAmountConfig';\n      authority: Address;\n      multiplier: number;\n      newMultiplierEffectiveTimestamp: number | bigint;\n      newMultiplier: number;\n    }\n  | {\n      __kind: 'PausableConfig';\n      authority: OptionOrNullable<Address>;\n      paused: boolean;\n    }\n  | { __kind: 'PausableAccount' };\n\nexport function getExtensionEncoder(): Encoder<ExtensionArgs> {\n  return getDiscriminatedUnionEncoder(\n    [\n      ['Uninitialized', getUnitEncoder()],\n      [\n        'TransferFeeConfig',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['transferFeeConfigAuthority', getAddressEncoder()],\n            ['withdrawWithheldAuthority', getAddressEncoder()],\n            ['withheldAmount', getU64Encoder()],\n            ['olderTransferFee', getTransferFeeEncoder()],\n            ['newerTransferFee', getTransferFeeEncoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'TransferFeeAmount',\n        addEncoderSizePrefix(\n          getStructEncoder([['withheldAmount', getU64Encoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'MintCloseAuthority',\n        addEncoderSizePrefix(\n          getStructEncoder([['closeAuthority', getAddressEncoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferMint',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'authority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['autoApproveNewAccounts', getBooleanEncoder()],\n            [\n              'auditorElgamalPubkey',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferAccount',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['approved', getBooleanEncoder()],\n            ['elgamalPubkey', getAddressEncoder()],\n            ['pendingBalanceLow', getEncryptedBalanceEncoder()],\n            ['pendingBalanceHigh', getEncryptedBalanceEncoder()],\n            ['availableBalance', getEncryptedBalanceEncoder()],\n            ['decryptableAvailableBalance', getDecryptableBalanceEncoder()],\n            ['allowConfidentialCredits', getBooleanEncoder()],\n            ['allowNonConfidentialCredits', getBooleanEncoder()],\n            ['pendingBalanceCreditCounter', getU64Encoder()],\n            ['maximumPendingBalanceCreditCounter', getU64Encoder()],\n            ['expectedPendingBalanceCreditCounter', getU64Encoder()],\n            ['actualPendingBalanceCreditCounter', getU64Encoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'DefaultAccountState',\n        addEncoderSizePrefix(\n          getStructEncoder([['state', getAccountStateEncoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'ImmutableOwner',\n        addEncoderSizePrefix(getStructEncoder([]), getU16Encoder()),\n      ],\n      [\n        'MemoTransfer',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['requireIncomingTransferMemos', getBooleanEncoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'NonTransferable',\n        addEncoderSizePrefix(getStructEncoder([]), getU16Encoder()),\n      ],\n      [\n        'InterestBearingConfig',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['rateAuthority', getAddressEncoder()],\n            ['initializationTimestamp', getU64Encoder()],\n            ['preUpdateAverageRate', getI16Encoder()],\n            ['lastUpdateTimestamp', getU64Encoder()],\n            ['currentRate', getI16Encoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'CpiGuard',\n        addEncoderSizePrefix(\n          getStructEncoder([['lockCpi', getBooleanEncoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'PermanentDelegate',\n        addEncoderSizePrefix(\n          getStructEncoder([['delegate', getAddressEncoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'NonTransferableAccount',\n        addEncoderSizePrefix(getStructEncoder([]), getU16Encoder()),\n      ],\n      [\n        'TransferHook',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['authority', getAddressEncoder()],\n            ['programId', getAddressEncoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'TransferHookAccount',\n        addEncoderSizePrefix(\n          getStructEncoder([['transferring', getBooleanEncoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferFee',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'authority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['elgamalPubkey', getAddressEncoder()],\n            ['harvestToMintEnabled', getBooleanEncoder()],\n            ['withheldAmount', getEncryptedBalanceEncoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferFeeAmount',\n        addEncoderSizePrefix(\n          getStructEncoder([['withheldAmount', getEncryptedBalanceEncoder()]]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'MetadataPointer',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'authority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            [\n              'metadataAddress',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'TokenMetadata',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'updateAuthority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['mint', getAddressEncoder()],\n            ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n            ['symbol', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n            ['uri', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n            [\n              'additionalMetadata',\n              getMapEncoder(\n                addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),\n                addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())\n              ),\n            ],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'GroupPointer',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'authority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            [\n              'groupAddress',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'TokenGroup',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'updateAuthority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['mint', getAddressEncoder()],\n            ['size', getU64Encoder()],\n            ['maxSize', getU64Encoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'GroupMemberPointer',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'authority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            [\n              'memberAddress',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'TokenGroupMember',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['mint', getAddressEncoder()],\n            ['group', getAddressEncoder()],\n            ['memberNumber', getU64Encoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      ['ConfidentialMintBurn', getUnitEncoder()],\n      [\n        'ScaledUiAmountConfig',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            ['authority', getAddressEncoder()],\n            ['multiplier', getF64Encoder()],\n            ['newMultiplierEffectiveTimestamp', getU64Encoder()],\n            ['newMultiplier', getF64Encoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      [\n        'PausableConfig',\n        addEncoderSizePrefix(\n          getStructEncoder([\n            [\n              'authority',\n              getOptionEncoder(getAddressEncoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['paused', getBooleanEncoder()],\n          ]),\n          getU16Encoder()\n        ),\n      ],\n      ['PausableAccount', getUnitEncoder()],\n    ],\n    { size: getU16Encoder() }\n  );\n}\n\nexport function getExtensionDecoder(): Decoder<Extension> {\n  return getDiscriminatedUnionDecoder(\n    [\n      ['Uninitialized', getUnitDecoder()],\n      [\n        'TransferFeeConfig',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['transferFeeConfigAuthority', getAddressDecoder()],\n            ['withdrawWithheldAuthority', getAddressDecoder()],\n            ['withheldAmount', getU64Decoder()],\n            ['olderTransferFee', getTransferFeeDecoder()],\n            ['newerTransferFee', getTransferFeeDecoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'TransferFeeAmount',\n        addDecoderSizePrefix(\n          getStructDecoder([['withheldAmount', getU64Decoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'MintCloseAuthority',\n        addDecoderSizePrefix(\n          getStructDecoder([['closeAuthority', getAddressDecoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferMint',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'authority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['autoApproveNewAccounts', getBooleanDecoder()],\n            [\n              'auditorElgamalPubkey',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferAccount',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['approved', getBooleanDecoder()],\n            ['elgamalPubkey', getAddressDecoder()],\n            ['pendingBalanceLow', getEncryptedBalanceDecoder()],\n            ['pendingBalanceHigh', getEncryptedBalanceDecoder()],\n            ['availableBalance', getEncryptedBalanceDecoder()],\n            ['decryptableAvailableBalance', getDecryptableBalanceDecoder()],\n            ['allowConfidentialCredits', getBooleanDecoder()],\n            ['allowNonConfidentialCredits', getBooleanDecoder()],\n            ['pendingBalanceCreditCounter', getU64Decoder()],\n            ['maximumPendingBalanceCreditCounter', getU64Decoder()],\n            ['expectedPendingBalanceCreditCounter', getU64Decoder()],\n            ['actualPendingBalanceCreditCounter', getU64Decoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'DefaultAccountState',\n        addDecoderSizePrefix(\n          getStructDecoder([['state', getAccountStateDecoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'ImmutableOwner',\n        addDecoderSizePrefix(getStructDecoder([]), getU16Decoder()),\n      ],\n      [\n        'MemoTransfer',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['requireIncomingTransferMemos', getBooleanDecoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'NonTransferable',\n        addDecoderSizePrefix(getStructDecoder([]), getU16Decoder()),\n      ],\n      [\n        'InterestBearingConfig',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['rateAuthority', getAddressDecoder()],\n            ['initializationTimestamp', getU64Decoder()],\n            ['preUpdateAverageRate', getI16Decoder()],\n            ['lastUpdateTimestamp', getU64Decoder()],\n            ['currentRate', getI16Decoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'CpiGuard',\n        addDecoderSizePrefix(\n          getStructDecoder([['lockCpi', getBooleanDecoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'PermanentDelegate',\n        addDecoderSizePrefix(\n          getStructDecoder([['delegate', getAddressDecoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'NonTransferableAccount',\n        addDecoderSizePrefix(getStructDecoder([]), getU16Decoder()),\n      ],\n      [\n        'TransferHook',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['authority', getAddressDecoder()],\n            ['programId', getAddressDecoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'TransferHookAccount',\n        addDecoderSizePrefix(\n          getStructDecoder([['transferring', getBooleanDecoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferFee',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'authority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['elgamalPubkey', getAddressDecoder()],\n            ['harvestToMintEnabled', getBooleanDecoder()],\n            ['withheldAmount', getEncryptedBalanceDecoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'ConfidentialTransferFeeAmount',\n        addDecoderSizePrefix(\n          getStructDecoder([['withheldAmount', getEncryptedBalanceDecoder()]]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'MetadataPointer',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'authority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            [\n              'metadataAddress',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'TokenMetadata',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'updateAuthority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['mint', getAddressDecoder()],\n            ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n            ['symbol', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n            ['uri', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n            [\n              'additionalMetadata',\n              getMapDecoder(\n                addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()),\n                addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())\n              ),\n            ],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'GroupPointer',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'authority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            [\n              'groupAddress',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'TokenGroup',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'updateAuthority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['mint', getAddressDecoder()],\n            ['size', getU64Decoder()],\n            ['maxSize', getU64Decoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'GroupMemberPointer',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'authority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            [\n              'memberAddress',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'TokenGroupMember',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['mint', getAddressDecoder()],\n            ['group', getAddressDecoder()],\n            ['memberNumber', getU64Decoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      ['ConfidentialMintBurn', getUnitDecoder()],\n      [\n        'ScaledUiAmountConfig',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            ['authority', getAddressDecoder()],\n            ['multiplier', getF64Decoder()],\n            ['newMultiplierEffectiveTimestamp', getU64Decoder()],\n            ['newMultiplier', getF64Decoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      [\n        'PausableConfig',\n        addDecoderSizePrefix(\n          getStructDecoder([\n            [\n              'authority',\n              getOptionDecoder(getAddressDecoder(), {\n                prefix: null,\n                noneValue: 'zeroes',\n              }),\n            ],\n            ['paused', getBooleanDecoder()],\n          ]),\n          getU16Decoder()\n        ),\n      ],\n      ['PausableAccount', getUnitDecoder()],\n    ],\n    { size: getU16Decoder() }\n  );\n}\n\nexport function getExtensionCodec(): Codec<ExtensionArgs, Extension> {\n  return combineCodec(getExtensionEncoder(), getExtensionDecoder());\n}\n\n// Data Enum Helpers.\nexport function extension(\n  kind: 'Uninitialized'\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'Uninitialized'>;\nexport function extension(\n  kind: 'TransferFeeConfig',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TransferFeeConfig'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TransferFeeConfig'>;\nexport function extension(\n  kind: 'TransferFeeAmount',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TransferFeeAmount'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TransferFeeAmount'>;\nexport function extension(\n  kind: 'MintCloseAuthority',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'MintCloseAuthority'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'MintCloseAuthority'>;\nexport function extension(\n  kind: 'ConfidentialTransferMint',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'ConfidentialTransferMint'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'ConfidentialTransferMint'\n>;\nexport function extension(\n  kind: 'ConfidentialTransferAccount',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'ConfidentialTransferAccount'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'ConfidentialTransferAccount'\n>;\nexport function extension(\n  kind: 'DefaultAccountState',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'DefaultAccountState'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'DefaultAccountState'>;\nexport function extension(\n  kind: 'ImmutableOwner',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'ImmutableOwner'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'ImmutableOwner'>;\nexport function extension(\n  kind: 'MemoTransfer',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'MemoTransfer'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'MemoTransfer'>;\nexport function extension(\n  kind: 'NonTransferable',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'NonTransferable'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'NonTransferable'>;\nexport function extension(\n  kind: 'InterestBearingConfig',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'InterestBearingConfig'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'InterestBearingConfig'\n>;\nexport function extension(\n  kind: 'CpiGuard',\n  data: GetDiscriminatedUnionVariantContent<ExtensionArgs, '__kind', 'CpiGuard'>\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'CpiGuard'>;\nexport function extension(\n  kind: 'PermanentDelegate',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'PermanentDelegate'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'PermanentDelegate'>;\nexport function extension(\n  kind: 'NonTransferableAccount',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'NonTransferableAccount'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'NonTransferableAccount'\n>;\nexport function extension(\n  kind: 'TransferHook',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TransferHook'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TransferHook'>;\nexport function extension(\n  kind: 'TransferHookAccount',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TransferHookAccount'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TransferHookAccount'>;\nexport function extension(\n  kind: 'ConfidentialTransferFee',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'ConfidentialTransferFee'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'ConfidentialTransferFee'\n>;\nexport function extension(\n  kind: 'ConfidentialTransferFeeAmount',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'ConfidentialTransferFeeAmount'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'ConfidentialTransferFeeAmount'\n>;\nexport function extension(\n  kind: 'MetadataPointer',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'MetadataPointer'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'MetadataPointer'>;\nexport function extension(\n  kind: 'TokenMetadata',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TokenMetadata'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TokenMetadata'>;\nexport function extension(\n  kind: 'GroupPointer',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'GroupPointer'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'GroupPointer'>;\nexport function extension(\n  kind: 'TokenGroup',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TokenGroup'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TokenGroup'>;\nexport function extension(\n  kind: 'GroupMemberPointer',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'GroupMemberPointer'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'GroupMemberPointer'>;\nexport function extension(\n  kind: 'TokenGroupMember',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'TokenGroupMember'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'TokenGroupMember'>;\nexport function extension(\n  kind: 'ConfidentialMintBurn'\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'ConfidentialMintBurn'\n>;\nexport function extension(\n  kind: 'ScaledUiAmountConfig',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'ScaledUiAmountConfig'\n  >\n): GetDiscriminatedUnionVariant<\n  ExtensionArgs,\n  '__kind',\n  'ScaledUiAmountConfig'\n>;\nexport function extension(\n  kind: 'PausableConfig',\n  data: GetDiscriminatedUnionVariantContent<\n    ExtensionArgs,\n    '__kind',\n    'PausableConfig'\n  >\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'PausableConfig'>;\nexport function extension(\n  kind: 'PausableAccount'\n): GetDiscriminatedUnionVariant<ExtensionArgs, '__kind', 'PausableAccount'>;\nexport function extension<K extends ExtensionArgs['__kind'], Data>(\n  kind: K,\n  data?: Data\n) {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isExtension<K extends Extension['__kind']>(\n  kind: K,\n  value: Extension\n): value is Extension & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getEnumDecoder,\n  getEnumEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n} from '@solana/kit';\n\n/**\n * Extensions that can be applied to mints or accounts.  Mint extensions must\n * only be applied to mint accounts, and account extensions must only be\n * applied to token holding accounts.\n */\nexport enum ExtensionType {\n  Uninitialized,\n  TransferFeeConfig,\n  TransferFeeAmount,\n  MintCloseAuthority,\n  ConfidentialTransferMint,\n  ConfidentialTransferAccount,\n  DefaultAccountState,\n  ImmutableOwner,\n  MemoTransfer,\n  NonTransferable,\n  InterestBearingConfig,\n  CpiGuard,\n  PermanentDelegate,\n  NonTransferableAccount,\n  TransferHook,\n  TransferHookAccount,\n  ConfidentialTransferFee,\n  ConfidentialTransferFeeAmount,\n  ScaledUiAmountConfig,\n  PausableConfig,\n  PausableAccount,\n  MetadataPointer,\n  TokenMetadata,\n  GroupPointer,\n  TokenGroup,\n  GroupMemberPointer,\n  TokenGroupMember,\n}\n\nexport type ExtensionTypeArgs = ExtensionType;\n\nexport function getExtensionTypeEncoder(): FixedSizeEncoder<ExtensionTypeArgs> {\n  return getEnumEncoder(ExtensionType, { size: getU16Encoder() });\n}\n\nexport function getExtensionTypeDecoder(): FixedSizeDecoder<ExtensionType> {\n  return getEnumDecoder(ExtensionType, { size: getU16Decoder() });\n}\n\nexport function getExtensionTypeCodec(): FixedSizeCodec<\n  ExtensionTypeArgs,\n  ExtensionType\n> {\n  return combineCodec(getExtensionTypeEncoder(), getExtensionTypeDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getDiscriminatedUnionDecoder,\n  getDiscriminatedUnionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getTupleDecoder,\n  getTupleEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getUnitDecoder,\n  getUnitEncoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type GetDiscriminatedUnionVariant,\n  type GetDiscriminatedUnionVariantContent,\n} from '@solana/kit';\n\n/** Fields in the metadata account, used for updating. */\nexport type TokenMetadataField =\n  | { __kind: 'Name' }\n  | { __kind: 'Symbol' }\n  | { __kind: 'Uri' }\n  | { __kind: 'Key'; fields: readonly [string] };\n\nexport type TokenMetadataFieldArgs = TokenMetadataField;\n\nexport function getTokenMetadataFieldEncoder(): Encoder<TokenMetadataFieldArgs> {\n  return getDiscriminatedUnionEncoder([\n    ['Name', getUnitEncoder()],\n    ['Symbol', getUnitEncoder()],\n    ['Uri', getUnitEncoder()],\n    [\n      'Key',\n      getStructEncoder([\n        [\n          'fields',\n          getTupleEncoder([\n            addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()),\n          ]),\n        ],\n      ]),\n    ],\n  ]);\n}\n\nexport function getTokenMetadataFieldDecoder(): Decoder<TokenMetadataField> {\n  return getDiscriminatedUnionDecoder([\n    ['Name', getUnitDecoder()],\n    ['Symbol', getUnitDecoder()],\n    ['Uri', getUnitDecoder()],\n    [\n      'Key',\n      getStructDecoder([\n        [\n          'fields',\n          getTupleDecoder([\n            addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder()),\n          ]),\n        ],\n      ]),\n    ],\n  ]);\n}\n\nexport function getTokenMetadataFieldCodec(): Codec<\n  TokenMetadataFieldArgs,\n  TokenMetadataField\n> {\n  return combineCodec(\n    getTokenMetadataFieldEncoder(),\n    getTokenMetadataFieldDecoder()\n  );\n}\n\n// Data Enum Helpers.\nexport function tokenMetadataField(\n  kind: 'Name'\n): GetDiscriminatedUnionVariant<TokenMetadataFieldArgs, '__kind', 'Name'>;\nexport function tokenMetadataField(\n  kind: 'Symbol'\n): GetDiscriminatedUnionVariant<TokenMetadataFieldArgs, '__kind', 'Symbol'>;\nexport function tokenMetadataField(\n  kind: 'Uri'\n): GetDiscriminatedUnionVariant<TokenMetadataFieldArgs, '__kind', 'Uri'>;\nexport function tokenMetadataField(\n  kind: 'Key',\n  data: GetDiscriminatedUnionVariantContent<\n    TokenMetadataFieldArgs,\n    '__kind',\n    'Key'\n  >['fields']\n): GetDiscriminatedUnionVariant<TokenMetadataFieldArgs, '__kind', 'Key'>;\nexport function tokenMetadataField<\n  K extends TokenMetadataFieldArgs['__kind'],\n  Data,\n>(kind: K, data?: Data) {\n  return Array.isArray(data)\n    ? { __kind: kind, fields: data }\n    : { __kind: kind, ...(data ?? {}) };\n}\n\nexport function isTokenMetadataField<K extends TokenMetadataField['__kind']>(\n  kind: K,\n  value: TokenMetadataField\n): value is TokenMetadataField & { __kind: K } {\n  return value.__kind === kind;\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n} from '@solana/kit';\n\nexport type TransferFee = {\n  /** First epoch where the transfer fee takes effect. */\n  epoch: bigint;\n  /** Maximum fee assessed on transfers, expressed as an amount of tokens. */\n  maximumFee: bigint;\n  /**\n   * Amount of transfer collected as fees, expressed as basis points of the\n   * transfer amount, ie. increments of 0.01%.\n   */\n  transferFeeBasisPoints: number;\n};\n\nexport type TransferFeeArgs = {\n  /** First epoch where the transfer fee takes effect. */\n  epoch: number | bigint;\n  /** Maximum fee assessed on transfers, expressed as an amount of tokens. */\n  maximumFee: number | bigint;\n  /**\n   * Amount of transfer collected as fees, expressed as basis points of the\n   * transfer amount, ie. increments of 0.01%.\n   */\n  transferFeeBasisPoints: number;\n};\n\nexport function getTransferFeeEncoder(): FixedSizeEncoder<TransferFeeArgs> {\n  return getStructEncoder([\n    ['epoch', getU64Encoder()],\n    ['maximumFee', getU64Encoder()],\n    ['transferFeeBasisPoints', getU16Encoder()],\n  ]);\n}\n\nexport function getTransferFeeDecoder(): FixedSizeDecoder<TransferFee> {\n  return getStructDecoder([\n    ['epoch', getU64Decoder()],\n    ['maximumFee', getU64Decoder()],\n    ['transferFeeBasisPoints', getU16Decoder()],\n  ]);\n}\n\nexport function getTransferFeeCodec(): FixedSizeCodec<\n  TransferFeeArgs,\n  TransferFee\n> {\n  return combineCodec(getTransferFeeEncoder(), getTransferFeeDecoder());\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getArrayDecoder,\n  getArrayEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getConstantDecoder,\n  getConstantEncoder,\n  getHiddenPrefixDecoder,\n  getHiddenPrefixEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  padLeftEncoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type Option,\n  type OptionOrNullable,\n} from '@solana/kit';\nimport {\n  getExtensionDecoder,\n  getExtensionEncoder,\n  type Extension,\n  type ExtensionArgs,\n} from '../types';\n\nexport type Mint = {\n  /**\n   * Optional authority used to mint new tokens. The mint authority may only\n   * be provided during mint creation. If no mint authority is present\n   * then the mint has a fixed supply and no further tokens may be minted.\n   */\n  mintAuthority: Option<Address>;\n  /** Total supply of tokens. */\n  supply: bigint;\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** Is `true` if this structure has been initialized. */\n  isInitialized: boolean;\n  /** Optional authority to freeze token accounts. */\n  freezeAuthority: Option<Address>;\n  /** The extensions activated on the mint account. */\n  extensions: Option<Array<Extension>>;\n};\n\nexport type MintArgs = {\n  /**\n   * Optional authority used to mint new tokens. The mint authority may only\n   * be provided during mint creation. If no mint authority is present\n   * then the mint has a fixed supply and no further tokens may be minted.\n   */\n  mintAuthority: OptionOrNullable<Address>;\n  /** Total supply of tokens. */\n  supply: number | bigint;\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** Is `true` if this structure has been initialized. */\n  isInitialized: boolean;\n  /** Optional authority to freeze token accounts. */\n  freezeAuthority: OptionOrNullable<Address>;\n  /** The extensions activated on the mint account. */\n  extensions: OptionOrNullable<Array<ExtensionArgs>>;\n};\n\nexport function getMintEncoder(): Encoder<MintArgs> {\n  return getStructEncoder([\n    [\n      'mintAuthority',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['supply', getU64Encoder()],\n    ['decimals', getU8Encoder()],\n    ['isInitialized', getBooleanEncoder()],\n    [\n      'freezeAuthority',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'extensions',\n      getOptionEncoder(\n        getHiddenPrefixEncoder(\n          getArrayEncoder(getExtensionEncoder(), { size: 'remainder' }),\n          [getConstantEncoder(padLeftEncoder(getU8Encoder(), 83).encode(1))]\n        ),\n        { prefix: null }\n      ),\n    ],\n  ]);\n}\n\nexport function getMintDecoder(): Decoder<Mint> {\n  return getStructDecoder([\n    [\n      'mintAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['supply', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n    ['isInitialized', getBooleanDecoder()],\n    [\n      'freezeAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'extensions',\n      getOptionDecoder(\n        getHiddenPrefixDecoder(\n          getArrayDecoder(getExtensionDecoder(), { size: 'remainder' }),\n          [getConstantDecoder(padLeftEncoder(getU8Encoder(), 83).encode(1))]\n        ),\n        { prefix: null }\n      ),\n    ],\n  ]);\n}\n\nexport function getMintCodec(): Codec<MintArgs, Mint> {\n  return combineCodec(getMintEncoder(), getMintDecoder());\n}\n\nexport function decodeMint<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Mint, TAddress>;\nexport function decodeMint<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Mint, TAddress>;\nexport function decodeMint<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Mint, TAddress> | MaybeAccount<Mint, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getMintDecoder()\n  );\n}\n\nexport async function fetchMint<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Mint, TAddress>> {\n  const maybeAccount = await fetchMaybeMint(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeMint<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Mint, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeMint(maybeAccount);\n}\n\nexport async function fetchAllMint(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Mint>[]> {\n  const maybeAccounts = await fetchAllMaybeMint(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeMint(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Mint>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeMint(maybeAccount));\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getArrayDecoder,\n  getArrayEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  type Account,\n  type Address,\n  type EncodedAccount,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n} from '@solana/kit';\n\nexport type Multisig = {\n  /** Number of signers required. */\n  m: number;\n  /** Number of valid signers. */\n  n: number;\n  /** Is `true` if this structure has been initialized. */\n  isInitialized: boolean;\n  /** Signer public keys. */\n  signers: Array<Address>;\n};\n\nexport type MultisigArgs = Multisig;\n\nexport function getMultisigEncoder(): FixedSizeEncoder<MultisigArgs> {\n  return getStructEncoder([\n    ['m', getU8Encoder()],\n    ['n', getU8Encoder()],\n    ['isInitialized', getBooleanEncoder()],\n    ['signers', getArrayEncoder(getAddressEncoder(), { size: 11 })],\n  ]);\n}\n\nexport function getMultisigDecoder(): FixedSizeDecoder<Multisig> {\n  return getStructDecoder([\n    ['m', getU8Decoder()],\n    ['n', getU8Decoder()],\n    ['isInitialized', getBooleanDecoder()],\n    ['signers', getArrayDecoder(getAddressDecoder(), { size: 11 })],\n  ]);\n}\n\nexport function getMultisigCodec(): FixedSizeCodec<MultisigArgs, Multisig> {\n  return combineCodec(getMultisigEncoder(), getMultisigDecoder());\n}\n\nexport function decodeMultisig<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Multisig, TAddress>;\nexport function decodeMultisig<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Multisig, TAddress>;\nexport function decodeMultisig<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Multisig, TAddress> | MaybeAccount<Multisig, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getMultisigDecoder()\n  );\n}\n\nexport async function fetchMultisig<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Multisig, TAddress>> {\n  const maybeAccount = await fetchMaybeMultisig(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeMultisig<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Multisig, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeMultisig(maybeAccount);\n}\n\nexport async function fetchAllMultisig(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Multisig>[]> {\n  const maybeAccounts = await fetchAllMaybeMultisig(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeMultisig(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Multisig>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeMultisig(maybeAccount));\n}\n\nexport function getMultisigSize(): number {\n  return 355;\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  assertAccountExists,\n  assertAccountsExist,\n  combineCodec,\n  decodeAccount,\n  fetchEncodedAccount,\n  fetchEncodedAccounts,\n  getAddressDecoder,\n  getAddressEncoder,\n  getArrayDecoder,\n  getArrayEncoder,\n  getConstantDecoder,\n  getConstantEncoder,\n  getHiddenPrefixDecoder,\n  getHiddenPrefixEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Encoder,\n  type Account,\n  type Address,\n  type Codec,\n  type Decoder,\n  type EncodedAccount,\n  type Encoder,\n  type FetchAccountConfig,\n  type FetchAccountsConfig,\n  type MaybeAccount,\n  type MaybeEncodedAccount,\n  type Option,\n  type OptionOrNullable,\n} from '@solana/kit';\nimport {\n  getAccountStateDecoder,\n  getAccountStateEncoder,\n  getExtensionDecoder,\n  getExtensionEncoder,\n  type AccountState,\n  type AccountStateArgs,\n  type Extension,\n  type ExtensionArgs,\n} from '../types';\n\nexport type Token = {\n  /** The mint associated with this account. */\n  mint: Address;\n  /** The owner of this account. */\n  owner: Address;\n  /** The amount of tokens this account holds. */\n  amount: bigint;\n  /**\n   * If `delegate` is `Some` then `delegated_amount` represents\n   * the amount authorized by the delegate.\n   */\n  delegate: Option<Address>;\n  /** The account's state. */\n  state: AccountState;\n  /**\n   * If is_native.is_some, this is a native token, and the value logs the\n   * rent-exempt reserve. An Account is required to be rent-exempt, so\n   * the value is used by the Processor to ensure that wrapped SOL\n   * accounts do not drop below this threshold.\n   */\n  isNative: Option<bigint>;\n  /** The amount delegated. */\n  delegatedAmount: bigint;\n  /** Optional authority to close the account. */\n  closeAuthority: Option<Address>;\n  /** The extensions activated on the token account. */\n  extensions: Option<Array<Extension>>;\n};\n\nexport type TokenArgs = {\n  /** The mint associated with this account. */\n  mint: Address;\n  /** The owner of this account. */\n  owner: Address;\n  /** The amount of tokens this account holds. */\n  amount: number | bigint;\n  /**\n   * If `delegate` is `Some` then `delegated_amount` represents\n   * the amount authorized by the delegate.\n   */\n  delegate: OptionOrNullable<Address>;\n  /** The account's state. */\n  state: AccountStateArgs;\n  /**\n   * If is_native.is_some, this is a native token, and the value logs the\n   * rent-exempt reserve. An Account is required to be rent-exempt, so\n   * the value is used by the Processor to ensure that wrapped SOL\n   * accounts do not drop below this threshold.\n   */\n  isNative: OptionOrNullable<number | bigint>;\n  /** The amount delegated. */\n  delegatedAmount: number | bigint;\n  /** Optional authority to close the account. */\n  closeAuthority: OptionOrNullable<Address>;\n  /** The extensions activated on the token account. */\n  extensions: OptionOrNullable<Array<ExtensionArgs>>;\n};\n\nexport function getTokenEncoder(): Encoder<TokenArgs> {\n  return getStructEncoder([\n    ['mint', getAddressEncoder()],\n    ['owner', getAddressEncoder()],\n    ['amount', getU64Encoder()],\n    [\n      'delegate',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['state', getAccountStateEncoder()],\n    [\n      'isNative',\n      getOptionEncoder(getU64Encoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['delegatedAmount', getU64Encoder()],\n    [\n      'closeAuthority',\n      getOptionEncoder(getAddressEncoder(), {\n        prefix: getU32Encoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'extensions',\n      getOptionEncoder(\n        getHiddenPrefixEncoder(\n          getArrayEncoder(getExtensionEncoder(), { size: 'remainder' }),\n          [getConstantEncoder(getU8Encoder().encode(2))]\n        ),\n        { prefix: null }\n      ),\n    ],\n  ]);\n}\n\nexport function getTokenDecoder(): Decoder<Token> {\n  return getStructDecoder([\n    ['mint', getAddressDecoder()],\n    ['owner', getAddressDecoder()],\n    ['amount', getU64Decoder()],\n    [\n      'delegate',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['state', getAccountStateDecoder()],\n    [\n      'isNative',\n      getOptionDecoder(getU64Decoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['delegatedAmount', getU64Decoder()],\n    [\n      'closeAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: getU32Decoder(),\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'extensions',\n      getOptionDecoder(\n        getHiddenPrefixDecoder(\n          getArrayDecoder(getExtensionDecoder(), { size: 'remainder' }),\n          [getConstantDecoder(getU8Encoder().encode(2))]\n        ),\n        { prefix: null }\n      ),\n    ],\n  ]);\n}\n\nexport function getTokenCodec(): Codec<TokenArgs, Token> {\n  return combineCodec(getTokenEncoder(), getTokenDecoder());\n}\n\nexport function decodeToken<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress>\n): Account<Token, TAddress>;\nexport function decodeToken<TAddress extends string = string>(\n  encodedAccount: MaybeEncodedAccount<TAddress>\n): MaybeAccount<Token, TAddress>;\nexport function decodeToken<TAddress extends string = string>(\n  encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>\n): Account<Token, TAddress> | MaybeAccount<Token, TAddress> {\n  return decodeAccount(\n    encodedAccount as MaybeEncodedAccount<TAddress>,\n    getTokenDecoder()\n  );\n}\n\nexport async function fetchToken<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<Account<Token, TAddress>> {\n  const maybeAccount = await fetchMaybeToken(rpc, address, config);\n  assertAccountExists(maybeAccount);\n  return maybeAccount;\n}\n\nexport async function fetchMaybeToken<TAddress extends string = string>(\n  rpc: Parameters<typeof fetchEncodedAccount>[0],\n  address: Address<TAddress>,\n  config?: FetchAccountConfig\n): Promise<MaybeAccount<Token, TAddress>> {\n  const maybeAccount = await fetchEncodedAccount(rpc, address, config);\n  return decodeToken(maybeAccount);\n}\n\nexport async function fetchAllToken(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<Account<Token>[]> {\n  const maybeAccounts = await fetchAllMaybeToken(rpc, addresses, config);\n  assertAccountsExist(maybeAccounts);\n  return maybeAccounts;\n}\n\nexport async function fetchAllMaybeToken(\n  rpc: Parameters<typeof fetchEncodedAccounts>[0],\n  addresses: Array<Address>,\n  config?: FetchAccountsConfig\n): Promise<MaybeAccount<Token>[]> {\n  const maybeAccounts = await fetchEncodedAccounts(rpc, addresses, config);\n  return maybeAccounts.map((maybeAccount) => decodeToken(maybeAccount));\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU8Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  type ParsedCreateAssociatedTokenIdempotentInstruction,\n  type ParsedCreateAssociatedTokenInstruction,\n  type ParsedRecoverNestedAssociatedTokenInstruction,\n} from '../instructions';\n\nexport const ASSOCIATED_TOKEN_PROGRAM_ADDRESS =\n  'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>;\n\nexport enum AssociatedTokenInstruction {\n  CreateAssociatedToken,\n  CreateAssociatedTokenIdempotent,\n  RecoverNestedAssociatedToken,\n}\n\nexport function identifyAssociatedTokenInstruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): AssociatedTokenInstruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU8Encoder().encode(0), 0)) {\n    return AssociatedTokenInstruction.CreateAssociatedToken;\n  }\n  if (containsBytes(data, getU8Encoder().encode(1), 0)) {\n    return AssociatedTokenInstruction.CreateAssociatedTokenIdempotent;\n  }\n  if (containsBytes(data, getU8Encoder().encode(2), 0)) {\n    return AssociatedTokenInstruction.RecoverNestedAssociatedToken;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a associatedToken instruction.'\n  );\n}\n\nexport type ParsedAssociatedTokenInstruction<\n  TProgram extends string = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',\n> =\n  | ({\n      instructionType: AssociatedTokenInstruction.CreateAssociatedToken;\n    } & ParsedCreateAssociatedTokenInstruction<TProgram>)\n  | ({\n      instructionType: AssociatedTokenInstruction.CreateAssociatedTokenIdempotent;\n    } & ParsedCreateAssociatedTokenIdempotentInstruction<TProgram>)\n  | ({\n      instructionType: AssociatedTokenInstruction.RecoverNestedAssociatedToken;\n    } & ParsedRecoverNestedAssociatedTokenInstruction<TProgram>);\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  containsBytes,\n  getU8Encoder,\n  type Address,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport {\n  type ParsedAmountToUiAmountInstruction,\n  type ParsedApplyConfidentialPendingBalanceInstruction,\n  type ParsedApproveCheckedInstruction,\n  type ParsedApproveConfidentialTransferAccountInstruction,\n  type ParsedApproveInstruction,\n  type ParsedBurnCheckedInstruction,\n  type ParsedBurnInstruction,\n  type ParsedCloseAccountInstruction,\n  type ParsedConfidentialDepositInstruction,\n  type ParsedConfidentialTransferInstruction,\n  type ParsedConfidentialTransferWithFeeInstruction,\n  type ParsedConfidentialWithdrawInstruction,\n  type ParsedConfigureConfidentialTransferAccountInstruction,\n  type ParsedCreateNativeMintInstruction,\n  type ParsedDisableConfidentialCreditsInstruction,\n  type ParsedDisableCpiGuardInstruction,\n  type ParsedDisableHarvestToMintInstruction,\n  type ParsedDisableMemoTransfersInstruction,\n  type ParsedDisableNonConfidentialCreditsInstruction,\n  type ParsedEmitTokenMetadataInstruction,\n  type ParsedEmptyConfidentialTransferAccountInstruction,\n  type ParsedEnableConfidentialCreditsInstruction,\n  type ParsedEnableCpiGuardInstruction,\n  type ParsedEnableHarvestToMintInstruction,\n  type ParsedEnableMemoTransfersInstruction,\n  type ParsedEnableNonConfidentialCreditsInstruction,\n  type ParsedFreezeAccountInstruction,\n  type ParsedGetAccountDataSizeInstruction,\n  type ParsedHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction,\n  type ParsedHarvestWithheldTokensToMintInstruction,\n  type ParsedInitializeAccount2Instruction,\n  type ParsedInitializeAccount3Instruction,\n  type ParsedInitializeAccountInstruction,\n  type ParsedInitializeConfidentialTransferFeeInstruction,\n  type ParsedInitializeConfidentialTransferMintInstruction,\n  type ParsedInitializeDefaultAccountStateInstruction,\n  type ParsedInitializeGroupMemberPointerInstruction,\n  type ParsedInitializeGroupPointerInstruction,\n  type ParsedInitializeImmutableOwnerInstruction,\n  type ParsedInitializeInterestBearingMintInstruction,\n  type ParsedInitializeMetadataPointerInstruction,\n  type ParsedInitializeMint2Instruction,\n  type ParsedInitializeMintCloseAuthorityInstruction,\n  type ParsedInitializeMintInstruction,\n  type ParsedInitializeMultisig2Instruction,\n  type ParsedInitializeMultisigInstruction,\n  type ParsedInitializeNonTransferableMintInstruction,\n  type ParsedInitializePausableConfigInstruction,\n  type ParsedInitializePermanentDelegateInstruction,\n  type ParsedInitializeScaledUiAmountMintInstruction,\n  type ParsedInitializeTokenGroupInstruction,\n  type ParsedInitializeTokenGroupMemberInstruction,\n  type ParsedInitializeTokenMetadataInstruction,\n  type ParsedInitializeTransferFeeConfigInstruction,\n  type ParsedInitializeTransferHookInstruction,\n  type ParsedMintToCheckedInstruction,\n  type ParsedMintToInstruction,\n  type ParsedPauseInstruction,\n  type ParsedReallocateInstruction,\n  type ParsedRemoveTokenMetadataKeyInstruction,\n  type ParsedResumeInstruction,\n  type ParsedRevokeInstruction,\n  type ParsedSetAuthorityInstruction,\n  type ParsedSetTransferFeeInstruction,\n  type ParsedSyncNativeInstruction,\n  type ParsedThawAccountInstruction,\n  type ParsedTransferCheckedInstruction,\n  type ParsedTransferCheckedWithFeeInstruction,\n  type ParsedTransferInstruction,\n  type ParsedUiAmountToAmountInstruction,\n  type ParsedUpdateConfidentialTransferMintInstruction,\n  type ParsedUpdateDefaultAccountStateInstruction,\n  type ParsedUpdateGroupMemberPointerInstruction,\n  type ParsedUpdateGroupPointerInstruction,\n  type ParsedUpdateMetadataPointerInstruction,\n  type ParsedUpdateMultiplierScaledUiMintInstruction,\n  type ParsedUpdateRateInterestBearingMintInstruction,\n  type ParsedUpdateTokenGroupMaxSizeInstruction,\n  type ParsedUpdateTokenGroupUpdateAuthorityInstruction,\n  type ParsedUpdateTokenMetadataFieldInstruction,\n  type ParsedUpdateTokenMetadataUpdateAuthorityInstruction,\n  type ParsedUpdateTransferHookInstruction,\n  type ParsedWithdrawExcessLamportsInstruction,\n  type ParsedWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction,\n  type ParsedWithdrawWithheldTokensFromAccountsInstruction,\n  type ParsedWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction,\n  type ParsedWithdrawWithheldTokensFromMintInstruction,\n} from '../instructions';\n\nexport const TOKEN_2022_PROGRAM_ADDRESS =\n  'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n\nexport enum Token2022Account {\n  Mint,\n  Token,\n  Multisig,\n}\n\nexport function identifyToken2022Account(\n  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): Token2022Account {\n  const data = 'data' in account ? account.data : account;\n  if (data.length === 82) {\n    return Token2022Account.Mint;\n  }\n  if (data.length === 165) {\n    return Token2022Account.Token;\n  }\n  if (data.length === 355) {\n    return Token2022Account.Multisig;\n  }\n  throw new Error(\n    'The provided account could not be identified as a token-2022 account.'\n  );\n}\n\nexport enum Token2022Instruction {\n  InitializeMint,\n  InitializeAccount,\n  InitializeMultisig,\n  Transfer,\n  Approve,\n  Revoke,\n  SetAuthority,\n  MintTo,\n  Burn,\n  CloseAccount,\n  FreezeAccount,\n  ThawAccount,\n  TransferChecked,\n  ApproveChecked,\n  MintToChecked,\n  BurnChecked,\n  InitializeAccount2,\n  SyncNative,\n  InitializeAccount3,\n  InitializeMultisig2,\n  InitializeMint2,\n  GetAccountDataSize,\n  InitializeImmutableOwner,\n  AmountToUiAmount,\n  UiAmountToAmount,\n  InitializeMintCloseAuthority,\n  InitializeTransferFeeConfig,\n  TransferCheckedWithFee,\n  WithdrawWithheldTokensFromMint,\n  WithdrawWithheldTokensFromAccounts,\n  HarvestWithheldTokensToMint,\n  SetTransferFee,\n  InitializeConfidentialTransferMint,\n  UpdateConfidentialTransferMint,\n  ConfigureConfidentialTransferAccount,\n  ApproveConfidentialTransferAccount,\n  EmptyConfidentialTransferAccount,\n  ConfidentialDeposit,\n  ConfidentialWithdraw,\n  ConfidentialTransfer,\n  ApplyConfidentialPendingBalance,\n  EnableConfidentialCredits,\n  DisableConfidentialCredits,\n  EnableNonConfidentialCredits,\n  DisableNonConfidentialCredits,\n  ConfidentialTransferWithFee,\n  InitializeDefaultAccountState,\n  UpdateDefaultAccountState,\n  Reallocate,\n  EnableMemoTransfers,\n  DisableMemoTransfers,\n  CreateNativeMint,\n  InitializeNonTransferableMint,\n  InitializeInterestBearingMint,\n  UpdateRateInterestBearingMint,\n  EnableCpiGuard,\n  DisableCpiGuard,\n  InitializePermanentDelegate,\n  InitializeTransferHook,\n  UpdateTransferHook,\n  InitializeConfidentialTransferFee,\n  WithdrawWithheldTokensFromMintForConfidentialTransferFee,\n  WithdrawWithheldTokensFromAccountsForConfidentialTransferFee,\n  HarvestWithheldTokensToMintForConfidentialTransferFee,\n  EnableHarvestToMint,\n  DisableHarvestToMint,\n  WithdrawExcessLamports,\n  InitializeMetadataPointer,\n  UpdateMetadataPointer,\n  InitializeGroupPointer,\n  UpdateGroupPointer,\n  InitializeGroupMemberPointer,\n  UpdateGroupMemberPointer,\n  InitializeScaledUiAmountMint,\n  UpdateMultiplierScaledUiMint,\n  InitializePausableConfig,\n  Pause,\n  Resume,\n  InitializeTokenMetadata,\n  UpdateTokenMetadataField,\n  RemoveTokenMetadataKey,\n  UpdateTokenMetadataUpdateAuthority,\n  EmitTokenMetadata,\n  InitializeTokenGroup,\n  UpdateTokenGroupMaxSize,\n  UpdateTokenGroupUpdateAuthority,\n  InitializeTokenGroupMember,\n}\n\nexport function identifyToken2022Instruction(\n  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array\n): Token2022Instruction {\n  const data = 'data' in instruction ? instruction.data : instruction;\n  if (containsBytes(data, getU8Encoder().encode(0), 0)) {\n    return Token2022Instruction.InitializeMint;\n  }\n  if (containsBytes(data, getU8Encoder().encode(1), 0)) {\n    return Token2022Instruction.InitializeAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(2), 0)) {\n    return Token2022Instruction.InitializeMultisig;\n  }\n  if (containsBytes(data, getU8Encoder().encode(3), 0)) {\n    return Token2022Instruction.Transfer;\n  }\n  if (containsBytes(data, getU8Encoder().encode(4), 0)) {\n    return Token2022Instruction.Approve;\n  }\n  if (containsBytes(data, getU8Encoder().encode(5), 0)) {\n    return Token2022Instruction.Revoke;\n  }\n  if (containsBytes(data, getU8Encoder().encode(6), 0)) {\n    return Token2022Instruction.SetAuthority;\n  }\n  if (containsBytes(data, getU8Encoder().encode(7), 0)) {\n    return Token2022Instruction.MintTo;\n  }\n  if (containsBytes(data, getU8Encoder().encode(8), 0)) {\n    return Token2022Instruction.Burn;\n  }\n  if (containsBytes(data, getU8Encoder().encode(9), 0)) {\n    return Token2022Instruction.CloseAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(10), 0)) {\n    return Token2022Instruction.FreezeAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(11), 0)) {\n    return Token2022Instruction.ThawAccount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(12), 0)) {\n    return Token2022Instruction.TransferChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(13), 0)) {\n    return Token2022Instruction.ApproveChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(14), 0)) {\n    return Token2022Instruction.MintToChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(15), 0)) {\n    return Token2022Instruction.BurnChecked;\n  }\n  if (containsBytes(data, getU8Encoder().encode(16), 0)) {\n    return Token2022Instruction.InitializeAccount2;\n  }\n  if (containsBytes(data, getU8Encoder().encode(17), 0)) {\n    return Token2022Instruction.SyncNative;\n  }\n  if (containsBytes(data, getU8Encoder().encode(18), 0)) {\n    return Token2022Instruction.InitializeAccount3;\n  }\n  if (containsBytes(data, getU8Encoder().encode(19), 0)) {\n    return Token2022Instruction.InitializeMultisig2;\n  }\n  if (containsBytes(data, getU8Encoder().encode(20), 0)) {\n    return Token2022Instruction.InitializeMint2;\n  }\n  if (containsBytes(data, getU8Encoder().encode(21), 0)) {\n    return Token2022Instruction.GetAccountDataSize;\n  }\n  if (containsBytes(data, getU8Encoder().encode(22), 0)) {\n    return Token2022Instruction.InitializeImmutableOwner;\n  }\n  if (containsBytes(data, getU8Encoder().encode(23), 0)) {\n    return Token2022Instruction.AmountToUiAmount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(24), 0)) {\n    return Token2022Instruction.UiAmountToAmount;\n  }\n  if (containsBytes(data, getU8Encoder().encode(25), 0)) {\n    return Token2022Instruction.InitializeMintCloseAuthority;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(26), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeTransferFeeConfig;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(26), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.TransferCheckedWithFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(26), 0) &&\n    containsBytes(data, getU8Encoder().encode(2), 1)\n  ) {\n    return Token2022Instruction.WithdrawWithheldTokensFromMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(26), 0) &&\n    containsBytes(data, getU8Encoder().encode(3), 1)\n  ) {\n    return Token2022Instruction.WithdrawWithheldTokensFromAccounts;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(26), 0) &&\n    containsBytes(data, getU8Encoder().encode(4), 1)\n  ) {\n    return Token2022Instruction.HarvestWithheldTokensToMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(26), 0) &&\n    containsBytes(data, getU8Encoder().encode(5), 1)\n  ) {\n    return Token2022Instruction.SetTransferFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeConfidentialTransferMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateConfidentialTransferMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(2), 1)\n  ) {\n    return Token2022Instruction.ConfigureConfidentialTransferAccount;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(3), 1)\n  ) {\n    return Token2022Instruction.ApproveConfidentialTransferAccount;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(4), 1)\n  ) {\n    return Token2022Instruction.EmptyConfidentialTransferAccount;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(5), 1)\n  ) {\n    return Token2022Instruction.ConfidentialDeposit;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(6), 1)\n  ) {\n    return Token2022Instruction.ConfidentialWithdraw;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(7), 1)\n  ) {\n    return Token2022Instruction.ConfidentialTransfer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(8), 1)\n  ) {\n    return Token2022Instruction.ApplyConfidentialPendingBalance;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(9), 1)\n  ) {\n    return Token2022Instruction.EnableConfidentialCredits;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(10), 1)\n  ) {\n    return Token2022Instruction.DisableConfidentialCredits;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(11), 1)\n  ) {\n    return Token2022Instruction.EnableNonConfidentialCredits;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(12), 1)\n  ) {\n    return Token2022Instruction.DisableNonConfidentialCredits;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(27), 0) &&\n    containsBytes(data, getU8Encoder().encode(13), 1)\n  ) {\n    return Token2022Instruction.ConfidentialTransferWithFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(28), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeDefaultAccountState;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(28), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateDefaultAccountState;\n  }\n  if (containsBytes(data, getU8Encoder().encode(29), 0)) {\n    return Token2022Instruction.Reallocate;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(30), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.EnableMemoTransfers;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(30), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.DisableMemoTransfers;\n  }\n  if (containsBytes(data, getU8Encoder().encode(31), 0)) {\n    return Token2022Instruction.CreateNativeMint;\n  }\n  if (containsBytes(data, getU8Encoder().encode(32), 0)) {\n    return Token2022Instruction.InitializeNonTransferableMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(33), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeInterestBearingMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(33), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateRateInterestBearingMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(34), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.EnableCpiGuard;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(34), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.DisableCpiGuard;\n  }\n  if (containsBytes(data, getU8Encoder().encode(35), 0)) {\n    return Token2022Instruction.InitializePermanentDelegate;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(36), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeTransferHook;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(36), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateTransferHook;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(37), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeConfidentialTransferFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(37), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.WithdrawWithheldTokensFromMintForConfidentialTransferFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(37), 0) &&\n    containsBytes(data, getU8Encoder().encode(2), 1)\n  ) {\n    return Token2022Instruction.WithdrawWithheldTokensFromAccountsForConfidentialTransferFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(37), 0) &&\n    containsBytes(data, getU8Encoder().encode(3), 1)\n  ) {\n    return Token2022Instruction.HarvestWithheldTokensToMintForConfidentialTransferFee;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(37), 0) &&\n    containsBytes(data, getU8Encoder().encode(4), 1)\n  ) {\n    return Token2022Instruction.EnableHarvestToMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(37), 0) &&\n    containsBytes(data, getU8Encoder().encode(5), 1)\n  ) {\n    return Token2022Instruction.DisableHarvestToMint;\n  }\n  if (containsBytes(data, getU8Encoder().encode(38), 0)) {\n    return Token2022Instruction.WithdrawExcessLamports;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(39), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeMetadataPointer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(39), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateMetadataPointer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(40), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeGroupPointer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(40), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateGroupPointer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(41), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeGroupMemberPointer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(41), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateGroupMemberPointer;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(43), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializeScaledUiAmountMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(43), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.UpdateMultiplierScaledUiMint;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(44), 0) &&\n    containsBytes(data, getU8Encoder().encode(0), 1)\n  ) {\n    return Token2022Instruction.InitializePausableConfig;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(44), 0) &&\n    containsBytes(data, getU8Encoder().encode(1), 1)\n  ) {\n    return Token2022Instruction.Pause;\n  }\n  if (\n    containsBytes(data, getU8Encoder().encode(44), 0) &&\n    containsBytes(data, getU8Encoder().encode(2), 1)\n  ) {\n    return Token2022Instruction.Resume;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([210, 225, 30, 162, 88, 184, 77, 141]),\n      0\n    )\n  ) {\n    return Token2022Instruction.InitializeTokenMetadata;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([221, 233, 49, 45, 181, 202, 220, 200]),\n      0\n    )\n  ) {\n    return Token2022Instruction.UpdateTokenMetadataField;\n  }\n  if (\n    containsBytes(data, new Uint8Array([234, 18, 32, 56, 89, 141, 37, 181]), 0)\n  ) {\n    return Token2022Instruction.RemoveTokenMetadataKey;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([215, 228, 166, 228, 84, 100, 86, 123]),\n      0\n    )\n  ) {\n    return Token2022Instruction.UpdateTokenMetadataUpdateAuthority;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([250, 166, 180, 250, 13, 12, 184, 70]),\n      0\n    )\n  ) {\n    return Token2022Instruction.EmitTokenMetadata;\n  }\n  if (\n    containsBytes(data, new Uint8Array([121, 113, 108, 39, 54, 51, 0, 4]), 0)\n  ) {\n    return Token2022Instruction.InitializeTokenGroup;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([108, 37, 171, 143, 248, 30, 18, 110]),\n      0\n    )\n  ) {\n    return Token2022Instruction.UpdateTokenGroupMaxSize;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([161, 105, 88, 1, 237, 221, 216, 203]),\n      0\n    )\n  ) {\n    return Token2022Instruction.UpdateTokenGroupUpdateAuthority;\n  }\n  if (\n    containsBytes(\n      data,\n      new Uint8Array([152, 32, 222, 176, 223, 237, 116, 134]),\n      0\n    )\n  ) {\n    return Token2022Instruction.InitializeTokenGroupMember;\n  }\n  throw new Error(\n    'The provided instruction could not be identified as a token-2022 instruction.'\n  );\n}\n\nexport type ParsedToken2022Instruction<\n  TProgram extends string = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb',\n> =\n  | ({\n      instructionType: Token2022Instruction.InitializeMint;\n    } & ParsedInitializeMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeAccount;\n    } & ParsedInitializeAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeMultisig;\n    } & ParsedInitializeMultisigInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Transfer;\n    } & ParsedTransferInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Approve;\n    } & ParsedApproveInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Revoke;\n    } & ParsedRevokeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.SetAuthority;\n    } & ParsedSetAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.MintTo;\n    } & ParsedMintToInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Burn;\n    } & ParsedBurnInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.CloseAccount;\n    } & ParsedCloseAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.FreezeAccount;\n    } & ParsedFreezeAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ThawAccount;\n    } & ParsedThawAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.TransferChecked;\n    } & ParsedTransferCheckedInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ApproveChecked;\n    } & ParsedApproveCheckedInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.MintToChecked;\n    } & ParsedMintToCheckedInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.BurnChecked;\n    } & ParsedBurnCheckedInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeAccount2;\n    } & ParsedInitializeAccount2Instruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.SyncNative;\n    } & ParsedSyncNativeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeAccount3;\n    } & ParsedInitializeAccount3Instruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeMultisig2;\n    } & ParsedInitializeMultisig2Instruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeMint2;\n    } & ParsedInitializeMint2Instruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.GetAccountDataSize;\n    } & ParsedGetAccountDataSizeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeImmutableOwner;\n    } & ParsedInitializeImmutableOwnerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.AmountToUiAmount;\n    } & ParsedAmountToUiAmountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UiAmountToAmount;\n    } & ParsedUiAmountToAmountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeMintCloseAuthority;\n    } & ParsedInitializeMintCloseAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeTransferFeeConfig;\n    } & ParsedInitializeTransferFeeConfigInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.TransferCheckedWithFee;\n    } & ParsedTransferCheckedWithFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.WithdrawWithheldTokensFromMint;\n    } & ParsedWithdrawWithheldTokensFromMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.WithdrawWithheldTokensFromAccounts;\n    } & ParsedWithdrawWithheldTokensFromAccountsInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.HarvestWithheldTokensToMint;\n    } & ParsedHarvestWithheldTokensToMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.SetTransferFee;\n    } & ParsedSetTransferFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeConfidentialTransferMint;\n    } & ParsedInitializeConfidentialTransferMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateConfidentialTransferMint;\n    } & ParsedUpdateConfidentialTransferMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ConfigureConfidentialTransferAccount;\n    } & ParsedConfigureConfidentialTransferAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ApproveConfidentialTransferAccount;\n    } & ParsedApproveConfidentialTransferAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EmptyConfidentialTransferAccount;\n    } & ParsedEmptyConfidentialTransferAccountInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ConfidentialDeposit;\n    } & ParsedConfidentialDepositInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ConfidentialWithdraw;\n    } & ParsedConfidentialWithdrawInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ConfidentialTransfer;\n    } & ParsedConfidentialTransferInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ApplyConfidentialPendingBalance;\n    } & ParsedApplyConfidentialPendingBalanceInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EnableConfidentialCredits;\n    } & ParsedEnableConfidentialCreditsInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.DisableConfidentialCredits;\n    } & ParsedDisableConfidentialCreditsInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EnableNonConfidentialCredits;\n    } & ParsedEnableNonConfidentialCreditsInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.DisableNonConfidentialCredits;\n    } & ParsedDisableNonConfidentialCreditsInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.ConfidentialTransferWithFee;\n    } & ParsedConfidentialTransferWithFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeDefaultAccountState;\n    } & ParsedInitializeDefaultAccountStateInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateDefaultAccountState;\n    } & ParsedUpdateDefaultAccountStateInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Reallocate;\n    } & ParsedReallocateInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EnableMemoTransfers;\n    } & ParsedEnableMemoTransfersInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.DisableMemoTransfers;\n    } & ParsedDisableMemoTransfersInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.CreateNativeMint;\n    } & ParsedCreateNativeMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeNonTransferableMint;\n    } & ParsedInitializeNonTransferableMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeInterestBearingMint;\n    } & ParsedInitializeInterestBearingMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateRateInterestBearingMint;\n    } & ParsedUpdateRateInterestBearingMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EnableCpiGuard;\n    } & ParsedEnableCpiGuardInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.DisableCpiGuard;\n    } & ParsedDisableCpiGuardInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializePermanentDelegate;\n    } & ParsedInitializePermanentDelegateInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeTransferHook;\n    } & ParsedInitializeTransferHookInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateTransferHook;\n    } & ParsedUpdateTransferHookInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeConfidentialTransferFee;\n    } & ParsedInitializeConfidentialTransferFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.WithdrawWithheldTokensFromMintForConfidentialTransferFee;\n    } & ParsedWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.WithdrawWithheldTokensFromAccountsForConfidentialTransferFee;\n    } & ParsedWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.HarvestWithheldTokensToMintForConfidentialTransferFee;\n    } & ParsedHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EnableHarvestToMint;\n    } & ParsedEnableHarvestToMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.DisableHarvestToMint;\n    } & ParsedDisableHarvestToMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.WithdrawExcessLamports;\n    } & ParsedWithdrawExcessLamportsInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeMetadataPointer;\n    } & ParsedInitializeMetadataPointerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateMetadataPointer;\n    } & ParsedUpdateMetadataPointerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeGroupPointer;\n    } & ParsedInitializeGroupPointerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateGroupPointer;\n    } & ParsedUpdateGroupPointerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeGroupMemberPointer;\n    } & ParsedInitializeGroupMemberPointerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateGroupMemberPointer;\n    } & ParsedUpdateGroupMemberPointerInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeScaledUiAmountMint;\n    } & ParsedInitializeScaledUiAmountMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateMultiplierScaledUiMint;\n    } & ParsedUpdateMultiplierScaledUiMintInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializePausableConfig;\n    } & ParsedInitializePausableConfigInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Pause;\n    } & ParsedPauseInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.Resume;\n    } & ParsedResumeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeTokenMetadata;\n    } & ParsedInitializeTokenMetadataInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateTokenMetadataField;\n    } & ParsedUpdateTokenMetadataFieldInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.RemoveTokenMetadataKey;\n    } & ParsedRemoveTokenMetadataKeyInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateTokenMetadataUpdateAuthority;\n    } & ParsedUpdateTokenMetadataUpdateAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.EmitTokenMetadata;\n    } & ParsedEmitTokenMetadataInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeTokenGroup;\n    } & ParsedInitializeTokenGroupInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateTokenGroupMaxSize;\n    } & ParsedUpdateTokenGroupMaxSizeInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.UpdateTokenGroupUpdateAuthority;\n    } & ParsedUpdateTokenGroupUpdateAuthorityInstruction<TProgram>)\n  | ({\n      instructionType: Token2022Instruction.InitializeTokenGroupMember;\n    } & ParsedInitializeTokenGroupMemberInstruction<TProgram>);\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  isProgramError,\n  type Address,\n  type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n  type SolanaError,\n} from '@solana/kit';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\n\n/** InvalidOwner: Associated token account owner does not match address derivation */\nexport const ASSOCIATED_TOKEN_ERROR__INVALID_OWNER = 0x0; // 0\n\nexport type AssociatedTokenError = typeof ASSOCIATED_TOKEN_ERROR__INVALID_OWNER;\n\nlet associatedTokenErrorMessages:\n  | Record<AssociatedTokenError, string>\n  | undefined;\nif (process.env.NODE_ENV !== 'production') {\n  associatedTokenErrorMessages = {\n    [ASSOCIATED_TOKEN_ERROR__INVALID_OWNER]: `Associated token account owner does not match address derivation`,\n  };\n}\n\nexport function getAssociatedTokenErrorMessage(\n  code: AssociatedTokenError\n): string {\n  if (process.env.NODE_ENV !== 'production') {\n    return (\n      associatedTokenErrorMessages as Record<AssociatedTokenError, string>\n    )[code];\n  }\n\n  return 'Error message not available in production bundles.';\n}\n\nexport function isAssociatedTokenError<\n  TProgramErrorCode extends AssociatedTokenError,\n>(\n  error: unknown,\n  transactionMessage: {\n    instructions: Record<number, { programAddress: Address }>;\n  },\n  code?: TProgramErrorCode\n): error is SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> &\n  Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {\n  return isProgramError<TProgramErrorCode>(\n    error,\n    transactionMessage,\n    ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n    code\n  );\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  isProgramError,\n  type Address,\n  type SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n  type SolanaError,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\n\n/** NotRentExempt: Lamport balance below rent-exempt threshold */\nexport const TOKEN_2022_ERROR__NOT_RENT_EXEMPT = 0x0; // 0\n/** InsufficientFunds: Insufficient funds */\nexport const TOKEN_2022_ERROR__INSUFFICIENT_FUNDS = 0x1; // 1\n/** InvalidMint: Invalid Mint */\nexport const TOKEN_2022_ERROR__INVALID_MINT = 0x2; // 2\n/** MintMismatch: Account not associated with this Mint */\nexport const TOKEN_2022_ERROR__MINT_MISMATCH = 0x3; // 3\n/** OwnerMismatch: Owner does not match */\nexport const TOKEN_2022_ERROR__OWNER_MISMATCH = 0x4; // 4\n/** FixedSupply: Fixed supply */\nexport const TOKEN_2022_ERROR__FIXED_SUPPLY = 0x5; // 5\n/** AlreadyInUse: Already in use */\nexport const TOKEN_2022_ERROR__ALREADY_IN_USE = 0x6; // 6\n/** InvalidNumberOfProvidedSigners: Invalid number of provided signers */\nexport const TOKEN_2022_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS = 0x7; // 7\n/** InvalidNumberOfRequiredSigners: Invalid number of required signers */\nexport const TOKEN_2022_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS = 0x8; // 8\n/** UninitializedState: State is unititialized */\nexport const TOKEN_2022_ERROR__UNINITIALIZED_STATE = 0x9; // 9\n/** NativeNotSupported: Instruction does not support native tokens */\nexport const TOKEN_2022_ERROR__NATIVE_NOT_SUPPORTED = 0xa; // 10\n/** NonNativeHasBalance: Non-native account can only be closed if its balance is zero */\nexport const TOKEN_2022_ERROR__NON_NATIVE_HAS_BALANCE = 0xb; // 11\n/** InvalidInstruction: Invalid instruction */\nexport const TOKEN_2022_ERROR__INVALID_INSTRUCTION = 0xc; // 12\n/** InvalidState: State is invalid for requested operation */\nexport const TOKEN_2022_ERROR__INVALID_STATE = 0xd; // 13\n/** Overflow: Operation overflowed */\nexport const TOKEN_2022_ERROR__OVERFLOW = 0xe; // 14\n/** AuthorityTypeNotSupported: Account does not support specified authority type */\nexport const TOKEN_2022_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED = 0xf; // 15\n/** MintCannotFreeze: This token mint cannot freeze accounts */\nexport const TOKEN_2022_ERROR__MINT_CANNOT_FREEZE = 0x10; // 16\n/** AccountFrozen: Account is frozen */\nexport const TOKEN_2022_ERROR__ACCOUNT_FROZEN = 0x11; // 17\n/** MintDecimalsMismatch: The provided decimals value different from the Mint decimals */\nexport const TOKEN_2022_ERROR__MINT_DECIMALS_MISMATCH = 0x12; // 18\n/** NonNativeNotSupported: Instruction does not support non-native tokens */\nexport const TOKEN_2022_ERROR__NON_NATIVE_NOT_SUPPORTED = 0x13; // 19\n\nexport type Token2022Error =\n  | typeof TOKEN_2022_ERROR__ACCOUNT_FROZEN\n  | typeof TOKEN_2022_ERROR__ALREADY_IN_USE\n  | typeof TOKEN_2022_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED\n  | typeof TOKEN_2022_ERROR__FIXED_SUPPLY\n  | typeof TOKEN_2022_ERROR__INSUFFICIENT_FUNDS\n  | typeof TOKEN_2022_ERROR__INVALID_INSTRUCTION\n  | typeof TOKEN_2022_ERROR__INVALID_MINT\n  | typeof TOKEN_2022_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS\n  | typeof TOKEN_2022_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS\n  | typeof TOKEN_2022_ERROR__INVALID_STATE\n  | typeof TOKEN_2022_ERROR__MINT_CANNOT_FREEZE\n  | typeof TOKEN_2022_ERROR__MINT_DECIMALS_MISMATCH\n  | typeof TOKEN_2022_ERROR__MINT_MISMATCH\n  | typeof TOKEN_2022_ERROR__NATIVE_NOT_SUPPORTED\n  | typeof TOKEN_2022_ERROR__NON_NATIVE_HAS_BALANCE\n  | typeof TOKEN_2022_ERROR__NON_NATIVE_NOT_SUPPORTED\n  | typeof TOKEN_2022_ERROR__NOT_RENT_EXEMPT\n  | typeof TOKEN_2022_ERROR__OVERFLOW\n  | typeof TOKEN_2022_ERROR__OWNER_MISMATCH\n  | typeof TOKEN_2022_ERROR__UNINITIALIZED_STATE;\n\nlet token2022ErrorMessages: Record<Token2022Error, string> | undefined;\nif (process.env.NODE_ENV !== 'production') {\n  token2022ErrorMessages = {\n    [TOKEN_2022_ERROR__ACCOUNT_FROZEN]: `Account is frozen`,\n    [TOKEN_2022_ERROR__ALREADY_IN_USE]: `Already in use`,\n    [TOKEN_2022_ERROR__AUTHORITY_TYPE_NOT_SUPPORTED]: `Account does not support specified authority type`,\n    [TOKEN_2022_ERROR__FIXED_SUPPLY]: `Fixed supply`,\n    [TOKEN_2022_ERROR__INSUFFICIENT_FUNDS]: `Insufficient funds`,\n    [TOKEN_2022_ERROR__INVALID_INSTRUCTION]: `Invalid instruction`,\n    [TOKEN_2022_ERROR__INVALID_MINT]: `Invalid Mint`,\n    [TOKEN_2022_ERROR__INVALID_NUMBER_OF_PROVIDED_SIGNERS]: `Invalid number of provided signers`,\n    [TOKEN_2022_ERROR__INVALID_NUMBER_OF_REQUIRED_SIGNERS]: `Invalid number of required signers`,\n    [TOKEN_2022_ERROR__INVALID_STATE]: `State is invalid for requested operation`,\n    [TOKEN_2022_ERROR__MINT_CANNOT_FREEZE]: `This token mint cannot freeze accounts`,\n    [TOKEN_2022_ERROR__MINT_DECIMALS_MISMATCH]: `The provided decimals value different from the Mint decimals`,\n    [TOKEN_2022_ERROR__MINT_MISMATCH]: `Account not associated with this Mint`,\n    [TOKEN_2022_ERROR__NATIVE_NOT_SUPPORTED]: `Instruction does not support native tokens`,\n    [TOKEN_2022_ERROR__NON_NATIVE_HAS_BALANCE]: `Non-native account can only be closed if its balance is zero`,\n    [TOKEN_2022_ERROR__NON_NATIVE_NOT_SUPPORTED]: `Instruction does not support non-native tokens`,\n    [TOKEN_2022_ERROR__NOT_RENT_EXEMPT]: `Lamport balance below rent-exempt threshold`,\n    [TOKEN_2022_ERROR__OVERFLOW]: `Operation overflowed`,\n    [TOKEN_2022_ERROR__OWNER_MISMATCH]: `Owner does not match`,\n    [TOKEN_2022_ERROR__UNINITIALIZED_STATE]: `State is unititialized`,\n  };\n}\n\nexport function getToken2022ErrorMessage(code: Token2022Error): string {\n  if (process.env.NODE_ENV !== 'production') {\n    return (token2022ErrorMessages as Record<Token2022Error, string>)[code];\n  }\n\n  return 'Error message not available in production bundles.';\n}\n\nexport function isToken2022Error<TProgramErrorCode extends Token2022Error>(\n  error: unknown,\n  transactionMessage: {\n    instructions: Record<number, { programAddress: Address }>;\n  },\n  code?: TProgramErrorCode\n): error is SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> &\n  Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> {\n  return isProgramError<TProgramErrorCode>(\n    error,\n    transactionMessage,\n    TOKEN_2022_PROGRAM_ADDRESS,\n    code\n  );\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  isProgramDerivedAddress,\n  isTransactionSigner as kitIsTransactionSigner,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type ProgramDerivedAddress,\n  type TransactionSigner,\n  upgradeRoleToSigner,\n} from '@solana/kit';\n\n/**\n * Asserts that the given value is not null or undefined.\n * @internal\n */\nexport function expectSome<T>(value: T | null | undefined): T {\n  if (value === null || value === undefined) {\n    throw new Error('Expected a value but received null or undefined.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a PublicKey.\n * @internal\n */\nexport function expectAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): Address<T> {\n  if (!value) {\n    throw new Error('Expected a Address.');\n  }\n  if (typeof value === 'object' && 'address' in value) {\n    return value.address;\n  }\n  if (Array.isArray(value)) {\n    return value[0] as Address<T>;\n  }\n  return value as Address<T>;\n}\n\n/**\n * Asserts that the given value is a PDA.\n * @internal\n */\nexport function expectProgramDerivedAddress<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): ProgramDerivedAddress<T> {\n  if (!value || !Array.isArray(value) || !isProgramDerivedAddress(value)) {\n    throw new Error('Expected a ProgramDerivedAddress.');\n  }\n  return value;\n}\n\n/**\n * Asserts that the given value is a TransactionSigner.\n * @internal\n */\nexport function expectTransactionSigner<T extends string = string>(\n  value:\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null\n    | undefined\n): TransactionSigner<T> {\n  if (!value || !isTransactionSigner(value)) {\n    throw new Error('Expected a TransactionSigner.');\n  }\n  return value;\n}\n\n/**\n * Defines an instruction account to resolve.\n * @internal\n */\nexport type ResolvedAccount<\n  T extends string = string,\n  U extends\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null =\n    | Address<T>\n    | ProgramDerivedAddress<T>\n    | TransactionSigner<T>\n    | null,\n> = {\n  isWritable: boolean;\n  value: U;\n};\n\n/**\n * Defines an instruction that stores additional bytes on-chain.\n * @internal\n */\nexport type InstructionWithByteDelta = {\n  byteDelta: number;\n};\n\n/**\n * Get account metas and signers from resolved accounts.\n * @internal\n */\nexport function getAccountMetaFactory(\n  programAddress: Address,\n  optionalAccountStrategy: 'omitted' | 'programId'\n) {\n  return (\n    account: ResolvedAccount\n  ): AccountMeta | AccountSignerMeta | undefined => {\n    if (!account.value) {\n      if (optionalAccountStrategy === 'omitted') return;\n      return Object.freeze({\n        address: programAddress,\n        role: AccountRole.READONLY,\n      });\n    }\n\n    const writableRole = account.isWritable\n      ? AccountRole.WRITABLE\n      : AccountRole.READONLY;\n    return Object.freeze({\n      address: expectAddress(account.value),\n      role: isTransactionSigner(account.value)\n        ? upgradeRoleToSigner(writableRole)\n        : writableRole,\n      ...(isTransactionSigner(account.value) ? { signer: account.value } : {}),\n    });\n  };\n}\n\nexport function isTransactionSigner<TAddress extends string = string>(\n  value:\n    | Address<TAddress>\n    | ProgramDerivedAddress<TAddress>\n    | TransactionSigner<TAddress>\n): value is TransactionSigner<TAddress> {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    'address' in value &&\n    kitIsTransactionSigner(value)\n  );\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR = 23;\n\nexport function getAmountToUiAmountDiscriminatorBytes() {\n  return getU8Encoder().encode(AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR);\n}\n\nexport type AmountToUiAmountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type AmountToUiAmountInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to reformat. */\n  amount: bigint;\n};\n\nexport type AmountToUiAmountInstructionDataArgs = {\n  /** The amount of tokens to reformat. */\n  amount: number | bigint;\n};\n\nexport function getAmountToUiAmountInstructionDataEncoder(): FixedSizeEncoder<AmountToUiAmountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: AMOUNT_TO_UI_AMOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getAmountToUiAmountInstructionDataDecoder(): FixedSizeDecoder<AmountToUiAmountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getAmountToUiAmountInstructionDataCodec(): FixedSizeCodec<\n  AmountToUiAmountInstructionDataArgs,\n  AmountToUiAmountInstructionData\n> {\n  return combineCodec(\n    getAmountToUiAmountInstructionDataEncoder(),\n    getAmountToUiAmountInstructionDataDecoder()\n  );\n}\n\nexport type AmountToUiAmountInput<TAccountMint extends string = string> = {\n  /** The mint to calculate for. */\n  mint: Address<TAccountMint>;\n  amount: AmountToUiAmountInstructionDataArgs['amount'];\n};\n\nexport function getAmountToUiAmountInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: AmountToUiAmountInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): AmountToUiAmountInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getAmountToUiAmountInstructionDataEncoder().encode(\n      args as AmountToUiAmountInstructionDataArgs\n    ),\n    programAddress,\n  } as AmountToUiAmountInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedAmountToUiAmountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to calculate for. */\n    mint: TAccountMetas[0];\n  };\n  data: AmountToUiAmountInstructionData;\n};\n\nexport function parseAmountToUiAmountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedAmountToUiAmountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getAmountToUiAmountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const APPLY_CONFIDENTIAL_PENDING_BALANCE_DISCRIMINATOR = 27;\n\nexport function getApplyConfidentialPendingBalanceDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    APPLY_CONFIDENTIAL_PENDING_BALANCE_DISCRIMINATOR\n  );\n}\n\nexport const APPLY_CONFIDENTIAL_PENDING_BALANCE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 8;\n\nexport function getApplyConfidentialPendingBalanceConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    APPLY_CONFIDENTIAL_PENDING_BALANCE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ApplyConfidentialPendingBalanceInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ApplyConfidentialPendingBalanceInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /**\n   * The expected number of pending balance credits since the last successful\n   * `ApplyPendingBalance` instruction\n   */\n  expectedPendingBalanceCreditCounter: bigint;\n  /**\n   * The new decryptable balance if the pending balance is applied\n   * successfully\n   */\n  newDecryptableAvailableBalance: DecryptableBalance;\n};\n\nexport type ApplyConfidentialPendingBalanceInstructionDataArgs = {\n  /**\n   * The expected number of pending balance credits since the last successful\n   * `ApplyPendingBalance` instruction\n   */\n  expectedPendingBalanceCreditCounter: number | bigint;\n  /**\n   * The new decryptable balance if the pending balance is applied\n   * successfully\n   */\n  newDecryptableAvailableBalance: DecryptableBalanceArgs;\n};\n\nexport function getApplyConfidentialPendingBalanceInstructionDataEncoder(): FixedSizeEncoder<ApplyConfidentialPendingBalanceInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['expectedPendingBalanceCreditCounter', getU64Encoder()],\n      ['newDecryptableAvailableBalance', getDecryptableBalanceEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: APPLY_CONFIDENTIAL_PENDING_BALANCE_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        APPLY_CONFIDENTIAL_PENDING_BALANCE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getApplyConfidentialPendingBalanceInstructionDataDecoder(): FixedSizeDecoder<ApplyConfidentialPendingBalanceInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['expectedPendingBalanceCreditCounter', getU64Decoder()],\n    ['newDecryptableAvailableBalance', getDecryptableBalanceDecoder()],\n  ]);\n}\n\nexport function getApplyConfidentialPendingBalanceInstructionDataCodec(): FixedSizeCodec<\n  ApplyConfidentialPendingBalanceInstructionDataArgs,\n  ApplyConfidentialPendingBalanceInstructionData\n> {\n  return combineCodec(\n    getApplyConfidentialPendingBalanceInstructionDataEncoder(),\n    getApplyConfidentialPendingBalanceInstructionDataDecoder()\n  );\n}\n\nexport type ApplyConfidentialPendingBalanceInput<\n  TAccountToken extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  expectedPendingBalanceCreditCounter: ApplyConfidentialPendingBalanceInstructionDataArgs['expectedPendingBalanceCreditCounter'];\n  newDecryptableAvailableBalance: ApplyConfidentialPendingBalanceInstructionDataArgs['newDecryptableAvailableBalance'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getApplyConfidentialPendingBalanceInstruction<\n  TAccountToken extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ApplyConfidentialPendingBalanceInput<TAccountToken, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): ApplyConfidentialPendingBalanceInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getApplyConfidentialPendingBalanceInstructionDataEncoder().encode(\n      args as ApplyConfidentialPendingBalanceInstructionDataArgs\n    ),\n    programAddress,\n  } as ApplyConfidentialPendingBalanceInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedApplyConfidentialPendingBalanceInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[1];\n  };\n  data: ApplyConfidentialPendingBalanceInstructionData;\n};\n\nexport function parseApplyConfidentialPendingBalanceInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedApplyConfidentialPendingBalanceInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), authority: getNextAccount() },\n    data: getApplyConfidentialPendingBalanceInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const APPROVE_DISCRIMINATOR = 4;\n\nexport function getApproveDiscriminatorBytes() {\n  return getU8Encoder().encode(APPROVE_DISCRIMINATOR);\n}\n\nexport type ApproveInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountDelegate extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountDelegate extends string\n        ? ReadonlyAccount<TAccountDelegate>\n        : TAccountDelegate,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ApproveInstructionData = {\n  discriminator: number;\n  /** The amount of tokens the delegate is approved for. */\n  amount: bigint;\n};\n\nexport type ApproveInstructionDataArgs = {\n  /** The amount of tokens the delegate is approved for. */\n  amount: number | bigint;\n};\n\nexport function getApproveInstructionDataEncoder(): FixedSizeEncoder<ApproveInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: APPROVE_DISCRIMINATOR })\n  );\n}\n\nexport function getApproveInstructionDataDecoder(): FixedSizeDecoder<ApproveInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getApproveInstructionDataCodec(): FixedSizeCodec<\n  ApproveInstructionDataArgs,\n  ApproveInstructionData\n> {\n  return combineCodec(\n    getApproveInstructionDataEncoder(),\n    getApproveInstructionDataDecoder()\n  );\n}\n\nexport type ApproveInput<\n  TAccountSource extends string = string,\n  TAccountDelegate extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The delegate. */\n  delegate: Address<TAccountDelegate>;\n  /** The source account owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  amount: ApproveInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getApproveInstruction<\n  TAccountSource extends string,\n  TAccountDelegate extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ApproveInput<TAccountSource, TAccountDelegate, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): ApproveInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountDelegate,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    delegate: { value: input.delegate ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.delegate),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getApproveInstructionDataEncoder().encode(\n      args as ApproveInstructionDataArgs\n    ),\n    programAddress,\n  } as ApproveInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountDelegate,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedApproveInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The delegate. */\n    delegate: TAccountMetas[1];\n    /** The source account owner or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: ApproveInstructionData;\n};\n\nexport function parseApproveInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedApproveInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      delegate: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getApproveInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const APPROVE_CHECKED_DISCRIMINATOR = 13;\n\nexport function getApproveCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(APPROVE_CHECKED_DISCRIMINATOR);\n}\n\nexport type ApproveCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountDelegate extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDelegate extends string\n        ? ReadonlyAccount<TAccountDelegate>\n        : TAccountDelegate,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ApproveCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of tokens the delegate is approved for. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type ApproveCheckedInstructionDataArgs = {\n  /** The amount of tokens the delegate is approved for. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getApproveCheckedInstructionDataEncoder(): FixedSizeEncoder<ApproveCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: APPROVE_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getApproveCheckedInstructionDataDecoder(): FixedSizeDecoder<ApproveCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getApproveCheckedInstructionDataCodec(): FixedSizeCodec<\n  ApproveCheckedInstructionDataArgs,\n  ApproveCheckedInstructionData\n> {\n  return combineCodec(\n    getApproveCheckedInstructionDataEncoder(),\n    getApproveCheckedInstructionDataDecoder()\n  );\n}\n\nexport type ApproveCheckedInput<\n  TAccountSource extends string = string,\n  TAccountMint extends string = string,\n  TAccountDelegate extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The delegate. */\n  delegate: Address<TAccountDelegate>;\n  /** The source account owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  amount: ApproveCheckedInstructionDataArgs['amount'];\n  decimals: ApproveCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getApproveCheckedInstruction<\n  TAccountSource extends string,\n  TAccountMint extends string,\n  TAccountDelegate extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ApproveCheckedInput<\n    TAccountSource,\n    TAccountMint,\n    TAccountDelegate,\n    TAccountOwner\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ApproveCheckedInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountMint,\n  TAccountDelegate,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    delegate: { value: input.delegate ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.delegate),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getApproveCheckedInstructionDataEncoder().encode(\n      args as ApproveCheckedInstructionDataArgs\n    ),\n    programAddress,\n  } as ApproveCheckedInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountMint,\n    TAccountDelegate,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedApproveCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The delegate. */\n    delegate: TAccountMetas[2];\n    /** The source account owner or its multisignature account. */\n    owner: TAccountMetas[3];\n  };\n  data: ApproveCheckedInstructionData;\n};\n\nexport function parseApproveCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedApproveCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      mint: getNextAccount(),\n      delegate: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getApproveCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR = 27;\n\nexport function getApproveConfidentialTransferAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR\n  );\n}\n\nexport const APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 3;\n\nexport function getApproveConfidentialTransferAccountConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ApproveConfidentialTransferAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlySignerAccount<TAccountAuthority> &\n            AccountSignerMeta<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ApproveConfidentialTransferAccountInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n};\n\nexport type ApproveConfidentialTransferAccountInstructionDataArgs = {};\n\nexport function getApproveConfidentialTransferAccountInstructionDataEncoder(): FixedSizeEncoder<ApproveConfidentialTransferAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        APPROVE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getApproveConfidentialTransferAccountInstructionDataDecoder(): FixedSizeDecoder<ApproveConfidentialTransferAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getApproveConfidentialTransferAccountInstructionDataCodec(): FixedSizeCodec<\n  ApproveConfidentialTransferAccountInstructionDataArgs,\n  ApproveConfidentialTransferAccountInstructionData\n> {\n  return combineCodec(\n    getApproveConfidentialTransferAccountInstructionDataEncoder(),\n    getApproveConfidentialTransferAccountInstructionDataDecoder()\n  );\n}\n\nexport type ApproveConfidentialTransferAccountInput<\n  TAccountToken extends string = string,\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account to approve. */\n  token: Address<TAccountToken>;\n  /** The corresponding SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /** Confidential transfer mint authority. */\n  authority: TransactionSigner<TAccountAuthority>;\n};\n\nexport function getApproveConfidentialTransferAccountInstruction<\n  TAccountToken extends string,\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ApproveConfidentialTransferAccountInput<\n    TAccountToken,\n    TAccountMint,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ApproveConfidentialTransferAccountInstruction<\n  TProgramAddress,\n  TAccountToken,\n  TAccountMint,\n  TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n    ],\n    data: getApproveConfidentialTransferAccountInstructionDataEncoder().encode(\n      {}\n    ),\n    programAddress,\n  } as ApproveConfidentialTransferAccountInstruction<\n    TProgramAddress,\n    TAccountToken,\n    TAccountMint,\n    TAccountAuthority\n  >);\n}\n\nexport type ParsedApproveConfidentialTransferAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account to approve. */\n    token: TAccountMetas[0];\n    /** The corresponding SPL Token mint. */\n    mint: TAccountMetas[1];\n    /** Confidential transfer mint authority. */\n    authority: TAccountMetas[2];\n  };\n  data: ApproveConfidentialTransferAccountInstructionData;\n};\n\nexport function parseApproveConfidentialTransferAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedApproveConfidentialTransferAccountInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getApproveConfidentialTransferAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const BURN_DISCRIMINATOR = 8;\n\nexport function getBurnDiscriminatorBytes() {\n  return getU8Encoder().encode(BURN_DISCRIMINATOR);\n}\n\nexport type BurnInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type BurnInstructionData = {\n  /** The amount of tokens to burn. */\n  discriminator: number;\n  amount: bigint;\n};\n\nexport type BurnInstructionDataArgs = { amount: number | bigint };\n\nexport function getBurnInstructionDataEncoder(): FixedSizeEncoder<BurnInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: BURN_DISCRIMINATOR })\n  );\n}\n\nexport function getBurnInstructionDataDecoder(): FixedSizeDecoder<BurnInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getBurnInstructionDataCodec(): FixedSizeCodec<\n  BurnInstructionDataArgs,\n  BurnInstructionData\n> {\n  return combineCodec(\n    getBurnInstructionDataEncoder(),\n    getBurnInstructionDataDecoder()\n  );\n}\n\nexport type BurnInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The account to burn from. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: BurnInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getBurnInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: BurnInput<TAccountAccount, TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): BurnInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getBurnInstructionDataEncoder().encode(\n      args as BurnInstructionDataArgs\n    ),\n    programAddress,\n  } as BurnInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedBurnInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to burn from. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: BurnInstructionData;\n};\n\nexport function parseBurnInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedBurnInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getBurnInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const BURN_CHECKED_DISCRIMINATOR = 15;\n\nexport function getBurnCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(BURN_CHECKED_DISCRIMINATOR);\n}\n\nexport type BurnCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type BurnCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to burn. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type BurnCheckedInstructionDataArgs = {\n  /** The amount of tokens to burn. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getBurnCheckedInstructionDataEncoder(): FixedSizeEncoder<BurnCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: BURN_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getBurnCheckedInstructionDataDecoder(): FixedSizeDecoder<BurnCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getBurnCheckedInstructionDataCodec(): FixedSizeCodec<\n  BurnCheckedInstructionDataArgs,\n  BurnCheckedInstructionData\n> {\n  return combineCodec(\n    getBurnCheckedInstructionDataEncoder(),\n    getBurnCheckedInstructionDataDecoder()\n  );\n}\n\nexport type BurnCheckedInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The account to burn from. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: BurnCheckedInstructionDataArgs['amount'];\n  decimals: BurnCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getBurnCheckedInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: BurnCheckedInput<TAccountAccount, TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): BurnCheckedInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getBurnCheckedInstructionDataEncoder().encode(\n      args as BurnCheckedInstructionDataArgs\n    ),\n    programAddress,\n  } as BurnCheckedInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedBurnCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to burn from. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: BurnCheckedInstructionData;\n};\n\nexport function parseBurnCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedBurnCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getBurnCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const CLOSE_ACCOUNT_DISCRIMINATOR = 9;\n\nexport function getCloseAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(CLOSE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type CloseAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountDestination extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CloseAccountInstructionData = { discriminator: number };\n\nexport type CloseAccountInstructionDataArgs = {};\n\nexport function getCloseAccountInstructionDataEncoder(): FixedSizeEncoder<CloseAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: CLOSE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getCloseAccountInstructionDataDecoder(): FixedSizeDecoder<CloseAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCloseAccountInstructionDataCodec(): FixedSizeCodec<\n  CloseAccountInstructionDataArgs,\n  CloseAccountInstructionData\n> {\n  return combineCodec(\n    getCloseAccountInstructionDataEncoder(),\n    getCloseAccountInstructionDataDecoder()\n  );\n}\n\nexport type CloseAccountInput<\n  TAccountAccount extends string = string,\n  TAccountDestination extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The account to close. */\n  account: Address<TAccountAccount>;\n  /** The destination account. */\n  destination: Address<TAccountDestination>;\n  /** The account's owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getCloseAccountInstruction<\n  TAccountAccount extends string,\n  TAccountDestination extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: CloseAccountInput<TAccountAccount, TAccountDestination, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): CloseAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountDestination,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getCloseAccountInstructionDataEncoder().encode({}),\n    programAddress,\n  } as CloseAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountDestination,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedCloseAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to close. */\n    account: TAccountMetas[0];\n    /** The destination account. */\n    destination: TAccountMetas[1];\n    /** The account's owner or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: CloseAccountInstructionData;\n};\n\nexport function parseCloseAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedCloseAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      destination: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getCloseAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const CONFIDENTIAL_DEPOSIT_DISCRIMINATOR = 27;\n\nexport function getConfidentialDepositDiscriminatorBytes() {\n  return getU8Encoder().encode(CONFIDENTIAL_DEPOSIT_DISCRIMINATOR);\n}\n\nexport const CONFIDENTIAL_DEPOSIT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 5;\n\nexport function getConfidentialDepositConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIDENTIAL_DEPOSIT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ConfidentialDepositInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ConfidentialDepositInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /** The amount of tokens to deposit. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type ConfidentialDepositInstructionDataArgs = {\n  /** The amount of tokens to deposit. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getConfidentialDepositInstructionDataEncoder(): FixedSizeEncoder<ConfidentialDepositInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIDENTIAL_DEPOSIT_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        CONFIDENTIAL_DEPOSIT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getConfidentialDepositInstructionDataDecoder(): FixedSizeDecoder<ConfidentialDepositInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getConfidentialDepositInstructionDataCodec(): FixedSizeCodec<\n  ConfidentialDepositInstructionDataArgs,\n  ConfidentialDepositInstructionData\n> {\n  return combineCodec(\n    getConfidentialDepositInstructionDataEncoder(),\n    getConfidentialDepositInstructionDataDecoder()\n  );\n}\n\nexport type ConfidentialDepositInput<\n  TAccountToken extends string = string,\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The corresponding SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: ConfidentialDepositInstructionDataArgs['amount'];\n  decimals: ConfidentialDepositInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getConfidentialDepositInstruction<\n  TAccountToken extends string,\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ConfidentialDepositInput<\n    TAccountToken,\n    TAccountMint,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ConfidentialDepositInstruction<\n  TProgramAddress,\n  TAccountToken,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getConfidentialDepositInstructionDataEncoder().encode(\n      args as ConfidentialDepositInstructionDataArgs\n    ),\n    programAddress,\n  } as ConfidentialDepositInstruction<\n    TProgramAddress,\n    TAccountToken,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedConfidentialDepositInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The corresponding SPL Token mint. */\n    mint: TAccountMetas[1];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: ConfidentialDepositInstructionData;\n};\n\nexport function parseConfidentialDepositInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedConfidentialDepositInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      mint: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getConfidentialDepositInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 27;\n\nexport function getConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(CONFIDENTIAL_TRANSFER_DISCRIMINATOR);\n}\n\nexport const CONFIDENTIAL_TRANSFER_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 7;\n\nexport function getConfidentialTransferConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIDENTIAL_TRANSFER_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ConfidentialTransferInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSourceToken extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountDestinationToken extends string | AccountMeta<string> = string,\n  TAccountInstructionsSysvar extends string | AccountMeta<string> = string,\n  TAccountEqualityRecord extends string | AccountMeta<string> = string,\n  TAccountCiphertextValidityRecord extends\n    | string\n    | AccountMeta<string> = string,\n  TAccountRangeRecord extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSourceToken extends string\n        ? WritableAccount<TAccountSourceToken>\n        : TAccountSourceToken,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestinationToken extends string\n        ? WritableAccount<TAccountDestinationToken>\n        : TAccountDestinationToken,\n      TAccountInstructionsSysvar extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvar>\n        : TAccountInstructionsSysvar,\n      TAccountEqualityRecord extends string\n        ? ReadonlyAccount<TAccountEqualityRecord>\n        : TAccountEqualityRecord,\n      TAccountCiphertextValidityRecord extends string\n        ? ReadonlyAccount<TAccountCiphertextValidityRecord>\n        : TAccountCiphertextValidityRecord,\n      TAccountRangeRecord extends string\n        ? ReadonlyAccount<TAccountRangeRecord>\n        : TAccountRangeRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ConfidentialTransferInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /** The new source decryptable balance if the transfer succeeds. */\n  newSourceDecryptableAvailableBalance: DecryptableBalance;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyCiphertextCommitmentEquality` instruction\n   * to the `Transfer` instruction in the transaction. If the offset is\n   * `0`, then use a context state account for the proof.\n   */\n  equalityProofInstructionOffset: number;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyBatchedGroupedCiphertext3HandlesValidity`\n   * instruction to the `Transfer` instruction in the transaction. If the\n   * offset is `0`, then use a context state account for the proof.\n   */\n  ciphertextValidityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::BatchedRangeProofU128Data`\n   * instruction to the `Transfer` instruction in the transaction. If the\n   * offset is `0`, then use a context state account for the proof.\n   */\n  rangeProofInstructionOffset: number;\n};\n\nexport type ConfidentialTransferInstructionDataArgs = {\n  /** The new source decryptable balance if the transfer succeeds. */\n  newSourceDecryptableAvailableBalance: DecryptableBalanceArgs;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyCiphertextCommitmentEquality` instruction\n   * to the `Transfer` instruction in the transaction. If the offset is\n   * `0`, then use a context state account for the proof.\n   */\n  equalityProofInstructionOffset: number;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyBatchedGroupedCiphertext3HandlesValidity`\n   * instruction to the `Transfer` instruction in the transaction. If the\n   * offset is `0`, then use a context state account for the proof.\n   */\n  ciphertextValidityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::BatchedRangeProofU128Data`\n   * instruction to the `Transfer` instruction in the transaction. If the\n   * offset is `0`, then use a context state account for the proof.\n   */\n  rangeProofInstructionOffset: number;\n};\n\nexport function getConfidentialTransferInstructionDataEncoder(): FixedSizeEncoder<ConfidentialTransferInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['newSourceDecryptableAvailableBalance', getDecryptableBalanceEncoder()],\n      ['equalityProofInstructionOffset', getI8Encoder()],\n      ['ciphertextValidityProofInstructionOffset', getI8Encoder()],\n      ['rangeProofInstructionOffset', getI8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        CONFIDENTIAL_TRANSFER_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getConfidentialTransferInstructionDataDecoder(): FixedSizeDecoder<ConfidentialTransferInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['newSourceDecryptableAvailableBalance', getDecryptableBalanceDecoder()],\n    ['equalityProofInstructionOffset', getI8Decoder()],\n    ['ciphertextValidityProofInstructionOffset', getI8Decoder()],\n    ['rangeProofInstructionOffset', getI8Decoder()],\n  ]);\n}\n\nexport function getConfidentialTransferInstructionDataCodec(): FixedSizeCodec<\n  ConfidentialTransferInstructionDataArgs,\n  ConfidentialTransferInstructionData\n> {\n  return combineCodec(\n    getConfidentialTransferInstructionDataEncoder(),\n    getConfidentialTransferInstructionDataDecoder()\n  );\n}\n\nexport type ConfidentialTransferInput<\n  TAccountSourceToken extends string = string,\n  TAccountMint extends string = string,\n  TAccountDestinationToken extends string = string,\n  TAccountInstructionsSysvar extends string = string,\n  TAccountEqualityRecord extends string = string,\n  TAccountCiphertextValidityRecord extends string = string,\n  TAccountRangeRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source SPL Token account. */\n  sourceToken: Address<TAccountSourceToken>;\n  /** The corresponding SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /** The destination SPL Token account. */\n  destinationToken: Address<TAccountDestinationToken>;\n  /**\n   * (Optional) Instructions sysvar if at least one of the\n   * `zk_elgamal_proof` instructions are included in the same\n   * transaction.\n   */\n  instructionsSysvar?: Address<TAccountInstructionsSysvar>;\n  /** (Optional) Equality proof record account or context state account. */\n  equalityRecord?: Address<TAccountEqualityRecord>;\n  /** (Optional) Ciphertext validity proof record account or context state account. */\n  ciphertextValidityRecord?: Address<TAccountCiphertextValidityRecord>;\n  /** (Optional) Range proof record account or context state account. */\n  rangeRecord?: Address<TAccountRangeRecord>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  newSourceDecryptableAvailableBalance: ConfidentialTransferInstructionDataArgs['newSourceDecryptableAvailableBalance'];\n  equalityProofInstructionOffset: ConfidentialTransferInstructionDataArgs['equalityProofInstructionOffset'];\n  ciphertextValidityProofInstructionOffset: ConfidentialTransferInstructionDataArgs['ciphertextValidityProofInstructionOffset'];\n  rangeProofInstructionOffset: ConfidentialTransferInstructionDataArgs['rangeProofInstructionOffset'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getConfidentialTransferInstruction<\n  TAccountSourceToken extends string,\n  TAccountMint extends string,\n  TAccountDestinationToken extends string,\n  TAccountInstructionsSysvar extends string,\n  TAccountEqualityRecord extends string,\n  TAccountCiphertextValidityRecord extends string,\n  TAccountRangeRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ConfidentialTransferInput<\n    TAccountSourceToken,\n    TAccountMint,\n    TAccountDestinationToken,\n    TAccountInstructionsSysvar,\n    TAccountEqualityRecord,\n    TAccountCiphertextValidityRecord,\n    TAccountRangeRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ConfidentialTransferInstruction<\n  TProgramAddress,\n  TAccountSourceToken,\n  TAccountMint,\n  TAccountDestinationToken,\n  TAccountInstructionsSysvar,\n  TAccountEqualityRecord,\n  TAccountCiphertextValidityRecord,\n  TAccountRangeRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    sourceToken: { value: input.sourceToken ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    destinationToken: {\n      value: input.destinationToken ?? null,\n      isWritable: true,\n    },\n    instructionsSysvar: {\n      value: input.instructionsSysvar ?? null,\n      isWritable: false,\n    },\n    equalityRecord: { value: input.equalityRecord ?? null, isWritable: false },\n    ciphertextValidityRecord: {\n      value: input.ciphertextValidityRecord ?? null,\n      isWritable: false,\n    },\n    rangeRecord: { value: input.rangeRecord ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.sourceToken),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destinationToken),\n      getAccountMeta(accounts.instructionsSysvar),\n      getAccountMeta(accounts.equalityRecord),\n      getAccountMeta(accounts.ciphertextValidityRecord),\n      getAccountMeta(accounts.rangeRecord),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getConfidentialTransferInstructionDataEncoder().encode(\n      args as ConfidentialTransferInstructionDataArgs\n    ),\n    programAddress,\n  } as ConfidentialTransferInstruction<\n    TProgramAddress,\n    TAccountSourceToken,\n    TAccountMint,\n    TAccountDestinationToken,\n    TAccountInstructionsSysvar,\n    TAccountEqualityRecord,\n    TAccountCiphertextValidityRecord,\n    TAccountRangeRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedConfidentialTransferInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source SPL Token account. */\n    sourceToken: TAccountMetas[0];\n    /** The corresponding SPL Token mint. */\n    mint: TAccountMetas[1];\n    /** The destination SPL Token account. */\n    destinationToken: TAccountMetas[2];\n    /**\n     * (Optional) Instructions sysvar if at least one of the\n     * `zk_elgamal_proof` instructions are included in the same\n     * transaction.\n     */\n    instructionsSysvar?: TAccountMetas[3] | undefined;\n    /** (Optional) Equality proof record account or context state account. */\n    equalityRecord?: TAccountMetas[4] | undefined;\n    /** (Optional) Ciphertext validity proof record account or context state account. */\n    ciphertextValidityRecord?: TAccountMetas[5] | undefined;\n    /** (Optional) Range proof record account or context state account. */\n    rangeRecord?: TAccountMetas[6] | undefined;\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[7];\n  };\n  data: ConfidentialTransferInstructionData;\n};\n\nexport function parseConfidentialTransferInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedConfidentialTransferInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 8) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      sourceToken: getNextAccount(),\n      mint: getNextAccount(),\n      destinationToken: getNextAccount(),\n      instructionsSysvar: getNextOptionalAccount(),\n      equalityRecord: getNextOptionalAccount(),\n      ciphertextValidityRecord: getNextOptionalAccount(),\n      rangeRecord: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getConfidentialTransferInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const CONFIDENTIAL_TRANSFER_WITH_FEE_DISCRIMINATOR = 27;\n\nexport function getConfidentialTransferWithFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(CONFIDENTIAL_TRANSFER_WITH_FEE_DISCRIMINATOR);\n}\n\nexport const CONFIDENTIAL_TRANSFER_WITH_FEE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 13;\n\nexport function getConfidentialTransferWithFeeConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIDENTIAL_TRANSFER_WITH_FEE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ConfidentialTransferWithFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSourceToken extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountDestinationToken extends string | AccountMeta<string> = string,\n  TAccountInstructionsSysvar extends string | AccountMeta<string> = string,\n  TAccountEqualityRecord extends string | AccountMeta<string> = string,\n  TAccountTransferAmountCiphertextValidityRecord extends\n    | string\n    | AccountMeta<string> = string,\n  TAccountFeeSigmaRecord extends string | AccountMeta<string> = string,\n  TAccountFeeCiphertextValidityRecord extends\n    | string\n    | AccountMeta<string> = string,\n  TAccountRangeRecord extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSourceToken extends string\n        ? WritableAccount<TAccountSourceToken>\n        : TAccountSourceToken,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestinationToken extends string\n        ? WritableAccount<TAccountDestinationToken>\n        : TAccountDestinationToken,\n      TAccountInstructionsSysvar extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvar>\n        : TAccountInstructionsSysvar,\n      TAccountEqualityRecord extends string\n        ? ReadonlyAccount<TAccountEqualityRecord>\n        : TAccountEqualityRecord,\n      TAccountTransferAmountCiphertextValidityRecord extends string\n        ? ReadonlyAccount<TAccountTransferAmountCiphertextValidityRecord>\n        : TAccountTransferAmountCiphertextValidityRecord,\n      TAccountFeeSigmaRecord extends string\n        ? ReadonlyAccount<TAccountFeeSigmaRecord>\n        : TAccountFeeSigmaRecord,\n      TAccountFeeCiphertextValidityRecord extends string\n        ? ReadonlyAccount<TAccountFeeCiphertextValidityRecord>\n        : TAccountFeeCiphertextValidityRecord,\n      TAccountRangeRecord extends string\n        ? ReadonlyAccount<TAccountRangeRecord>\n        : TAccountRangeRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ConfidentialTransferWithFeeInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /** The new source decryptable balance if the transfer succeeds. */\n  newSourceDecryptableAvailableBalance: DecryptableBalance;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyCiphertextCommitmentEquality` instruction\n   * to the `TransferWithFee` instruction in the transaction. If the offset\n   * is `0`, then use a context state account for the proof.\n   */\n  equalityProofInstructionOffset: number;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyBatchedGroupedCiphertext3HandlesValidity`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  transferAmountCiphertextValidityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::VerifyPercentageWithFee`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  feeSigmaProofInstructionOffset: number;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyBatchedGroupedCiphertext2HandlesValidity`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  feeCiphertextValidityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::BatchedRangeProofU256Data`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  rangeProofInstructionOffset: number;\n};\n\nexport type ConfidentialTransferWithFeeInstructionDataArgs = {\n  /** The new source decryptable balance if the transfer succeeds. */\n  newSourceDecryptableAvailableBalance: DecryptableBalanceArgs;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyCiphertextCommitmentEquality` instruction\n   * to the `TransferWithFee` instruction in the transaction. If the offset\n   * is `0`, then use a context state account for the proof.\n   */\n  equalityProofInstructionOffset: number;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyBatchedGroupedCiphertext3HandlesValidity`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  transferAmountCiphertextValidityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::VerifyPercentageWithFee`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  feeSigmaProofInstructionOffset: number;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyBatchedGroupedCiphertext2HandlesValidity`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  feeCiphertextValidityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::BatchedRangeProofU256Data`\n   * instruction to the `TransferWithFee` instruction in the transaction.\n   * If the offset is `0`, then use a context state account for the\n   * proof.\n   */\n  rangeProofInstructionOffset: number;\n};\n\nexport function getConfidentialTransferWithFeeInstructionDataEncoder(): FixedSizeEncoder<ConfidentialTransferWithFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['newSourceDecryptableAvailableBalance', getDecryptableBalanceEncoder()],\n      ['equalityProofInstructionOffset', getI8Encoder()],\n      [\n        'transferAmountCiphertextValidityProofInstructionOffset',\n        getI8Encoder(),\n      ],\n      ['feeSigmaProofInstructionOffset', getI8Encoder()],\n      ['feeCiphertextValidityProofInstructionOffset', getI8Encoder()],\n      ['rangeProofInstructionOffset', getI8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIDENTIAL_TRANSFER_WITH_FEE_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        CONFIDENTIAL_TRANSFER_WITH_FEE_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getConfidentialTransferWithFeeInstructionDataDecoder(): FixedSizeDecoder<ConfidentialTransferWithFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['newSourceDecryptableAvailableBalance', getDecryptableBalanceDecoder()],\n    ['equalityProofInstructionOffset', getI8Decoder()],\n    ['transferAmountCiphertextValidityProofInstructionOffset', getI8Decoder()],\n    ['feeSigmaProofInstructionOffset', getI8Decoder()],\n    ['feeCiphertextValidityProofInstructionOffset', getI8Decoder()],\n    ['rangeProofInstructionOffset', getI8Decoder()],\n  ]);\n}\n\nexport function getConfidentialTransferWithFeeInstructionDataCodec(): FixedSizeCodec<\n  ConfidentialTransferWithFeeInstructionDataArgs,\n  ConfidentialTransferWithFeeInstructionData\n> {\n  return combineCodec(\n    getConfidentialTransferWithFeeInstructionDataEncoder(),\n    getConfidentialTransferWithFeeInstructionDataDecoder()\n  );\n}\n\nexport type ConfidentialTransferWithFeeInput<\n  TAccountSourceToken extends string = string,\n  TAccountMint extends string = string,\n  TAccountDestinationToken extends string = string,\n  TAccountInstructionsSysvar extends string = string,\n  TAccountEqualityRecord extends string = string,\n  TAccountTransferAmountCiphertextValidityRecord extends string = string,\n  TAccountFeeSigmaRecord extends string = string,\n  TAccountFeeCiphertextValidityRecord extends string = string,\n  TAccountRangeRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source SPL Token account. */\n  sourceToken: Address<TAccountSourceToken>;\n  /** The corresponding SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /** The destination SPL Token account. */\n  destinationToken: Address<TAccountDestinationToken>;\n  /**\n   * (Optional) Instructions sysvar if at least one of the\n   * `zk_elgamal_proof` instructions are included in the same\n   * transaction.\n   */\n  instructionsSysvar?: Address<TAccountInstructionsSysvar>;\n  /** (Optional) Equality proof record account or context state account. */\n  equalityRecord?: Address<TAccountEqualityRecord>;\n  /**\n   * (Optional) Transfer amount ciphertext validity proof record\n   * account or context state account.\n   */\n  transferAmountCiphertextValidityRecord?: Address<TAccountTransferAmountCiphertextValidityRecord>;\n  /** (Optional) Fee sigma proof record account or context state account. */\n  feeSigmaRecord?: Address<TAccountFeeSigmaRecord>;\n  /** (Optional) Fee ciphertext validity proof record account or context state account. */\n  feeCiphertextValidityRecord?: Address<TAccountFeeCiphertextValidityRecord>;\n  /** (Optional) Range proof record account or context state account. */\n  rangeRecord?: Address<TAccountRangeRecord>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  newSourceDecryptableAvailableBalance: ConfidentialTransferWithFeeInstructionDataArgs['newSourceDecryptableAvailableBalance'];\n  equalityProofInstructionOffset: ConfidentialTransferWithFeeInstructionDataArgs['equalityProofInstructionOffset'];\n  transferAmountCiphertextValidityProofInstructionOffset: ConfidentialTransferWithFeeInstructionDataArgs['transferAmountCiphertextValidityProofInstructionOffset'];\n  feeSigmaProofInstructionOffset: ConfidentialTransferWithFeeInstructionDataArgs['feeSigmaProofInstructionOffset'];\n  feeCiphertextValidityProofInstructionOffset: ConfidentialTransferWithFeeInstructionDataArgs['feeCiphertextValidityProofInstructionOffset'];\n  rangeProofInstructionOffset: ConfidentialTransferWithFeeInstructionDataArgs['rangeProofInstructionOffset'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getConfidentialTransferWithFeeInstruction<\n  TAccountSourceToken extends string,\n  TAccountMint extends string,\n  TAccountDestinationToken extends string,\n  TAccountInstructionsSysvar extends string,\n  TAccountEqualityRecord extends string,\n  TAccountTransferAmountCiphertextValidityRecord extends string,\n  TAccountFeeSigmaRecord extends string,\n  TAccountFeeCiphertextValidityRecord extends string,\n  TAccountRangeRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ConfidentialTransferWithFeeInput<\n    TAccountSourceToken,\n    TAccountMint,\n    TAccountDestinationToken,\n    TAccountInstructionsSysvar,\n    TAccountEqualityRecord,\n    TAccountTransferAmountCiphertextValidityRecord,\n    TAccountFeeSigmaRecord,\n    TAccountFeeCiphertextValidityRecord,\n    TAccountRangeRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ConfidentialTransferWithFeeInstruction<\n  TProgramAddress,\n  TAccountSourceToken,\n  TAccountMint,\n  TAccountDestinationToken,\n  TAccountInstructionsSysvar,\n  TAccountEqualityRecord,\n  TAccountTransferAmountCiphertextValidityRecord,\n  TAccountFeeSigmaRecord,\n  TAccountFeeCiphertextValidityRecord,\n  TAccountRangeRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    sourceToken: { value: input.sourceToken ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    destinationToken: {\n      value: input.destinationToken ?? null,\n      isWritable: true,\n    },\n    instructionsSysvar: {\n      value: input.instructionsSysvar ?? null,\n      isWritable: false,\n    },\n    equalityRecord: { value: input.equalityRecord ?? null, isWritable: false },\n    transferAmountCiphertextValidityRecord: {\n      value: input.transferAmountCiphertextValidityRecord ?? null,\n      isWritable: false,\n    },\n    feeSigmaRecord: { value: input.feeSigmaRecord ?? null, isWritable: false },\n    feeCiphertextValidityRecord: {\n      value: input.feeCiphertextValidityRecord ?? null,\n      isWritable: false,\n    },\n    rangeRecord: { value: input.rangeRecord ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.sourceToken),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destinationToken),\n      getAccountMeta(accounts.instructionsSysvar),\n      getAccountMeta(accounts.equalityRecord),\n      getAccountMeta(accounts.transferAmountCiphertextValidityRecord),\n      getAccountMeta(accounts.feeSigmaRecord),\n      getAccountMeta(accounts.feeCiphertextValidityRecord),\n      getAccountMeta(accounts.rangeRecord),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getConfidentialTransferWithFeeInstructionDataEncoder().encode(\n      args as ConfidentialTransferWithFeeInstructionDataArgs\n    ),\n    programAddress,\n  } as ConfidentialTransferWithFeeInstruction<\n    TProgramAddress,\n    TAccountSourceToken,\n    TAccountMint,\n    TAccountDestinationToken,\n    TAccountInstructionsSysvar,\n    TAccountEqualityRecord,\n    TAccountTransferAmountCiphertextValidityRecord,\n    TAccountFeeSigmaRecord,\n    TAccountFeeCiphertextValidityRecord,\n    TAccountRangeRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedConfidentialTransferWithFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source SPL Token account. */\n    sourceToken: TAccountMetas[0];\n    /** The corresponding SPL Token mint. */\n    mint: TAccountMetas[1];\n    /** The destination SPL Token account. */\n    destinationToken: TAccountMetas[2];\n    /**\n     * (Optional) Instructions sysvar if at least one of the\n     * `zk_elgamal_proof` instructions are included in the same\n     * transaction.\n     */\n    instructionsSysvar?: TAccountMetas[3] | undefined;\n    /** (Optional) Equality proof record account or context state account. */\n    equalityRecord?: TAccountMetas[4] | undefined;\n    /**\n     * (Optional) Transfer amount ciphertext validity proof record\n     * account or context state account.\n     */\n    transferAmountCiphertextValidityRecord?: TAccountMetas[5] | undefined;\n    /** (Optional) Fee sigma proof record account or context state account. */\n    feeSigmaRecord?: TAccountMetas[6] | undefined;\n    /** (Optional) Fee ciphertext validity proof record account or context state account. */\n    feeCiphertextValidityRecord?: TAccountMetas[7] | undefined;\n    /** (Optional) Range proof record account or context state account. */\n    rangeRecord?: TAccountMetas[8] | undefined;\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[9];\n  };\n  data: ConfidentialTransferWithFeeInstructionData;\n};\n\nexport function parseConfidentialTransferWithFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedConfidentialTransferWithFeeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 10) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      sourceToken: getNextAccount(),\n      mint: getNextAccount(),\n      destinationToken: getNextAccount(),\n      instructionsSysvar: getNextOptionalAccount(),\n      equalityRecord: getNextOptionalAccount(),\n      transferAmountCiphertextValidityRecord: getNextOptionalAccount(),\n      feeSigmaRecord: getNextOptionalAccount(),\n      feeCiphertextValidityRecord: getNextOptionalAccount(),\n      rangeRecord: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getConfidentialTransferWithFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const CONFIDENTIAL_WITHDRAW_DISCRIMINATOR = 27;\n\nexport function getConfidentialWithdrawDiscriminatorBytes() {\n  return getU8Encoder().encode(CONFIDENTIAL_WITHDRAW_DISCRIMINATOR);\n}\n\nexport const CONFIDENTIAL_WITHDRAW_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 6;\n\nexport function getConfidentialWithdrawConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIDENTIAL_WITHDRAW_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ConfidentialWithdrawInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountInstructionsSysvar extends string | AccountMeta<string> = string,\n  TAccountEqualityRecord extends string | AccountMeta<string> = string,\n  TAccountRangeRecord extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountInstructionsSysvar extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvar>\n        : TAccountInstructionsSysvar,\n      TAccountEqualityRecord extends string\n        ? ReadonlyAccount<TAccountEqualityRecord>\n        : TAccountEqualityRecord,\n      TAccountRangeRecord extends string\n        ? ReadonlyAccount<TAccountRangeRecord>\n        : TAccountRangeRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ConfidentialWithdrawInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /** The amount of tokens to withdraw. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** The new decryptable balance if the withdrawal succeeds. */\n  newDecryptableAvailableBalance: DecryptableBalance;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyCiphertextCommitmentEquality` instruction\n   * to the `Withdraw` instruction in the transaction. If the offset is\n   * `0`, then use a context state account for the proof.\n   */\n  equalityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::BatchedRangeProofU64`\n   * instruction to the `Withdraw` instruction in the transaction. If the\n   * offset is `0`, then use a context state account for the proof.\n   */\n  rangeProofInstructionOffset: number;\n};\n\nexport type ConfidentialWithdrawInstructionDataArgs = {\n  /** The amount of tokens to withdraw. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** The new decryptable balance if the withdrawal succeeds. */\n  newDecryptableAvailableBalance: DecryptableBalanceArgs;\n  /**\n   * Relative location of the\n   * `ProofInstruction::VerifyCiphertextCommitmentEquality` instruction\n   * to the `Withdraw` instruction in the transaction. If the offset is\n   * `0`, then use a context state account for the proof.\n   */\n  equalityProofInstructionOffset: number;\n  /**\n   * Relative location of the `ProofInstruction::BatchedRangeProofU64`\n   * instruction to the `Withdraw` instruction in the transaction. If the\n   * offset is `0`, then use a context state account for the proof.\n   */\n  rangeProofInstructionOffset: number;\n};\n\nexport function getConfidentialWithdrawInstructionDataEncoder(): FixedSizeEncoder<ConfidentialWithdrawInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n      ['newDecryptableAvailableBalance', getDecryptableBalanceEncoder()],\n      ['equalityProofInstructionOffset', getI8Encoder()],\n      ['rangeProofInstructionOffset', getI8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIDENTIAL_WITHDRAW_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        CONFIDENTIAL_WITHDRAW_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getConfidentialWithdrawInstructionDataDecoder(): FixedSizeDecoder<ConfidentialWithdrawInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n    ['newDecryptableAvailableBalance', getDecryptableBalanceDecoder()],\n    ['equalityProofInstructionOffset', getI8Decoder()],\n    ['rangeProofInstructionOffset', getI8Decoder()],\n  ]);\n}\n\nexport function getConfidentialWithdrawInstructionDataCodec(): FixedSizeCodec<\n  ConfidentialWithdrawInstructionDataArgs,\n  ConfidentialWithdrawInstructionData\n> {\n  return combineCodec(\n    getConfidentialWithdrawInstructionDataEncoder(),\n    getConfidentialWithdrawInstructionDataDecoder()\n  );\n}\n\nexport type ConfidentialWithdrawInput<\n  TAccountToken extends string = string,\n  TAccountMint extends string = string,\n  TAccountInstructionsSysvar extends string = string,\n  TAccountEqualityRecord extends string = string,\n  TAccountRangeRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The corresponding SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /**\n   * Instructions sysvar if at least one of the\n   * `zk_elgamal_proof` instructions are included in the same\n   * transaction.\n   */\n  instructionsSysvar?: Address<TAccountInstructionsSysvar>;\n  /** (Optional) Equality proof record account or context state account. */\n  equalityRecord?: Address<TAccountEqualityRecord>;\n  /** (Optional) Range proof record account or context state account. */\n  rangeRecord?: Address<TAccountRangeRecord>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: ConfidentialWithdrawInstructionDataArgs['amount'];\n  decimals: ConfidentialWithdrawInstructionDataArgs['decimals'];\n  newDecryptableAvailableBalance: ConfidentialWithdrawInstructionDataArgs['newDecryptableAvailableBalance'];\n  equalityProofInstructionOffset: ConfidentialWithdrawInstructionDataArgs['equalityProofInstructionOffset'];\n  rangeProofInstructionOffset: ConfidentialWithdrawInstructionDataArgs['rangeProofInstructionOffset'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getConfidentialWithdrawInstruction<\n  TAccountToken extends string,\n  TAccountMint extends string,\n  TAccountInstructionsSysvar extends string,\n  TAccountEqualityRecord extends string,\n  TAccountRangeRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ConfidentialWithdrawInput<\n    TAccountToken,\n    TAccountMint,\n    TAccountInstructionsSysvar,\n    TAccountEqualityRecord,\n    TAccountRangeRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ConfidentialWithdrawInstruction<\n  TProgramAddress,\n  TAccountToken,\n  TAccountMint,\n  TAccountInstructionsSysvar,\n  TAccountEqualityRecord,\n  TAccountRangeRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    instructionsSysvar: {\n      value: input.instructionsSysvar ?? null,\n      isWritable: false,\n    },\n    equalityRecord: { value: input.equalityRecord ?? null, isWritable: false },\n    rangeRecord: { value: input.rangeRecord ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.instructionsSysvar),\n      getAccountMeta(accounts.equalityRecord),\n      getAccountMeta(accounts.rangeRecord),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getConfidentialWithdrawInstructionDataEncoder().encode(\n      args as ConfidentialWithdrawInstructionDataArgs\n    ),\n    programAddress,\n  } as ConfidentialWithdrawInstruction<\n    TProgramAddress,\n    TAccountToken,\n    TAccountMint,\n    TAccountInstructionsSysvar,\n    TAccountEqualityRecord,\n    TAccountRangeRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedConfidentialWithdrawInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The corresponding SPL Token mint. */\n    mint: TAccountMetas[1];\n    /**\n     * Instructions sysvar if at least one of the\n     * `zk_elgamal_proof` instructions are included in the same\n     * transaction.\n     */\n    instructionsSysvar?: TAccountMetas[2] | undefined;\n    /** (Optional) Equality proof record account or context state account. */\n    equalityRecord?: TAccountMetas[3] | undefined;\n    /** (Optional) Range proof record account or context state account. */\n    rangeRecord?: TAccountMetas[4] | undefined;\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[5];\n  };\n  data: ConfidentialWithdrawInstructionData;\n};\n\nexport function parseConfidentialWithdrawInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedConfidentialWithdrawInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      mint: getNextAccount(),\n      instructionsSysvar: getNextOptionalAccount(),\n      equalityRecord: getNextOptionalAccount(),\n      rangeRecord: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getConfidentialWithdrawInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR = 27;\n\nexport function getConfigureConfidentialTransferAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR\n  );\n}\n\nexport const CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 2;\n\nexport function getConfigureConfidentialTransferAccountConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type ConfigureConfidentialTransferAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountInstructionsSysvarOrContextState extends\n    | string\n    | AccountMeta<string> = 'Sysvar1nstructions1111111111111111111111111',\n  TAccountRecord extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountInstructionsSysvarOrContextState extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvarOrContextState>\n        : TAccountInstructionsSysvarOrContextState,\n      TAccountRecord extends string\n        ? ReadonlyAccount<TAccountRecord>\n        : TAccountRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ConfigureConfidentialTransferAccountInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /** The decryptable balance (always 0) once the configure account succeeds. */\n  decryptableZeroBalance: DecryptableBalance;\n  /**\n   * The maximum number of despots and transfers that an account can receiver\n   * before the `ApplyPendingBalance` is executed\n   */\n  maximumPendingBalanceCreditCounter: bigint;\n  /**\n   * Relative location of the `ProofInstruction::ZeroCiphertextProof`\n   * instruction to the `ConfigureAccount` instruction in the\n   * transaction. If the offset is `0`, then use a context state account\n   * for the proof.\n   */\n  proofInstructionOffset: number;\n};\n\nexport type ConfigureConfidentialTransferAccountInstructionDataArgs = {\n  /** The decryptable balance (always 0) once the configure account succeeds. */\n  decryptableZeroBalance: DecryptableBalanceArgs;\n  /**\n   * The maximum number of despots and transfers that an account can receiver\n   * before the `ApplyPendingBalance` is executed\n   */\n  maximumPendingBalanceCreditCounter: number | bigint;\n  /**\n   * Relative location of the `ProofInstruction::ZeroCiphertextProof`\n   * instruction to the `ConfigureAccount` instruction in the\n   * transaction. If the offset is `0`, then use a context state account\n   * for the proof.\n   */\n  proofInstructionOffset: number;\n};\n\nexport function getConfigureConfidentialTransferAccountInstructionDataEncoder(): FixedSizeEncoder<ConfigureConfidentialTransferAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['decryptableZeroBalance', getDecryptableBalanceEncoder()],\n      ['maximumPendingBalanceCreditCounter', getU64Encoder()],\n      ['proofInstructionOffset', getI8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        CONFIGURE_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getConfigureConfidentialTransferAccountInstructionDataDecoder(): FixedSizeDecoder<ConfigureConfidentialTransferAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['decryptableZeroBalance', getDecryptableBalanceDecoder()],\n    ['maximumPendingBalanceCreditCounter', getU64Decoder()],\n    ['proofInstructionOffset', getI8Decoder()],\n  ]);\n}\n\nexport function getConfigureConfidentialTransferAccountInstructionDataCodec(): FixedSizeCodec<\n  ConfigureConfidentialTransferAccountInstructionDataArgs,\n  ConfigureConfidentialTransferAccountInstructionData\n> {\n  return combineCodec(\n    getConfigureConfidentialTransferAccountInstructionDataEncoder(),\n    getConfigureConfidentialTransferAccountInstructionDataDecoder()\n  );\n}\n\nexport type ConfigureConfidentialTransferAccountInput<\n  TAccountToken extends string = string,\n  TAccountMint extends string = string,\n  TAccountInstructionsSysvarOrContextState extends string = string,\n  TAccountRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The corresponding SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /**\n   * Instructions sysvar if `VerifyPubkeyValidity` is included in\n   * the same transaction or context state account if\n   * `VerifyPubkeyValidity` is pre-verified into a context state\n   * account.\n   */\n  instructionsSysvarOrContextState?: Address<TAccountInstructionsSysvarOrContextState>;\n  /** (Optional) Record account if the accompanying proof is to be read from a record account. */\n  record?: Address<TAccountRecord>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  decryptableZeroBalance: ConfigureConfidentialTransferAccountInstructionDataArgs['decryptableZeroBalance'];\n  maximumPendingBalanceCreditCounter: ConfigureConfidentialTransferAccountInstructionDataArgs['maximumPendingBalanceCreditCounter'];\n  proofInstructionOffset: ConfigureConfidentialTransferAccountInstructionDataArgs['proofInstructionOffset'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getConfigureConfidentialTransferAccountInstruction<\n  TAccountToken extends string,\n  TAccountMint extends string,\n  TAccountInstructionsSysvarOrContextState extends string,\n  TAccountRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ConfigureConfidentialTransferAccountInput<\n    TAccountToken,\n    TAccountMint,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ConfigureConfidentialTransferAccountInstruction<\n  TProgramAddress,\n  TAccountToken,\n  TAccountMint,\n  TAccountInstructionsSysvarOrContextState,\n  TAccountRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    instructionsSysvarOrContextState: {\n      value: input.instructionsSysvarOrContextState ?? null,\n      isWritable: false,\n    },\n    record: { value: input.record ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.instructionsSysvarOrContextState.value) {\n    accounts.instructionsSysvarOrContextState.value =\n      'Sysvar1nstructions1111111111111111111111111' as Address<'Sysvar1nstructions1111111111111111111111111'>;\n  }\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.instructionsSysvarOrContextState),\n      getAccountMeta(accounts.record),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getConfigureConfidentialTransferAccountInstructionDataEncoder().encode(\n      args as ConfigureConfidentialTransferAccountInstructionDataArgs\n    ),\n    programAddress,\n  } as ConfigureConfidentialTransferAccountInstruction<\n    TProgramAddress,\n    TAccountToken,\n    TAccountMint,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedConfigureConfidentialTransferAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The corresponding SPL Token mint. */\n    mint: TAccountMetas[1];\n    /**\n     * Instructions sysvar if `VerifyPubkeyValidity` is included in\n     * the same transaction or context state account if\n     * `VerifyPubkeyValidity` is pre-verified into a context state\n     * account.\n     */\n    instructionsSysvarOrContextState: TAccountMetas[2];\n    /** (Optional) Record account if the accompanying proof is to be read from a record account. */\n    record?: TAccountMetas[3] | undefined;\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[4];\n  };\n  data: ConfigureConfidentialTransferAccountInstructionData;\n};\n\nexport function parseConfigureConfidentialTransferAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedConfigureConfidentialTransferAccountInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      mint: getNextAccount(),\n      instructionsSysvarOrContextState: getNextAccount(),\n      record: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getConfigureConfidentialTransferAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  getAddressEncoder,\n  getProgramDerivedAddress,\n  type Address,\n  type ProgramDerivedAddress,\n} from '@solana/kit';\n\nexport type AssociatedTokenSeeds = {\n  /** The wallet address of the associated token account. */\n  owner: Address;\n  /** The address of the token program to use. */\n  tokenProgram: Address;\n  /** The mint address of the associated token account. */\n  mint: Address;\n};\n\nexport async function findAssociatedTokenPda(\n  seeds: AssociatedTokenSeeds,\n  config: { programAddress?: Address | undefined } = {}\n): Promise<ProgramDerivedAddress> {\n  const {\n    programAddress = 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>,\n  } = config;\n  return await getProgramDerivedAddress({\n    programAddress,\n    seeds: [\n      getAddressEncoder().encode(seeds.owner),\n      getAddressEncoder().encode(seeds.tokenProgram),\n      getAddressEncoder().encode(seeds.mint),\n    ],\n  });\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { findAssociatedTokenPda } from '../pdas';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport {\n  expectAddress,\n  getAccountMetaFactory,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR = 0;\n\nexport function getCreateAssociatedTokenDiscriminatorBytes() {\n  return getU8Encoder().encode(CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR);\n}\n\nexport type CreateAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountPayer extends string | AccountMeta<string> = string,\n  TAccountAta extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | AccountMeta<string> = '11111111111111111111111111111111',\n  TAccountTokenProgram extends\n    | string\n    | AccountMeta<string> = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            AccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountAta extends string ? WritableAccount<TAccountAta> : TAccountAta,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateAssociatedTokenInstructionData = { discriminator: number };\n\nexport type CreateAssociatedTokenInstructionDataArgs = {};\n\nexport function getCreateAssociatedTokenInstructionDataEncoder(): FixedSizeEncoder<CreateAssociatedTokenInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: CREATE_ASSOCIATED_TOKEN_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getCreateAssociatedTokenInstructionDataDecoder(): FixedSizeDecoder<CreateAssociatedTokenInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCreateAssociatedTokenInstructionDataCodec(): FixedSizeCodec<\n  CreateAssociatedTokenInstructionDataArgs,\n  CreateAssociatedTokenInstructionData\n> {\n  return combineCodec(\n    getCreateAssociatedTokenInstructionDataEncoder(),\n    getCreateAssociatedTokenInstructionDataDecoder()\n  );\n}\n\nexport type CreateAssociatedTokenAsyncInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata?: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport async function getCreateAssociatedTokenInstructionAsync<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenAsyncInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): Promise<\n  CreateAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n  }\n  if (!accounts.ata.value) {\n    accounts.ata.value = await findAssociatedTokenPda({\n      owner: expectAddress(accounts.owner.value),\n      tokenProgram: expectAddress(accounts.tokenProgram.value),\n      mint: expectAddress(accounts.mint.value),\n    });\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    data: getCreateAssociatedTokenInstructionDataEncoder().encode({}),\n    programAddress,\n  } as CreateAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >);\n}\n\nexport type CreateAssociatedTokenInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getCreateAssociatedTokenInstruction<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CreateAssociatedTokenInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountAta,\n  TAccountOwner,\n  TAccountMint,\n  TAccountSystemProgram,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    data: getCreateAssociatedTokenInstructionDataEncoder().encode({}),\n    programAddress,\n  } as CreateAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >);\n}\n\nexport type ParsedCreateAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Funding account (must be a system account). */\n    payer: TAccountMetas[0];\n    /** Associated token account address to be created. */\n    ata: TAccountMetas[1];\n    /** Wallet address for the new associated token account. */\n    owner: TAccountMetas[2];\n    /** The token mint for the new associated token account. */\n    mint: TAccountMetas[3];\n    /** System program. */\n    systemProgram: TAccountMetas[4];\n    /** SPL Token program. */\n    tokenProgram: TAccountMetas[5];\n  };\n  data: CreateAssociatedTokenInstructionData;\n};\n\nexport function parseCreateAssociatedTokenInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedCreateAssociatedTokenInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      ata: getNextAccount(),\n      owner: getNextAccount(),\n      mint: getNextAccount(),\n      systemProgram: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getCreateAssociatedTokenInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { findAssociatedTokenPda } from '../pdas';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport {\n  expectAddress,\n  getAccountMetaFactory,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR = 1;\n\nexport function getCreateAssociatedTokenIdempotentDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR\n  );\n}\n\nexport type CreateAssociatedTokenIdempotentInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountPayer extends string | AccountMeta<string> = string,\n  TAccountAta extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | AccountMeta<string> = '11111111111111111111111111111111',\n  TAccountTokenProgram extends\n    | string\n    | AccountMeta<string> = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            AccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountAta extends string ? WritableAccount<TAccountAta> : TAccountAta,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateAssociatedTokenIdempotentInstructionData = {\n  discriminator: number;\n};\n\nexport type CreateAssociatedTokenIdempotentInstructionDataArgs = {};\n\nexport function getCreateAssociatedTokenIdempotentInstructionDataEncoder(): FixedSizeEncoder<CreateAssociatedTokenIdempotentInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: CREATE_ASSOCIATED_TOKEN_IDEMPOTENT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getCreateAssociatedTokenIdempotentInstructionDataDecoder(): FixedSizeDecoder<CreateAssociatedTokenIdempotentInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCreateAssociatedTokenIdempotentInstructionDataCodec(): FixedSizeCodec<\n  CreateAssociatedTokenIdempotentInstructionDataArgs,\n  CreateAssociatedTokenIdempotentInstructionData\n> {\n  return combineCodec(\n    getCreateAssociatedTokenIdempotentInstructionDataEncoder(),\n    getCreateAssociatedTokenIdempotentInstructionDataDecoder()\n  );\n}\n\nexport type CreateAssociatedTokenIdempotentAsyncInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata?: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport async function getCreateAssociatedTokenIdempotentInstructionAsync<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenIdempotentAsyncInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): Promise<\n  CreateAssociatedTokenIdempotentInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n  }\n  if (!accounts.ata.value) {\n    accounts.ata.value = await findAssociatedTokenPda({\n      owner: expectAddress(accounts.owner.value),\n      tokenProgram: expectAddress(accounts.tokenProgram.value),\n      mint: expectAddress(accounts.mint.value),\n    });\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    data: getCreateAssociatedTokenIdempotentInstructionDataEncoder().encode({}),\n    programAddress,\n  } as CreateAssociatedTokenIdempotentInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >);\n}\n\nexport type CreateAssociatedTokenIdempotentInput<\n  TAccountPayer extends string = string,\n  TAccountAta extends string = string,\n  TAccountOwner extends string = string,\n  TAccountMint extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Funding account (must be a system account). */\n  payer: TransactionSigner<TAccountPayer>;\n  /** Associated token account address to be created. */\n  ata: Address<TAccountAta>;\n  /** Wallet address for the new associated token account. */\n  owner: Address<TAccountOwner>;\n  /** The token mint for the new associated token account. */\n  mint: Address<TAccountMint>;\n  /** System program. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getCreateAssociatedTokenIdempotentInstruction<\n  TAccountPayer extends string,\n  TAccountAta extends string,\n  TAccountOwner extends string,\n  TAccountMint extends string,\n  TAccountSystemProgram extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: CreateAssociatedTokenIdempotentInput<\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CreateAssociatedTokenIdempotentInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountAta,\n  TAccountOwner,\n  TAccountMint,\n  TAccountSystemProgram,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    ata: { value: input.ata ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n    mint: { value: input.mint ?? null, isWritable: false },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n  }\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.ata),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    data: getCreateAssociatedTokenIdempotentInstructionDataEncoder().encode({}),\n    programAddress,\n  } as CreateAssociatedTokenIdempotentInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountAta,\n    TAccountOwner,\n    TAccountMint,\n    TAccountSystemProgram,\n    TAccountTokenProgram\n  >);\n}\n\nexport type ParsedCreateAssociatedTokenIdempotentInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Funding account (must be a system account). */\n    payer: TAccountMetas[0];\n    /** Associated token account address to be created. */\n    ata: TAccountMetas[1];\n    /** Wallet address for the new associated token account. */\n    owner: TAccountMetas[2];\n    /** The token mint for the new associated token account. */\n    mint: TAccountMetas[3];\n    /** System program. */\n    systemProgram: TAccountMetas[4];\n    /** SPL Token program. */\n    tokenProgram: TAccountMetas[5];\n  };\n  data: CreateAssociatedTokenIdempotentInstructionData;\n};\n\nexport function parseCreateAssociatedTokenIdempotentInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedCreateAssociatedTokenIdempotentInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 6) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      ata: getNextAccount(),\n      owner: getNextAccount(),\n      mint: getNextAccount(),\n      systemProgram: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getCreateAssociatedTokenIdempotentInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const CREATE_NATIVE_MINT_DISCRIMINATOR = 31;\n\nexport function getCreateNativeMintDiscriminatorBytes() {\n  return getU8Encoder().encode(CREATE_NATIVE_MINT_DISCRIMINATOR);\n}\n\nexport type CreateNativeMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountPayer extends string | AccountMeta<string> = string,\n  TAccountNativeMint extends string | AccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | AccountMeta<string> = '11111111111111111111111111111111',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            AccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountNativeMint extends string\n        ? WritableAccount<TAccountNativeMint>\n        : TAccountNativeMint,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type CreateNativeMintInstructionData = { discriminator: number };\n\nexport type CreateNativeMintInstructionDataArgs = {};\n\nexport function getCreateNativeMintInstructionDataEncoder(): FixedSizeEncoder<CreateNativeMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: CREATE_NATIVE_MINT_DISCRIMINATOR })\n  );\n}\n\nexport function getCreateNativeMintInstructionDataDecoder(): FixedSizeDecoder<CreateNativeMintInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getCreateNativeMintInstructionDataCodec(): FixedSizeCodec<\n  CreateNativeMintInstructionDataArgs,\n  CreateNativeMintInstructionData\n> {\n  return combineCodec(\n    getCreateNativeMintInstructionDataEncoder(),\n    getCreateNativeMintInstructionDataDecoder()\n  );\n}\n\nexport type CreateNativeMintInput<\n  TAccountPayer extends string = string,\n  TAccountNativeMint extends string = string,\n  TAccountSystemProgram extends string = string,\n> = {\n  /** Funding account (must be a system account) */\n  payer: TransactionSigner<TAccountPayer>;\n  /** The native mint address */\n  nativeMint: Address<TAccountNativeMint>;\n  /** System program for mint account funding */\n  systemProgram?: Address<TAccountSystemProgram>;\n};\n\nexport function getCreateNativeMintInstruction<\n  TAccountPayer extends string,\n  TAccountNativeMint extends string,\n  TAccountSystemProgram extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: CreateNativeMintInput<\n    TAccountPayer,\n    TAccountNativeMint,\n    TAccountSystemProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): CreateNativeMintInstruction<\n  TProgramAddress,\n  TAccountPayer,\n  TAccountNativeMint,\n  TAccountSystemProgram\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    payer: { value: input.payer ?? null, isWritable: true },\n    nativeMint: { value: input.nativeMint ?? null, isWritable: true },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.nativeMint),\n      getAccountMeta(accounts.systemProgram),\n    ],\n    data: getCreateNativeMintInstructionDataEncoder().encode({}),\n    programAddress,\n  } as CreateNativeMintInstruction<\n    TProgramAddress,\n    TAccountPayer,\n    TAccountNativeMint,\n    TAccountSystemProgram\n  >);\n}\n\nexport type ParsedCreateNativeMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Funding account (must be a system account) */\n    payer: TAccountMetas[0];\n    /** The native mint address */\n    nativeMint: TAccountMetas[1];\n    /** System program for mint account funding */\n    systemProgram: TAccountMetas[2];\n  };\n  data: CreateNativeMintInstructionData;\n};\n\nexport function parseCreateNativeMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedCreateNativeMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      payer: getNextAccount(),\n      nativeMint: getNextAccount(),\n      systemProgram: getNextAccount(),\n    },\n    data: getCreateNativeMintInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DISABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR = 27;\n\nexport function getDisableConfidentialCreditsDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR);\n}\n\nexport const DISABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 10;\n\nexport function getDisableConfidentialCreditsConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    DISABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type DisableConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DisableConfidentialCreditsInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n};\n\nexport type DisableConfidentialCreditsInstructionDataArgs = {};\n\nexport function getDisableConfidentialCreditsInstructionDataEncoder(): FixedSizeEncoder<DisableConfidentialCreditsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        DISABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getDisableConfidentialCreditsInstructionDataDecoder(): FixedSizeDecoder<DisableConfidentialCreditsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getDisableConfidentialCreditsInstructionDataCodec(): FixedSizeCodec<\n  DisableConfidentialCreditsInstructionDataArgs,\n  DisableConfidentialCreditsInstructionData\n> {\n  return combineCodec(\n    getDisableConfidentialCreditsInstructionDataEncoder(),\n    getDisableConfidentialCreditsInstructionDataDecoder()\n  );\n}\n\nexport type DisableConfidentialCreditsInput<\n  TAccountToken extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getDisableConfidentialCreditsInstruction<\n  TAccountToken extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: DisableConfidentialCreditsInput<TAccountToken, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): DisableConfidentialCreditsInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getDisableConfidentialCreditsInstructionDataEncoder().encode({}),\n    programAddress,\n  } as DisableConfidentialCreditsInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedDisableConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[1];\n  };\n  data: DisableConfidentialCreditsInstructionData;\n};\n\nexport function parseDisableConfidentialCreditsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedDisableConfidentialCreditsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), authority: getNextAccount() },\n    data: getDisableConfidentialCreditsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DISABLE_CPI_GUARD_DISCRIMINATOR = 34;\n\nexport function getDisableCpiGuardDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_CPI_GUARD_DISCRIMINATOR);\n}\n\nexport const DISABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR = 1;\n\nexport function getDisableCpiGuardCpiGuardDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR);\n}\n\nexport type DisableCpiGuardInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DisableCpiGuardInstructionData = {\n  discriminator: number;\n  cpiGuardDiscriminator: number;\n};\n\nexport type DisableCpiGuardInstructionDataArgs = {};\n\nexport function getDisableCpiGuardInstructionDataEncoder(): FixedSizeEncoder<DisableCpiGuardInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['cpiGuardDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_CPI_GUARD_DISCRIMINATOR,\n      cpiGuardDiscriminator: DISABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getDisableCpiGuardInstructionDataDecoder(): FixedSizeDecoder<DisableCpiGuardInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['cpiGuardDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getDisableCpiGuardInstructionDataCodec(): FixedSizeCodec<\n  DisableCpiGuardInstructionDataArgs,\n  DisableCpiGuardInstructionData\n> {\n  return combineCodec(\n    getDisableCpiGuardInstructionDataEncoder(),\n    getDisableCpiGuardInstructionDataDecoder()\n  );\n}\n\nexport type DisableCpiGuardInput<\n  TAccountToken extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The token account to update. */\n  token: Address<TAccountToken>;\n  /** The account's owner/delegate or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getDisableCpiGuardInstruction<\n  TAccountToken extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: DisableCpiGuardInput<TAccountToken, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): DisableCpiGuardInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getDisableCpiGuardInstructionDataEncoder().encode({}),\n    programAddress,\n  } as DisableCpiGuardInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedDisableCpiGuardInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token account to update. */\n    token: TAccountMetas[0];\n    /** The account's owner/delegate or its multisignature account. */\n    owner: TAccountMetas[1];\n  };\n  data: DisableCpiGuardInstructionData;\n};\n\nexport function parseDisableCpiGuardInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedDisableCpiGuardInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), owner: getNextAccount() },\n    data: getDisableCpiGuardInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DISABLE_HARVEST_TO_MINT_DISCRIMINATOR = 37;\n\nexport function getDisableHarvestToMintDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_HARVEST_TO_MINT_DISCRIMINATOR);\n}\n\nexport const DISABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 5;\n\nexport function getDisableHarvestToMintConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    DISABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type DisableHarvestToMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DisableHarvestToMintInstructionData = {\n  discriminator: number;\n  confidentialTransferFeeDiscriminator: number;\n};\n\nexport type DisableHarvestToMintInstructionDataArgs = {};\n\nexport function getDisableHarvestToMintInstructionDataEncoder(): FixedSizeEncoder<DisableHarvestToMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferFeeDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_HARVEST_TO_MINT_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator:\n        DISABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getDisableHarvestToMintInstructionDataDecoder(): FixedSizeDecoder<DisableHarvestToMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferFeeDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getDisableHarvestToMintInstructionDataCodec(): FixedSizeCodec<\n  DisableHarvestToMintInstructionDataArgs,\n  DisableHarvestToMintInstructionData\n> {\n  return combineCodec(\n    getDisableHarvestToMintInstructionDataEncoder(),\n    getDisableHarvestToMintInstructionDataDecoder()\n  );\n}\n\nexport type DisableHarvestToMintInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The confidential transfer fee authority */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getDisableHarvestToMintInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: DisableHarvestToMintInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): DisableHarvestToMintInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getDisableHarvestToMintInstructionDataEncoder().encode({}),\n    programAddress,\n  } as DisableHarvestToMintInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedDisableHarvestToMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. */\n    mint: TAccountMetas[0];\n    /** The confidential transfer fee authority */\n    authority: TAccountMetas[1];\n  };\n  data: DisableHarvestToMintInstructionData;\n};\n\nexport function parseDisableHarvestToMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedDisableHarvestToMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), authority: getNextAccount() },\n    data: getDisableHarvestToMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DISABLE_MEMO_TRANSFERS_DISCRIMINATOR = 30;\n\nexport function getDisableMemoTransfersDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_MEMO_TRANSFERS_DISCRIMINATOR);\n}\n\nexport const DISABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR = 1;\n\nexport function getDisableMemoTransfersMemoTransfersDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    DISABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR\n  );\n}\n\nexport type DisableMemoTransfersInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DisableMemoTransfersInstructionData = {\n  discriminator: number;\n  memoTransfersDiscriminator: number;\n};\n\nexport type DisableMemoTransfersInstructionDataArgs = {};\n\nexport function getDisableMemoTransfersInstructionDataEncoder(): FixedSizeEncoder<DisableMemoTransfersInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['memoTransfersDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_MEMO_TRANSFERS_DISCRIMINATOR,\n      memoTransfersDiscriminator:\n        DISABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getDisableMemoTransfersInstructionDataDecoder(): FixedSizeDecoder<DisableMemoTransfersInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['memoTransfersDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getDisableMemoTransfersInstructionDataCodec(): FixedSizeCodec<\n  DisableMemoTransfersInstructionDataArgs,\n  DisableMemoTransfersInstructionData\n> {\n  return combineCodec(\n    getDisableMemoTransfersInstructionDataEncoder(),\n    getDisableMemoTransfersInstructionDataDecoder()\n  );\n}\n\nexport type DisableMemoTransfersInput<\n  TAccountToken extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The token account to update. */\n  token: Address<TAccountToken>;\n  /** The account's owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getDisableMemoTransfersInstruction<\n  TAccountToken extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: DisableMemoTransfersInput<TAccountToken, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): DisableMemoTransfersInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getDisableMemoTransfersInstructionDataEncoder().encode({}),\n    programAddress,\n  } as DisableMemoTransfersInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedDisableMemoTransfersInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token account to update. */\n    token: TAccountMetas[0];\n    /** The account's owner or its multisignature account. */\n    owner: TAccountMetas[1];\n  };\n  data: DisableMemoTransfersInstructionData;\n};\n\nexport function parseDisableMemoTransfersInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedDisableMemoTransfersInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), owner: getNextAccount() },\n    data: getDisableMemoTransfersInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const DISABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR = 27;\n\nexport function getDisableNonConfidentialCreditsDiscriminatorBytes() {\n  return getU8Encoder().encode(DISABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR);\n}\n\nexport const DISABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 12;\n\nexport function getDisableNonConfidentialCreditsConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    DISABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type DisableNonConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type DisableNonConfidentialCreditsInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n};\n\nexport type DisableNonConfidentialCreditsInstructionDataArgs = {};\n\nexport function getDisableNonConfidentialCreditsInstructionDataEncoder(): FixedSizeEncoder<DisableNonConfidentialCreditsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: DISABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        DISABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getDisableNonConfidentialCreditsInstructionDataDecoder(): FixedSizeDecoder<DisableNonConfidentialCreditsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getDisableNonConfidentialCreditsInstructionDataCodec(): FixedSizeCodec<\n  DisableNonConfidentialCreditsInstructionDataArgs,\n  DisableNonConfidentialCreditsInstructionData\n> {\n  return combineCodec(\n    getDisableNonConfidentialCreditsInstructionDataEncoder(),\n    getDisableNonConfidentialCreditsInstructionDataDecoder()\n  );\n}\n\nexport type DisableNonConfidentialCreditsInput<\n  TAccountToken extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getDisableNonConfidentialCreditsInstruction<\n  TAccountToken extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: DisableNonConfidentialCreditsInput<TAccountToken, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): DisableNonConfidentialCreditsInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getDisableNonConfidentialCreditsInstructionDataEncoder().encode({}),\n    programAddress,\n  } as DisableNonConfidentialCreditsInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedDisableNonConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[1];\n  };\n  data: DisableNonConfidentialCreditsInstructionData;\n};\n\nexport function parseDisableNonConfidentialCreditsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedDisableNonConfidentialCreditsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), authority: getNextAccount() },\n    data: getDisableNonConfidentialCreditsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getBytesDecoder,\n  getBytesEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  none,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const EMIT_TOKEN_METADATA_DISCRIMINATOR = new Uint8Array([\n  250, 166, 180, 250, 13, 12, 184, 70,\n]);\n\nexport function getEmitTokenMetadataDiscriminatorBytes() {\n  return getBytesEncoder().encode(EMIT_TOKEN_METADATA_DISCRIMINATOR);\n}\n\nexport type EmitTokenMetadataInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetadata extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMetadata extends string\n        ? ReadonlyAccount<TAccountMetadata>\n        : TAccountMetadata,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EmitTokenMetadataInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** Start of range of data to emit */\n  start: Option<bigint>;\n  /** End of range of data to emit */\n  end: Option<bigint>;\n};\n\nexport type EmitTokenMetadataInstructionDataArgs = {\n  /** Start of range of data to emit */\n  start?: OptionOrNullable<number | bigint>;\n  /** End of range of data to emit */\n  end?: OptionOrNullable<number | bigint>;\n};\n\nexport function getEmitTokenMetadataInstructionDataEncoder(): Encoder<EmitTokenMetadataInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      ['start', getOptionEncoder(getU64Encoder())],\n      ['end', getOptionEncoder(getU64Encoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: EMIT_TOKEN_METADATA_DISCRIMINATOR,\n      start: value.start ?? none(),\n      end: value.end ?? none(),\n    })\n  );\n}\n\nexport function getEmitTokenMetadataInstructionDataDecoder(): Decoder<EmitTokenMetadataInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    ['start', getOptionDecoder(getU64Decoder())],\n    ['end', getOptionDecoder(getU64Decoder())],\n  ]);\n}\n\nexport function getEmitTokenMetadataInstructionDataCodec(): Codec<\n  EmitTokenMetadataInstructionDataArgs,\n  EmitTokenMetadataInstructionData\n> {\n  return combineCodec(\n    getEmitTokenMetadataInstructionDataEncoder(),\n    getEmitTokenMetadataInstructionDataDecoder()\n  );\n}\n\nexport type EmitTokenMetadataInput<TAccountMetadata extends string = string> = {\n  metadata: Address<TAccountMetadata>;\n  start?: EmitTokenMetadataInstructionDataArgs['start'];\n  end?: EmitTokenMetadataInstructionDataArgs['end'];\n};\n\nexport function getEmitTokenMetadataInstruction<\n  TAccountMetadata extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EmitTokenMetadataInput<TAccountMetadata>,\n  config?: { programAddress?: TProgramAddress }\n): EmitTokenMetadataInstruction<TProgramAddress, TAccountMetadata> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.metadata)],\n    data: getEmitTokenMetadataInstructionDataEncoder().encode(\n      args as EmitTokenMetadataInstructionDataArgs\n    ),\n    programAddress,\n  } as EmitTokenMetadataInstruction<TProgramAddress, TAccountMetadata>);\n}\n\nexport type ParsedEmitTokenMetadataInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    metadata: TAccountMetas[0];\n  };\n  data: EmitTokenMetadataInstructionData;\n};\n\nexport function parseEmitTokenMetadataInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedEmitTokenMetadataInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { metadata: getNextAccount() },\n    data: getEmitTokenMetadataInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR = 27;\n\nexport function getEmptyConfidentialTransferAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR\n  );\n}\n\nexport const EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 4;\n\nexport function getEmptyConfidentialTransferAccountConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type EmptyConfidentialTransferAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountInstructionsSysvarOrContextState extends\n    | string\n    | AccountMeta<string> = 'Sysvar1nstructions1111111111111111111111111',\n  TAccountRecord extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountInstructionsSysvarOrContextState extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvarOrContextState>\n        : TAccountInstructionsSysvarOrContextState,\n      TAccountRecord extends string\n        ? ReadonlyAccount<TAccountRecord>\n        : TAccountRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EmptyConfidentialTransferAccountInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /**\n   * Relative location of the `ProofInstruction::VerifyCloseAccount`\n   * instruction to the `EmptyAccount` instruction in the transaction. If\n   * the offset is `0`, then use a context state account for the proof.\n   */\n  proofInstructionOffset: number;\n};\n\nexport type EmptyConfidentialTransferAccountInstructionDataArgs = {\n  /**\n   * Relative location of the `ProofInstruction::VerifyCloseAccount`\n   * instruction to the `EmptyAccount` instruction in the transaction. If\n   * the offset is `0`, then use a context state account for the proof.\n   */\n  proofInstructionOffset: number;\n};\n\nexport function getEmptyConfidentialTransferAccountInstructionDataEncoder(): FixedSizeEncoder<EmptyConfidentialTransferAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['proofInstructionOffset', getI8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        EMPTY_CONFIDENTIAL_TRANSFER_ACCOUNT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getEmptyConfidentialTransferAccountInstructionDataDecoder(): FixedSizeDecoder<EmptyConfidentialTransferAccountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['proofInstructionOffset', getI8Decoder()],\n  ]);\n}\n\nexport function getEmptyConfidentialTransferAccountInstructionDataCodec(): FixedSizeCodec<\n  EmptyConfidentialTransferAccountInstructionDataArgs,\n  EmptyConfidentialTransferAccountInstructionData\n> {\n  return combineCodec(\n    getEmptyConfidentialTransferAccountInstructionDataEncoder(),\n    getEmptyConfidentialTransferAccountInstructionDataDecoder()\n  );\n}\n\nexport type EmptyConfidentialTransferAccountInput<\n  TAccountToken extends string = string,\n  TAccountInstructionsSysvarOrContextState extends string = string,\n  TAccountRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /**\n   * Instructions sysvar if `VerifyZeroCiphertext` is included in\n   * the same transaction or context state account if\n   * `VerifyZeroCiphertext` is pre-verified into a context state\n   * account.\n   */\n  instructionsSysvarOrContextState?: Address<TAccountInstructionsSysvarOrContextState>;\n  /** (Optional) Record account if the accompanying proof is to be read from a record account. */\n  record?: Address<TAccountRecord>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  proofInstructionOffset: EmptyConfidentialTransferAccountInstructionDataArgs['proofInstructionOffset'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getEmptyConfidentialTransferAccountInstruction<\n  TAccountToken extends string,\n  TAccountInstructionsSysvarOrContextState extends string,\n  TAccountRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EmptyConfidentialTransferAccountInput<\n    TAccountToken,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): EmptyConfidentialTransferAccountInstruction<\n  TProgramAddress,\n  TAccountToken,\n  TAccountInstructionsSysvarOrContextState,\n  TAccountRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    instructionsSysvarOrContextState: {\n      value: input.instructionsSysvarOrContextState ?? null,\n      isWritable: false,\n    },\n    record: { value: input.record ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.instructionsSysvarOrContextState.value) {\n    accounts.instructionsSysvarOrContextState.value =\n      'Sysvar1nstructions1111111111111111111111111' as Address<'Sysvar1nstructions1111111111111111111111111'>;\n  }\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.instructionsSysvarOrContextState),\n      getAccountMeta(accounts.record),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getEmptyConfidentialTransferAccountInstructionDataEncoder().encode(\n      args as EmptyConfidentialTransferAccountInstructionDataArgs\n    ),\n    programAddress,\n  } as EmptyConfidentialTransferAccountInstruction<\n    TProgramAddress,\n    TAccountToken,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedEmptyConfidentialTransferAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /**\n     * Instructions sysvar if `VerifyZeroCiphertext` is included in\n     * the same transaction or context state account if\n     * `VerifyZeroCiphertext` is pre-verified into a context state\n     * account.\n     */\n    instructionsSysvarOrContextState: TAccountMetas[1];\n    /** (Optional) Record account if the accompanying proof is to be read from a record account. */\n    record?: TAccountMetas[2] | undefined;\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[3];\n  };\n  data: EmptyConfidentialTransferAccountInstructionData;\n};\n\nexport function parseEmptyConfidentialTransferAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedEmptyConfidentialTransferAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      instructionsSysvarOrContextState: getNextAccount(),\n      record: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getEmptyConfidentialTransferAccountInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ENABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR = 27;\n\nexport function getEnableConfidentialCreditsDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR);\n}\n\nexport const ENABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 9;\n\nexport function getEnableConfidentialCreditsConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    ENABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type EnableConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EnableConfidentialCreditsInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n};\n\nexport type EnableConfidentialCreditsInstructionDataArgs = {};\n\nexport function getEnableConfidentialCreditsInstructionDataEncoder(): FixedSizeEncoder<EnableConfidentialCreditsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_CONFIDENTIAL_CREDITS_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        ENABLE_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getEnableConfidentialCreditsInstructionDataDecoder(): FixedSizeDecoder<EnableConfidentialCreditsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getEnableConfidentialCreditsInstructionDataCodec(): FixedSizeCodec<\n  EnableConfidentialCreditsInstructionDataArgs,\n  EnableConfidentialCreditsInstructionData\n> {\n  return combineCodec(\n    getEnableConfidentialCreditsInstructionDataEncoder(),\n    getEnableConfidentialCreditsInstructionDataDecoder()\n  );\n}\n\nexport type EnableConfidentialCreditsInput<\n  TAccountToken extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getEnableConfidentialCreditsInstruction<\n  TAccountToken extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EnableConfidentialCreditsInput<TAccountToken, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): EnableConfidentialCreditsInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getEnableConfidentialCreditsInstructionDataEncoder().encode({}),\n    programAddress,\n  } as EnableConfidentialCreditsInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedEnableConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[1];\n  };\n  data: EnableConfidentialCreditsInstructionData;\n};\n\nexport function parseEnableConfidentialCreditsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedEnableConfidentialCreditsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), authority: getNextAccount() },\n    data: getEnableConfidentialCreditsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ENABLE_CPI_GUARD_DISCRIMINATOR = 34;\n\nexport function getEnableCpiGuardDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_CPI_GUARD_DISCRIMINATOR);\n}\n\nexport const ENABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR = 0;\n\nexport function getEnableCpiGuardCpiGuardDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR);\n}\n\nexport type EnableCpiGuardInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EnableCpiGuardInstructionData = {\n  discriminator: number;\n  cpiGuardDiscriminator: number;\n};\n\nexport type EnableCpiGuardInstructionDataArgs = {};\n\nexport function getEnableCpiGuardInstructionDataEncoder(): FixedSizeEncoder<EnableCpiGuardInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['cpiGuardDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_CPI_GUARD_DISCRIMINATOR,\n      cpiGuardDiscriminator: ENABLE_CPI_GUARD_CPI_GUARD_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getEnableCpiGuardInstructionDataDecoder(): FixedSizeDecoder<EnableCpiGuardInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['cpiGuardDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getEnableCpiGuardInstructionDataCodec(): FixedSizeCodec<\n  EnableCpiGuardInstructionDataArgs,\n  EnableCpiGuardInstructionData\n> {\n  return combineCodec(\n    getEnableCpiGuardInstructionDataEncoder(),\n    getEnableCpiGuardInstructionDataDecoder()\n  );\n}\n\nexport type EnableCpiGuardInput<\n  TAccountToken extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The token account to update. */\n  token: Address<TAccountToken>;\n  /** The account's owner/delegate or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getEnableCpiGuardInstruction<\n  TAccountToken extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EnableCpiGuardInput<TAccountToken, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): EnableCpiGuardInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getEnableCpiGuardInstructionDataEncoder().encode({}),\n    programAddress,\n  } as EnableCpiGuardInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedEnableCpiGuardInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token account to update. */\n    token: TAccountMetas[0];\n    /** The account's owner/delegate or its multisignature account. */\n    owner: TAccountMetas[1];\n  };\n  data: EnableCpiGuardInstructionData;\n};\n\nexport function parseEnableCpiGuardInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedEnableCpiGuardInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), owner: getNextAccount() },\n    data: getEnableCpiGuardInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ENABLE_HARVEST_TO_MINT_DISCRIMINATOR = 37;\n\nexport function getEnableHarvestToMintDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_HARVEST_TO_MINT_DISCRIMINATOR);\n}\n\nexport const ENABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 4;\n\nexport function getEnableHarvestToMintConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    ENABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type EnableHarvestToMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EnableHarvestToMintInstructionData = {\n  discriminator: number;\n  confidentialTransferFeeDiscriminator: number;\n};\n\nexport type EnableHarvestToMintInstructionDataArgs = {};\n\nexport function getEnableHarvestToMintInstructionDataEncoder(): FixedSizeEncoder<EnableHarvestToMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferFeeDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_HARVEST_TO_MINT_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator:\n        ENABLE_HARVEST_TO_MINT_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getEnableHarvestToMintInstructionDataDecoder(): FixedSizeDecoder<EnableHarvestToMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferFeeDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getEnableHarvestToMintInstructionDataCodec(): FixedSizeCodec<\n  EnableHarvestToMintInstructionDataArgs,\n  EnableHarvestToMintInstructionData\n> {\n  return combineCodec(\n    getEnableHarvestToMintInstructionDataEncoder(),\n    getEnableHarvestToMintInstructionDataDecoder()\n  );\n}\n\nexport type EnableHarvestToMintInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The confidential transfer fee authority */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getEnableHarvestToMintInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EnableHarvestToMintInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): EnableHarvestToMintInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getEnableHarvestToMintInstructionDataEncoder().encode({}),\n    programAddress,\n  } as EnableHarvestToMintInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedEnableHarvestToMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. */\n    mint: TAccountMetas[0];\n    /** The confidential transfer fee authority */\n    authority: TAccountMetas[1];\n  };\n  data: EnableHarvestToMintInstructionData;\n};\n\nexport function parseEnableHarvestToMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedEnableHarvestToMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), authority: getNextAccount() },\n    data: getEnableHarvestToMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ENABLE_MEMO_TRANSFERS_DISCRIMINATOR = 30;\n\nexport function getEnableMemoTransfersDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_MEMO_TRANSFERS_DISCRIMINATOR);\n}\n\nexport const ENABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR = 0;\n\nexport function getEnableMemoTransfersMemoTransfersDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    ENABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR\n  );\n}\n\nexport type EnableMemoTransfersInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EnableMemoTransfersInstructionData = {\n  discriminator: number;\n  memoTransfersDiscriminator: number;\n};\n\nexport type EnableMemoTransfersInstructionDataArgs = {};\n\nexport function getEnableMemoTransfersInstructionDataEncoder(): FixedSizeEncoder<EnableMemoTransfersInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['memoTransfersDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_MEMO_TRANSFERS_DISCRIMINATOR,\n      memoTransfersDiscriminator:\n        ENABLE_MEMO_TRANSFERS_MEMO_TRANSFERS_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getEnableMemoTransfersInstructionDataDecoder(): FixedSizeDecoder<EnableMemoTransfersInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['memoTransfersDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getEnableMemoTransfersInstructionDataCodec(): FixedSizeCodec<\n  EnableMemoTransfersInstructionDataArgs,\n  EnableMemoTransfersInstructionData\n> {\n  return combineCodec(\n    getEnableMemoTransfersInstructionDataEncoder(),\n    getEnableMemoTransfersInstructionDataDecoder()\n  );\n}\n\nexport type EnableMemoTransfersInput<\n  TAccountToken extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The token account to update. */\n  token: Address<TAccountToken>;\n  /** The account's owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getEnableMemoTransfersInstruction<\n  TAccountToken extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EnableMemoTransfersInput<TAccountToken, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): EnableMemoTransfersInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getEnableMemoTransfersInstructionDataEncoder().encode({}),\n    programAddress,\n  } as EnableMemoTransfersInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedEnableMemoTransfersInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token account to update. */\n    token: TAccountMetas[0];\n    /** The account's owner or its multisignature account. */\n    owner: TAccountMetas[1];\n  };\n  data: EnableMemoTransfersInstructionData;\n};\n\nexport function parseEnableMemoTransfersInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedEnableMemoTransfersInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), owner: getNextAccount() },\n    data: getEnableMemoTransfersInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const ENABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR = 27;\n\nexport function getEnableNonConfidentialCreditsDiscriminatorBytes() {\n  return getU8Encoder().encode(ENABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR);\n}\n\nexport const ENABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 11;\n\nexport function getEnableNonConfidentialCreditsConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    ENABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type EnableNonConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type EnableNonConfidentialCreditsInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n};\n\nexport type EnableNonConfidentialCreditsInstructionDataArgs = {};\n\nexport function getEnableNonConfidentialCreditsInstructionDataEncoder(): FixedSizeEncoder<EnableNonConfidentialCreditsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: ENABLE_NON_CONFIDENTIAL_CREDITS_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        ENABLE_NON_CONFIDENTIAL_CREDITS_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getEnableNonConfidentialCreditsInstructionDataDecoder(): FixedSizeDecoder<EnableNonConfidentialCreditsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getEnableNonConfidentialCreditsInstructionDataCodec(): FixedSizeCodec<\n  EnableNonConfidentialCreditsInstructionDataArgs,\n  EnableNonConfidentialCreditsInstructionData\n> {\n  return combineCodec(\n    getEnableNonConfidentialCreditsInstructionDataEncoder(),\n    getEnableNonConfidentialCreditsInstructionDataDecoder()\n  );\n}\n\nexport type EnableNonConfidentialCreditsInput<\n  TAccountToken extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token account. */\n  token: Address<TAccountToken>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getEnableNonConfidentialCreditsInstruction<\n  TAccountToken extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: EnableNonConfidentialCreditsInput<TAccountToken, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): EnableNonConfidentialCreditsInstruction<\n  TProgramAddress,\n  TAccountToken,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getEnableNonConfidentialCreditsInstructionDataEncoder().encode({}),\n    programAddress,\n  } as EnableNonConfidentialCreditsInstruction<\n    TProgramAddress,\n    TAccountToken,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedEnableNonConfidentialCreditsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token account. */\n    token: TAccountMetas[0];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[1];\n  };\n  data: EnableNonConfidentialCreditsInstructionData;\n};\n\nexport function parseEnableNonConfidentialCreditsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedEnableNonConfidentialCreditsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { token: getNextAccount(), authority: getNextAccount() },\n    data: getEnableNonConfidentialCreditsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const FREEZE_ACCOUNT_DISCRIMINATOR = 10;\n\nexport function getFreezeAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(FREEZE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type FreezeAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type FreezeAccountInstructionData = { discriminator: number };\n\nexport type FreezeAccountInstructionDataArgs = {};\n\nexport function getFreezeAccountInstructionDataEncoder(): FixedSizeEncoder<FreezeAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: FREEZE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getFreezeAccountInstructionDataDecoder(): FixedSizeDecoder<FreezeAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getFreezeAccountInstructionDataCodec(): FixedSizeCodec<\n  FreezeAccountInstructionDataArgs,\n  FreezeAccountInstructionData\n> {\n  return combineCodec(\n    getFreezeAccountInstructionDataEncoder(),\n    getFreezeAccountInstructionDataDecoder()\n  );\n}\n\nexport type FreezeAccountInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The account to freeze. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The mint freeze authority or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getFreezeAccountInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: FreezeAccountInput<TAccountAccount, TAccountMint, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): FreezeAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getFreezeAccountInstructionDataEncoder().encode({}),\n    programAddress,\n  } as FreezeAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedFreezeAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to freeze. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The mint freeze authority or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: FreezeAccountInstructionData;\n};\n\nexport function parseFreezeAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedFreezeAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getFreezeAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR = 21;\n\nexport function getGetAccountDataSizeDiscriminatorBytes() {\n  return getU8Encoder().encode(GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR);\n}\n\nexport type GetAccountDataSizeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type GetAccountDataSizeInstructionData = { discriminator: number };\n\nexport type GetAccountDataSizeInstructionDataArgs = {};\n\nexport function getGetAccountDataSizeInstructionDataEncoder(): FixedSizeEncoder<GetAccountDataSizeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: GET_ACCOUNT_DATA_SIZE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getGetAccountDataSizeInstructionDataDecoder(): FixedSizeDecoder<GetAccountDataSizeInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getGetAccountDataSizeInstructionDataCodec(): FixedSizeCodec<\n  GetAccountDataSizeInstructionDataArgs,\n  GetAccountDataSizeInstructionData\n> {\n  return combineCodec(\n    getGetAccountDataSizeInstructionDataEncoder(),\n    getGetAccountDataSizeInstructionDataDecoder()\n  );\n}\n\nexport type GetAccountDataSizeInput<TAccountMint extends string = string> = {\n  /** The mint to calculate for. */\n  mint: Address<TAccountMint>;\n};\n\nexport function getGetAccountDataSizeInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: GetAccountDataSizeInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): GetAccountDataSizeInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getGetAccountDataSizeInstructionDataEncoder().encode({}),\n    programAddress,\n  } as GetAccountDataSizeInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedGetAccountDataSizeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to calculate for. */\n    mint: TAccountMetas[0];\n  };\n  data: GetAccountDataSizeInstructionData;\n};\n\nexport function parseGetAccountDataSizeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedGetAccountDataSizeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getGetAccountDataSizeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const HARVEST_WITHHELD_TOKENS_TO_MINT_DISCRIMINATOR = 26;\n\nexport function getHarvestWithheldTokensToMintDiscriminatorBytes() {\n  return getU8Encoder().encode(HARVEST_WITHHELD_TOKENS_TO_MINT_DISCRIMINATOR);\n}\n\nexport const HARVEST_WITHHELD_TOKENS_TO_MINT_TRANSFER_FEE_DISCRIMINATOR = 4;\n\nexport function getHarvestWithheldTokensToMintTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    HARVEST_WITHHELD_TOKENS_TO_MINT_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type HarvestWithheldTokensToMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type HarvestWithheldTokensToMintInstructionData = {\n  discriminator: number;\n  transferFeeDiscriminator: number;\n};\n\nexport type HarvestWithheldTokensToMintInstructionDataArgs = {};\n\nexport function getHarvestWithheldTokensToMintInstructionDataEncoder(): FixedSizeEncoder<HarvestWithheldTokensToMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferFeeDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: HARVEST_WITHHELD_TOKENS_TO_MINT_DISCRIMINATOR,\n      transferFeeDiscriminator:\n        HARVEST_WITHHELD_TOKENS_TO_MINT_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getHarvestWithheldTokensToMintInstructionDataDecoder(): FixedSizeDecoder<HarvestWithheldTokensToMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferFeeDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getHarvestWithheldTokensToMintInstructionDataCodec(): FixedSizeCodec<\n  HarvestWithheldTokensToMintInstructionDataArgs,\n  HarvestWithheldTokensToMintInstructionData\n> {\n  return combineCodec(\n    getHarvestWithheldTokensToMintInstructionDataEncoder(),\n    getHarvestWithheldTokensToMintInstructionDataDecoder()\n  );\n}\n\nexport type HarvestWithheldTokensToMintInput<\n  TAccountMint extends string = string,\n> = {\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  sources: Array<Address>;\n};\n\nexport function getHarvestWithheldTokensToMintInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: HarvestWithheldTokensToMintInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): HarvestWithheldTokensToMintInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = args.sources.map((address) => ({\n    address,\n    role: AccountRole.WRITABLE,\n  }));\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint), ...remainingAccounts],\n    data: getHarvestWithheldTokensToMintInstructionDataEncoder().encode({}),\n    programAddress,\n  } as HarvestWithheldTokensToMintInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedHarvestWithheldTokensToMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. */\n    mint: TAccountMetas[0];\n  };\n  data: HarvestWithheldTokensToMintInstructionData;\n};\n\nexport function parseHarvestWithheldTokensToMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedHarvestWithheldTokensToMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getHarvestWithheldTokensToMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 37;\n\nexport function getHarvestWithheldTokensToMintForConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport const HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 3;\n\nexport function getHarvestWithheldTokensToMintForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type HarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionData =\n  { discriminator: number; confidentialTransferFeeDiscriminator: number };\n\nexport type HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataArgs =\n  {};\n\nexport function getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataEncoder(): FixedSizeEncoder<HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferFeeDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator:\n        HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator:\n        HARVEST_WITHHELD_TOKENS_TO_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataDecoder(): FixedSizeDecoder<HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferFeeDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataCodec(): FixedSizeCodec<\n  HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataArgs,\n  HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionData\n> {\n  return combineCodec(\n    getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataEncoder(),\n    getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataDecoder()\n  );\n}\n\nexport type HarvestWithheldTokensToMintForConfidentialTransferFeeInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  sources?: Array<Address>;\n};\n\nexport function getHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: HarvestWithheldTokensToMintForConfidentialTransferFeeInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): HarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n  TProgramAddress,\n  TAccountMint\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.sources ?? []).map(\n    (address) => ({ address, role: AccountRole.WRITABLE })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint), ...remainingAccounts],\n    data: getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataEncoder().encode(\n      {}\n    ),\n    programAddress,\n  } as HarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n    TProgramAddress,\n    TAccountMint\n  >);\n}\n\nexport type ParsedHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n  };\n  data: HarvestWithheldTokensToMintForConfidentialTransferFeeInstructionData;\n};\n\nexport function parseHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedHarvestWithheldTokensToMintForConfidentialTransferFeeInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getHarvestWithheldTokensToMintForConfidentialTransferFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_ACCOUNT_DISCRIMINATOR = 1;\n\nexport function getInitializeAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type InitializeAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeAccountInstructionData = { discriminator: number };\n\nexport type InitializeAccountInstructionDataArgs = {};\n\nexport function getInitializeAccountInstructionDataEncoder(): FixedSizeEncoder<InitializeAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeAccountInstructionDataDecoder(): FixedSizeDecoder<InitializeAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getInitializeAccountInstructionDataCodec(): FixedSizeCodec<\n  InitializeAccountInstructionDataArgs,\n  InitializeAccountInstructionData\n> {\n  return combineCodec(\n    getInitializeAccountInstructionDataEncoder(),\n    getInitializeAccountInstructionDataDecoder()\n  );\n}\n\nexport type InitializeAccountInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountOwner extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n  /** The mint this account will be associated with. */\n  mint: Address<TAccountMint>;\n  /** The new account's owner/multisignature. */\n  owner: Address<TAccountOwner>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n};\n\nexport function getInitializeAccountInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountOwner extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeAccountInput<\n    TAccountAccount,\n    TAccountMint,\n    TAccountOwner,\n    TAccountRent\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  TAccountOwner,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.owner),\n      getAccountMeta(accounts.rent),\n    ],\n    data: getInitializeAccountInstructionDataEncoder().encode({}),\n    programAddress,\n  } as InitializeAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    TAccountOwner,\n    TAccountRent\n  >);\n}\n\nexport type ParsedInitializeAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n    /** The mint this account will be associated with. */\n    mint: TAccountMetas[1];\n    /** The new account's owner/multisignature. */\n    owner: TAccountMetas[2];\n    /** Rent sysvar. */\n    rent: TAccountMetas[3];\n  };\n  data: InitializeAccountInstructionData;\n};\n\nexport function parseInitializeAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      owner: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializeAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_ACCOUNT2_DISCRIMINATOR = 16;\n\nexport function getInitializeAccount2DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_ACCOUNT2_DISCRIMINATOR);\n}\n\nexport type InitializeAccount2Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeAccount2InstructionData = {\n  discriminator: number;\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport type InitializeAccount2InstructionDataArgs = {\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport function getInitializeAccount2InstructionDataEncoder(): FixedSizeEncoder<InitializeAccount2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['owner', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT2_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeAccount2InstructionDataDecoder(): FixedSizeDecoder<InitializeAccount2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['owner', getAddressDecoder()],\n  ]);\n}\n\nexport function getInitializeAccount2InstructionDataCodec(): FixedSizeCodec<\n  InitializeAccount2InstructionDataArgs,\n  InitializeAccount2InstructionData\n> {\n  return combineCodec(\n    getInitializeAccount2InstructionDataEncoder(),\n    getInitializeAccount2InstructionDataDecoder()\n  );\n}\n\nexport type InitializeAccount2Input<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n  /** The mint this account will be associated with. */\n  mint: Address<TAccountMint>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n  owner: InitializeAccount2InstructionDataArgs['owner'];\n};\n\nexport function getInitializeAccount2Instruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeAccount2Input<TAccountAccount, TAccountMint, TAccountRent>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeAccount2Instruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.rent),\n    ],\n    data: getInitializeAccount2InstructionDataEncoder().encode(\n      args as InitializeAccount2InstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeAccount2Instruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    TAccountRent\n  >);\n}\n\nexport type ParsedInitializeAccount2Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n    /** The mint this account will be associated with. */\n    mint: TAccountMetas[1];\n    /** Rent sysvar. */\n    rent: TAccountMetas[2];\n  };\n  data: InitializeAccount2InstructionData;\n};\n\nexport function parseInitializeAccount2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeAccount2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      rent: getNextAccount(),\n    },\n    data: getInitializeAccount2InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_ACCOUNT3_DISCRIMINATOR = 18;\n\nexport function getInitializeAccount3DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_ACCOUNT3_DISCRIMINATOR);\n}\n\nexport type InitializeAccount3Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeAccount3InstructionData = {\n  discriminator: number;\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport type InitializeAccount3InstructionDataArgs = {\n  /** The new account's owner/multisignature. */\n  owner: Address;\n};\n\nexport function getInitializeAccount3InstructionDataEncoder(): FixedSizeEncoder<InitializeAccount3InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['owner', getAddressEncoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_ACCOUNT3_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeAccount3InstructionDataDecoder(): FixedSizeDecoder<InitializeAccount3InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['owner', getAddressDecoder()],\n  ]);\n}\n\nexport function getInitializeAccount3InstructionDataCodec(): FixedSizeCodec<\n  InitializeAccount3InstructionDataArgs,\n  InitializeAccount3InstructionData\n> {\n  return combineCodec(\n    getInitializeAccount3InstructionDataEncoder(),\n    getInitializeAccount3InstructionDataDecoder()\n  );\n}\n\nexport type InitializeAccount3Input<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n  /** The mint this account will be associated with. */\n  mint: Address<TAccountMint>;\n  owner: InitializeAccount3InstructionDataArgs['owner'];\n};\n\nexport function getInitializeAccount3Instruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeAccount3Input<TAccountAccount, TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeAccount3Instruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.account), getAccountMeta(accounts.mint)],\n    data: getInitializeAccount3InstructionDataEncoder().encode(\n      args as InitializeAccount3InstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeAccount3Instruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint\n  >);\n}\n\nexport type ParsedInitializeAccount3Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n    /** The mint this account will be associated with. */\n    mint: TAccountMetas[1];\n  };\n  data: InitializeAccount3InstructionData;\n};\n\nexport function parseInitializeAccount3Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeAccount3Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { account: getNextAccount(), mint: getNextAccount() },\n    data: getInitializeAccount3InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 37;\n\nexport function getInitializeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport const INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 0;\n\nexport function getInitializeConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type InitializeConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeConfidentialTransferFeeInstructionData = {\n  discriminator: number;\n  confidentialTransferFeeDiscriminator: number;\n  /** Optional authority to set the withdraw withheld authority ElGamal key */\n  authority: Option<Address>;\n  /** Withheld fees from accounts must be encrypted with this ElGamal key */\n  withdrawWithheldAuthorityElGamalPubkey: Option<Address>;\n};\n\nexport type InitializeConfidentialTransferFeeInstructionDataArgs = {\n  /** Optional authority to set the withdraw withheld authority ElGamal key */\n  authority: OptionOrNullable<Address>;\n  /** Withheld fees from accounts must be encrypted with this ElGamal key */\n  withdrawWithheldAuthorityElGamalPubkey: OptionOrNullable<Address>;\n};\n\nexport function getInitializeConfidentialTransferFeeInstructionDataEncoder(): FixedSizeEncoder<InitializeConfidentialTransferFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferFeeDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      [\n        'withdrawWithheldAuthorityElGamalPubkey',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator:\n        INITIALIZE_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeConfidentialTransferFeeInstructionDataDecoder(): FixedSizeDecoder<InitializeConfidentialTransferFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferFeeDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'withdrawWithheldAuthorityElGamalPubkey',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializeConfidentialTransferFeeInstructionDataCodec(): FixedSizeCodec<\n  InitializeConfidentialTransferFeeInstructionDataArgs,\n  InitializeConfidentialTransferFeeInstructionData\n> {\n  return combineCodec(\n    getInitializeConfidentialTransferFeeInstructionDataEncoder(),\n    getInitializeConfidentialTransferFeeInstructionDataDecoder()\n  );\n}\n\nexport type InitializeConfidentialTransferFeeInput<\n  TAccountMint extends string = string,\n> = {\n  /** The SPL Token mint. */\n  mint: Address<TAccountMint>;\n  authority: InitializeConfidentialTransferFeeInstructionDataArgs['authority'];\n  withdrawWithheldAuthorityElGamalPubkey: InitializeConfidentialTransferFeeInstructionDataArgs['withdrawWithheldAuthorityElGamalPubkey'];\n};\n\nexport function getInitializeConfidentialTransferFeeInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeConfidentialTransferFeeInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeConfidentialTransferFeeInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeConfidentialTransferFeeInstructionDataEncoder().encode(\n      args as InitializeConfidentialTransferFeeInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeConfidentialTransferFeeInstruction<\n    TProgramAddress,\n    TAccountMint\n  >);\n}\n\nexport type ParsedInitializeConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token mint. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeConfidentialTransferFeeInstructionData;\n};\n\nexport function parseInitializeConfidentialTransferFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeConfidentialTransferFeeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeConfidentialTransferFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR = 27;\n\nexport function getInitializeConfidentialTransferMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR\n  );\n}\n\nexport const INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 0;\n\nexport function getInitializeConfidentialTransferMintConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type InitializeConfidentialTransferMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeConfidentialTransferMintInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /**\n   * Authority to modify the `ConfidentialTransferMint` configuration and to\n   * approve new accounts.\n   */\n  authority: Option<Address>;\n  /**\n   * Determines if newly configured accounts must be approved by the\n   * `authority` before they may be used by the user.\n   */\n  autoApproveNewAccounts: boolean;\n  /** New authority to decode any transfer amount in a confidential transfer. */\n  auditorElgamalPubkey: Option<Address>;\n};\n\nexport type InitializeConfidentialTransferMintInstructionDataArgs = {\n  /**\n   * Authority to modify the `ConfidentialTransferMint` configuration and to\n   * approve new accounts.\n   */\n  authority: OptionOrNullable<Address>;\n  /**\n   * Determines if newly configured accounts must be approved by the\n   * `authority` before they may be used by the user.\n   */\n  autoApproveNewAccounts: boolean;\n  /** New authority to decode any transfer amount in a confidential transfer. */\n  auditorElgamalPubkey: OptionOrNullable<Address>;\n};\n\nexport function getInitializeConfidentialTransferMintInstructionDataEncoder(): FixedSizeEncoder<InitializeConfidentialTransferMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      ['autoApproveNewAccounts', getBooleanEncoder()],\n      [\n        'auditorElgamalPubkey',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        INITIALIZE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeConfidentialTransferMintInstructionDataDecoder(): FixedSizeDecoder<InitializeConfidentialTransferMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['autoApproveNewAccounts', getBooleanDecoder()],\n    [\n      'auditorElgamalPubkey',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializeConfidentialTransferMintInstructionDataCodec(): FixedSizeCodec<\n  InitializeConfidentialTransferMintInstructionDataArgs,\n  InitializeConfidentialTransferMintInstructionData\n> {\n  return combineCodec(\n    getInitializeConfidentialTransferMintInstructionDataEncoder(),\n    getInitializeConfidentialTransferMintInstructionDataDecoder()\n  );\n}\n\nexport type InitializeConfidentialTransferMintInput<\n  TAccountMint extends string = string,\n> = {\n  /** The SPL Token mint. */\n  mint: Address<TAccountMint>;\n  authority: InitializeConfidentialTransferMintInstructionDataArgs['authority'];\n  autoApproveNewAccounts: InitializeConfidentialTransferMintInstructionDataArgs['autoApproveNewAccounts'];\n  auditorElgamalPubkey: InitializeConfidentialTransferMintInstructionDataArgs['auditorElgamalPubkey'];\n};\n\nexport function getInitializeConfidentialTransferMintInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeConfidentialTransferMintInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeConfidentialTransferMintInstruction<\n  TProgramAddress,\n  TAccountMint\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeConfidentialTransferMintInstructionDataEncoder().encode(\n      args as InitializeConfidentialTransferMintInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeConfidentialTransferMintInstruction<\n    TProgramAddress,\n    TAccountMint\n  >);\n}\n\nexport type ParsedInitializeConfidentialTransferMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token mint. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeConfidentialTransferMintInstructionData;\n};\n\nexport function parseInitializeConfidentialTransferMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeConfidentialTransferMintInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeConfidentialTransferMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getAccountStateDecoder,\n  getAccountStateEncoder,\n  type AccountState,\n  type AccountStateArgs,\n} from '../types';\n\nexport const INITIALIZE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = 28;\n\nexport function getInitializeDefaultAccountStateDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = 0;\n\nexport function getInitializeDefaultAccountStateDefaultAccountStateDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR\n  );\n}\n\nexport type InitializeDefaultAccountStateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeDefaultAccountStateInstructionData = {\n  discriminator: number;\n  defaultAccountStateDiscriminator: number;\n  /** The state each new token account should start with. */\n  state: AccountState;\n};\n\nexport type InitializeDefaultAccountStateInstructionDataArgs = {\n  /** The state each new token account should start with. */\n  state: AccountStateArgs;\n};\n\nexport function getInitializeDefaultAccountStateInstructionDataEncoder(): FixedSizeEncoder<InitializeDefaultAccountStateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['defaultAccountStateDiscriminator', getU8Encoder()],\n      ['state', getAccountStateEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR,\n      defaultAccountStateDiscriminator:\n        INITIALIZE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeDefaultAccountStateInstructionDataDecoder(): FixedSizeDecoder<InitializeDefaultAccountStateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['defaultAccountStateDiscriminator', getU8Decoder()],\n    ['state', getAccountStateDecoder()],\n  ]);\n}\n\nexport function getInitializeDefaultAccountStateInstructionDataCodec(): FixedSizeCodec<\n  InitializeDefaultAccountStateInstructionDataArgs,\n  InitializeDefaultAccountStateInstructionData\n> {\n  return combineCodec(\n    getInitializeDefaultAccountStateInstructionDataEncoder(),\n    getInitializeDefaultAccountStateInstructionDataDecoder()\n  );\n}\n\nexport type InitializeDefaultAccountStateInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  state: InitializeDefaultAccountStateInstructionDataArgs['state'];\n};\n\nexport function getInitializeDefaultAccountStateInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeDefaultAccountStateInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeDefaultAccountStateInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeDefaultAccountStateInstructionDataEncoder().encode(\n      args as InitializeDefaultAccountStateInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeDefaultAccountStateInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializeDefaultAccountStateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeDefaultAccountStateInstructionData;\n};\n\nexport function parseInitializeDefaultAccountStateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeDefaultAccountStateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeDefaultAccountStateInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_GROUP_MEMBER_POINTER_DISCRIMINATOR = 41;\n\nexport function getInitializeGroupMemberPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_GROUP_MEMBER_POINTER_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR = 0;\n\nexport function getInitializeGroupMemberPointerGroupMemberPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR\n  );\n}\n\nexport type InitializeGroupMemberPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeGroupMemberPointerInstructionData = {\n  discriminator: number;\n  groupMemberPointerDiscriminator: number;\n  /** The public key for the account that can update the group member address. */\n  authority: Option<Address>;\n  /** The account address that holds the member. */\n  memberAddress: Option<Address>;\n};\n\nexport type InitializeGroupMemberPointerInstructionDataArgs = {\n  /** The public key for the account that can update the group member address. */\n  authority: OptionOrNullable<Address>;\n  /** The account address that holds the member. */\n  memberAddress: OptionOrNullable<Address>;\n};\n\nexport function getInitializeGroupMemberPointerInstructionDataEncoder(): FixedSizeEncoder<InitializeGroupMemberPointerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['groupMemberPointerDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      [\n        'memberAddress',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_GROUP_MEMBER_POINTER_DISCRIMINATOR,\n      groupMemberPointerDiscriminator:\n        INITIALIZE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeGroupMemberPointerInstructionDataDecoder(): FixedSizeDecoder<InitializeGroupMemberPointerInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['groupMemberPointerDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'memberAddress',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializeGroupMemberPointerInstructionDataCodec(): FixedSizeCodec<\n  InitializeGroupMemberPointerInstructionDataArgs,\n  InitializeGroupMemberPointerInstructionData\n> {\n  return combineCodec(\n    getInitializeGroupMemberPointerInstructionDataEncoder(),\n    getInitializeGroupMemberPointerInstructionDataDecoder()\n  );\n}\n\nexport type InitializeGroupMemberPointerInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  authority: InitializeGroupMemberPointerInstructionDataArgs['authority'];\n  memberAddress: InitializeGroupMemberPointerInstructionDataArgs['memberAddress'];\n};\n\nexport function getInitializeGroupMemberPointerInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeGroupMemberPointerInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeGroupMemberPointerInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeGroupMemberPointerInstructionDataEncoder().encode(\n      args as InitializeGroupMemberPointerInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeGroupMemberPointerInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializeGroupMemberPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeGroupMemberPointerInstructionData;\n};\n\nexport function parseInitializeGroupMemberPointerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeGroupMemberPointerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeGroupMemberPointerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_GROUP_POINTER_DISCRIMINATOR = 40;\n\nexport function getInitializeGroupPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_GROUP_POINTER_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR = 0;\n\nexport function getInitializeGroupPointerGroupPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR\n  );\n}\n\nexport type InitializeGroupPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeGroupPointerInstructionData = {\n  discriminator: number;\n  groupPointerDiscriminator: number;\n  /** The public key for the account that can update the group address. */\n  authority: Option<Address>;\n  /** The account address that holds the group. */\n  groupAddress: Option<Address>;\n};\n\nexport type InitializeGroupPointerInstructionDataArgs = {\n  /** The public key for the account that can update the group address. */\n  authority: OptionOrNullable<Address>;\n  /** The account address that holds the group. */\n  groupAddress: OptionOrNullable<Address>;\n};\n\nexport function getInitializeGroupPointerInstructionDataEncoder(): FixedSizeEncoder<InitializeGroupPointerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['groupPointerDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      [\n        'groupAddress',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_GROUP_POINTER_DISCRIMINATOR,\n      groupPointerDiscriminator:\n        INITIALIZE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeGroupPointerInstructionDataDecoder(): FixedSizeDecoder<InitializeGroupPointerInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['groupPointerDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'groupAddress',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializeGroupPointerInstructionDataCodec(): FixedSizeCodec<\n  InitializeGroupPointerInstructionDataArgs,\n  InitializeGroupPointerInstructionData\n> {\n  return combineCodec(\n    getInitializeGroupPointerInstructionDataEncoder(),\n    getInitializeGroupPointerInstructionDataDecoder()\n  );\n}\n\nexport type InitializeGroupPointerInput<TAccountMint extends string = string> =\n  {\n    /** The mint to initialize. */\n    mint: Address<TAccountMint>;\n    authority: InitializeGroupPointerInstructionDataArgs['authority'];\n    groupAddress: InitializeGroupPointerInstructionDataArgs['groupAddress'];\n  };\n\nexport function getInitializeGroupPointerInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeGroupPointerInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeGroupPointerInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeGroupPointerInstructionDataEncoder().encode(\n      args as InitializeGroupPointerInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeGroupPointerInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializeGroupPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeGroupPointerInstructionData;\n};\n\nexport function parseInitializeGroupPointerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeGroupPointerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeGroupPointerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR = 22;\n\nexport function getInitializeImmutableOwnerDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR);\n}\n\nexport type InitializeImmutableOwnerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeImmutableOwnerInstructionData = { discriminator: number };\n\nexport type InitializeImmutableOwnerInstructionDataArgs = {};\n\nexport function getInitializeImmutableOwnerInstructionDataEncoder(): FixedSizeEncoder<InitializeImmutableOwnerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_IMMUTABLE_OWNER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeImmutableOwnerInstructionDataDecoder(): FixedSizeDecoder<InitializeImmutableOwnerInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getInitializeImmutableOwnerInstructionDataCodec(): FixedSizeCodec<\n  InitializeImmutableOwnerInstructionDataArgs,\n  InitializeImmutableOwnerInstructionData\n> {\n  return combineCodec(\n    getInitializeImmutableOwnerInstructionDataEncoder(),\n    getInitializeImmutableOwnerInstructionDataDecoder()\n  );\n}\n\nexport type InitializeImmutableOwnerInput<\n  TAccountAccount extends string = string,\n> = {\n  /** The account to initialize. */\n  account: Address<TAccountAccount>;\n};\n\nexport function getInitializeImmutableOwnerInstruction<\n  TAccountAccount extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeImmutableOwnerInput<TAccountAccount>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeImmutableOwnerInstruction<TProgramAddress, TAccountAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.account)],\n    data: getInitializeImmutableOwnerInstructionDataEncoder().encode({}),\n    programAddress,\n  } as InitializeImmutableOwnerInstruction<TProgramAddress, TAccountAccount>);\n}\n\nexport type ParsedInitializeImmutableOwnerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to initialize. */\n    account: TAccountMetas[0];\n  };\n  data: InitializeImmutableOwnerInstructionData;\n};\n\nexport function parseInitializeImmutableOwnerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeImmutableOwnerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { account: getNextAccount() },\n    data: getInitializeImmutableOwnerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getI16Decoder,\n  getI16Encoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_INTEREST_BEARING_MINT_DISCRIMINATOR = 33;\n\nexport function getInitializeInterestBearingMintDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_INTEREST_BEARING_MINT_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR = 0;\n\nexport function getInitializeInterestBearingMintInterestBearingMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR\n  );\n}\n\nexport type InitializeInterestBearingMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeInterestBearingMintInstructionData = {\n  discriminator: number;\n  interestBearingMintDiscriminator: number;\n  /** The public key for the account that can update the rate */\n  rateAuthority: Option<Address>;\n  /** The initial interest rate */\n  rate: number;\n};\n\nexport type InitializeInterestBearingMintInstructionDataArgs = {\n  /** The public key for the account that can update the rate */\n  rateAuthority: OptionOrNullable<Address>;\n  /** The initial interest rate */\n  rate: number;\n};\n\nexport function getInitializeInterestBearingMintInstructionDataEncoder(): FixedSizeEncoder<InitializeInterestBearingMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['interestBearingMintDiscriminator', getU8Encoder()],\n      [\n        'rateAuthority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      ['rate', getI16Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_INTEREST_BEARING_MINT_DISCRIMINATOR,\n      interestBearingMintDiscriminator:\n        INITIALIZE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeInterestBearingMintInstructionDataDecoder(): FixedSizeDecoder<InitializeInterestBearingMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['interestBearingMintDiscriminator', getU8Decoder()],\n    [\n      'rateAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['rate', getI16Decoder()],\n  ]);\n}\n\nexport function getInitializeInterestBearingMintInstructionDataCodec(): FixedSizeCodec<\n  InitializeInterestBearingMintInstructionDataArgs,\n  InitializeInterestBearingMintInstructionData\n> {\n  return combineCodec(\n    getInitializeInterestBearingMintInstructionDataEncoder(),\n    getInitializeInterestBearingMintInstructionDataDecoder()\n  );\n}\n\nexport type InitializeInterestBearingMintInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  rateAuthority: InitializeInterestBearingMintInstructionDataArgs['rateAuthority'];\n  rate: InitializeInterestBearingMintInstructionDataArgs['rate'];\n};\n\nexport function getInitializeInterestBearingMintInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeInterestBearingMintInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeInterestBearingMintInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeInterestBearingMintInstructionDataEncoder().encode(\n      args as InitializeInterestBearingMintInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeInterestBearingMintInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializeInterestBearingMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeInterestBearingMintInstructionData;\n};\n\nexport function parseInitializeInterestBearingMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeInterestBearingMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeInterestBearingMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_METADATA_POINTER_DISCRIMINATOR = 39;\n\nexport function getInitializeMetadataPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_METADATA_POINTER_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR = 0;\n\nexport function getInitializeMetadataPointerMetadataPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR\n  );\n}\n\nexport type InitializeMetadataPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMetadataPointerInstructionData = {\n  discriminator: number;\n  metadataPointerDiscriminator: number;\n  /** The public key for the account that can update the metadata address. */\n  authority: Option<Address>;\n  /** The account address that holds the metadata. */\n  metadataAddress: Option<Address>;\n};\n\nexport type InitializeMetadataPointerInstructionDataArgs = {\n  /** The public key for the account that can update the metadata address. */\n  authority: OptionOrNullable<Address>;\n  /** The account address that holds the metadata. */\n  metadataAddress: OptionOrNullable<Address>;\n};\n\nexport function getInitializeMetadataPointerInstructionDataEncoder(): FixedSizeEncoder<InitializeMetadataPointerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['metadataPointerDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      [\n        'metadataAddress',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_METADATA_POINTER_DISCRIMINATOR,\n      metadataPointerDiscriminator:\n        INITIALIZE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeMetadataPointerInstructionDataDecoder(): FixedSizeDecoder<InitializeMetadataPointerInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['metadataPointerDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'metadataAddress',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializeMetadataPointerInstructionDataCodec(): FixedSizeCodec<\n  InitializeMetadataPointerInstructionDataArgs,\n  InitializeMetadataPointerInstructionData\n> {\n  return combineCodec(\n    getInitializeMetadataPointerInstructionDataEncoder(),\n    getInitializeMetadataPointerInstructionDataDecoder()\n  );\n}\n\nexport type InitializeMetadataPointerInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  authority: InitializeMetadataPointerInstructionDataArgs['authority'];\n  metadataAddress: InitializeMetadataPointerInstructionDataArgs['metadataAddress'];\n};\n\nexport function getInitializeMetadataPointerInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeMetadataPointerInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMetadataPointerInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeMetadataPointerInstructionDataEncoder().encode(\n      args as InitializeMetadataPointerInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeMetadataPointerInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializeMetadataPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeMetadataPointerInstructionData;\n};\n\nexport function parseInitializeMetadataPointerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeMetadataPointerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeMetadataPointerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  none,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MINT_DISCRIMINATOR = 0;\n\nexport function getInitializeMintDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MINT_DISCRIMINATOR);\n}\n\nexport type InitializeMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMintInstructionData = {\n  discriminator: number;\n  /** Number of decimals in token account amounts. */\n  decimals: number;\n  /** Minting authority. */\n  mintAuthority: Address;\n  /** Optional authority that can freeze token accounts. */\n  freezeAuthority: Option<Address>;\n};\n\nexport type InitializeMintInstructionDataArgs = {\n  /** Number of decimals in token account amounts. */\n  decimals: number;\n  /** Minting authority. */\n  mintAuthority: Address;\n  /** Optional authority that can freeze token accounts. */\n  freezeAuthority?: OptionOrNullable<Address>;\n};\n\nexport function getInitializeMintInstructionDataEncoder(): Encoder<InitializeMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['decimals', getU8Encoder()],\n      ['mintAuthority', getAddressEncoder()],\n      ['freezeAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_MINT_DISCRIMINATOR,\n      freezeAuthority: value.freezeAuthority ?? none(),\n    })\n  );\n}\n\nexport function getInitializeMintInstructionDataDecoder(): Decoder<InitializeMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['decimals', getU8Decoder()],\n    ['mintAuthority', getAddressDecoder()],\n    ['freezeAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getInitializeMintInstructionDataCodec(): Codec<\n  InitializeMintInstructionDataArgs,\n  InitializeMintInstructionData\n> {\n  return combineCodec(\n    getInitializeMintInstructionDataEncoder(),\n    getInitializeMintInstructionDataDecoder()\n  );\n}\n\nexport type InitializeMintInput<\n  TAccountMint extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** Token mint account. */\n  mint: Address<TAccountMint>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n  decimals: InitializeMintInstructionDataArgs['decimals'];\n  mintAuthority: InitializeMintInstructionDataArgs['mintAuthority'];\n  freezeAuthority?: InitializeMintInstructionDataArgs['freezeAuthority'];\n};\n\nexport function getInitializeMintInstruction<\n  TAccountMint extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeMintInput<TAccountMint, TAccountRent>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMintInstruction<TProgramAddress, TAccountMint, TAccountRent> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint), getAccountMeta(accounts.rent)],\n    data: getInitializeMintInstructionDataEncoder().encode(\n      args as InitializeMintInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeMintInstruction<TProgramAddress, TAccountMint, TAccountRent>);\n}\n\nexport type ParsedInitializeMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Token mint account. */\n    mint: TAccountMetas[0];\n    /** Rent sysvar. */\n    rent: TAccountMetas[1];\n  };\n  data: InitializeMintInstructionData;\n};\n\nexport function parseInitializeMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), rent: getNextAccount() },\n    data: getInitializeMintInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  none,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MINT2_DISCRIMINATOR = 20;\n\nexport function getInitializeMint2DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MINT2_DISCRIMINATOR);\n}\n\nexport type InitializeMint2Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMint2InstructionData = {\n  discriminator: number;\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** The authority/multisignature to mint tokens. */\n  mintAuthority: Address;\n  /** The optional freeze authority/multisignature of the mint. */\n  freezeAuthority: Option<Address>;\n};\n\nexport type InitializeMint2InstructionDataArgs = {\n  /** Number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /** The authority/multisignature to mint tokens. */\n  mintAuthority: Address;\n  /** The optional freeze authority/multisignature of the mint. */\n  freezeAuthority?: OptionOrNullable<Address>;\n};\n\nexport function getInitializeMint2InstructionDataEncoder(): Encoder<InitializeMint2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['decimals', getU8Encoder()],\n      ['mintAuthority', getAddressEncoder()],\n      ['freezeAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_MINT2_DISCRIMINATOR,\n      freezeAuthority: value.freezeAuthority ?? none(),\n    })\n  );\n}\n\nexport function getInitializeMint2InstructionDataDecoder(): Decoder<InitializeMint2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['decimals', getU8Decoder()],\n    ['mintAuthority', getAddressDecoder()],\n    ['freezeAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getInitializeMint2InstructionDataCodec(): Codec<\n  InitializeMint2InstructionDataArgs,\n  InitializeMint2InstructionData\n> {\n  return combineCodec(\n    getInitializeMint2InstructionDataEncoder(),\n    getInitializeMint2InstructionDataDecoder()\n  );\n}\n\nexport type InitializeMint2Input<TAccountMint extends string = string> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  decimals: InitializeMint2InstructionDataArgs['decimals'];\n  mintAuthority: InitializeMint2InstructionDataArgs['mintAuthority'];\n  freezeAuthority?: InitializeMint2InstructionDataArgs['freezeAuthority'];\n};\n\nexport function getInitializeMint2Instruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeMint2Input<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMint2Instruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeMint2InstructionDataEncoder().encode(\n      args as InitializeMint2InstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeMint2Instruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializeMint2Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeMint2InstructionData;\n};\n\nexport function parseInitializeMint2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeMint2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeMint2InstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MINT_CLOSE_AUTHORITY_DISCRIMINATOR = 25;\n\nexport function getInitializeMintCloseAuthorityDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MINT_CLOSE_AUTHORITY_DISCRIMINATOR);\n}\n\nexport type InitializeMintCloseAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMintCloseAuthorityInstructionData = {\n  discriminator: number;\n  /** Authority that must sign the `CloseAccount` instruction on a mint. */\n  closeAuthority: Option<Address>;\n};\n\nexport type InitializeMintCloseAuthorityInstructionDataArgs = {\n  /** Authority that must sign the `CloseAccount` instruction on a mint. */\n  closeAuthority: OptionOrNullable<Address>;\n};\n\nexport function getInitializeMintCloseAuthorityInstructionDataEncoder(): Encoder<InitializeMintCloseAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['closeAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_MINT_CLOSE_AUTHORITY_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeMintCloseAuthorityInstructionDataDecoder(): Decoder<InitializeMintCloseAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['closeAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getInitializeMintCloseAuthorityInstructionDataCodec(): Codec<\n  InitializeMintCloseAuthorityInstructionDataArgs,\n  InitializeMintCloseAuthorityInstructionData\n> {\n  return combineCodec(\n    getInitializeMintCloseAuthorityInstructionDataEncoder(),\n    getInitializeMintCloseAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type InitializeMintCloseAuthorityInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  closeAuthority: InitializeMintCloseAuthorityInstructionDataArgs['closeAuthority'];\n};\n\nexport function getInitializeMintCloseAuthorityInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeMintCloseAuthorityInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMintCloseAuthorityInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeMintCloseAuthorityInstructionDataEncoder().encode(\n      args as InitializeMintCloseAuthorityInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeMintCloseAuthorityInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializeMintCloseAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeMintCloseAuthorityInstructionData;\n};\n\nexport function parseInitializeMintCloseAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeMintCloseAuthorityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeMintCloseAuthorityInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MULTISIG_DISCRIMINATOR = 2;\n\nexport function getInitializeMultisigDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MULTISIG_DISCRIMINATOR);\n}\n\nexport type InitializeMultisigInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMultisig extends string | AccountMeta<string> = string,\n  TAccountRent extends\n    | string\n    | AccountMeta<string> = 'SysvarRent111111111111111111111111111111111',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMultisig extends string\n        ? WritableAccount<TAccountMultisig>\n        : TAccountMultisig,\n      TAccountRent extends string\n        ? ReadonlyAccount<TAccountRent>\n        : TAccountRent,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMultisigInstructionData = {\n  discriminator: number;\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport type InitializeMultisigInstructionDataArgs = {\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport function getInitializeMultisigInstructionDataEncoder(): FixedSizeEncoder<InitializeMultisigInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['m', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_MULTISIG_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeMultisigInstructionDataDecoder(): FixedSizeDecoder<InitializeMultisigInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['m', getU8Decoder()],\n  ]);\n}\n\nexport function getInitializeMultisigInstructionDataCodec(): FixedSizeCodec<\n  InitializeMultisigInstructionDataArgs,\n  InitializeMultisigInstructionData\n> {\n  return combineCodec(\n    getInitializeMultisigInstructionDataEncoder(),\n    getInitializeMultisigInstructionDataDecoder()\n  );\n}\n\nexport type InitializeMultisigInput<\n  TAccountMultisig extends string = string,\n  TAccountRent extends string = string,\n> = {\n  /** The multisignature account to initialize. */\n  multisig: Address<TAccountMultisig>;\n  /** Rent sysvar. */\n  rent?: Address<TAccountRent>;\n  m: InitializeMultisigInstructionDataArgs['m'];\n  signers: Array<Address>;\n};\n\nexport function getInitializeMultisigInstruction<\n  TAccountMultisig extends string,\n  TAccountRent extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeMultisigInput<TAccountMultisig, TAccountRent>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMultisigInstruction<\n  TProgramAddress,\n  TAccountMultisig,\n  TAccountRent\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    multisig: { value: input.multisig ?? null, isWritable: true },\n    rent: { value: input.rent ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.rent.value) {\n    accounts.rent.value =\n      'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\n  }\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = args.signers.map((address) => ({\n    address,\n    role: AccountRole.READONLY,\n  }));\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.multisig),\n      getAccountMeta(accounts.rent),\n      ...remainingAccounts,\n    ],\n    data: getInitializeMultisigInstructionDataEncoder().encode(\n      args as InitializeMultisigInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeMultisigInstruction<\n    TProgramAddress,\n    TAccountMultisig,\n    TAccountRent\n  >);\n}\n\nexport type ParsedInitializeMultisigInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The multisignature account to initialize. */\n    multisig: TAccountMetas[0];\n    /** Rent sysvar. */\n    rent: TAccountMetas[1];\n  };\n  data: InitializeMultisigInstructionData;\n};\n\nexport function parseInitializeMultisigInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeMultisigInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { multisig: getNextAccount(), rent: getNextAccount() },\n    data: getInitializeMultisigInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_MULTISIG2_DISCRIMINATOR = 19;\n\nexport function getInitializeMultisig2DiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_MULTISIG2_DISCRIMINATOR);\n}\n\nexport type InitializeMultisig2Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMultisig extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMultisig extends string\n        ? WritableAccount<TAccountMultisig>\n        : TAccountMultisig,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeMultisig2InstructionData = {\n  discriminator: number;\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport type InitializeMultisig2InstructionDataArgs = {\n  /** The number of signers (M) required to validate this multisignature account. */\n  m: number;\n};\n\nexport function getInitializeMultisig2InstructionDataEncoder(): FixedSizeEncoder<InitializeMultisig2InstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['m', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: INITIALIZE_MULTISIG2_DISCRIMINATOR })\n  );\n}\n\nexport function getInitializeMultisig2InstructionDataDecoder(): FixedSizeDecoder<InitializeMultisig2InstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['m', getU8Decoder()],\n  ]);\n}\n\nexport function getInitializeMultisig2InstructionDataCodec(): FixedSizeCodec<\n  InitializeMultisig2InstructionDataArgs,\n  InitializeMultisig2InstructionData\n> {\n  return combineCodec(\n    getInitializeMultisig2InstructionDataEncoder(),\n    getInitializeMultisig2InstructionDataDecoder()\n  );\n}\n\nexport type InitializeMultisig2Input<TAccountMultisig extends string = string> =\n  {\n    /** The multisignature account to initialize. */\n    multisig: Address<TAccountMultisig>;\n    m: InitializeMultisig2InstructionDataArgs['m'];\n    signers: Array<Address>;\n  };\n\nexport function getInitializeMultisig2Instruction<\n  TAccountMultisig extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeMultisig2Input<TAccountMultisig>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeMultisig2Instruction<TProgramAddress, TAccountMultisig> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    multisig: { value: input.multisig ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = args.signers.map((address) => ({\n    address,\n    role: AccountRole.READONLY,\n  }));\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.multisig), ...remainingAccounts],\n    data: getInitializeMultisig2InstructionDataEncoder().encode(\n      args as InitializeMultisig2InstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeMultisig2Instruction<TProgramAddress, TAccountMultisig>);\n}\n\nexport type ParsedInitializeMultisig2Instruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The multisignature account to initialize. */\n    multisig: TAccountMetas[0];\n  };\n  data: InitializeMultisig2InstructionData;\n};\n\nexport function parseInitializeMultisig2Instruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeMultisig2Instruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { multisig: getNextAccount() },\n    data: getInitializeMultisig2InstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_NON_TRANSFERABLE_MINT_DISCRIMINATOR = 32;\n\nexport function getInitializeNonTransferableMintDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_NON_TRANSFERABLE_MINT_DISCRIMINATOR);\n}\n\nexport type InitializeNonTransferableMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeNonTransferableMintInstructionData = {\n  discriminator: number;\n};\n\nexport type InitializeNonTransferableMintInstructionDataArgs = {};\n\nexport function getInitializeNonTransferableMintInstructionDataEncoder(): FixedSizeEncoder<InitializeNonTransferableMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_NON_TRANSFERABLE_MINT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeNonTransferableMintInstructionDataDecoder(): FixedSizeDecoder<InitializeNonTransferableMintInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getInitializeNonTransferableMintInstructionDataCodec(): FixedSizeCodec<\n  InitializeNonTransferableMintInstructionDataArgs,\n  InitializeNonTransferableMintInstructionData\n> {\n  return combineCodec(\n    getInitializeNonTransferableMintInstructionDataEncoder(),\n    getInitializeNonTransferableMintInstructionDataDecoder()\n  );\n}\n\nexport type InitializeNonTransferableMintInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint account to initialize. */\n  mint: Address<TAccountMint>;\n};\n\nexport function getInitializeNonTransferableMintInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeNonTransferableMintInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeNonTransferableMintInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeNonTransferableMintInstructionDataEncoder().encode({}),\n    programAddress,\n  } as InitializeNonTransferableMintInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializeNonTransferableMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint account to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeNonTransferableMintInstructionData;\n};\n\nexport function parseInitializeNonTransferableMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeNonTransferableMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeNonTransferableMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_PAUSABLE_CONFIG_DISCRIMINATOR = 44;\n\nexport function getInitializePausableConfigDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_PAUSABLE_CONFIG_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_PAUSABLE_CONFIG_PAUSABLE_DISCRIMINATOR = 0;\n\nexport function getInitializePausableConfigPausableDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_PAUSABLE_CONFIG_PAUSABLE_DISCRIMINATOR\n  );\n}\n\nexport type InitializePausableConfigInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializePausableConfigInstructionData = {\n  discriminator: number;\n  pausableDiscriminator: number;\n  /** The authority that can pause and resume the mint. */\n  authority: Option<Address>;\n};\n\nexport type InitializePausableConfigInstructionDataArgs = {\n  /** The authority that can pause and resume the mint. */\n  authority: OptionOrNullable<Address>;\n};\n\nexport function getInitializePausableConfigInstructionDataEncoder(): FixedSizeEncoder<InitializePausableConfigInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['pausableDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_PAUSABLE_CONFIG_DISCRIMINATOR,\n      pausableDiscriminator: INITIALIZE_PAUSABLE_CONFIG_PAUSABLE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializePausableConfigInstructionDataDecoder(): FixedSizeDecoder<InitializePausableConfigInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['pausableDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializePausableConfigInstructionDataCodec(): FixedSizeCodec<\n  InitializePausableConfigInstructionDataArgs,\n  InitializePausableConfigInstructionData\n> {\n  return combineCodec(\n    getInitializePausableConfigInstructionDataEncoder(),\n    getInitializePausableConfigInstructionDataDecoder()\n  );\n}\n\nexport type InitializePausableConfigInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  authority: InitializePausableConfigInstructionDataArgs['authority'];\n};\n\nexport function getInitializePausableConfigInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializePausableConfigInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializePausableConfigInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializePausableConfigInstructionDataEncoder().encode(\n      args as InitializePausableConfigInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializePausableConfigInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializePausableConfigInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializePausableConfigInstructionData;\n};\n\nexport function parseInitializePausableConfigInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializePausableConfigInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializePausableConfigInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_PERMANENT_DELEGATE_DISCRIMINATOR = 35;\n\nexport function getInitializePermanentDelegateDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_PERMANENT_DELEGATE_DISCRIMINATOR);\n}\n\nexport type InitializePermanentDelegateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializePermanentDelegateInstructionData = {\n  discriminator: number;\n  /** Authority that may sign for `Transfer`s and `Burn`s on any account */\n  delegate: Address;\n};\n\nexport type InitializePermanentDelegateInstructionDataArgs = {\n  /** Authority that may sign for `Transfer`s and `Burn`s on any account */\n  delegate: Address;\n};\n\nexport function getInitializePermanentDelegateInstructionDataEncoder(): FixedSizeEncoder<InitializePermanentDelegateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['delegate', getAddressEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_PERMANENT_DELEGATE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializePermanentDelegateInstructionDataDecoder(): FixedSizeDecoder<InitializePermanentDelegateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['delegate', getAddressDecoder()],\n  ]);\n}\n\nexport function getInitializePermanentDelegateInstructionDataCodec(): FixedSizeCodec<\n  InitializePermanentDelegateInstructionDataArgs,\n  InitializePermanentDelegateInstructionData\n> {\n  return combineCodec(\n    getInitializePermanentDelegateInstructionDataEncoder(),\n    getInitializePermanentDelegateInstructionDataDecoder()\n  );\n}\n\nexport type InitializePermanentDelegateInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  delegate: InitializePermanentDelegateInstructionDataArgs['delegate'];\n};\n\nexport function getInitializePermanentDelegateInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializePermanentDelegateInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializePermanentDelegateInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializePermanentDelegateInstructionDataEncoder().encode(\n      args as InitializePermanentDelegateInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializePermanentDelegateInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializePermanentDelegateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializePermanentDelegateInstructionData;\n};\n\nexport function parseInitializePermanentDelegateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializePermanentDelegateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializePermanentDelegateInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getF64Decoder,\n  getF64Encoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR = 43;\n\nexport function getInitializeScaledUiAmountMintDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_SCALED_UI_AMOUNT_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR = 0;\n\nexport function getInitializeScaledUiAmountMintScaledUiAmountMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_SCALED_UI_AMOUNT_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR\n  );\n}\n\nexport type InitializeScaledUiAmountMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeScaledUiAmountMintInstructionData = {\n  discriminator: number;\n  scaledUiAmountMintDiscriminator: number;\n  /** The authority that can update the multiplier */\n  authority: Option<Address>;\n  /** The initial multiplier for the scaled UI extension */\n  multiplier: number;\n};\n\nexport type InitializeScaledUiAmountMintInstructionDataArgs = {\n  /** The authority that can update the multiplier */\n  authority: OptionOrNullable<Address>;\n  /** The initial multiplier for the scaled UI extension */\n  multiplier: number;\n};\n\nexport function getInitializeScaledUiAmountMintInstructionDataEncoder(): FixedSizeEncoder<InitializeScaledUiAmountMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['scaledUiAmountMintDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      ['multiplier', getF64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR,\n      scaledUiAmountMintDiscriminator:\n        INITIALIZE_SCALED_UI_AMOUNT_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeScaledUiAmountMintInstructionDataDecoder(): FixedSizeDecoder<InitializeScaledUiAmountMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['scaledUiAmountMintDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['multiplier', getF64Decoder()],\n  ]);\n}\n\nexport function getInitializeScaledUiAmountMintInstructionDataCodec(): FixedSizeCodec<\n  InitializeScaledUiAmountMintInstructionDataArgs,\n  InitializeScaledUiAmountMintInstructionData\n> {\n  return combineCodec(\n    getInitializeScaledUiAmountMintInstructionDataEncoder(),\n    getInitializeScaledUiAmountMintInstructionDataDecoder()\n  );\n}\n\nexport type InitializeScaledUiAmountMintInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  authority: InitializeScaledUiAmountMintInstructionDataArgs['authority'];\n  multiplier: InitializeScaledUiAmountMintInstructionDataArgs['multiplier'];\n};\n\nexport function getInitializeScaledUiAmountMintInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeScaledUiAmountMintInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeScaledUiAmountMintInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeScaledUiAmountMintInstructionDataEncoder().encode(\n      args as InitializeScaledUiAmountMintInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeScaledUiAmountMintInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializeScaledUiAmountMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeScaledUiAmountMintInstructionData;\n};\n\nexport function parseInitializeScaledUiAmountMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeScaledUiAmountMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeScaledUiAmountMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_TOKEN_GROUP_DISCRIMINATOR = new Uint8Array([\n  121, 113, 108, 39, 54, 51, 0, 4,\n]);\n\nexport function getInitializeTokenGroupDiscriminatorBytes() {\n  return getBytesEncoder().encode(INITIALIZE_TOKEN_GROUP_DISCRIMINATOR);\n}\n\nexport type InitializeTokenGroupInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountGroup extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountMintAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountGroup extends string\n        ? WritableAccount<TAccountGroup>\n        : TAccountGroup,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountMintAuthority extends string\n        ? ReadonlySignerAccount<TAccountMintAuthority> &\n            AccountSignerMeta<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeTokenGroupInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** Update authority for the group */\n  updateAuthority: Option<Address>;\n  /** The maximum number of group members */\n  maxSize: bigint;\n};\n\nexport type InitializeTokenGroupInstructionDataArgs = {\n  /** Update authority for the group */\n  updateAuthority: OptionOrNullable<Address>;\n  /** The maximum number of group members */\n  maxSize: number | bigint;\n};\n\nexport function getInitializeTokenGroupInstructionDataEncoder(): Encoder<InitializeTokenGroupInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      [\n        'updateAuthority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      ['maxSize', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TOKEN_GROUP_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeTokenGroupInstructionDataDecoder(): Decoder<InitializeTokenGroupInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    [\n      'updateAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    ['maxSize', getU64Decoder()],\n  ]);\n}\n\nexport function getInitializeTokenGroupInstructionDataCodec(): Codec<\n  InitializeTokenGroupInstructionDataArgs,\n  InitializeTokenGroupInstructionData\n> {\n  return combineCodec(\n    getInitializeTokenGroupInstructionDataEncoder(),\n    getInitializeTokenGroupInstructionDataDecoder()\n  );\n}\n\nexport type InitializeTokenGroupInput<\n  TAccountGroup extends string = string,\n  TAccountMint extends string = string,\n  TAccountMintAuthority extends string = string,\n> = {\n  group: Address<TAccountGroup>;\n  mint: Address<TAccountMint>;\n  mintAuthority: TransactionSigner<TAccountMintAuthority>;\n  updateAuthority: InitializeTokenGroupInstructionDataArgs['updateAuthority'];\n  maxSize: InitializeTokenGroupInstructionDataArgs['maxSize'];\n};\n\nexport function getInitializeTokenGroupInstruction<\n  TAccountGroup extends string,\n  TAccountMint extends string,\n  TAccountMintAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeTokenGroupInput<\n    TAccountGroup,\n    TAccountMint,\n    TAccountMintAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeTokenGroupInstruction<\n  TProgramAddress,\n  TAccountGroup,\n  TAccountMint,\n  TAccountMintAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    group: { value: input.group ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.group),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.mintAuthority),\n    ],\n    data: getInitializeTokenGroupInstructionDataEncoder().encode(\n      args as InitializeTokenGroupInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeTokenGroupInstruction<\n    TProgramAddress,\n    TAccountGroup,\n    TAccountMint,\n    TAccountMintAuthority\n  >);\n}\n\nexport type ParsedInitializeTokenGroupInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    group: TAccountMetas[0];\n    mint: TAccountMetas[1];\n    mintAuthority: TAccountMetas[2];\n  };\n  data: InitializeTokenGroupInstructionData;\n};\n\nexport function parseInitializeTokenGroupInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeTokenGroupInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      group: getNextAccount(),\n      mint: getNextAccount(),\n      mintAuthority: getNextAccount(),\n    },\n    data: getInitializeTokenGroupInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_TOKEN_GROUP_MEMBER_DISCRIMINATOR = new Uint8Array([\n  152, 32, 222, 176, 223, 237, 116, 134,\n]);\n\nexport function getInitializeTokenGroupMemberDiscriminatorBytes() {\n  return getBytesEncoder().encode(INITIALIZE_TOKEN_GROUP_MEMBER_DISCRIMINATOR);\n}\n\nexport type InitializeTokenGroupMemberInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMember extends string | AccountMeta<string> = string,\n  TAccountMemberMint extends string | AccountMeta<string> = string,\n  TAccountMemberMintAuthority extends string | AccountMeta<string> = string,\n  TAccountGroup extends string | AccountMeta<string> = string,\n  TAccountGroupUpdateAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMember extends string\n        ? WritableAccount<TAccountMember>\n        : TAccountMember,\n      TAccountMemberMint extends string\n        ? ReadonlyAccount<TAccountMemberMint>\n        : TAccountMemberMint,\n      TAccountMemberMintAuthority extends string\n        ? ReadonlySignerAccount<TAccountMemberMintAuthority> &\n            AccountSignerMeta<TAccountMemberMintAuthority>\n        : TAccountMemberMintAuthority,\n      TAccountGroup extends string\n        ? WritableAccount<TAccountGroup>\n        : TAccountGroup,\n      TAccountGroupUpdateAuthority extends string\n        ? ReadonlySignerAccount<TAccountGroupUpdateAuthority> &\n            AccountSignerMeta<TAccountGroupUpdateAuthority>\n        : TAccountGroupUpdateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeTokenGroupMemberInstructionData = {\n  discriminator: ReadonlyUint8Array;\n};\n\nexport type InitializeTokenGroupMemberInstructionDataArgs = {};\n\nexport function getInitializeTokenGroupMemberInstructionDataEncoder(): Encoder<InitializeTokenGroupMemberInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getBytesEncoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TOKEN_GROUP_MEMBER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeTokenGroupMemberInstructionDataDecoder(): Decoder<InitializeTokenGroupMemberInstructionData> {\n  return getStructDecoder([['discriminator', getBytesDecoder()]]);\n}\n\nexport function getInitializeTokenGroupMemberInstructionDataCodec(): Codec<\n  InitializeTokenGroupMemberInstructionDataArgs,\n  InitializeTokenGroupMemberInstructionData\n> {\n  return combineCodec(\n    getInitializeTokenGroupMemberInstructionDataEncoder(),\n    getInitializeTokenGroupMemberInstructionDataDecoder()\n  );\n}\n\nexport type InitializeTokenGroupMemberInput<\n  TAccountMember extends string = string,\n  TAccountMemberMint extends string = string,\n  TAccountMemberMintAuthority extends string = string,\n  TAccountGroup extends string = string,\n  TAccountGroupUpdateAuthority extends string = string,\n> = {\n  member: Address<TAccountMember>;\n  memberMint: Address<TAccountMemberMint>;\n  memberMintAuthority: TransactionSigner<TAccountMemberMintAuthority>;\n  group: Address<TAccountGroup>;\n  groupUpdateAuthority: TransactionSigner<TAccountGroupUpdateAuthority>;\n};\n\nexport function getInitializeTokenGroupMemberInstruction<\n  TAccountMember extends string,\n  TAccountMemberMint extends string,\n  TAccountMemberMintAuthority extends string,\n  TAccountGroup extends string,\n  TAccountGroupUpdateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeTokenGroupMemberInput<\n    TAccountMember,\n    TAccountMemberMint,\n    TAccountMemberMintAuthority,\n    TAccountGroup,\n    TAccountGroupUpdateAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeTokenGroupMemberInstruction<\n  TProgramAddress,\n  TAccountMember,\n  TAccountMemberMint,\n  TAccountMemberMintAuthority,\n  TAccountGroup,\n  TAccountGroupUpdateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    member: { value: input.member ?? null, isWritable: true },\n    memberMint: { value: input.memberMint ?? null, isWritable: false },\n    memberMintAuthority: {\n      value: input.memberMintAuthority ?? null,\n      isWritable: false,\n    },\n    group: { value: input.group ?? null, isWritable: true },\n    groupUpdateAuthority: {\n      value: input.groupUpdateAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.member),\n      getAccountMeta(accounts.memberMint),\n      getAccountMeta(accounts.memberMintAuthority),\n      getAccountMeta(accounts.group),\n      getAccountMeta(accounts.groupUpdateAuthority),\n    ],\n    data: getInitializeTokenGroupMemberInstructionDataEncoder().encode({}),\n    programAddress,\n  } as InitializeTokenGroupMemberInstruction<\n    TProgramAddress,\n    TAccountMember,\n    TAccountMemberMint,\n    TAccountMemberMintAuthority,\n    TAccountGroup,\n    TAccountGroupUpdateAuthority\n  >);\n}\n\nexport type ParsedInitializeTokenGroupMemberInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    member: TAccountMetas[0];\n    memberMint: TAccountMetas[1];\n    memberMintAuthority: TAccountMetas[2];\n    group: TAccountMetas[3];\n    groupUpdateAuthority: TAccountMetas[4];\n  };\n  data: InitializeTokenGroupMemberInstructionData;\n};\n\nexport function parseInitializeTokenGroupMemberInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeTokenGroupMemberInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      member: getNextAccount(),\n      memberMint: getNextAccount(),\n      memberMintAuthority: getNextAccount(),\n      group: getNextAccount(),\n      groupUpdateAuthority: getNextAccount(),\n    },\n    data: getInitializeTokenGroupMemberInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_TOKEN_METADATA_DISCRIMINATOR = new Uint8Array([\n  210, 225, 30, 162, 88, 184, 77, 141,\n]);\n\nexport function getInitializeTokenMetadataDiscriminatorBytes() {\n  return getBytesEncoder().encode(INITIALIZE_TOKEN_METADATA_DISCRIMINATOR);\n}\n\nexport type InitializeTokenMetadataInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetadata extends string | AccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountMintAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMetadata extends string\n        ? WritableAccount<TAccountMetadata>\n        : TAccountMetadata,\n      TAccountUpdateAuthority extends string\n        ? ReadonlyAccount<TAccountUpdateAuthority>\n        : TAccountUpdateAuthority,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountMintAuthority extends string\n        ? ReadonlySignerAccount<TAccountMintAuthority> &\n            AccountSignerMeta<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeTokenMetadataInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** Longer name of the token. */\n  name: string;\n  /** Shortened symbol of the token. */\n  symbol: string;\n  /** URI pointing to more metadata (image, video, etc.). */\n  uri: string;\n};\n\nexport type InitializeTokenMetadataInstructionDataArgs = {\n  /** Longer name of the token. */\n  name: string;\n  /** Shortened symbol of the token. */\n  symbol: string;\n  /** URI pointing to more metadata (image, video, etc.). */\n  uri: string;\n};\n\nexport function getInitializeTokenMetadataInstructionDataEncoder(): Encoder<InitializeTokenMetadataInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n      ['symbol', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n      ['uri', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TOKEN_METADATA_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeTokenMetadataInstructionDataDecoder(): Decoder<InitializeTokenMetadataInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ['symbol', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n    ['uri', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n  ]);\n}\n\nexport function getInitializeTokenMetadataInstructionDataCodec(): Codec<\n  InitializeTokenMetadataInstructionDataArgs,\n  InitializeTokenMetadataInstructionData\n> {\n  return combineCodec(\n    getInitializeTokenMetadataInstructionDataEncoder(),\n    getInitializeTokenMetadataInstructionDataDecoder()\n  );\n}\n\nexport type InitializeTokenMetadataInput<\n  TAccountMetadata extends string = string,\n  TAccountUpdateAuthority extends string = string,\n  TAccountMint extends string = string,\n  TAccountMintAuthority extends string = string,\n> = {\n  metadata: Address<TAccountMetadata>;\n  updateAuthority: Address<TAccountUpdateAuthority>;\n  mint: Address<TAccountMint>;\n  mintAuthority: TransactionSigner<TAccountMintAuthority>;\n  name: InitializeTokenMetadataInstructionDataArgs['name'];\n  symbol: InitializeTokenMetadataInstructionDataArgs['symbol'];\n  uri: InitializeTokenMetadataInstructionDataArgs['uri'];\n};\n\nexport function getInitializeTokenMetadataInstruction<\n  TAccountMetadata extends string,\n  TAccountUpdateAuthority extends string,\n  TAccountMint extends string,\n  TAccountMintAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeTokenMetadataInput<\n    TAccountMetadata,\n    TAccountUpdateAuthority,\n    TAccountMint,\n    TAccountMintAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): InitializeTokenMetadataInstruction<\n  TProgramAddress,\n  TAccountMetadata,\n  TAccountUpdateAuthority,\n  TAccountMint,\n  TAccountMintAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n    mint: { value: input.mint ?? null, isWritable: false },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.metadata),\n      getAccountMeta(accounts.updateAuthority),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.mintAuthority),\n    ],\n    data: getInitializeTokenMetadataInstructionDataEncoder().encode(\n      args as InitializeTokenMetadataInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeTokenMetadataInstruction<\n    TProgramAddress,\n    TAccountMetadata,\n    TAccountUpdateAuthority,\n    TAccountMint,\n    TAccountMintAuthority\n  >);\n}\n\nexport type ParsedInitializeTokenMetadataInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    metadata: TAccountMetas[0];\n    updateAuthority: TAccountMetas[1];\n    mint: TAccountMetas[2];\n    mintAuthority: TAccountMetas[3];\n  };\n  data: InitializeTokenMetadataInstructionData;\n};\n\nexport function parseInitializeTokenMetadataInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeTokenMetadataInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      metadata: getNextAccount(),\n      updateAuthority: getNextAccount(),\n      mint: getNextAccount(),\n      mintAuthority: getNextAccount(),\n    },\n    data: getInitializeTokenMetadataInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_TRANSFER_FEE_CONFIG_DISCRIMINATOR = 26;\n\nexport function getInitializeTransferFeeConfigDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_TRANSFER_FEE_CONFIG_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_TRANSFER_FEE_CONFIG_TRANSFER_FEE_DISCRIMINATOR = 0;\n\nexport function getInitializeTransferFeeConfigTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_TRANSFER_FEE_CONFIG_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type InitializeTransferFeeConfigInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeTransferFeeConfigInstructionData = {\n  discriminator: number;\n  transferFeeDiscriminator: number;\n  /** Pubkey that may update the fees. */\n  transferFeeConfigAuthority: Option<Address>;\n  /** Withdraw instructions must be signed by this key. */\n  withdrawWithheldAuthority: Option<Address>;\n  /** Amount of transfer collected as fees, expressed as basis points of the transfer amount. */\n  transferFeeBasisPoints: number;\n  /** Maximum fee assessed on transfers. */\n  maximumFee: bigint;\n};\n\nexport type InitializeTransferFeeConfigInstructionDataArgs = {\n  /** Pubkey that may update the fees. */\n  transferFeeConfigAuthority: OptionOrNullable<Address>;\n  /** Withdraw instructions must be signed by this key. */\n  withdrawWithheldAuthority: OptionOrNullable<Address>;\n  /** Amount of transfer collected as fees, expressed as basis points of the transfer amount. */\n  transferFeeBasisPoints: number;\n  /** Maximum fee assessed on transfers. */\n  maximumFee: number | bigint;\n};\n\nexport function getInitializeTransferFeeConfigInstructionDataEncoder(): Encoder<InitializeTransferFeeConfigInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferFeeDiscriminator', getU8Encoder()],\n      ['transferFeeConfigAuthority', getOptionEncoder(getAddressEncoder())],\n      ['withdrawWithheldAuthority', getOptionEncoder(getAddressEncoder())],\n      ['transferFeeBasisPoints', getU16Encoder()],\n      ['maximumFee', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TRANSFER_FEE_CONFIG_DISCRIMINATOR,\n      transferFeeDiscriminator:\n        INITIALIZE_TRANSFER_FEE_CONFIG_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeTransferFeeConfigInstructionDataDecoder(): Decoder<InitializeTransferFeeConfigInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferFeeDiscriminator', getU8Decoder()],\n    ['transferFeeConfigAuthority', getOptionDecoder(getAddressDecoder())],\n    ['withdrawWithheldAuthority', getOptionDecoder(getAddressDecoder())],\n    ['transferFeeBasisPoints', getU16Decoder()],\n    ['maximumFee', getU64Decoder()],\n  ]);\n}\n\nexport function getInitializeTransferFeeConfigInstructionDataCodec(): Codec<\n  InitializeTransferFeeConfigInstructionDataArgs,\n  InitializeTransferFeeConfigInstructionData\n> {\n  return combineCodec(\n    getInitializeTransferFeeConfigInstructionDataEncoder(),\n    getInitializeTransferFeeConfigInstructionDataDecoder()\n  );\n}\n\nexport type InitializeTransferFeeConfigInput<\n  TAccountMint extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  transferFeeConfigAuthority: InitializeTransferFeeConfigInstructionDataArgs['transferFeeConfigAuthority'];\n  withdrawWithheldAuthority: InitializeTransferFeeConfigInstructionDataArgs['withdrawWithheldAuthority'];\n  transferFeeBasisPoints: InitializeTransferFeeConfigInstructionDataArgs['transferFeeBasisPoints'];\n  maximumFee: InitializeTransferFeeConfigInstructionDataArgs['maximumFee'];\n};\n\nexport function getInitializeTransferFeeConfigInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeTransferFeeConfigInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeTransferFeeConfigInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeTransferFeeConfigInstructionDataEncoder().encode(\n      args as InitializeTransferFeeConfigInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeTransferFeeConfigInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializeTransferFeeConfigInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeTransferFeeConfigInstructionData;\n};\n\nexport function parseInitializeTransferFeeConfigInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeTransferFeeConfigInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeTransferFeeConfigInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const INITIALIZE_TRANSFER_HOOK_DISCRIMINATOR = 36;\n\nexport function getInitializeTransferHookDiscriminatorBytes() {\n  return getU8Encoder().encode(INITIALIZE_TRANSFER_HOOK_DISCRIMINATOR);\n}\n\nexport const INITIALIZE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR = 0;\n\nexport function getInitializeTransferHookTransferHookDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    INITIALIZE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR\n  );\n}\n\nexport type InitializeTransferHookInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type InitializeTransferHookInstructionData = {\n  discriminator: number;\n  transferHookDiscriminator: number;\n  /** The public key for the account that can update the program id */\n  authority: Option<Address>;\n  /** The program id that performs logic during transfers */\n  programId: Option<Address>;\n};\n\nexport type InitializeTransferHookInstructionDataArgs = {\n  /** The public key for the account that can update the program id */\n  authority: OptionOrNullable<Address>;\n  /** The program id that performs logic during transfers */\n  programId: OptionOrNullable<Address>;\n};\n\nexport function getInitializeTransferHookInstructionDataEncoder(): FixedSizeEncoder<InitializeTransferHookInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferHookDiscriminator', getU8Encoder()],\n      [\n        'authority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n      [\n        'programId',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: INITIALIZE_TRANSFER_HOOK_DISCRIMINATOR,\n      transferHookDiscriminator:\n        INITIALIZE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getInitializeTransferHookInstructionDataDecoder(): FixedSizeDecoder<InitializeTransferHookInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferHookDiscriminator', getU8Decoder()],\n    [\n      'authority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n    [\n      'programId',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getInitializeTransferHookInstructionDataCodec(): FixedSizeCodec<\n  InitializeTransferHookInstructionDataArgs,\n  InitializeTransferHookInstructionData\n> {\n  return combineCodec(\n    getInitializeTransferHookInstructionDataEncoder(),\n    getInitializeTransferHookInstructionDataDecoder()\n  );\n}\n\nexport type InitializeTransferHookInput<TAccountMint extends string = string> =\n  {\n    /** The mint to initialize. */\n    mint: Address<TAccountMint>;\n    authority: InitializeTransferHookInstructionDataArgs['authority'];\n    programId: InitializeTransferHookInstructionDataArgs['programId'];\n  };\n\nexport function getInitializeTransferHookInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: InitializeTransferHookInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): InitializeTransferHookInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getInitializeTransferHookInstructionDataEncoder().encode(\n      args as InitializeTransferHookInstructionDataArgs\n    ),\n    programAddress,\n  } as InitializeTransferHookInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedInitializeTransferHookInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n  };\n  data: InitializeTransferHookInstructionData;\n};\n\nexport function parseInitializeTransferHookInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedInitializeTransferHookInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getInitializeTransferHookInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const MINT_TO_DISCRIMINATOR = 7;\n\nexport function getMintToDiscriminatorBytes() {\n  return getU8Encoder().encode(MINT_TO_DISCRIMINATOR);\n}\n\nexport type MintToInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountMintAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMintAuthority extends string\n        ? ReadonlyAccount<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type MintToInstructionData = {\n  discriminator: number;\n  /** The amount of new tokens to mint. */\n  amount: bigint;\n};\n\nexport type MintToInstructionDataArgs = {\n  /** The amount of new tokens to mint. */\n  amount: number | bigint;\n};\n\nexport function getMintToInstructionDataEncoder(): FixedSizeEncoder<MintToInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: MINT_TO_DISCRIMINATOR })\n  );\n}\n\nexport function getMintToInstructionDataDecoder(): FixedSizeDecoder<MintToInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getMintToInstructionDataCodec(): FixedSizeCodec<\n  MintToInstructionDataArgs,\n  MintToInstructionData\n> {\n  return combineCodec(\n    getMintToInstructionDataEncoder(),\n    getMintToInstructionDataDecoder()\n  );\n}\n\nexport type MintToInput<\n  TAccountMint extends string = string,\n  TAccountToken extends string = string,\n  TAccountMintAuthority extends string = string,\n> = {\n  /** The mint account. */\n  mint: Address<TAccountMint>;\n  /** The account to mint tokens to. */\n  token: Address<TAccountToken>;\n  /** The mint's minting authority or its multisignature account. */\n  mintAuthority:\n    | Address<TAccountMintAuthority>\n    | TransactionSigner<TAccountMintAuthority>;\n  amount: MintToInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getMintToInstruction<\n  TAccountMint extends string,\n  TAccountToken extends string,\n  TAccountMintAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: MintToInput<TAccountMint, TAccountToken, TAccountMintAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): MintToInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountToken,\n  (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n    ? ReadonlySignerAccount<TAccountMintAuthority> &\n        AccountSignerMeta<TAccountMintAuthority>\n    : TAccountMintAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    token: { value: input.token ?? null, isWritable: true },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mintAuthority),\n      ...remainingAccounts,\n    ],\n    data: getMintToInstructionDataEncoder().encode(\n      args as MintToInstructionDataArgs\n    ),\n    programAddress,\n  } as MintToInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountToken,\n    (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n      ? ReadonlySignerAccount<TAccountMintAuthority> &\n          AccountSignerMeta<TAccountMintAuthority>\n      : TAccountMintAuthority\n  >);\n}\n\nexport type ParsedMintToInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint account. */\n    mint: TAccountMetas[0];\n    /** The account to mint tokens to. */\n    token: TAccountMetas[1];\n    /** The mint's minting authority or its multisignature account. */\n    mintAuthority: TAccountMetas[2];\n  };\n  data: MintToInstructionData;\n};\n\nexport function parseMintToInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedMintToInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      token: getNextAccount(),\n      mintAuthority: getNextAccount(),\n    },\n    data: getMintToInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const MINT_TO_CHECKED_DISCRIMINATOR = 14;\n\nexport function getMintToCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(MINT_TO_CHECKED_DISCRIMINATOR);\n}\n\nexport type MintToCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountMintAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountMintAuthority extends string\n        ? ReadonlyAccount<TAccountMintAuthority>\n        : TAccountMintAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type MintToCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of new tokens to mint. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type MintToCheckedInstructionDataArgs = {\n  /** The amount of new tokens to mint. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getMintToCheckedInstructionDataEncoder(): FixedSizeEncoder<MintToCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: MINT_TO_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getMintToCheckedInstructionDataDecoder(): FixedSizeDecoder<MintToCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getMintToCheckedInstructionDataCodec(): FixedSizeCodec<\n  MintToCheckedInstructionDataArgs,\n  MintToCheckedInstructionData\n> {\n  return combineCodec(\n    getMintToCheckedInstructionDataEncoder(),\n    getMintToCheckedInstructionDataDecoder()\n  );\n}\n\nexport type MintToCheckedInput<\n  TAccountMint extends string = string,\n  TAccountToken extends string = string,\n  TAccountMintAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The account to mint tokens to. */\n  token: Address<TAccountToken>;\n  /** The mint's minting authority or its multisignature account. */\n  mintAuthority:\n    | Address<TAccountMintAuthority>\n    | TransactionSigner<TAccountMintAuthority>;\n  amount: MintToCheckedInstructionDataArgs['amount'];\n  decimals: MintToCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getMintToCheckedInstruction<\n  TAccountMint extends string,\n  TAccountToken extends string,\n  TAccountMintAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: MintToCheckedInput<TAccountMint, TAccountToken, TAccountMintAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): MintToCheckedInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountToken,\n  (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n    ? ReadonlySignerAccount<TAccountMintAuthority> &\n        AccountSignerMeta<TAccountMintAuthority>\n    : TAccountMintAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    token: { value: input.token ?? null, isWritable: true },\n    mintAuthority: { value: input.mintAuthority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.mintAuthority),\n      ...remainingAccounts,\n    ],\n    data: getMintToCheckedInstructionDataEncoder().encode(\n      args as MintToCheckedInstructionDataArgs\n    ),\n    programAddress,\n  } as MintToCheckedInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountToken,\n    (typeof input)['mintAuthority'] extends TransactionSigner<TAccountMintAuthority>\n      ? ReadonlySignerAccount<TAccountMintAuthority> &\n          AccountSignerMeta<TAccountMintAuthority>\n      : TAccountMintAuthority\n  >);\n}\n\nexport type ParsedMintToCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The account to mint tokens to. */\n    token: TAccountMetas[1];\n    /** The mint's minting authority or its multisignature account. */\n    mintAuthority: TAccountMetas[2];\n  };\n  data: MintToCheckedInstructionData;\n};\n\nexport function parseMintToCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedMintToCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      token: getNextAccount(),\n      mintAuthority: getNextAccount(),\n    },\n    data: getMintToCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const PAUSE_DISCRIMINATOR = 44;\n\nexport function getPauseDiscriminatorBytes() {\n  return getU8Encoder().encode(PAUSE_DISCRIMINATOR);\n}\n\nexport const PAUSE_PAUSABLE_DISCRIMINATOR = 1;\n\nexport function getPausePausableDiscriminatorBytes() {\n  return getU8Encoder().encode(PAUSE_PAUSABLE_DISCRIMINATOR);\n}\n\nexport type PauseInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type PauseInstructionData = {\n  discriminator: number;\n  pausableDiscriminator: number;\n};\n\nexport type PauseInstructionDataArgs = {};\n\nexport function getPauseInstructionDataEncoder(): FixedSizeEncoder<PauseInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['pausableDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: PAUSE_DISCRIMINATOR,\n      pausableDiscriminator: PAUSE_PAUSABLE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getPauseInstructionDataDecoder(): FixedSizeDecoder<PauseInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['pausableDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getPauseInstructionDataCodec(): FixedSizeCodec<\n  PauseInstructionDataArgs,\n  PauseInstructionData\n> {\n  return combineCodec(\n    getPauseInstructionDataEncoder(),\n    getPauseInstructionDataDecoder()\n  );\n}\n\nexport type PauseInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The pausable authority that can pause the mint. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n};\n\nexport function getPauseInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: PauseInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): PauseInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n    ],\n    data: getPauseInstructionDataEncoder().encode({}),\n    programAddress,\n  } as PauseInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedPauseInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The pausable authority that can pause the mint. */\n    authority: TAccountMetas[1];\n  };\n  data: PauseInstructionData;\n};\n\nexport function parsePauseInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedPauseInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), authority: getNextAccount() },\n    data: getPauseInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getArrayDecoder,\n  getArrayEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getExtensionTypeDecoder,\n  getExtensionTypeEncoder,\n  type ExtensionType,\n  type ExtensionTypeArgs,\n} from '../types';\n\nexport const REALLOCATE_DISCRIMINATOR = 29;\n\nexport function getReallocateDiscriminatorBytes() {\n  return getU8Encoder().encode(REALLOCATE_DISCRIMINATOR);\n}\n\nexport type ReallocateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountToken extends string | AccountMeta<string> = string,\n  TAccountPayer extends string | AccountMeta<string> = string,\n  TAccountSystemProgram extends\n    | string\n    | AccountMeta<string> = '11111111111111111111111111111111',\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountToken extends string\n        ? WritableAccount<TAccountToken>\n        : TAccountToken,\n      TAccountPayer extends string\n        ? WritableSignerAccount<TAccountPayer> &\n            AccountSignerMeta<TAccountPayer>\n        : TAccountPayer,\n      TAccountSystemProgram extends string\n        ? ReadonlyAccount<TAccountSystemProgram>\n        : TAccountSystemProgram,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ReallocateInstructionData = {\n  discriminator: number;\n  /** New extension types to include in the reallocated account. */\n  newExtensionTypes: Array<ExtensionType>;\n};\n\nexport type ReallocateInstructionDataArgs = {\n  /** New extension types to include in the reallocated account. */\n  newExtensionTypes: Array<ExtensionTypeArgs>;\n};\n\nexport function getReallocateInstructionDataEncoder(): Encoder<ReallocateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      [\n        'newExtensionTypes',\n        getArrayEncoder(getExtensionTypeEncoder(), { size: 'remainder' }),\n      ],\n    ]),\n    (value) => ({ ...value, discriminator: REALLOCATE_DISCRIMINATOR })\n  );\n}\n\nexport function getReallocateInstructionDataDecoder(): Decoder<ReallocateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    [\n      'newExtensionTypes',\n      getArrayDecoder(getExtensionTypeDecoder(), { size: 'remainder' }),\n    ],\n  ]);\n}\n\nexport function getReallocateInstructionDataCodec(): Codec<\n  ReallocateInstructionDataArgs,\n  ReallocateInstructionData\n> {\n  return combineCodec(\n    getReallocateInstructionDataEncoder(),\n    getReallocateInstructionDataDecoder()\n  );\n}\n\nexport type ReallocateInput<\n  TAccountToken extends string = string,\n  TAccountPayer extends string = string,\n  TAccountSystemProgram extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The token account to reallocate. */\n  token: Address<TAccountToken>;\n  /** The payer account to fund reallocation. */\n  payer: TransactionSigner<TAccountPayer>;\n  /** System program for reallocation funding. */\n  systemProgram?: Address<TAccountSystemProgram>;\n  /** The account's owner or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  newExtensionTypes: ReallocateInstructionDataArgs['newExtensionTypes'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getReallocateInstruction<\n  TAccountToken extends string,\n  TAccountPayer extends string,\n  TAccountSystemProgram extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ReallocateInput<\n    TAccountToken,\n    TAccountPayer,\n    TAccountSystemProgram,\n    TAccountOwner\n  >,\n  config?: { programAddress?: TProgramAddress }\n): ReallocateInstruction<\n  TProgramAddress,\n  TAccountToken,\n  TAccountPayer,\n  TAccountSystemProgram,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    token: { value: input.token ?? null, isWritable: true },\n    payer: { value: input.payer ?? null, isWritable: true },\n    systemProgram: { value: input.systemProgram ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Resolve default values.\n  if (!accounts.systemProgram.value) {\n    accounts.systemProgram.value =\n      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n  }\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.token),\n      getAccountMeta(accounts.payer),\n      getAccountMeta(accounts.systemProgram),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getReallocateInstructionDataEncoder().encode(\n      args as ReallocateInstructionDataArgs\n    ),\n    programAddress,\n  } as ReallocateInstruction<\n    TProgramAddress,\n    TAccountToken,\n    TAccountPayer,\n    TAccountSystemProgram,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedReallocateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token account to reallocate. */\n    token: TAccountMetas[0];\n    /** The payer account to fund reallocation. */\n    payer: TAccountMetas[1];\n    /** System program for reallocation funding. */\n    systemProgram: TAccountMetas[2];\n    /** The account's owner or its multisignature account. */\n    owner: TAccountMetas[3];\n  };\n  data: ReallocateInstructionData;\n};\n\nexport function parseReallocateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedReallocateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      token: getNextAccount(),\n      payer: getNextAccount(),\n      systemProgram: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getReallocateInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { findAssociatedTokenPda } from '../pdas';\nimport { ASSOCIATED_TOKEN_PROGRAM_ADDRESS } from '../programs';\nimport {\n  expectAddress,\n  getAccountMetaFactory,\n  type ResolvedAccount,\n} from '../shared';\n\nexport const RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR = 2;\n\nexport function getRecoverNestedAssociatedTokenDiscriminatorBytes() {\n  return getU8Encoder().encode(RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR);\n}\n\nexport type RecoverNestedAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountNestedAssociatedAccountAddress extends\n    | string\n    | AccountMeta<string> = string,\n  TAccountNestedTokenMintAddress extends string | AccountMeta<string> = string,\n  TAccountDestinationAssociatedAccountAddress extends\n    | string\n    | AccountMeta<string> = string,\n  TAccountOwnerAssociatedAccountAddress extends\n    | string\n    | AccountMeta<string> = string,\n  TAccountOwnerTokenMintAddress extends string | AccountMeta<string> = string,\n  TAccountWalletAddress extends string | AccountMeta<string> = string,\n  TAccountTokenProgram extends\n    | string\n    | AccountMeta<string> = 'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb',\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountNestedAssociatedAccountAddress extends string\n        ? WritableAccount<TAccountNestedAssociatedAccountAddress>\n        : TAccountNestedAssociatedAccountAddress,\n      TAccountNestedTokenMintAddress extends string\n        ? ReadonlyAccount<TAccountNestedTokenMintAddress>\n        : TAccountNestedTokenMintAddress,\n      TAccountDestinationAssociatedAccountAddress extends string\n        ? WritableAccount<TAccountDestinationAssociatedAccountAddress>\n        : TAccountDestinationAssociatedAccountAddress,\n      TAccountOwnerAssociatedAccountAddress extends string\n        ? ReadonlyAccount<TAccountOwnerAssociatedAccountAddress>\n        : TAccountOwnerAssociatedAccountAddress,\n      TAccountOwnerTokenMintAddress extends string\n        ? ReadonlyAccount<TAccountOwnerTokenMintAddress>\n        : TAccountOwnerTokenMintAddress,\n      TAccountWalletAddress extends string\n        ? WritableSignerAccount<TAccountWalletAddress> &\n            AccountSignerMeta<TAccountWalletAddress>\n        : TAccountWalletAddress,\n      TAccountTokenProgram extends string\n        ? ReadonlyAccount<TAccountTokenProgram>\n        : TAccountTokenProgram,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type RecoverNestedAssociatedTokenInstructionData = {\n  discriminator: number;\n};\n\nexport type RecoverNestedAssociatedTokenInstructionDataArgs = {};\n\nexport function getRecoverNestedAssociatedTokenInstructionDataEncoder(): FixedSizeEncoder<RecoverNestedAssociatedTokenInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: RECOVER_NESTED_ASSOCIATED_TOKEN_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getRecoverNestedAssociatedTokenInstructionDataDecoder(): FixedSizeDecoder<RecoverNestedAssociatedTokenInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getRecoverNestedAssociatedTokenInstructionDataCodec(): FixedSizeCodec<\n  RecoverNestedAssociatedTokenInstructionDataArgs,\n  RecoverNestedAssociatedTokenInstructionData\n> {\n  return combineCodec(\n    getRecoverNestedAssociatedTokenInstructionDataEncoder(),\n    getRecoverNestedAssociatedTokenInstructionDataDecoder()\n  );\n}\n\nexport type RecoverNestedAssociatedTokenAsyncInput<\n  TAccountNestedAssociatedAccountAddress extends string = string,\n  TAccountNestedTokenMintAddress extends string = string,\n  TAccountDestinationAssociatedAccountAddress extends string = string,\n  TAccountOwnerAssociatedAccountAddress extends string = string,\n  TAccountOwnerTokenMintAddress extends string = string,\n  TAccountWalletAddress extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Nested associated token account, must be owned by `ownerAssociatedAccountAddress`. */\n  nestedAssociatedAccountAddress?: Address<TAccountNestedAssociatedAccountAddress>;\n  /** Token mint for the nested associated token account. */\n  nestedTokenMintAddress: Address<TAccountNestedTokenMintAddress>;\n  /** Wallet's associated token account. */\n  destinationAssociatedAccountAddress?: Address<TAccountDestinationAssociatedAccountAddress>;\n  /** Owner associated token account address, must be owned by `walletAddress`. */\n  ownerAssociatedAccountAddress?: Address<TAccountOwnerAssociatedAccountAddress>;\n  /** Token mint for the owner associated token account. */\n  ownerTokenMintAddress: Address<TAccountOwnerTokenMintAddress>;\n  /** Wallet address for the owner associated token account. */\n  walletAddress: TransactionSigner<TAccountWalletAddress>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport async function getRecoverNestedAssociatedTokenInstructionAsync<\n  TAccountNestedAssociatedAccountAddress extends string,\n  TAccountNestedTokenMintAddress extends string,\n  TAccountDestinationAssociatedAccountAddress extends string,\n  TAccountOwnerAssociatedAccountAddress extends string,\n  TAccountOwnerTokenMintAddress extends string,\n  TAccountWalletAddress extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: RecoverNestedAssociatedTokenAsyncInput<\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): Promise<\n  RecoverNestedAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nestedAssociatedAccountAddress: {\n      value: input.nestedAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    nestedTokenMintAddress: {\n      value: input.nestedTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    destinationAssociatedAccountAddress: {\n      value: input.destinationAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    ownerAssociatedAccountAddress: {\n      value: input.ownerAssociatedAccountAddress ?? null,\n      isWritable: false,\n    },\n    ownerTokenMintAddress: {\n      value: input.ownerTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    walletAddress: { value: input.walletAddress ?? null, isWritable: true },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n  }\n  if (!accounts.ownerAssociatedAccountAddress.value) {\n    accounts.ownerAssociatedAccountAddress.value = await findAssociatedTokenPda(\n      {\n        owner: expectAddress(accounts.walletAddress.value),\n        tokenProgram: expectAddress(accounts.tokenProgram.value),\n        mint: expectAddress(accounts.ownerTokenMintAddress.value),\n      }\n    );\n  }\n  if (!accounts.nestedAssociatedAccountAddress.value) {\n    accounts.nestedAssociatedAccountAddress.value =\n      await findAssociatedTokenPda({\n        owner: expectAddress(accounts.ownerAssociatedAccountAddress.value),\n        tokenProgram: expectAddress(accounts.tokenProgram.value),\n        mint: expectAddress(accounts.nestedTokenMintAddress.value),\n      });\n  }\n  if (!accounts.destinationAssociatedAccountAddress.value) {\n    accounts.destinationAssociatedAccountAddress.value =\n      await findAssociatedTokenPda({\n        owner: expectAddress(accounts.walletAddress.value),\n        tokenProgram: expectAddress(accounts.tokenProgram.value),\n        mint: expectAddress(accounts.nestedTokenMintAddress.value),\n      });\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.nestedAssociatedAccountAddress),\n      getAccountMeta(accounts.nestedTokenMintAddress),\n      getAccountMeta(accounts.destinationAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerTokenMintAddress),\n      getAccountMeta(accounts.walletAddress),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    data: getRecoverNestedAssociatedTokenInstructionDataEncoder().encode({}),\n    programAddress,\n  } as RecoverNestedAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >);\n}\n\nexport type RecoverNestedAssociatedTokenInput<\n  TAccountNestedAssociatedAccountAddress extends string = string,\n  TAccountNestedTokenMintAddress extends string = string,\n  TAccountDestinationAssociatedAccountAddress extends string = string,\n  TAccountOwnerAssociatedAccountAddress extends string = string,\n  TAccountOwnerTokenMintAddress extends string = string,\n  TAccountWalletAddress extends string = string,\n  TAccountTokenProgram extends string = string,\n> = {\n  /** Nested associated token account, must be owned by `ownerAssociatedAccountAddress`. */\n  nestedAssociatedAccountAddress: Address<TAccountNestedAssociatedAccountAddress>;\n  /** Token mint for the nested associated token account. */\n  nestedTokenMintAddress: Address<TAccountNestedTokenMintAddress>;\n  /** Wallet's associated token account. */\n  destinationAssociatedAccountAddress: Address<TAccountDestinationAssociatedAccountAddress>;\n  /** Owner associated token account address, must be owned by `walletAddress`. */\n  ownerAssociatedAccountAddress: Address<TAccountOwnerAssociatedAccountAddress>;\n  /** Token mint for the owner associated token account. */\n  ownerTokenMintAddress: Address<TAccountOwnerTokenMintAddress>;\n  /** Wallet address for the owner associated token account. */\n  walletAddress: TransactionSigner<TAccountWalletAddress>;\n  /** SPL Token program. */\n  tokenProgram?: Address<TAccountTokenProgram>;\n};\n\nexport function getRecoverNestedAssociatedTokenInstruction<\n  TAccountNestedAssociatedAccountAddress extends string,\n  TAccountNestedTokenMintAddress extends string,\n  TAccountDestinationAssociatedAccountAddress extends string,\n  TAccountOwnerAssociatedAccountAddress extends string,\n  TAccountOwnerTokenMintAddress extends string,\n  TAccountWalletAddress extends string,\n  TAccountTokenProgram extends string,\n  TProgramAddress extends Address = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n>(\n  input: RecoverNestedAssociatedTokenInput<\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >,\n  config?: { programAddress?: TProgramAddress }\n): RecoverNestedAssociatedTokenInstruction<\n  TProgramAddress,\n  TAccountNestedAssociatedAccountAddress,\n  TAccountNestedTokenMintAddress,\n  TAccountDestinationAssociatedAccountAddress,\n  TAccountOwnerAssociatedAccountAddress,\n  TAccountOwnerTokenMintAddress,\n  TAccountWalletAddress,\n  TAccountTokenProgram\n> {\n  // Program address.\n  const programAddress =\n    config?.programAddress ?? ASSOCIATED_TOKEN_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    nestedAssociatedAccountAddress: {\n      value: input.nestedAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    nestedTokenMintAddress: {\n      value: input.nestedTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    destinationAssociatedAccountAddress: {\n      value: input.destinationAssociatedAccountAddress ?? null,\n      isWritable: true,\n    },\n    ownerAssociatedAccountAddress: {\n      value: input.ownerAssociatedAccountAddress ?? null,\n      isWritable: false,\n    },\n    ownerTokenMintAddress: {\n      value: input.ownerTokenMintAddress ?? null,\n      isWritable: false,\n    },\n    walletAddress: { value: input.walletAddress ?? null, isWritable: true },\n    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Resolve default values.\n  if (!accounts.tokenProgram.value) {\n    accounts.tokenProgram.value =\n      'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb' as Address<'TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb'>;\n  }\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.nestedAssociatedAccountAddress),\n      getAccountMeta(accounts.nestedTokenMintAddress),\n      getAccountMeta(accounts.destinationAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerAssociatedAccountAddress),\n      getAccountMeta(accounts.ownerTokenMintAddress),\n      getAccountMeta(accounts.walletAddress),\n      getAccountMeta(accounts.tokenProgram),\n    ],\n    data: getRecoverNestedAssociatedTokenInstructionDataEncoder().encode({}),\n    programAddress,\n  } as RecoverNestedAssociatedTokenInstruction<\n    TProgramAddress,\n    TAccountNestedAssociatedAccountAddress,\n    TAccountNestedTokenMintAddress,\n    TAccountDestinationAssociatedAccountAddress,\n    TAccountOwnerAssociatedAccountAddress,\n    TAccountOwnerTokenMintAddress,\n    TAccountWalletAddress,\n    TAccountTokenProgram\n  >);\n}\n\nexport type ParsedRecoverNestedAssociatedTokenInstruction<\n  TProgram extends string = typeof ASSOCIATED_TOKEN_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Nested associated token account, must be owned by `ownerAssociatedAccountAddress`. */\n    nestedAssociatedAccountAddress: TAccountMetas[0];\n    /** Token mint for the nested associated token account. */\n    nestedTokenMintAddress: TAccountMetas[1];\n    /** Wallet's associated token account. */\n    destinationAssociatedAccountAddress: TAccountMetas[2];\n    /** Owner associated token account address, must be owned by `walletAddress`. */\n    ownerAssociatedAccountAddress: TAccountMetas[3];\n    /** Token mint for the owner associated token account. */\n    ownerTokenMintAddress: TAccountMetas[4];\n    /** Wallet address for the owner associated token account. */\n    walletAddress: TAccountMetas[5];\n    /** SPL Token program. */\n    tokenProgram: TAccountMetas[6];\n  };\n  data: RecoverNestedAssociatedTokenInstructionData;\n};\n\nexport function parseRecoverNestedAssociatedTokenInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedRecoverNestedAssociatedTokenInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 7) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      nestedAssociatedAccountAddress: getNextAccount(),\n      nestedTokenMintAddress: getNextAccount(),\n      destinationAssociatedAccountAddress: getNextAccount(),\n      ownerAssociatedAccountAddress: getNextAccount(),\n      ownerTokenMintAddress: getNextAccount(),\n      walletAddress: getNextAccount(),\n      tokenProgram: getNextAccount(),\n    },\n    data: getRecoverNestedAssociatedTokenInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const REMOVE_TOKEN_METADATA_KEY_DISCRIMINATOR = new Uint8Array([\n  234, 18, 32, 56, 89, 141, 37, 181,\n]);\n\nexport function getRemoveTokenMetadataKeyDiscriminatorBytes() {\n  return getBytesEncoder().encode(REMOVE_TOKEN_METADATA_KEY_DISCRIMINATOR);\n}\n\nexport type RemoveTokenMetadataKeyInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetadata extends string | AccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMetadata extends string\n        ? WritableAccount<TAccountMetadata>\n        : TAccountMetadata,\n      TAccountUpdateAuthority extends string\n        ? ReadonlySignerAccount<TAccountUpdateAuthority> &\n            AccountSignerMeta<TAccountUpdateAuthority>\n        : TAccountUpdateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type RemoveTokenMetadataKeyInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /**\n   * If the idempotent flag is set to true, then the instruction will not\n   * error if the key does not exist\n   */\n  idempotent: boolean;\n  /** Key to remove in the additional metadata portion. */\n  key: string;\n};\n\nexport type RemoveTokenMetadataKeyInstructionDataArgs = {\n  /**\n   * If the idempotent flag is set to true, then the instruction will not\n   * error if the key does not exist\n   */\n  idempotent?: boolean;\n  /** Key to remove in the additional metadata portion. */\n  key: string;\n};\n\nexport function getRemoveTokenMetadataKeyInstructionDataEncoder(): Encoder<RemoveTokenMetadataKeyInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      ['idempotent', getBooleanEncoder()],\n      ['key', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: REMOVE_TOKEN_METADATA_KEY_DISCRIMINATOR,\n      idempotent: value.idempotent ?? false,\n    })\n  );\n}\n\nexport function getRemoveTokenMetadataKeyInstructionDataDecoder(): Decoder<RemoveTokenMetadataKeyInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    ['idempotent', getBooleanDecoder()],\n    ['key', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n  ]);\n}\n\nexport function getRemoveTokenMetadataKeyInstructionDataCodec(): Codec<\n  RemoveTokenMetadataKeyInstructionDataArgs,\n  RemoveTokenMetadataKeyInstructionData\n> {\n  return combineCodec(\n    getRemoveTokenMetadataKeyInstructionDataEncoder(),\n    getRemoveTokenMetadataKeyInstructionDataDecoder()\n  );\n}\n\nexport type RemoveTokenMetadataKeyInput<\n  TAccountMetadata extends string = string,\n  TAccountUpdateAuthority extends string = string,\n> = {\n  metadata: Address<TAccountMetadata>;\n  updateAuthority: TransactionSigner<TAccountUpdateAuthority>;\n  idempotent?: RemoveTokenMetadataKeyInstructionDataArgs['idempotent'];\n  key: RemoveTokenMetadataKeyInstructionDataArgs['key'];\n};\n\nexport function getRemoveTokenMetadataKeyInstruction<\n  TAccountMetadata extends string,\n  TAccountUpdateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: RemoveTokenMetadataKeyInput<TAccountMetadata, TAccountUpdateAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): RemoveTokenMetadataKeyInstruction<\n  TProgramAddress,\n  TAccountMetadata,\n  TAccountUpdateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.metadata),\n      getAccountMeta(accounts.updateAuthority),\n    ],\n    data: getRemoveTokenMetadataKeyInstructionDataEncoder().encode(\n      args as RemoveTokenMetadataKeyInstructionDataArgs\n    ),\n    programAddress,\n  } as RemoveTokenMetadataKeyInstruction<\n    TProgramAddress,\n    TAccountMetadata,\n    TAccountUpdateAuthority\n  >);\n}\n\nexport type ParsedRemoveTokenMetadataKeyInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    metadata: TAccountMetas[0];\n    updateAuthority: TAccountMetas[1];\n  };\n  data: RemoveTokenMetadataKeyInstructionData;\n};\n\nexport function parseRemoveTokenMetadataKeyInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedRemoveTokenMetadataKeyInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { metadata: getNextAccount(), updateAuthority: getNextAccount() },\n    data: getRemoveTokenMetadataKeyInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const RESUME_DISCRIMINATOR = 44;\n\nexport function getResumeDiscriminatorBytes() {\n  return getU8Encoder().encode(RESUME_DISCRIMINATOR);\n}\n\nexport const RESUME_PAUSABLE_DISCRIMINATOR = 2;\n\nexport function getResumePausableDiscriminatorBytes() {\n  return getU8Encoder().encode(RESUME_PAUSABLE_DISCRIMINATOR);\n}\n\nexport type ResumeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ResumeInstructionData = {\n  discriminator: number;\n  pausableDiscriminator: number;\n};\n\nexport type ResumeInstructionDataArgs = {};\n\nexport function getResumeInstructionDataEncoder(): FixedSizeEncoder<ResumeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['pausableDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: RESUME_DISCRIMINATOR,\n      pausableDiscriminator: RESUME_PAUSABLE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getResumeInstructionDataDecoder(): FixedSizeDecoder<ResumeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['pausableDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getResumeInstructionDataCodec(): FixedSizeCodec<\n  ResumeInstructionDataArgs,\n  ResumeInstructionData\n> {\n  return combineCodec(\n    getResumeInstructionDataEncoder(),\n    getResumeInstructionDataDecoder()\n  );\n}\n\nexport type ResumeInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The pausable authority that can resume the mint. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n};\n\nexport function getResumeInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ResumeInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): ResumeInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n    ],\n    data: getResumeInstructionDataEncoder().encode({}),\n    programAddress,\n  } as ResumeInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedResumeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The pausable authority that can resume the mint. */\n    authority: TAccountMetas[1];\n  };\n  data: ResumeInstructionData;\n};\n\nexport function parseResumeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedResumeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), authority: getNextAccount() },\n    data: getResumeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const REVOKE_DISCRIMINATOR = 5;\n\nexport function getRevokeDiscriminatorBytes() {\n  return getU8Encoder().encode(REVOKE_DISCRIMINATOR);\n}\n\nexport type RevokeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type RevokeInstructionData = { discriminator: number };\n\nexport type RevokeInstructionDataArgs = {};\n\nexport function getRevokeInstructionDataEncoder(): FixedSizeEncoder<RevokeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: REVOKE_DISCRIMINATOR })\n  );\n}\n\nexport function getRevokeInstructionDataDecoder(): FixedSizeDecoder<RevokeInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getRevokeInstructionDataCodec(): FixedSizeCodec<\n  RevokeInstructionDataArgs,\n  RevokeInstructionData\n> {\n  return combineCodec(\n    getRevokeInstructionDataEncoder(),\n    getRevokeInstructionDataDecoder()\n  );\n}\n\nexport type RevokeInput<\n  TAccountSource extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The source account owner or its multisignature. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getRevokeInstruction<\n  TAccountSource extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: RevokeInput<TAccountSource, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): RevokeInstruction<\n  TProgramAddress,\n  TAccountSource,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getRevokeInstructionDataEncoder().encode({}),\n    programAddress,\n  } as RevokeInstruction<\n    TProgramAddress,\n    TAccountSource,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedRevokeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The source account owner or its multisignature. */\n    owner: TAccountMetas[1];\n  };\n  data: RevokeInstructionData;\n};\n\nexport function parseRevokeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedRevokeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { source: getNextAccount(), owner: getNextAccount() },\n    data: getRevokeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getAuthorityTypeDecoder,\n  getAuthorityTypeEncoder,\n  type AuthorityType,\n  type AuthorityTypeArgs,\n} from '../types';\n\nexport const SET_AUTHORITY_DISCRIMINATOR = 6;\n\nexport function getSetAuthorityDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_AUTHORITY_DISCRIMINATOR);\n}\n\nexport type SetAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountOwned extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountOwned extends string\n        ? WritableAccount<TAccountOwned>\n        : TAccountOwned,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetAuthorityInstructionData = {\n  discriminator: number;\n  /** The type of authority to update. */\n  authorityType: AuthorityType;\n  /** The new authority */\n  newAuthority: Option<Address>;\n};\n\nexport type SetAuthorityInstructionDataArgs = {\n  /** The type of authority to update. */\n  authorityType: AuthorityTypeArgs;\n  /** The new authority */\n  newAuthority: OptionOrNullable<Address>;\n};\n\nexport function getSetAuthorityInstructionDataEncoder(): Encoder<SetAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['authorityType', getAuthorityTypeEncoder()],\n      ['newAuthority', getOptionEncoder(getAddressEncoder())],\n    ]),\n    (value) => ({ ...value, discriminator: SET_AUTHORITY_DISCRIMINATOR })\n  );\n}\n\nexport function getSetAuthorityInstructionDataDecoder(): Decoder<SetAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['authorityType', getAuthorityTypeDecoder()],\n    ['newAuthority', getOptionDecoder(getAddressDecoder())],\n  ]);\n}\n\nexport function getSetAuthorityInstructionDataCodec(): Codec<\n  SetAuthorityInstructionDataArgs,\n  SetAuthorityInstructionData\n> {\n  return combineCodec(\n    getSetAuthorityInstructionDataEncoder(),\n    getSetAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type SetAuthorityInput<\n  TAccountOwned extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The mint or account to change the authority of. */\n  owned: Address<TAccountOwned>;\n  /** The current authority or the multisignature account of the mint or account to update. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  authorityType: SetAuthorityInstructionDataArgs['authorityType'];\n  newAuthority: SetAuthorityInstructionDataArgs['newAuthority'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getSetAuthorityInstruction<\n  TAccountOwned extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: SetAuthorityInput<TAccountOwned, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): SetAuthorityInstruction<\n  TProgramAddress,\n  TAccountOwned,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    owned: { value: input.owned ?? null, isWritable: true },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.owned),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getSetAuthorityInstructionDataEncoder().encode(\n      args as SetAuthorityInstructionDataArgs\n    ),\n    programAddress,\n  } as SetAuthorityInstruction<\n    TProgramAddress,\n    TAccountOwned,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedSetAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint or account to change the authority of. */\n    owned: TAccountMetas[0];\n    /** The current authority or the multisignature account of the mint or account to update. */\n    owner: TAccountMetas[1];\n  };\n  data: SetAuthorityInstructionData;\n};\n\nexport function parseSetAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedSetAuthorityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { owned: getNextAccount(), owner: getNextAccount() },\n    data: getSetAuthorityInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU16Decoder,\n  getU16Encoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SET_TRANSFER_FEE_DISCRIMINATOR = 26;\n\nexport function getSetTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_TRANSFER_FEE_DISCRIMINATOR);\n}\n\nexport const SET_TRANSFER_FEE_TRANSFER_FEE_DISCRIMINATOR = 5;\n\nexport function getSetTransferFeeTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(SET_TRANSFER_FEE_TRANSFER_FEE_DISCRIMINATOR);\n}\n\nexport type SetTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountTransferFeeConfigAuthority extends\n    | string\n    | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountTransferFeeConfigAuthority extends string\n        ? ReadonlyAccount<TAccountTransferFeeConfigAuthority>\n        : TAccountTransferFeeConfigAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SetTransferFeeInstructionData = {\n  discriminator: number;\n  transferFeeDiscriminator: number;\n  /** Amount of transfer collected as fees, expressed as basis points of the transfer amount. */\n  transferFeeBasisPoints: number;\n  /** Maximum fee assessed on transfers. */\n  maximumFee: bigint;\n};\n\nexport type SetTransferFeeInstructionDataArgs = {\n  /** Amount of transfer collected as fees, expressed as basis points of the transfer amount. */\n  transferFeeBasisPoints: number;\n  /** Maximum fee assessed on transfers. */\n  maximumFee: number | bigint;\n};\n\nexport function getSetTransferFeeInstructionDataEncoder(): FixedSizeEncoder<SetTransferFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferFeeDiscriminator', getU8Encoder()],\n      ['transferFeeBasisPoints', getU16Encoder()],\n      ['maximumFee', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: SET_TRANSFER_FEE_DISCRIMINATOR,\n      transferFeeDiscriminator: SET_TRANSFER_FEE_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getSetTransferFeeInstructionDataDecoder(): FixedSizeDecoder<SetTransferFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferFeeDiscriminator', getU8Decoder()],\n    ['transferFeeBasisPoints', getU16Decoder()],\n    ['maximumFee', getU64Decoder()],\n  ]);\n}\n\nexport function getSetTransferFeeInstructionDataCodec(): FixedSizeCodec<\n  SetTransferFeeInstructionDataArgs,\n  SetTransferFeeInstructionData\n> {\n  return combineCodec(\n    getSetTransferFeeInstructionDataEncoder(),\n    getSetTransferFeeInstructionDataDecoder()\n  );\n}\n\nexport type SetTransferFeeInput<\n  TAccountMint extends string = string,\n  TAccountTransferFeeConfigAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The mint's fee account owner or its multisignature account. */\n  transferFeeConfigAuthority:\n    | Address<TAccountTransferFeeConfigAuthority>\n    | TransactionSigner<TAccountTransferFeeConfigAuthority>;\n  transferFeeBasisPoints: SetTransferFeeInstructionDataArgs['transferFeeBasisPoints'];\n  maximumFee: SetTransferFeeInstructionDataArgs['maximumFee'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getSetTransferFeeInstruction<\n  TAccountMint extends string,\n  TAccountTransferFeeConfigAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: SetTransferFeeInput<TAccountMint, TAccountTransferFeeConfigAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): SetTransferFeeInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['transferFeeConfigAuthority'] extends TransactionSigner<TAccountTransferFeeConfigAuthority>\n    ? ReadonlySignerAccount<TAccountTransferFeeConfigAuthority> &\n        AccountSignerMeta<TAccountTransferFeeConfigAuthority>\n    : TAccountTransferFeeConfigAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    transferFeeConfigAuthority: {\n      value: input.transferFeeConfigAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.transferFeeConfigAuthority),\n      ...remainingAccounts,\n    ],\n    data: getSetTransferFeeInstructionDataEncoder().encode(\n      args as SetTransferFeeInstructionDataArgs\n    ),\n    programAddress,\n  } as SetTransferFeeInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['transferFeeConfigAuthority'] extends TransactionSigner<TAccountTransferFeeConfigAuthority>\n      ? ReadonlySignerAccount<TAccountTransferFeeConfigAuthority> &\n          AccountSignerMeta<TAccountTransferFeeConfigAuthority>\n      : TAccountTransferFeeConfigAuthority\n  >);\n}\n\nexport type ParsedSetTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The mint's fee account owner or its multisignature account. */\n    transferFeeConfigAuthority: TAccountMetas[1];\n  };\n  data: SetTransferFeeInstructionData;\n};\n\nexport function parseSetTransferFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedSetTransferFeeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      transferFeeConfigAuthority: getNextAccount(),\n    },\n    data: getSetTransferFeeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const SYNC_NATIVE_DISCRIMINATOR = 17;\n\nexport function getSyncNativeDiscriminatorBytes() {\n  return getU8Encoder().encode(SYNC_NATIVE_DISCRIMINATOR);\n}\n\nexport type SyncNativeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type SyncNativeInstructionData = { discriminator: number };\n\nexport type SyncNativeInstructionDataArgs = {};\n\nexport function getSyncNativeInstructionDataEncoder(): FixedSizeEncoder<SyncNativeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: SYNC_NATIVE_DISCRIMINATOR })\n  );\n}\n\nexport function getSyncNativeInstructionDataDecoder(): FixedSizeDecoder<SyncNativeInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getSyncNativeInstructionDataCodec(): FixedSizeCodec<\n  SyncNativeInstructionDataArgs,\n  SyncNativeInstructionData\n> {\n  return combineCodec(\n    getSyncNativeInstructionDataEncoder(),\n    getSyncNativeInstructionDataDecoder()\n  );\n}\n\nexport type SyncNativeInput<TAccountAccount extends string = string> = {\n  /** The native token account to sync with its underlying lamports. */\n  account: Address<TAccountAccount>;\n};\n\nexport function getSyncNativeInstruction<\n  TAccountAccount extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: SyncNativeInput<TAccountAccount>,\n  config?: { programAddress?: TProgramAddress }\n): SyncNativeInstruction<TProgramAddress, TAccountAccount> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.account)],\n    data: getSyncNativeInstructionDataEncoder().encode({}),\n    programAddress,\n  } as SyncNativeInstruction<TProgramAddress, TAccountAccount>);\n}\n\nexport type ParsedSyncNativeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The native token account to sync with its underlying lamports. */\n    account: TAccountMetas[0];\n  };\n  data: SyncNativeInstructionData;\n};\n\nexport function parseSyncNativeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedSyncNativeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { account: getNextAccount() },\n    data: getSyncNativeInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const THAW_ACCOUNT_DISCRIMINATOR = 11;\n\nexport function getThawAccountDiscriminatorBytes() {\n  return getU8Encoder().encode(THAW_ACCOUNT_DISCRIMINATOR);\n}\n\nexport type ThawAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountAccount extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountOwner extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountAccount extends string\n        ? WritableAccount<TAccountAccount>\n        : TAccountAccount,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountOwner extends string\n        ? ReadonlyAccount<TAccountOwner>\n        : TAccountOwner,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type ThawAccountInstructionData = { discriminator: number };\n\nexport type ThawAccountInstructionDataArgs = {};\n\nexport function getThawAccountInstructionDataEncoder(): FixedSizeEncoder<ThawAccountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({ ...value, discriminator: THAW_ACCOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getThawAccountInstructionDataDecoder(): FixedSizeDecoder<ThawAccountInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getThawAccountInstructionDataCodec(): FixedSizeCodec<\n  ThawAccountInstructionDataArgs,\n  ThawAccountInstructionData\n> {\n  return combineCodec(\n    getThawAccountInstructionDataEncoder(),\n    getThawAccountInstructionDataDecoder()\n  );\n}\n\nexport type ThawAccountInput<\n  TAccountAccount extends string = string,\n  TAccountMint extends string = string,\n  TAccountOwner extends string = string,\n> = {\n  /** The account to thaw. */\n  account: Address<TAccountAccount>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The mint freeze authority or its multisignature account. */\n  owner: Address<TAccountOwner> | TransactionSigner<TAccountOwner>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getThawAccountInstruction<\n  TAccountAccount extends string,\n  TAccountMint extends string,\n  TAccountOwner extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: ThawAccountInput<TAccountAccount, TAccountMint, TAccountOwner>,\n  config?: { programAddress?: TProgramAddress }\n): ThawAccountInstruction<\n  TProgramAddress,\n  TAccountAccount,\n  TAccountMint,\n  (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n    ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n    : TAccountOwner\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    account: { value: input.account ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    owner: { value: input.owner ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.account),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.owner),\n      ...remainingAccounts,\n    ],\n    data: getThawAccountInstructionDataEncoder().encode({}),\n    programAddress,\n  } as ThawAccountInstruction<\n    TProgramAddress,\n    TAccountAccount,\n    TAccountMint,\n    (typeof input)['owner'] extends TransactionSigner<TAccountOwner>\n      ? ReadonlySignerAccount<TAccountOwner> & AccountSignerMeta<TAccountOwner>\n      : TAccountOwner\n  >);\n}\n\nexport type ParsedThawAccountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The account to thaw. */\n    account: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The mint freeze authority or its multisignature account. */\n    owner: TAccountMetas[2];\n  };\n  data: ThawAccountInstructionData;\n};\n\nexport function parseThawAccountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedThawAccountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      account: getNextAccount(),\n      mint: getNextAccount(),\n      owner: getNextAccount(),\n    },\n    data: getThawAccountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_DISCRIMINATOR = 3;\n\nexport function getTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(TRANSFER_DISCRIMINATOR);\n}\n\nexport type TransferInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountDestination extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to transfer. */\n  amount: bigint;\n};\n\nexport type TransferInstructionDataArgs = {\n  /** The amount of tokens to transfer. */\n  amount: number | bigint;\n};\n\nexport function getTransferInstructionDataEncoder(): FixedSizeEncoder<TransferInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: TRANSFER_DISCRIMINATOR })\n  );\n}\n\nexport function getTransferInstructionDataDecoder(): FixedSizeDecoder<TransferInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n  ]);\n}\n\nexport function getTransferInstructionDataCodec(): FixedSizeCodec<\n  TransferInstructionDataArgs,\n  TransferInstructionData\n> {\n  return combineCodec(\n    getTransferInstructionDataEncoder(),\n    getTransferInstructionDataDecoder()\n  );\n}\n\nexport type TransferInput<\n  TAccountSource extends string = string,\n  TAccountDestination extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The destination account. */\n  destination: Address<TAccountDestination>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: TransferInstructionDataArgs['amount'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getTransferInstruction<\n  TAccountSource extends string,\n  TAccountDestination extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: TransferInput<TAccountSource, TAccountDestination, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): TransferInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountDestination,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getTransferInstructionDataEncoder().encode(\n      args as TransferInstructionDataArgs\n    ),\n    programAddress,\n  } as TransferInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountDestination,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedTransferInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The destination account. */\n    destination: TAccountMetas[1];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: TransferInstructionData;\n};\n\nexport function parseTransferInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedTransferInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      destination: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getTransferInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_CHECKED_DISCRIMINATOR = 12;\n\nexport function getTransferCheckedDiscriminatorBytes() {\n  return getU8Encoder().encode(TRANSFER_CHECKED_DISCRIMINATOR);\n}\n\nexport type TransferCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountDestination extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferCheckedInstructionData = {\n  discriminator: number;\n  /** The amount of tokens to transfer. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport type TransferCheckedInstructionDataArgs = {\n  /** The amount of tokens to transfer. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n};\n\nexport function getTransferCheckedInstructionDataEncoder(): FixedSizeEncoder<TransferCheckedInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: TRANSFER_CHECKED_DISCRIMINATOR })\n  );\n}\n\nexport function getTransferCheckedInstructionDataDecoder(): FixedSizeDecoder<TransferCheckedInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n  ]);\n}\n\nexport function getTransferCheckedInstructionDataCodec(): FixedSizeCodec<\n  TransferCheckedInstructionDataArgs,\n  TransferCheckedInstructionData\n> {\n  return combineCodec(\n    getTransferCheckedInstructionDataEncoder(),\n    getTransferCheckedInstructionDataDecoder()\n  );\n}\n\nexport type TransferCheckedInput<\n  TAccountSource extends string = string,\n  TAccountMint extends string = string,\n  TAccountDestination extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source account. */\n  source: Address<TAccountSource>;\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The destination account. */\n  destination: Address<TAccountDestination>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: TransferCheckedInstructionDataArgs['amount'];\n  decimals: TransferCheckedInstructionDataArgs['decimals'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getTransferCheckedInstruction<\n  TAccountSource extends string,\n  TAccountMint extends string,\n  TAccountDestination extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: TransferCheckedInput<\n    TAccountSource,\n    TAccountMint,\n    TAccountDestination,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): TransferCheckedInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountMint,\n  TAccountDestination,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    destination: { value: input.destination ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getTransferCheckedInstructionDataEncoder().encode(\n      args as TransferCheckedInstructionDataArgs\n    ),\n    programAddress,\n  } as TransferCheckedInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountMint,\n    TAccountDestination,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedTransferCheckedInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. */\n    source: TAccountMetas[0];\n    /** The token mint. */\n    mint: TAccountMetas[1];\n    /** The destination account. */\n    destination: TAccountMetas[2];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[3];\n  };\n  data: TransferCheckedInstructionData;\n};\n\nexport function parseTransferCheckedInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedTransferCheckedInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      mint: getNextAccount(),\n      destination: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getTransferCheckedInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const TRANSFER_CHECKED_WITH_FEE_DISCRIMINATOR = 26;\n\nexport function getTransferCheckedWithFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(TRANSFER_CHECKED_WITH_FEE_DISCRIMINATOR);\n}\n\nexport const TRANSFER_CHECKED_WITH_FEE_TRANSFER_FEE_DISCRIMINATOR = 1;\n\nexport function getTransferCheckedWithFeeTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    TRANSFER_CHECKED_WITH_FEE_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type TransferCheckedWithFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSource extends string | AccountMeta<string> = string,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountDestination extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSource extends string\n        ? WritableAccount<TAccountSource>\n        : TAccountSource,\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type TransferCheckedWithFeeInstructionData = {\n  discriminator: number;\n  transferFeeDiscriminator: number;\n  /** The amount of tokens to transfer. */\n  amount: bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /**\n   * Expected fee assessed on this transfer, calculated off-chain based\n   * on the transfer_fee_basis_points and maximum_fee of the mint. May\n   * be 0 for a mint without a configured transfer fee.\n   */\n  fee: bigint;\n};\n\nexport type TransferCheckedWithFeeInstructionDataArgs = {\n  /** The amount of tokens to transfer. */\n  amount: number | bigint;\n  /** Expected number of base 10 digits to the right of the decimal place. */\n  decimals: number;\n  /**\n   * Expected fee assessed on this transfer, calculated off-chain based\n   * on the transfer_fee_basis_points and maximum_fee of the mint. May\n   * be 0 for a mint without a configured transfer fee.\n   */\n  fee: number | bigint;\n};\n\nexport function getTransferCheckedWithFeeInstructionDataEncoder(): FixedSizeEncoder<TransferCheckedWithFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferFeeDiscriminator', getU8Encoder()],\n      ['amount', getU64Encoder()],\n      ['decimals', getU8Encoder()],\n      ['fee', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: TRANSFER_CHECKED_WITH_FEE_DISCRIMINATOR,\n      transferFeeDiscriminator:\n        TRANSFER_CHECKED_WITH_FEE_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getTransferCheckedWithFeeInstructionDataDecoder(): FixedSizeDecoder<TransferCheckedWithFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferFeeDiscriminator', getU8Decoder()],\n    ['amount', getU64Decoder()],\n    ['decimals', getU8Decoder()],\n    ['fee', getU64Decoder()],\n  ]);\n}\n\nexport function getTransferCheckedWithFeeInstructionDataCodec(): FixedSizeCodec<\n  TransferCheckedWithFeeInstructionDataArgs,\n  TransferCheckedWithFeeInstructionData\n> {\n  return combineCodec(\n    getTransferCheckedWithFeeInstructionDataEncoder(),\n    getTransferCheckedWithFeeInstructionDataDecoder()\n  );\n}\n\nexport type TransferCheckedWithFeeInput<\n  TAccountSource extends string = string,\n  TAccountMint extends string = string,\n  TAccountDestination extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The source account. May include the `TransferFeeAmount` extension. */\n  source: Address<TAccountSource>;\n  /** The token mint. May include the `TransferFeeConfig` extension. */\n  mint: Address<TAccountMint>;\n  /** The destination account. May include the `TransferFeeAmount` extension. */\n  destination: Address<TAccountDestination>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  amount: TransferCheckedWithFeeInstructionDataArgs['amount'];\n  decimals: TransferCheckedWithFeeInstructionDataArgs['decimals'];\n  fee: TransferCheckedWithFeeInstructionDataArgs['fee'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getTransferCheckedWithFeeInstruction<\n  TAccountSource extends string,\n  TAccountMint extends string,\n  TAccountDestination extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: TransferCheckedWithFeeInput<\n    TAccountSource,\n    TAccountMint,\n    TAccountDestination,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): TransferCheckedWithFeeInstruction<\n  TProgramAddress,\n  TAccountSource,\n  TAccountMint,\n  TAccountDestination,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    source: { value: input.source ?? null, isWritable: true },\n    mint: { value: input.mint ?? null, isWritable: false },\n    destination: { value: input.destination ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.source),\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getTransferCheckedWithFeeInstructionDataEncoder().encode(\n      args as TransferCheckedWithFeeInstructionDataArgs\n    ),\n    programAddress,\n  } as TransferCheckedWithFeeInstruction<\n    TProgramAddress,\n    TAccountSource,\n    TAccountMint,\n    TAccountDestination,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedTransferCheckedWithFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The source account. May include the `TransferFeeAmount` extension. */\n    source: TAccountMetas[0];\n    /** The token mint. May include the `TransferFeeConfig` extension. */\n    mint: TAccountMetas[1];\n    /** The destination account. May include the `TransferFeeAmount` extension. */\n    destination: TAccountMetas[2];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[3];\n  };\n  data: TransferCheckedWithFeeInstructionData;\n};\n\nexport function parseTransferCheckedWithFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedTransferCheckedWithFeeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 4) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      source: getNextAccount(),\n      mint: getNextAccount(),\n      destination: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getTransferCheckedWithFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlyUint8Array,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR = 24;\n\nexport function getUiAmountToAmountDiscriminatorBytes() {\n  return getU8Encoder().encode(UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR);\n}\n\nexport type UiAmountToAmountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UiAmountToAmountInstructionData = {\n  discriminator: number;\n  /** The ui_amount of tokens to reformat. */\n  uiAmount: string;\n};\n\nexport type UiAmountToAmountInstructionDataArgs = {\n  /** The ui_amount of tokens to reformat. */\n  uiAmount: string;\n};\n\nexport function getUiAmountToAmountInstructionDataEncoder(): Encoder<UiAmountToAmountInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['uiAmount', getUtf8Encoder()],\n    ]),\n    (value) => ({ ...value, discriminator: UI_AMOUNT_TO_AMOUNT_DISCRIMINATOR })\n  );\n}\n\nexport function getUiAmountToAmountInstructionDataDecoder(): Decoder<UiAmountToAmountInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['uiAmount', getUtf8Decoder()],\n  ]);\n}\n\nexport function getUiAmountToAmountInstructionDataCodec(): Codec<\n  UiAmountToAmountInstructionDataArgs,\n  UiAmountToAmountInstructionData\n> {\n  return combineCodec(\n    getUiAmountToAmountInstructionDataEncoder(),\n    getUiAmountToAmountInstructionDataDecoder()\n  );\n}\n\nexport type UiAmountToAmountInput<TAccountMint extends string = string> = {\n  /** The mint to calculate for. */\n  mint: Address<TAccountMint>;\n  uiAmount: UiAmountToAmountInstructionDataArgs['uiAmount'];\n};\n\nexport function getUiAmountToAmountInstruction<\n  TAccountMint extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UiAmountToAmountInput<TAccountMint>,\n  config?: { programAddress?: TProgramAddress }\n): UiAmountToAmountInstruction<TProgramAddress, TAccountMint> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [getAccountMeta(accounts.mint)],\n    data: getUiAmountToAmountInstructionDataEncoder().encode(\n      args as UiAmountToAmountInstructionDataArgs\n    ),\n    programAddress,\n  } as UiAmountToAmountInstruction<TProgramAddress, TAccountMint>);\n}\n\nexport type ParsedUiAmountToAmountInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to calculate for. */\n    mint: TAccountMetas[0];\n  };\n  data: UiAmountToAmountInstructionData;\n};\n\nexport function parseUiAmountToAmountInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUiAmountToAmountInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 1) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount() },\n    data: getUiAmountToAmountInstructionDataDecoder().decode(instruction.data),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBooleanDecoder,\n  getBooleanEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR = 27;\n\nexport function getUpdateConfidentialTransferMintDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR);\n}\n\nexport const UPDATE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR = 1;\n\nexport function getUpdateConfidentialTransferMintConfidentialTransferDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR\n  );\n}\n\nexport type UpdateConfidentialTransferMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlySignerAccount<TAccountAuthority> &\n            AccountSignerMeta<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateConfidentialTransferMintInstructionData = {\n  discriminator: number;\n  confidentialTransferDiscriminator: number;\n  /**\n   * Determines if newly configured accounts must be approved by the\n   * `authority` before they may be used by the user.\n   */\n  autoApproveNewAccounts: boolean;\n  /** New authority to decode any transfer amount in a confidential transfer. */\n  auditorElgamalPubkey: Option<Address>;\n};\n\nexport type UpdateConfidentialTransferMintInstructionDataArgs = {\n  /**\n   * Determines if newly configured accounts must be approved by the\n   * `authority` before they may be used by the user.\n   */\n  autoApproveNewAccounts: boolean;\n  /** New authority to decode any transfer amount in a confidential transfer. */\n  auditorElgamalPubkey: OptionOrNullable<Address>;\n};\n\nexport function getUpdateConfidentialTransferMintInstructionDataEncoder(): FixedSizeEncoder<UpdateConfidentialTransferMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferDiscriminator', getU8Encoder()],\n      ['autoApproveNewAccounts', getBooleanEncoder()],\n      [\n        'auditorElgamalPubkey',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_CONFIDENTIAL_TRANSFER_MINT_DISCRIMINATOR,\n      confidentialTransferDiscriminator:\n        UPDATE_CONFIDENTIAL_TRANSFER_MINT_CONFIDENTIAL_TRANSFER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateConfidentialTransferMintInstructionDataDecoder(): FixedSizeDecoder<UpdateConfidentialTransferMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferDiscriminator', getU8Decoder()],\n    ['autoApproveNewAccounts', getBooleanDecoder()],\n    [\n      'auditorElgamalPubkey',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateConfidentialTransferMintInstructionDataCodec(): FixedSizeCodec<\n  UpdateConfidentialTransferMintInstructionDataArgs,\n  UpdateConfidentialTransferMintInstructionData\n> {\n  return combineCodec(\n    getUpdateConfidentialTransferMintInstructionDataEncoder(),\n    getUpdateConfidentialTransferMintInstructionDataDecoder()\n  );\n}\n\nexport type UpdateConfidentialTransferMintInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The SPL Token mint. */\n  mint: Address<TAccountMint>;\n  /** Confidential transfer mint authority. */\n  authority: TransactionSigner<TAccountAuthority>;\n  autoApproveNewAccounts: UpdateConfidentialTransferMintInstructionDataArgs['autoApproveNewAccounts'];\n  auditorElgamalPubkey: UpdateConfidentialTransferMintInstructionDataArgs['auditorElgamalPubkey'];\n};\n\nexport function getUpdateConfidentialTransferMintInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateConfidentialTransferMintInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): UpdateConfidentialTransferMintInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n    ],\n    data: getUpdateConfidentialTransferMintInstructionDataEncoder().encode(\n      args as UpdateConfidentialTransferMintInstructionDataArgs\n    ),\n    programAddress,\n  } as UpdateConfidentialTransferMintInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountAuthority\n  >);\n}\n\nexport type ParsedUpdateConfidentialTransferMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The SPL Token mint. */\n    mint: TAccountMetas[0];\n    /** Confidential transfer mint authority. */\n    authority: TAccountMetas[1];\n  };\n  data: UpdateConfidentialTransferMintInstructionData;\n};\n\nexport function parseUpdateConfidentialTransferMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpdateConfidentialTransferMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), authority: getNextAccount() },\n    data: getUpdateConfidentialTransferMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getAccountStateDecoder,\n  getAccountStateEncoder,\n  type AccountState,\n  type AccountStateArgs,\n} from '../types';\n\nexport const UPDATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = 28;\n\nexport function getUpdateDefaultAccountStateDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR);\n}\n\nexport const UPDATE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR = 1;\n\nexport function getUpdateDefaultAccountStateDefaultAccountStateDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR\n  );\n}\n\nexport type UpdateDefaultAccountStateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountFreezeAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountFreezeAuthority extends string\n        ? ReadonlyAccount<TAccountFreezeAuthority>\n        : TAccountFreezeAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateDefaultAccountStateInstructionData = {\n  discriminator: number;\n  defaultAccountStateDiscriminator: number;\n  /** The state each new token account should start with. */\n  state: AccountState;\n};\n\nexport type UpdateDefaultAccountStateInstructionDataArgs = {\n  /** The state each new token account should start with. */\n  state: AccountStateArgs;\n};\n\nexport function getUpdateDefaultAccountStateInstructionDataEncoder(): FixedSizeEncoder<UpdateDefaultAccountStateInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['defaultAccountStateDiscriminator', getU8Encoder()],\n      ['state', getAccountStateEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR,\n      defaultAccountStateDiscriminator:\n        UPDATE_DEFAULT_ACCOUNT_STATE_DEFAULT_ACCOUNT_STATE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateDefaultAccountStateInstructionDataDecoder(): FixedSizeDecoder<UpdateDefaultAccountStateInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['defaultAccountStateDiscriminator', getU8Decoder()],\n    ['state', getAccountStateDecoder()],\n  ]);\n}\n\nexport function getUpdateDefaultAccountStateInstructionDataCodec(): FixedSizeCodec<\n  UpdateDefaultAccountStateInstructionDataArgs,\n  UpdateDefaultAccountStateInstructionData\n> {\n  return combineCodec(\n    getUpdateDefaultAccountStateInstructionDataEncoder(),\n    getUpdateDefaultAccountStateInstructionDataDecoder()\n  );\n}\n\nexport type UpdateDefaultAccountStateInput<\n  TAccountMint extends string = string,\n  TAccountFreezeAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The mint freeze authority or its multisignature account. */\n  freezeAuthority:\n    | Address<TAccountFreezeAuthority>\n    | TransactionSigner<TAccountFreezeAuthority>;\n  state: UpdateDefaultAccountStateInstructionDataArgs['state'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateDefaultAccountStateInstruction<\n  TAccountMint extends string,\n  TAccountFreezeAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateDefaultAccountStateInput<TAccountMint, TAccountFreezeAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): UpdateDefaultAccountStateInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['freezeAuthority'] extends TransactionSigner<TAccountFreezeAuthority>\n    ? ReadonlySignerAccount<TAccountFreezeAuthority> &\n        AccountSignerMeta<TAccountFreezeAuthority>\n    : TAccountFreezeAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    freezeAuthority: {\n      value: input.freezeAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.freezeAuthority),\n      ...remainingAccounts,\n    ],\n    data: getUpdateDefaultAccountStateInstructionDataEncoder().encode(\n      args as UpdateDefaultAccountStateInstructionDataArgs\n    ),\n    programAddress,\n  } as UpdateDefaultAccountStateInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['freezeAuthority'] extends TransactionSigner<TAccountFreezeAuthority>\n      ? ReadonlySignerAccount<TAccountFreezeAuthority> &\n          AccountSignerMeta<TAccountFreezeAuthority>\n      : TAccountFreezeAuthority\n  >);\n}\n\nexport type ParsedUpdateDefaultAccountStateInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The mint freeze authority or its multisignature account. */\n    freezeAuthority: TAccountMetas[1];\n  };\n  data: UpdateDefaultAccountStateInstructionData;\n};\n\nexport function parseUpdateDefaultAccountStateInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpdateDefaultAccountStateInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), freezeAuthority: getNextAccount() },\n    data: getUpdateDefaultAccountStateInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_GROUP_MEMBER_POINTER_DISCRIMINATOR = 41;\n\nexport function getUpdateGroupMemberPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_GROUP_MEMBER_POINTER_DISCRIMINATOR);\n}\n\nexport const UPDATE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR = 1;\n\nexport function getUpdateGroupMemberPointerGroupMemberPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR\n  );\n}\n\nexport type UpdateGroupMemberPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountGroupMemberPointerAuthority extends\n    | string\n    | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountGroupMemberPointerAuthority extends string\n        ? ReadonlyAccount<TAccountGroupMemberPointerAuthority>\n        : TAccountGroupMemberPointerAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateGroupMemberPointerInstructionData = {\n  discriminator: number;\n  groupMemberPointerDiscriminator: number;\n  /** The new account address that holds the member. */\n  memberAddress: Option<Address>;\n};\n\nexport type UpdateGroupMemberPointerInstructionDataArgs = {\n  /** The new account address that holds the member. */\n  memberAddress: OptionOrNullable<Address>;\n};\n\nexport function getUpdateGroupMemberPointerInstructionDataEncoder(): FixedSizeEncoder<UpdateGroupMemberPointerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['groupMemberPointerDiscriminator', getU8Encoder()],\n      [\n        'memberAddress',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_GROUP_MEMBER_POINTER_DISCRIMINATOR,\n      groupMemberPointerDiscriminator:\n        UPDATE_GROUP_MEMBER_POINTER_GROUP_MEMBER_POINTER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateGroupMemberPointerInstructionDataDecoder(): FixedSizeDecoder<UpdateGroupMemberPointerInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['groupMemberPointerDiscriminator', getU8Decoder()],\n    [\n      'memberAddress',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateGroupMemberPointerInstructionDataCodec(): FixedSizeCodec<\n  UpdateGroupMemberPointerInstructionDataArgs,\n  UpdateGroupMemberPointerInstructionData\n> {\n  return combineCodec(\n    getUpdateGroupMemberPointerInstructionDataEncoder(),\n    getUpdateGroupMemberPointerInstructionDataDecoder()\n  );\n}\n\nexport type UpdateGroupMemberPointerInput<\n  TAccountMint extends string = string,\n  TAccountGroupMemberPointerAuthority extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  /** The group member pointer authority or its multisignature account. */\n  groupMemberPointerAuthority:\n    | Address<TAccountGroupMemberPointerAuthority>\n    | TransactionSigner<TAccountGroupMemberPointerAuthority>;\n  memberAddress: UpdateGroupMemberPointerInstructionDataArgs['memberAddress'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateGroupMemberPointerInstruction<\n  TAccountMint extends string,\n  TAccountGroupMemberPointerAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateGroupMemberPointerInput<\n    TAccountMint,\n    TAccountGroupMemberPointerAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateGroupMemberPointerInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['groupMemberPointerAuthority'] extends TransactionSigner<TAccountGroupMemberPointerAuthority>\n    ? ReadonlySignerAccount<TAccountGroupMemberPointerAuthority> &\n        AccountSignerMeta<TAccountGroupMemberPointerAuthority>\n    : TAccountGroupMemberPointerAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    groupMemberPointerAuthority: {\n      value: input.groupMemberPointerAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.groupMemberPointerAuthority),\n      ...remainingAccounts,\n    ],\n    data: getUpdateGroupMemberPointerInstructionDataEncoder().encode(\n      args as UpdateGroupMemberPointerInstructionDataArgs\n    ),\n    programAddress,\n  } as UpdateGroupMemberPointerInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['groupMemberPointerAuthority'] extends TransactionSigner<TAccountGroupMemberPointerAuthority>\n      ? ReadonlySignerAccount<TAccountGroupMemberPointerAuthority> &\n          AccountSignerMeta<TAccountGroupMemberPointerAuthority>\n      : TAccountGroupMemberPointerAuthority\n  >);\n}\n\nexport type ParsedUpdateGroupMemberPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n    /** The group member pointer authority or its multisignature account. */\n    groupMemberPointerAuthority: TAccountMetas[1];\n  };\n  data: UpdateGroupMemberPointerInstructionData;\n};\n\nexport function parseUpdateGroupMemberPointerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpdateGroupMemberPointerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      groupMemberPointerAuthority: getNextAccount(),\n    },\n    data: getUpdateGroupMemberPointerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_GROUP_POINTER_DISCRIMINATOR = 40;\n\nexport function getUpdateGroupPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_GROUP_POINTER_DISCRIMINATOR);\n}\n\nexport const UPDATE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR = 1;\n\nexport function getUpdateGroupPointerGroupPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR\n  );\n}\n\nexport type UpdateGroupPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountGroupPointerAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountGroupPointerAuthority extends string\n        ? ReadonlyAccount<TAccountGroupPointerAuthority>\n        : TAccountGroupPointerAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateGroupPointerInstructionData = {\n  discriminator: number;\n  groupPointerDiscriminator: number;\n  /** The new account address that holds the group configurations. */\n  groupAddress: Option<Address>;\n};\n\nexport type UpdateGroupPointerInstructionDataArgs = {\n  /** The new account address that holds the group configurations. */\n  groupAddress: OptionOrNullable<Address>;\n};\n\nexport function getUpdateGroupPointerInstructionDataEncoder(): FixedSizeEncoder<UpdateGroupPointerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['groupPointerDiscriminator', getU8Encoder()],\n      [\n        'groupAddress',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_GROUP_POINTER_DISCRIMINATOR,\n      groupPointerDiscriminator:\n        UPDATE_GROUP_POINTER_GROUP_POINTER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateGroupPointerInstructionDataDecoder(): FixedSizeDecoder<UpdateGroupPointerInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['groupPointerDiscriminator', getU8Decoder()],\n    [\n      'groupAddress',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateGroupPointerInstructionDataCodec(): FixedSizeCodec<\n  UpdateGroupPointerInstructionDataArgs,\n  UpdateGroupPointerInstructionData\n> {\n  return combineCodec(\n    getUpdateGroupPointerInstructionDataEncoder(),\n    getUpdateGroupPointerInstructionDataDecoder()\n  );\n}\n\nexport type UpdateGroupPointerInput<\n  TAccountMint extends string = string,\n  TAccountGroupPointerAuthority extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  /** The group pointer authority or its multisignature account. */\n  groupPointerAuthority:\n    | Address<TAccountGroupPointerAuthority>\n    | TransactionSigner<TAccountGroupPointerAuthority>;\n  groupAddress: UpdateGroupPointerInstructionDataArgs['groupAddress'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateGroupPointerInstruction<\n  TAccountMint extends string,\n  TAccountGroupPointerAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateGroupPointerInput<TAccountMint, TAccountGroupPointerAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): UpdateGroupPointerInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['groupPointerAuthority'] extends TransactionSigner<TAccountGroupPointerAuthority>\n    ? ReadonlySignerAccount<TAccountGroupPointerAuthority> &\n        AccountSignerMeta<TAccountGroupPointerAuthority>\n    : TAccountGroupPointerAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    groupPointerAuthority: {\n      value: input.groupPointerAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.groupPointerAuthority),\n      ...remainingAccounts,\n    ],\n    data: getUpdateGroupPointerInstructionDataEncoder().encode(\n      args as UpdateGroupPointerInstructionDataArgs\n    ),\n    programAddress,\n  } as UpdateGroupPointerInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['groupPointerAuthority'] extends TransactionSigner<TAccountGroupPointerAuthority>\n      ? ReadonlySignerAccount<TAccountGroupPointerAuthority> &\n          AccountSignerMeta<TAccountGroupPointerAuthority>\n      : TAccountGroupPointerAuthority\n  >);\n}\n\nexport type ParsedUpdateGroupPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n    /** The group pointer authority or its multisignature account. */\n    groupPointerAuthority: TAccountMetas[1];\n  };\n  data: UpdateGroupPointerInstructionData;\n};\n\nexport function parseUpdateGroupPointerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpdateGroupPointerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      groupPointerAuthority: getNextAccount(),\n    },\n    data: getUpdateGroupPointerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_METADATA_POINTER_DISCRIMINATOR = 39;\n\nexport function getUpdateMetadataPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_METADATA_POINTER_DISCRIMINATOR);\n}\n\nexport const UPDATE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR = 1;\n\nexport function getUpdateMetadataPointerMetadataPointerDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR\n  );\n}\n\nexport type UpdateMetadataPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountMetadataPointerAuthority extends\n    | string\n    | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountMetadataPointerAuthority extends string\n        ? ReadonlyAccount<TAccountMetadataPointerAuthority>\n        : TAccountMetadataPointerAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateMetadataPointerInstructionData = {\n  discriminator: number;\n  metadataPointerDiscriminator: number;\n  /** The new account address that holds the metadata. */\n  metadataAddress: Option<Address>;\n};\n\nexport type UpdateMetadataPointerInstructionDataArgs = {\n  /** The new account address that holds the metadata. */\n  metadataAddress: OptionOrNullable<Address>;\n};\n\nexport function getUpdateMetadataPointerInstructionDataEncoder(): FixedSizeEncoder<UpdateMetadataPointerInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['metadataPointerDiscriminator', getU8Encoder()],\n      [\n        'metadataAddress',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_METADATA_POINTER_DISCRIMINATOR,\n      metadataPointerDiscriminator:\n        UPDATE_METADATA_POINTER_METADATA_POINTER_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateMetadataPointerInstructionDataDecoder(): FixedSizeDecoder<UpdateMetadataPointerInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['metadataPointerDiscriminator', getU8Decoder()],\n    [\n      'metadataAddress',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateMetadataPointerInstructionDataCodec(): FixedSizeCodec<\n  UpdateMetadataPointerInstructionDataArgs,\n  UpdateMetadataPointerInstructionData\n> {\n  return combineCodec(\n    getUpdateMetadataPointerInstructionDataEncoder(),\n    getUpdateMetadataPointerInstructionDataDecoder()\n  );\n}\n\nexport type UpdateMetadataPointerInput<\n  TAccountMint extends string = string,\n  TAccountMetadataPointerAuthority extends string = string,\n> = {\n  /** The mint to initialize. */\n  mint: Address<TAccountMint>;\n  /** The metadata pointer authority or its multisignature account. */\n  metadataPointerAuthority:\n    | Address<TAccountMetadataPointerAuthority>\n    | TransactionSigner<TAccountMetadataPointerAuthority>;\n  metadataAddress: UpdateMetadataPointerInstructionDataArgs['metadataAddress'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateMetadataPointerInstruction<\n  TAccountMint extends string,\n  TAccountMetadataPointerAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateMetadataPointerInput<\n    TAccountMint,\n    TAccountMetadataPointerAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateMetadataPointerInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['metadataPointerAuthority'] extends TransactionSigner<TAccountMetadataPointerAuthority>\n    ? ReadonlySignerAccount<TAccountMetadataPointerAuthority> &\n        AccountSignerMeta<TAccountMetadataPointerAuthority>\n    : TAccountMetadataPointerAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    metadataPointerAuthority: {\n      value: input.metadataPointerAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.metadataPointerAuthority),\n      ...remainingAccounts,\n    ],\n    data: getUpdateMetadataPointerInstructionDataEncoder().encode(\n      args as UpdateMetadataPointerInstructionDataArgs\n    ),\n    programAddress,\n  } as UpdateMetadataPointerInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['metadataPointerAuthority'] extends TransactionSigner<TAccountMetadataPointerAuthority>\n      ? ReadonlySignerAccount<TAccountMetadataPointerAuthority> &\n          AccountSignerMeta<TAccountMetadataPointerAuthority>\n      : TAccountMetadataPointerAuthority\n  >);\n}\n\nexport type ParsedUpdateMetadataPointerInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint to initialize. */\n    mint: TAccountMetas[0];\n    /** The metadata pointer authority or its multisignature account. */\n    metadataPointerAuthority: TAccountMetas[1];\n  };\n  data: UpdateMetadataPointerInstructionData;\n};\n\nexport function parseUpdateMetadataPointerInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpdateMetadataPointerInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      metadataPointerAuthority: getNextAccount(),\n    },\n    data: getUpdateMetadataPointerInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getF64Decoder,\n  getF64Encoder,\n  getI64Decoder,\n  getI64Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_MULTIPLIER_SCALED_UI_MINT_DISCRIMINATOR = 43;\n\nexport function getUpdateMultiplierScaledUiMintDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_MULTIPLIER_SCALED_UI_MINT_DISCRIMINATOR);\n}\n\nexport const UPDATE_MULTIPLIER_SCALED_UI_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR = 1;\n\nexport function getUpdateMultiplierScaledUiMintScaledUiAmountMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_MULTIPLIER_SCALED_UI_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR\n  );\n}\n\nexport type UpdateMultiplierScaledUiMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? WritableAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateMultiplierScaledUiMintInstructionData = {\n  discriminator: number;\n  scaledUiAmountMintDiscriminator: number;\n  /** The new multiplier for the scaled UI extension */\n  multiplier: number;\n  /** The timestamp at which the new multiplier will take effect */\n  effectiveTimestamp: bigint;\n};\n\nexport type UpdateMultiplierScaledUiMintInstructionDataArgs = {\n  /** The new multiplier for the scaled UI extension */\n  multiplier: number;\n  /** The timestamp at which the new multiplier will take effect */\n  effectiveTimestamp: number | bigint;\n};\n\nexport function getUpdateMultiplierScaledUiMintInstructionDataEncoder(): FixedSizeEncoder<UpdateMultiplierScaledUiMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['scaledUiAmountMintDiscriminator', getU8Encoder()],\n      ['multiplier', getF64Encoder()],\n      ['effectiveTimestamp', getI64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_MULTIPLIER_SCALED_UI_MINT_DISCRIMINATOR,\n      scaledUiAmountMintDiscriminator:\n        UPDATE_MULTIPLIER_SCALED_UI_MINT_SCALED_UI_AMOUNT_MINT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateMultiplierScaledUiMintInstructionDataDecoder(): FixedSizeDecoder<UpdateMultiplierScaledUiMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['scaledUiAmountMintDiscriminator', getU8Decoder()],\n    ['multiplier', getF64Decoder()],\n    ['effectiveTimestamp', getI64Decoder()],\n  ]);\n}\n\nexport function getUpdateMultiplierScaledUiMintInstructionDataCodec(): FixedSizeCodec<\n  UpdateMultiplierScaledUiMintInstructionDataArgs,\n  UpdateMultiplierScaledUiMintInstructionData\n> {\n  return combineCodec(\n    getUpdateMultiplierScaledUiMintInstructionDataEncoder(),\n    getUpdateMultiplierScaledUiMintInstructionDataDecoder()\n  );\n}\n\nexport type UpdateMultiplierScaledUiMintInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The multiplier authority. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiplier: UpdateMultiplierScaledUiMintInstructionDataArgs['multiplier'];\n  effectiveTimestamp: UpdateMultiplierScaledUiMintInstructionDataArgs['effectiveTimestamp'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateMultiplierScaledUiMintInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateMultiplierScaledUiMintInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): UpdateMultiplierScaledUiMintInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? WritableSignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getUpdateMultiplierScaledUiMintInstructionDataEncoder().encode(\n      args as UpdateMultiplierScaledUiMintInstructionDataArgs\n    ),\n    programAddress,\n  } as UpdateMultiplierScaledUiMintInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? WritableSignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedUpdateMultiplierScaledUiMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The multiplier authority. */\n    authority: TAccountMetas[1];\n  };\n  data: UpdateMultiplierScaledUiMintInstructionData;\n};\n\nexport function parseUpdateMultiplierScaledUiMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpdateMultiplierScaledUiMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), authority: getNextAccount() },\n    data: getUpdateMultiplierScaledUiMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI16Decoder,\n  getI16Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n  type WritableSignerAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_RATE_INTEREST_BEARING_MINT_DISCRIMINATOR = 33;\n\nexport function getUpdateRateInterestBearingMintDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_RATE_INTEREST_BEARING_MINT_DISCRIMINATOR);\n}\n\nexport const UPDATE_RATE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR = 1;\n\nexport function getUpdateRateInterestBearingMintInterestBearingMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_RATE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR\n  );\n}\n\nexport type UpdateRateInterestBearingMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountRateAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountRateAuthority extends string\n        ? WritableAccount<TAccountRateAuthority>\n        : TAccountRateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateRateInterestBearingMintInstructionData = {\n  discriminator: number;\n  interestBearingMintDiscriminator: number;\n  /** The interest rate to update. */\n  rate: number;\n};\n\nexport type UpdateRateInterestBearingMintInstructionDataArgs = {\n  /** The interest rate to update. */\n  rate: number;\n};\n\nexport function getUpdateRateInterestBearingMintInstructionDataEncoder(): FixedSizeEncoder<UpdateRateInterestBearingMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['interestBearingMintDiscriminator', getU8Encoder()],\n      ['rate', getI16Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_RATE_INTEREST_BEARING_MINT_DISCRIMINATOR,\n      interestBearingMintDiscriminator:\n        UPDATE_RATE_INTEREST_BEARING_MINT_INTEREST_BEARING_MINT_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateRateInterestBearingMintInstructionDataDecoder(): FixedSizeDecoder<UpdateRateInterestBearingMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['interestBearingMintDiscriminator', getU8Decoder()],\n    ['rate', getI16Decoder()],\n  ]);\n}\n\nexport function getUpdateRateInterestBearingMintInstructionDataCodec(): FixedSizeCodec<\n  UpdateRateInterestBearingMintInstructionDataArgs,\n  UpdateRateInterestBearingMintInstructionData\n> {\n  return combineCodec(\n    getUpdateRateInterestBearingMintInstructionDataEncoder(),\n    getUpdateRateInterestBearingMintInstructionDataDecoder()\n  );\n}\n\nexport type UpdateRateInterestBearingMintInput<\n  TAccountMint extends string = string,\n  TAccountRateAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The mint rate authority. */\n  rateAuthority:\n    | Address<TAccountRateAuthority>\n    | TransactionSigner<TAccountRateAuthority>;\n  rate: UpdateRateInterestBearingMintInstructionDataArgs['rate'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateRateInterestBearingMintInstruction<\n  TAccountMint extends string,\n  TAccountRateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateRateInterestBearingMintInput<\n    TAccountMint,\n    TAccountRateAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateRateInterestBearingMintInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['rateAuthority'] extends TransactionSigner<TAccountRateAuthority>\n    ? WritableSignerAccount<TAccountRateAuthority> &\n        AccountSignerMeta<TAccountRateAuthority>\n    : TAccountRateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    rateAuthority: { value: input.rateAuthority ?? null, isWritable: true },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.rateAuthority),\n      ...remainingAccounts,\n    ],\n    data: getUpdateRateInterestBearingMintInstructionDataEncoder().encode(\n      args as UpdateRateInterestBearingMintInstructionDataArgs\n    ),\n    programAddress,\n  } as UpdateRateInterestBearingMintInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['rateAuthority'] extends TransactionSigner<TAccountRateAuthority>\n      ? WritableSignerAccount<TAccountRateAuthority> &\n          AccountSignerMeta<TAccountRateAuthority>\n      : TAccountRateAuthority\n  >);\n}\n\nexport type ParsedUpdateRateInterestBearingMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The mint rate authority. */\n    rateAuthority: TAccountMetas[1];\n  };\n  data: UpdateRateInterestBearingMintInstructionData;\n};\n\nexport function parseUpdateRateInterestBearingMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpdateRateInterestBearingMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), rateAuthority: getNextAccount() },\n    data: getUpdateRateInterestBearingMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU64Decoder,\n  getU64Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_TOKEN_GROUP_MAX_SIZE_DISCRIMINATOR = new Uint8Array([\n  108, 37, 171, 143, 248, 30, 18, 110,\n]);\n\nexport function getUpdateTokenGroupMaxSizeDiscriminatorBytes() {\n  return getBytesEncoder().encode(UPDATE_TOKEN_GROUP_MAX_SIZE_DISCRIMINATOR);\n}\n\nexport type UpdateTokenGroupMaxSizeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountGroup extends string | AccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountGroup extends string\n        ? WritableAccount<TAccountGroup>\n        : TAccountGroup,\n      TAccountUpdateAuthority extends string\n        ? ReadonlySignerAccount<TAccountUpdateAuthority> &\n            AccountSignerMeta<TAccountUpdateAuthority>\n        : TAccountUpdateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateTokenGroupMaxSizeInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** New max size for the group */\n  maxSize: bigint;\n};\n\nexport type UpdateTokenGroupMaxSizeInstructionDataArgs = {\n  /** New max size for the group */\n  maxSize: number | bigint;\n};\n\nexport function getUpdateTokenGroupMaxSizeInstructionDataEncoder(): Encoder<UpdateTokenGroupMaxSizeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      ['maxSize', getU64Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TOKEN_GROUP_MAX_SIZE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateTokenGroupMaxSizeInstructionDataDecoder(): Decoder<UpdateTokenGroupMaxSizeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    ['maxSize', getU64Decoder()],\n  ]);\n}\n\nexport function getUpdateTokenGroupMaxSizeInstructionDataCodec(): Codec<\n  UpdateTokenGroupMaxSizeInstructionDataArgs,\n  UpdateTokenGroupMaxSizeInstructionData\n> {\n  return combineCodec(\n    getUpdateTokenGroupMaxSizeInstructionDataEncoder(),\n    getUpdateTokenGroupMaxSizeInstructionDataDecoder()\n  );\n}\n\nexport type UpdateTokenGroupMaxSizeInput<\n  TAccountGroup extends string = string,\n  TAccountUpdateAuthority extends string = string,\n> = {\n  group: Address<TAccountGroup>;\n  updateAuthority: TransactionSigner<TAccountUpdateAuthority>;\n  maxSize: UpdateTokenGroupMaxSizeInstructionDataArgs['maxSize'];\n};\n\nexport function getUpdateTokenGroupMaxSizeInstruction<\n  TAccountGroup extends string,\n  TAccountUpdateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateTokenGroupMaxSizeInput<TAccountGroup, TAccountUpdateAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): UpdateTokenGroupMaxSizeInstruction<\n  TProgramAddress,\n  TAccountGroup,\n  TAccountUpdateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    group: { value: input.group ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.group),\n      getAccountMeta(accounts.updateAuthority),\n    ],\n    data: getUpdateTokenGroupMaxSizeInstructionDataEncoder().encode(\n      args as UpdateTokenGroupMaxSizeInstructionDataArgs\n    ),\n    programAddress,\n  } as UpdateTokenGroupMaxSizeInstruction<\n    TProgramAddress,\n    TAccountGroup,\n    TAccountUpdateAuthority\n  >);\n}\n\nexport type ParsedUpdateTokenGroupMaxSizeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    group: TAccountMetas[0];\n    updateAuthority: TAccountMetas[1];\n  };\n  data: UpdateTokenGroupMaxSizeInstructionData;\n};\n\nexport function parseUpdateTokenGroupMaxSizeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpdateTokenGroupMaxSizeInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { group: getNextAccount(), updateAuthority: getNextAccount() },\n    data: getUpdateTokenGroupMaxSizeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_TOKEN_GROUP_UPDATE_AUTHORITY_DISCRIMINATOR = new Uint8Array(\n  [161, 105, 88, 1, 237, 221, 216, 203]\n);\n\nexport function getUpdateTokenGroupUpdateAuthorityDiscriminatorBytes() {\n  return getBytesEncoder().encode(\n    UPDATE_TOKEN_GROUP_UPDATE_AUTHORITY_DISCRIMINATOR\n  );\n}\n\nexport type UpdateTokenGroupUpdateAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountGroup extends string | AccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountGroup extends string\n        ? WritableAccount<TAccountGroup>\n        : TAccountGroup,\n      TAccountUpdateAuthority extends string\n        ? ReadonlySignerAccount<TAccountUpdateAuthority> &\n            AccountSignerMeta<TAccountUpdateAuthority>\n        : TAccountUpdateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateTokenGroupUpdateAuthorityInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** New authority for the group, or unset if `None` */\n  newUpdateAuthority: Option<Address>;\n};\n\nexport type UpdateTokenGroupUpdateAuthorityInstructionDataArgs = {\n  /** New authority for the group, or unset if `None` */\n  newUpdateAuthority: OptionOrNullable<Address>;\n};\n\nexport function getUpdateTokenGroupUpdateAuthorityInstructionDataEncoder(): Encoder<UpdateTokenGroupUpdateAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      [\n        'newUpdateAuthority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TOKEN_GROUP_UPDATE_AUTHORITY_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateTokenGroupUpdateAuthorityInstructionDataDecoder(): Decoder<UpdateTokenGroupUpdateAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    [\n      'newUpdateAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateTokenGroupUpdateAuthorityInstructionDataCodec(): Codec<\n  UpdateTokenGroupUpdateAuthorityInstructionDataArgs,\n  UpdateTokenGroupUpdateAuthorityInstructionData\n> {\n  return combineCodec(\n    getUpdateTokenGroupUpdateAuthorityInstructionDataEncoder(),\n    getUpdateTokenGroupUpdateAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type UpdateTokenGroupUpdateAuthorityInput<\n  TAccountGroup extends string = string,\n  TAccountUpdateAuthority extends string = string,\n> = {\n  group: Address<TAccountGroup>;\n  /** Current update authority */\n  updateAuthority: TransactionSigner<TAccountUpdateAuthority>;\n  newUpdateAuthority: UpdateTokenGroupUpdateAuthorityInstructionDataArgs['newUpdateAuthority'];\n};\n\nexport function getUpdateTokenGroupUpdateAuthorityInstruction<\n  TAccountGroup extends string,\n  TAccountUpdateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateTokenGroupUpdateAuthorityInput<\n    TAccountGroup,\n    TAccountUpdateAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateTokenGroupUpdateAuthorityInstruction<\n  TProgramAddress,\n  TAccountGroup,\n  TAccountUpdateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    group: { value: input.group ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.group),\n      getAccountMeta(accounts.updateAuthority),\n    ],\n    data: getUpdateTokenGroupUpdateAuthorityInstructionDataEncoder().encode(\n      args as UpdateTokenGroupUpdateAuthorityInstructionDataArgs\n    ),\n    programAddress,\n  } as UpdateTokenGroupUpdateAuthorityInstruction<\n    TProgramAddress,\n    TAccountGroup,\n    TAccountUpdateAuthority\n  >);\n}\n\nexport type ParsedUpdateTokenGroupUpdateAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    group: TAccountMetas[0];\n    /** Current update authority */\n    updateAuthority: TAccountMetas[1];\n  };\n  data: UpdateTokenGroupUpdateAuthorityInstructionData;\n};\n\nexport function parseUpdateTokenGroupUpdateAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpdateTokenGroupUpdateAuthorityInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { group: getNextAccount(), updateAuthority: getNextAccount() },\n    data: getUpdateTokenGroupUpdateAuthorityInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  addDecoderSizePrefix,\n  addEncoderSizePrefix,\n  combineCodec,\n  getBytesDecoder,\n  getBytesEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU32Decoder,\n  getU32Encoder,\n  getUtf8Decoder,\n  getUtf8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getTokenMetadataFieldDecoder,\n  getTokenMetadataFieldEncoder,\n  type TokenMetadataField,\n  type TokenMetadataFieldArgs,\n} from '../types';\n\nexport const UPDATE_TOKEN_METADATA_FIELD_DISCRIMINATOR = new Uint8Array([\n  221, 233, 49, 45, 181, 202, 220, 200,\n]);\n\nexport function getUpdateTokenMetadataFieldDiscriminatorBytes() {\n  return getBytesEncoder().encode(UPDATE_TOKEN_METADATA_FIELD_DISCRIMINATOR);\n}\n\nexport type UpdateTokenMetadataFieldInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetadata extends string | AccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMetadata extends string\n        ? WritableAccount<TAccountMetadata>\n        : TAccountMetadata,\n      TAccountUpdateAuthority extends string\n        ? ReadonlySignerAccount<TAccountUpdateAuthority> &\n            AccountSignerMeta<TAccountUpdateAuthority>\n        : TAccountUpdateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateTokenMetadataFieldInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** Field to update in the metadata. */\n  field: TokenMetadataField;\n  /** Value to write for the field. */\n  value: string;\n};\n\nexport type UpdateTokenMetadataFieldInstructionDataArgs = {\n  /** Field to update in the metadata. */\n  field: TokenMetadataFieldArgs;\n  /** Value to write for the field. */\n  value: string;\n};\n\nexport function getUpdateTokenMetadataFieldInstructionDataEncoder(): Encoder<UpdateTokenMetadataFieldInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      ['field', getTokenMetadataFieldEncoder()],\n      ['value', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TOKEN_METADATA_FIELD_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateTokenMetadataFieldInstructionDataDecoder(): Decoder<UpdateTokenMetadataFieldInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    ['field', getTokenMetadataFieldDecoder()],\n    ['value', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n  ]);\n}\n\nexport function getUpdateTokenMetadataFieldInstructionDataCodec(): Codec<\n  UpdateTokenMetadataFieldInstructionDataArgs,\n  UpdateTokenMetadataFieldInstructionData\n> {\n  return combineCodec(\n    getUpdateTokenMetadataFieldInstructionDataEncoder(),\n    getUpdateTokenMetadataFieldInstructionDataDecoder()\n  );\n}\n\nexport type UpdateTokenMetadataFieldInput<\n  TAccountMetadata extends string = string,\n  TAccountUpdateAuthority extends string = string,\n> = {\n  metadata: Address<TAccountMetadata>;\n  updateAuthority: TransactionSigner<TAccountUpdateAuthority>;\n  field: UpdateTokenMetadataFieldInstructionDataArgs['field'];\n  value: UpdateTokenMetadataFieldInstructionDataArgs['value'];\n};\n\nexport function getUpdateTokenMetadataFieldInstruction<\n  TAccountMetadata extends string,\n  TAccountUpdateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateTokenMetadataFieldInput<\n    TAccountMetadata,\n    TAccountUpdateAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateTokenMetadataFieldInstruction<\n  TProgramAddress,\n  TAccountMetadata,\n  TAccountUpdateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.metadata),\n      getAccountMeta(accounts.updateAuthority),\n    ],\n    data: getUpdateTokenMetadataFieldInstructionDataEncoder().encode(\n      args as UpdateTokenMetadataFieldInstructionDataArgs\n    ),\n    programAddress,\n  } as UpdateTokenMetadataFieldInstruction<\n    TProgramAddress,\n    TAccountMetadata,\n    TAccountUpdateAuthority\n  >);\n}\n\nexport type ParsedUpdateTokenMetadataFieldInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    metadata: TAccountMetas[0];\n    updateAuthority: TAccountMetas[1];\n  };\n  data: UpdateTokenMetadataFieldInstructionData;\n};\n\nexport function parseUpdateTokenMetadataFieldInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpdateTokenMetadataFieldInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { metadata: getNextAccount(), updateAuthority: getNextAccount() },\n    data: getUpdateTokenMetadataFieldInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getBytesDecoder,\n  getBytesEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type Codec,\n  type Decoder,\n  type Encoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_TOKEN_METADATA_UPDATE_AUTHORITY_DISCRIMINATOR =\n  new Uint8Array([215, 228, 166, 228, 84, 100, 86, 123]);\n\nexport function getUpdateTokenMetadataUpdateAuthorityDiscriminatorBytes() {\n  return getBytesEncoder().encode(\n    UPDATE_TOKEN_METADATA_UPDATE_AUTHORITY_DISCRIMINATOR\n  );\n}\n\nexport type UpdateTokenMetadataUpdateAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetadata extends string | AccountMeta<string> = string,\n  TAccountUpdateAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMetadata extends string\n        ? WritableAccount<TAccountMetadata>\n        : TAccountMetadata,\n      TAccountUpdateAuthority extends string\n        ? ReadonlySignerAccount<TAccountUpdateAuthority> &\n            AccountSignerMeta<TAccountUpdateAuthority>\n        : TAccountUpdateAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateTokenMetadataUpdateAuthorityInstructionData = {\n  discriminator: ReadonlyUint8Array;\n  /** New authority for the token metadata, or unset if `None` */\n  newUpdateAuthority: Option<Address>;\n};\n\nexport type UpdateTokenMetadataUpdateAuthorityInstructionDataArgs = {\n  /** New authority for the token metadata, or unset if `None` */\n  newUpdateAuthority: OptionOrNullable<Address>;\n};\n\nexport function getUpdateTokenMetadataUpdateAuthorityInstructionDataEncoder(): Encoder<UpdateTokenMetadataUpdateAuthorityInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getBytesEncoder()],\n      [\n        'newUpdateAuthority',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TOKEN_METADATA_UPDATE_AUTHORITY_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateTokenMetadataUpdateAuthorityInstructionDataDecoder(): Decoder<UpdateTokenMetadataUpdateAuthorityInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getBytesDecoder()],\n    [\n      'newUpdateAuthority',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateTokenMetadataUpdateAuthorityInstructionDataCodec(): Codec<\n  UpdateTokenMetadataUpdateAuthorityInstructionDataArgs,\n  UpdateTokenMetadataUpdateAuthorityInstructionData\n> {\n  return combineCodec(\n    getUpdateTokenMetadataUpdateAuthorityInstructionDataEncoder(),\n    getUpdateTokenMetadataUpdateAuthorityInstructionDataDecoder()\n  );\n}\n\nexport type UpdateTokenMetadataUpdateAuthorityInput<\n  TAccountMetadata extends string = string,\n  TAccountUpdateAuthority extends string = string,\n> = {\n  metadata: Address<TAccountMetadata>;\n  updateAuthority: TransactionSigner<TAccountUpdateAuthority>;\n  newUpdateAuthority: UpdateTokenMetadataUpdateAuthorityInstructionDataArgs['newUpdateAuthority'];\n};\n\nexport function getUpdateTokenMetadataUpdateAuthorityInstruction<\n  TAccountMetadata extends string,\n  TAccountUpdateAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateTokenMetadataUpdateAuthorityInput<\n    TAccountMetadata,\n    TAccountUpdateAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): UpdateTokenMetadataUpdateAuthorityInstruction<\n  TProgramAddress,\n  TAccountMetadata,\n  TAccountUpdateAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    metadata: { value: input.metadata ?? null, isWritable: true },\n    updateAuthority: {\n      value: input.updateAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.metadata),\n      getAccountMeta(accounts.updateAuthority),\n    ],\n    data: getUpdateTokenMetadataUpdateAuthorityInstructionDataEncoder().encode(\n      args as UpdateTokenMetadataUpdateAuthorityInstructionDataArgs\n    ),\n    programAddress,\n  } as UpdateTokenMetadataUpdateAuthorityInstruction<\n    TProgramAddress,\n    TAccountMetadata,\n    TAccountUpdateAuthority\n  >);\n}\n\nexport type ParsedUpdateTokenMetadataUpdateAuthorityInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    metadata: TAccountMetas[0];\n    updateAuthority: TAccountMetas[1];\n  };\n  data: UpdateTokenMetadataUpdateAuthorityInstructionData;\n};\n\nexport function parseUpdateTokenMetadataUpdateAuthorityInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpdateTokenMetadataUpdateAuthorityInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { metadata: getNextAccount(), updateAuthority: getNextAccount() },\n    data: getUpdateTokenMetadataUpdateAuthorityInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getAddressDecoder,\n  getAddressEncoder,\n  getOptionDecoder,\n  getOptionEncoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type Option,\n  type OptionOrNullable,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const UPDATE_TRANSFER_HOOK_DISCRIMINATOR = 36;\n\nexport function getUpdateTransferHookDiscriminatorBytes() {\n  return getU8Encoder().encode(UPDATE_TRANSFER_HOOK_DISCRIMINATOR);\n}\n\nexport const UPDATE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR = 1;\n\nexport function getUpdateTransferHookTransferHookDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    UPDATE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR\n  );\n}\n\nexport type UpdateTransferHookInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type UpdateTransferHookInstructionData = {\n  discriminator: number;\n  transferHookDiscriminator: number;\n  /** The program id that performs logic during transfers */\n  programId: Option<Address>;\n};\n\nexport type UpdateTransferHookInstructionDataArgs = {\n  /** The program id that performs logic during transfers */\n  programId: OptionOrNullable<Address>;\n};\n\nexport function getUpdateTransferHookInstructionDataEncoder(): FixedSizeEncoder<UpdateTransferHookInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferHookDiscriminator', getU8Encoder()],\n      [\n        'programId',\n        getOptionEncoder(getAddressEncoder(), {\n          prefix: null,\n          noneValue: 'zeroes',\n        }),\n      ],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: UPDATE_TRANSFER_HOOK_DISCRIMINATOR,\n      transferHookDiscriminator:\n        UPDATE_TRANSFER_HOOK_TRANSFER_HOOK_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getUpdateTransferHookInstructionDataDecoder(): FixedSizeDecoder<UpdateTransferHookInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferHookDiscriminator', getU8Decoder()],\n    [\n      'programId',\n      getOptionDecoder(getAddressDecoder(), {\n        prefix: null,\n        noneValue: 'zeroes',\n      }),\n    ],\n  ]);\n}\n\nexport function getUpdateTransferHookInstructionDataCodec(): FixedSizeCodec<\n  UpdateTransferHookInstructionDataArgs,\n  UpdateTransferHookInstructionData\n> {\n  return combineCodec(\n    getUpdateTransferHookInstructionDataEncoder(),\n    getUpdateTransferHookInstructionDataDecoder()\n  );\n}\n\nexport type UpdateTransferHookInput<\n  TAccountMint extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The mint. */\n  mint: Address<TAccountMint>;\n  /** The transfer hook authority. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  programId: UpdateTransferHookInstructionDataArgs['programId'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getUpdateTransferHookInstruction<\n  TAccountMint extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: UpdateTransferHookInput<TAccountMint, TAccountAuthority>,\n  config?: { programAddress?: TProgramAddress }\n): UpdateTransferHookInstruction<\n  TProgramAddress,\n  TAccountMint,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getUpdateTransferHookInstructionDataEncoder().encode(\n      args as UpdateTransferHookInstructionDataArgs\n    ),\n    programAddress,\n  } as UpdateTransferHookInstruction<\n    TProgramAddress,\n    TAccountMint,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedUpdateTransferHookInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The mint. */\n    mint: TAccountMetas[0];\n    /** The transfer hook authority. */\n    authority: TAccountMetas[1];\n  };\n  data: UpdateTransferHookInstructionData;\n};\n\nexport function parseUpdateTransferHookInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedUpdateTransferHookInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 2) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: { mint: getNextAccount(), authority: getNextAccount() },\n    data: getUpdateTransferHookInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const WITHDRAW_EXCESS_LAMPORTS_DISCRIMINATOR = 38;\n\nexport function getWithdrawExcessLamportsDiscriminatorBytes() {\n  return getU8Encoder().encode(WITHDRAW_EXCESS_LAMPORTS_DISCRIMINATOR);\n}\n\nexport type WithdrawExcessLamportsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountSourceAccount extends string | AccountMeta<string> = string,\n  TAccountDestinationAccount extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountSourceAccount extends string\n        ? WritableAccount<TAccountSourceAccount>\n        : TAccountSourceAccount,\n      TAccountDestinationAccount extends string\n        ? WritableAccount<TAccountDestinationAccount>\n        : TAccountDestinationAccount,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawExcessLamportsInstructionData = { discriminator: number };\n\nexport type WithdrawExcessLamportsInstructionDataArgs = {};\n\nexport function getWithdrawExcessLamportsInstructionDataEncoder(): FixedSizeEncoder<WithdrawExcessLamportsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([['discriminator', getU8Encoder()]]),\n    (value) => ({\n      ...value,\n      discriminator: WITHDRAW_EXCESS_LAMPORTS_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWithdrawExcessLamportsInstructionDataDecoder(): FixedSizeDecoder<WithdrawExcessLamportsInstructionData> {\n  return getStructDecoder([['discriminator', getU8Decoder()]]);\n}\n\nexport function getWithdrawExcessLamportsInstructionDataCodec(): FixedSizeCodec<\n  WithdrawExcessLamportsInstructionDataArgs,\n  WithdrawExcessLamportsInstructionData\n> {\n  return combineCodec(\n    getWithdrawExcessLamportsInstructionDataEncoder(),\n    getWithdrawExcessLamportsInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawExcessLamportsInput<\n  TAccountSourceAccount extends string = string,\n  TAccountDestinationAccount extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** Account holding excess lamports. */\n  sourceAccount: Address<TAccountSourceAccount>;\n  /** Destination account for withdrawn lamports. */\n  destinationAccount: Address<TAccountDestinationAccount>;\n  /** The source account's owner/delegate or its multisignature account. */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getWithdrawExcessLamportsInstruction<\n  TAccountSourceAccount extends string,\n  TAccountDestinationAccount extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: WithdrawExcessLamportsInput<\n    TAccountSourceAccount,\n    TAccountDestinationAccount,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawExcessLamportsInstruction<\n  TProgramAddress,\n  TAccountSourceAccount,\n  TAccountDestinationAccount,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    sourceAccount: { value: input.sourceAccount ?? null, isWritable: true },\n    destinationAccount: {\n      value: input.destinationAccount ?? null,\n      isWritable: true,\n    },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.sourceAccount),\n      getAccountMeta(accounts.destinationAccount),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getWithdrawExcessLamportsInstructionDataEncoder().encode({}),\n    programAddress,\n  } as WithdrawExcessLamportsInstruction<\n    TProgramAddress,\n    TAccountSourceAccount,\n    TAccountDestinationAccount,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedWithdrawExcessLamportsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** Account holding excess lamports. */\n    sourceAccount: TAccountMetas[0];\n    /** Destination account for withdrawn lamports. */\n    destinationAccount: TAccountMetas[1];\n    /** The source account's owner/delegate or its multisignature account. */\n    authority: TAccountMetas[2];\n  };\n  data: WithdrawExcessLamportsInstructionData;\n};\n\nexport function parseWithdrawExcessLamportsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedWithdrawExcessLamportsInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      sourceAccount: getNextAccount(),\n      destinationAccount: getNextAccount(),\n      authority: getNextAccount(),\n    },\n    data: getWithdrawExcessLamportsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_DISCRIMINATOR = 26;\n\nexport function getWithdrawWithheldTokensFromAccountsDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_DISCRIMINATOR\n  );\n}\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_TRANSFER_FEE_DISCRIMINATOR = 3;\n\nexport function getWithdrawWithheldTokensFromAccountsTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type WithdrawWithheldTokensFromAccountsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountFeeReceiver extends string | AccountMeta<string> = string,\n  TAccountWithdrawWithheldAuthority extends\n    | string\n    | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountFeeReceiver extends string\n        ? WritableAccount<TAccountFeeReceiver>\n        : TAccountFeeReceiver,\n      TAccountWithdrawWithheldAuthority extends string\n        ? ReadonlyAccount<TAccountWithdrawWithheldAuthority>\n        : TAccountWithdrawWithheldAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawWithheldTokensFromAccountsInstructionData = {\n  discriminator: number;\n  transferFeeDiscriminator: number;\n  /** Number of token accounts harvested. */\n  numTokenAccounts: number;\n};\n\nexport type WithdrawWithheldTokensFromAccountsInstructionDataArgs = {\n  /** Number of token accounts harvested. */\n  numTokenAccounts: number;\n};\n\nexport function getWithdrawWithheldTokensFromAccountsInstructionDataEncoder(): FixedSizeEncoder<WithdrawWithheldTokensFromAccountsInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferFeeDiscriminator', getU8Encoder()],\n      ['numTokenAccounts', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_DISCRIMINATOR,\n      transferFeeDiscriminator:\n        WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWithdrawWithheldTokensFromAccountsInstructionDataDecoder(): FixedSizeDecoder<WithdrawWithheldTokensFromAccountsInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferFeeDiscriminator', getU8Decoder()],\n    ['numTokenAccounts', getU8Decoder()],\n  ]);\n}\n\nexport function getWithdrawWithheldTokensFromAccountsInstructionDataCodec(): FixedSizeCodec<\n  WithdrawWithheldTokensFromAccountsInstructionDataArgs,\n  WithdrawWithheldTokensFromAccountsInstructionData\n> {\n  return combineCodec(\n    getWithdrawWithheldTokensFromAccountsInstructionDataEncoder(),\n    getWithdrawWithheldTokensFromAccountsInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawWithheldTokensFromAccountsInput<\n  TAccountMint extends string = string,\n  TAccountFeeReceiver extends string = string,\n  TAccountWithdrawWithheldAuthority extends string = string,\n> = {\n  /** The token mint. Must include the `TransferFeeConfig` extension. */\n  mint: Address<TAccountMint>;\n  /**\n   * The fee receiver account. Must include the `TransferFeeAmount`\n   * extension associated with the provided mint.\n   */\n  feeReceiver: Address<TAccountFeeReceiver>;\n  /** The mint's `withdraw_withheld_authority` or its multisignature account. */\n  withdrawWithheldAuthority:\n    | Address<TAccountWithdrawWithheldAuthority>\n    | TransactionSigner<TAccountWithdrawWithheldAuthority>;\n  numTokenAccounts: WithdrawWithheldTokensFromAccountsInstructionDataArgs['numTokenAccounts'];\n  multiSigners?: Array<TransactionSigner>;\n  sources: Array<Address>;\n};\n\nexport function getWithdrawWithheldTokensFromAccountsInstruction<\n  TAccountMint extends string,\n  TAccountFeeReceiver extends string,\n  TAccountWithdrawWithheldAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: WithdrawWithheldTokensFromAccountsInput<\n    TAccountMint,\n    TAccountFeeReceiver,\n    TAccountWithdrawWithheldAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawWithheldTokensFromAccountsInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountFeeReceiver,\n  (typeof input)['withdrawWithheldAuthority'] extends TransactionSigner<TAccountWithdrawWithheldAuthority>\n    ? ReadonlySignerAccount<TAccountWithdrawWithheldAuthority> &\n        AccountSignerMeta<TAccountWithdrawWithheldAuthority>\n    : TAccountWithdrawWithheldAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n    feeReceiver: { value: input.feeReceiver ?? null, isWritable: true },\n    withdrawWithheldAuthority: {\n      value: input.withdrawWithheldAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = [\n    ...(args.multiSigners ?? []).map((signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })),\n    ...args.sources.map((address) => ({ address, role: AccountRole.WRITABLE })),\n  ];\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.feeReceiver),\n      getAccountMeta(accounts.withdrawWithheldAuthority),\n      ...remainingAccounts,\n    ],\n    data: getWithdrawWithheldTokensFromAccountsInstructionDataEncoder().encode(\n      args as WithdrawWithheldTokensFromAccountsInstructionDataArgs\n    ),\n    programAddress,\n  } as WithdrawWithheldTokensFromAccountsInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountFeeReceiver,\n    (typeof input)['withdrawWithheldAuthority'] extends TransactionSigner<TAccountWithdrawWithheldAuthority>\n      ? ReadonlySignerAccount<TAccountWithdrawWithheldAuthority> &\n          AccountSignerMeta<TAccountWithdrawWithheldAuthority>\n      : TAccountWithdrawWithheldAuthority\n  >);\n}\n\nexport type ParsedWithdrawWithheldTokensFromAccountsInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. Must include the `TransferFeeConfig` extension. */\n    mint: TAccountMetas[0];\n    /**\n     * The fee receiver account. Must include the `TransferFeeAmount`\n     * extension associated with the provided mint.\n     */\n    feeReceiver: TAccountMetas[1];\n    /** The mint's `withdraw_withheld_authority` or its multisignature account. */\n    withdrawWithheldAuthority: TAccountMetas[2];\n  };\n  data: WithdrawWithheldTokensFromAccountsInstructionData;\n};\n\nexport function parseWithdrawWithheldTokensFromAccountsInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedWithdrawWithheldTokensFromAccountsInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      feeReceiver: getNextAccount(),\n      withdrawWithheldAuthority: getNextAccount(),\n    },\n    data: getWithdrawWithheldTokensFromAccountsInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 37;\n\nexport function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 2;\n\nexport function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountDestination extends string | AccountMeta<string> = string,\n  TAccountInstructionsSysvarOrContextState extends\n    | string\n    | AccountMeta<string> = string,\n  TAccountRecord extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? ReadonlyAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountInstructionsSysvarOrContextState extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvarOrContextState>\n        : TAccountInstructionsSysvarOrContextState,\n      TAccountRecord extends string\n        ? ReadonlyAccount<TAccountRecord>\n        : TAccountRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionData =\n  {\n    discriminator: number;\n    confidentialTransferFeeDiscriminator: number;\n    /** Number of token accounts harvested */\n    numTokenAccounts: number;\n    /** Proof instruction offset */\n    proofInstructionOffset: number;\n    /** The new decryptable balance in the destination token account */\n    newDecryptableAvailableBalance: DecryptableBalance;\n  };\n\nexport type WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs =\n  {\n    /** Number of token accounts harvested */\n    numTokenAccounts: number;\n    /** Proof instruction offset */\n    proofInstructionOffset: number;\n    /** The new decryptable balance in the destination token account */\n    newDecryptableAvailableBalance: DecryptableBalanceArgs;\n  };\n\nexport function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataEncoder(): FixedSizeEncoder<WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferFeeDiscriminator', getU8Encoder()],\n      ['numTokenAccounts', getU8Encoder()],\n      ['proofInstructionOffset', getI8Encoder()],\n      ['newDecryptableAvailableBalance', getDecryptableBalanceEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator:\n        WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator:\n        WITHDRAW_WITHHELD_TOKENS_FROM_ACCOUNTS_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataDecoder(): FixedSizeDecoder<WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferFeeDiscriminator', getU8Decoder()],\n    ['numTokenAccounts', getU8Decoder()],\n    ['proofInstructionOffset', getI8Decoder()],\n    ['newDecryptableAvailableBalance', getDecryptableBalanceDecoder()],\n  ]);\n}\n\nexport function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataCodec(): FixedSizeCodec<\n  WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs,\n  WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionData\n> {\n  return combineCodec(\n    getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataEncoder(),\n    getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInput<\n  TAccountMint extends string = string,\n  TAccountDestination extends string = string,\n  TAccountInstructionsSysvarOrContextState extends string = string,\n  TAccountRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The fee receiver account. */\n  destination: Address<TAccountDestination>;\n  /** Instructions sysvar or context state account */\n  instructionsSysvarOrContextState: Address<TAccountInstructionsSysvarOrContextState>;\n  /** Optional record account */\n  record?: Address<TAccountRecord>;\n  /** The mint's withdraw_withheld_authority */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  numTokenAccounts: WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs['numTokenAccounts'];\n  proofInstructionOffset: WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs['proofInstructionOffset'];\n  newDecryptableAvailableBalance: WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs['newDecryptableAvailableBalance'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n  TAccountMint extends string,\n  TAccountDestination extends string,\n  TAccountInstructionsSysvarOrContextState extends string,\n  TAccountRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInput<\n    TAccountMint,\n    TAccountDestination,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountDestination,\n  TAccountInstructionsSysvarOrContextState,\n  TAccountRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: false },\n    destination: { value: input.destination ?? null, isWritable: true },\n    instructionsSysvarOrContextState: {\n      value: input.instructionsSysvarOrContextState ?? null,\n      isWritable: false,\n    },\n    record: { value: input.record ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.instructionsSysvarOrContextState),\n      getAccountMeta(accounts.record),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataEncoder().encode(\n      args as WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataArgs\n    ),\n    programAddress,\n  } as WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountDestination,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. */\n    mint: TAccountMetas[0];\n    /** The fee receiver account. */\n    destination: TAccountMetas[1];\n    /** Instructions sysvar or context state account */\n    instructionsSysvarOrContextState: TAccountMetas[2];\n    /** Optional record account */\n    record?: TAccountMetas[3] | undefined;\n    /** The mint's withdraw_withheld_authority */\n    authority: TAccountMetas[4];\n  };\n  data: WithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionData;\n};\n\nexport function parseWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      destination: getNextAccount(),\n      instructionsSysvarOrContextState: getNextAccount(),\n      record: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getWithdrawWithheldTokensFromAccountsForConfidentialTransferFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_MINT_DISCRIMINATOR = 26;\n\nexport function getWithdrawWithheldTokensFromMintDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_MINT_DISCRIMINATOR\n  );\n}\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_MINT_TRANSFER_FEE_DISCRIMINATOR = 2;\n\nexport function getWithdrawWithheldTokensFromMintTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_MINT_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type WithdrawWithheldTokensFromMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountFeeReceiver extends string | AccountMeta<string> = string,\n  TAccountWithdrawWithheldAuthority extends\n    | string\n    | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountFeeReceiver extends string\n        ? WritableAccount<TAccountFeeReceiver>\n        : TAccountFeeReceiver,\n      TAccountWithdrawWithheldAuthority extends string\n        ? ReadonlyAccount<TAccountWithdrawWithheldAuthority>\n        : TAccountWithdrawWithheldAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawWithheldTokensFromMintInstructionData = {\n  discriminator: number;\n  transferFeeDiscriminator: number;\n};\n\nexport type WithdrawWithheldTokensFromMintInstructionDataArgs = {};\n\nexport function getWithdrawWithheldTokensFromMintInstructionDataEncoder(): FixedSizeEncoder<WithdrawWithheldTokensFromMintInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['transferFeeDiscriminator', getU8Encoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator: WITHDRAW_WITHHELD_TOKENS_FROM_MINT_DISCRIMINATOR,\n      transferFeeDiscriminator:\n        WITHDRAW_WITHHELD_TOKENS_FROM_MINT_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWithdrawWithheldTokensFromMintInstructionDataDecoder(): FixedSizeDecoder<WithdrawWithheldTokensFromMintInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['transferFeeDiscriminator', getU8Decoder()],\n  ]);\n}\n\nexport function getWithdrawWithheldTokensFromMintInstructionDataCodec(): FixedSizeCodec<\n  WithdrawWithheldTokensFromMintInstructionDataArgs,\n  WithdrawWithheldTokensFromMintInstructionData\n> {\n  return combineCodec(\n    getWithdrawWithheldTokensFromMintInstructionDataEncoder(),\n    getWithdrawWithheldTokensFromMintInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawWithheldTokensFromMintInput<\n  TAccountMint extends string = string,\n  TAccountFeeReceiver extends string = string,\n  TAccountWithdrawWithheldAuthority extends string = string,\n> = {\n  /** The token mint. Must include the `TransferFeeConfig` extension. */\n  mint: Address<TAccountMint>;\n  /**\n   * The fee receiver account. Must include the `TransferFeeAmount`\n   * extension associated with the provided mint.\n   */\n  feeReceiver: Address<TAccountFeeReceiver>;\n  /** The mint's `withdraw_withheld_authority` or its multisignature account. */\n  withdrawWithheldAuthority:\n    | Address<TAccountWithdrawWithheldAuthority>\n    | TransactionSigner<TAccountWithdrawWithheldAuthority>;\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getWithdrawWithheldTokensFromMintInstruction<\n  TAccountMint extends string,\n  TAccountFeeReceiver extends string,\n  TAccountWithdrawWithheldAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: WithdrawWithheldTokensFromMintInput<\n    TAccountMint,\n    TAccountFeeReceiver,\n    TAccountWithdrawWithheldAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawWithheldTokensFromMintInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountFeeReceiver,\n  (typeof input)['withdrawWithheldAuthority'] extends TransactionSigner<TAccountWithdrawWithheldAuthority>\n    ? ReadonlySignerAccount<TAccountWithdrawWithheldAuthority> &\n        AccountSignerMeta<TAccountWithdrawWithheldAuthority>\n    : TAccountWithdrawWithheldAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    feeReceiver: { value: input.feeReceiver ?? null, isWritable: true },\n    withdrawWithheldAuthority: {\n      value: input.withdrawWithheldAuthority ?? null,\n      isWritable: false,\n    },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.feeReceiver),\n      getAccountMeta(accounts.withdrawWithheldAuthority),\n      ...remainingAccounts,\n    ],\n    data: getWithdrawWithheldTokensFromMintInstructionDataEncoder().encode({}),\n    programAddress,\n  } as WithdrawWithheldTokensFromMintInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountFeeReceiver,\n    (typeof input)['withdrawWithheldAuthority'] extends TransactionSigner<TAccountWithdrawWithheldAuthority>\n      ? ReadonlySignerAccount<TAccountWithdrawWithheldAuthority> &\n          AccountSignerMeta<TAccountWithdrawWithheldAuthority>\n      : TAccountWithdrawWithheldAuthority\n  >);\n}\n\nexport type ParsedWithdrawWithheldTokensFromMintInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. Must include the `TransferFeeConfig` extension. */\n    mint: TAccountMetas[0];\n    /**\n     * The fee receiver account. Must include the `TransferFeeAmount`\n     * extension associated with the provided mint.\n     */\n    feeReceiver: TAccountMetas[1];\n    /** The mint's `withdraw_withheld_authority` or its multisignature account. */\n    withdrawWithheldAuthority: TAccountMetas[2];\n  };\n  data: WithdrawWithheldTokensFromMintInstructionData;\n};\n\nexport function parseWithdrawWithheldTokensFromMintInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedWithdrawWithheldTokensFromMintInstruction<TProgram, TAccountMetas> {\n  if (instruction.accounts.length < 3) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      feeReceiver: getNextAccount(),\n      withdrawWithheldAuthority: getNextAccount(),\n    },\n    data: getWithdrawWithheldTokensFromMintInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","/**\n * This code was AUTOGENERATED using the Codama library.\n * Please DO NOT EDIT THIS FILE, instead use visitors\n * to add features, then rerun Codama to update it.\n *\n * @see https://github.com/codama-idl/codama\n */\n\nimport {\n  AccountRole,\n  combineCodec,\n  getI8Decoder,\n  getI8Encoder,\n  getStructDecoder,\n  getStructEncoder,\n  getU8Decoder,\n  getU8Encoder,\n  transformEncoder,\n  type AccountMeta,\n  type AccountSignerMeta,\n  type Address,\n  type FixedSizeCodec,\n  type FixedSizeDecoder,\n  type FixedSizeEncoder,\n  type Instruction,\n  type InstructionWithAccounts,\n  type InstructionWithData,\n  type ReadonlyAccount,\n  type ReadonlySignerAccount,\n  type ReadonlyUint8Array,\n  type TransactionSigner,\n  type WritableAccount,\n} from '@solana/kit';\nimport { TOKEN_2022_PROGRAM_ADDRESS } from '../programs';\nimport { getAccountMetaFactory, type ResolvedAccount } from '../shared';\nimport {\n  getDecryptableBalanceDecoder,\n  getDecryptableBalanceEncoder,\n  type DecryptableBalance,\n  type DecryptableBalanceArgs,\n} from '../types';\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 37;\n\nexport function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport const WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR = 1;\n\nexport function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeConfidentialTransferFeeDiscriminatorBytes() {\n  return getU8Encoder().encode(\n    WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR\n  );\n}\n\nexport type WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMint extends string | AccountMeta<string> = string,\n  TAccountDestination extends string | AccountMeta<string> = string,\n  TAccountInstructionsSysvarOrContextState extends\n    | string\n    | AccountMeta<string> = string,\n  TAccountRecord extends string | AccountMeta<string> = string,\n  TAccountAuthority extends string | AccountMeta<string> = string,\n  TRemainingAccounts extends readonly AccountMeta<string>[] = [],\n> = Instruction<TProgram> &\n  InstructionWithData<ReadonlyUint8Array> &\n  InstructionWithAccounts<\n    [\n      TAccountMint extends string\n        ? WritableAccount<TAccountMint>\n        : TAccountMint,\n      TAccountDestination extends string\n        ? WritableAccount<TAccountDestination>\n        : TAccountDestination,\n      TAccountInstructionsSysvarOrContextState extends string\n        ? ReadonlyAccount<TAccountInstructionsSysvarOrContextState>\n        : TAccountInstructionsSysvarOrContextState,\n      TAccountRecord extends string\n        ? ReadonlyAccount<TAccountRecord>\n        : TAccountRecord,\n      TAccountAuthority extends string\n        ? ReadonlyAccount<TAccountAuthority>\n        : TAccountAuthority,\n      ...TRemainingAccounts,\n    ]\n  >;\n\nexport type WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionData =\n  {\n    discriminator: number;\n    confidentialTransferFeeDiscriminator: number;\n    /** Proof instruction offset */\n    proofInstructionOffset: number;\n    /** The new decryptable balance in the destination token account */\n    newDecryptableAvailableBalance: DecryptableBalance;\n  };\n\nexport type WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataArgs =\n  {\n    /** Proof instruction offset */\n    proofInstructionOffset: number;\n    /** The new decryptable balance in the destination token account */\n    newDecryptableAvailableBalance: DecryptableBalanceArgs;\n  };\n\nexport function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataEncoder(): FixedSizeEncoder<WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataArgs> {\n  return transformEncoder(\n    getStructEncoder([\n      ['discriminator', getU8Encoder()],\n      ['confidentialTransferFeeDiscriminator', getU8Encoder()],\n      ['proofInstructionOffset', getI8Encoder()],\n      ['newDecryptableAvailableBalance', getDecryptableBalanceEncoder()],\n    ]),\n    (value) => ({\n      ...value,\n      discriminator:\n        WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n      confidentialTransferFeeDiscriminator:\n        WITHDRAW_WITHHELD_TOKENS_FROM_MINT_FOR_CONFIDENTIAL_TRANSFER_FEE_CONFIDENTIAL_TRANSFER_FEE_DISCRIMINATOR,\n    })\n  );\n}\n\nexport function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataDecoder(): FixedSizeDecoder<WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionData> {\n  return getStructDecoder([\n    ['discriminator', getU8Decoder()],\n    ['confidentialTransferFeeDiscriminator', getU8Decoder()],\n    ['proofInstructionOffset', getI8Decoder()],\n    ['newDecryptableAvailableBalance', getDecryptableBalanceDecoder()],\n  ]);\n}\n\nexport function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataCodec(): FixedSizeCodec<\n  WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataArgs,\n  WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionData\n> {\n  return combineCodec(\n    getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataEncoder(),\n    getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataDecoder()\n  );\n}\n\nexport type WithdrawWithheldTokensFromMintForConfidentialTransferFeeInput<\n  TAccountMint extends string = string,\n  TAccountDestination extends string = string,\n  TAccountInstructionsSysvarOrContextState extends string = string,\n  TAccountRecord extends string = string,\n  TAccountAuthority extends string = string,\n> = {\n  /** The token mint. */\n  mint: Address<TAccountMint>;\n  /** The fee receiver account. */\n  destination: Address<TAccountDestination>;\n  /** Instructions sysvar or context state account */\n  instructionsSysvarOrContextState: Address<TAccountInstructionsSysvarOrContextState>;\n  /** Optional record account if proof is read from record */\n  record?: Address<TAccountRecord>;\n  /** The mint's withdraw_withheld_authority */\n  authority: Address<TAccountAuthority> | TransactionSigner<TAccountAuthority>;\n  proofInstructionOffset: WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataArgs['proofInstructionOffset'];\n  newDecryptableAvailableBalance: WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataArgs['newDecryptableAvailableBalance'];\n  multiSigners?: Array<TransactionSigner>;\n};\n\nexport function getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n  TAccountMint extends string,\n  TAccountDestination extends string,\n  TAccountInstructionsSysvarOrContextState extends string,\n  TAccountRecord extends string,\n  TAccountAuthority extends string,\n  TProgramAddress extends Address = typeof TOKEN_2022_PROGRAM_ADDRESS,\n>(\n  input: WithdrawWithheldTokensFromMintForConfidentialTransferFeeInput<\n    TAccountMint,\n    TAccountDestination,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    TAccountAuthority\n  >,\n  config?: { programAddress?: TProgramAddress }\n): WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n  TProgramAddress,\n  TAccountMint,\n  TAccountDestination,\n  TAccountInstructionsSysvarOrContextState,\n  TAccountRecord,\n  (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n    ? ReadonlySignerAccount<TAccountAuthority> &\n        AccountSignerMeta<TAccountAuthority>\n    : TAccountAuthority\n> {\n  // Program address.\n  const programAddress = config?.programAddress ?? TOKEN_2022_PROGRAM_ADDRESS;\n\n  // Original accounts.\n  const originalAccounts = {\n    mint: { value: input.mint ?? null, isWritable: true },\n    destination: { value: input.destination ?? null, isWritable: true },\n    instructionsSysvarOrContextState: {\n      value: input.instructionsSysvarOrContextState ?? null,\n      isWritable: false,\n    },\n    record: { value: input.record ?? null, isWritable: false },\n    authority: { value: input.authority ?? null, isWritable: false },\n  };\n  const accounts = originalAccounts as Record<\n    keyof typeof originalAccounts,\n    ResolvedAccount\n  >;\n\n  // Original args.\n  const args = { ...input };\n\n  // Remaining accounts.\n  const remainingAccounts: AccountMeta[] = (args.multiSigners ?? []).map(\n    (signer) => ({\n      address: signer.address,\n      role: AccountRole.READONLY_SIGNER,\n      signer,\n    })\n  );\n\n  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');\n  return Object.freeze({\n    accounts: [\n      getAccountMeta(accounts.mint),\n      getAccountMeta(accounts.destination),\n      getAccountMeta(accounts.instructionsSysvarOrContextState),\n      getAccountMeta(accounts.record),\n      getAccountMeta(accounts.authority),\n      ...remainingAccounts,\n    ],\n    data: getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataEncoder().encode(\n      args as WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataArgs\n    ),\n    programAddress,\n  } as WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n    TProgramAddress,\n    TAccountMint,\n    TAccountDestination,\n    TAccountInstructionsSysvarOrContextState,\n    TAccountRecord,\n    (typeof input)['authority'] extends TransactionSigner<TAccountAuthority>\n      ? ReadonlySignerAccount<TAccountAuthority> &\n          AccountSignerMeta<TAccountAuthority>\n      : TAccountAuthority\n  >);\n}\n\nexport type ParsedWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n  TProgram extends string = typeof TOKEN_2022_PROGRAM_ADDRESS,\n  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],\n> = {\n  programAddress: Address<TProgram>;\n  accounts: {\n    /** The token mint. */\n    mint: TAccountMetas[0];\n    /** The fee receiver account. */\n    destination: TAccountMetas[1];\n    /** Instructions sysvar or context state account */\n    instructionsSysvarOrContextState: TAccountMetas[2];\n    /** Optional record account if proof is read from record */\n    record?: TAccountMetas[3] | undefined;\n    /** The mint's withdraw_withheld_authority */\n    authority: TAccountMetas[4];\n  };\n  data: WithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionData;\n};\n\nexport function parseWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n  TProgram extends string,\n  TAccountMetas extends readonly AccountMeta[],\n>(\n  instruction: Instruction<TProgram> &\n    InstructionWithAccounts<TAccountMetas> &\n    InstructionWithData<ReadonlyUint8Array>\n): ParsedWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstruction<\n  TProgram,\n  TAccountMetas\n> {\n  if (instruction.accounts.length < 5) {\n    // TODO: Coded error.\n    throw new Error('Not enough accounts');\n  }\n  let accountIndex = 0;\n  const getNextAccount = () => {\n    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;\n    accountIndex += 1;\n    return accountMeta;\n  };\n  const getNextOptionalAccount = () => {\n    const accountMeta = getNextAccount();\n    return accountMeta.address === TOKEN_2022_PROGRAM_ADDRESS\n      ? undefined\n      : accountMeta;\n  };\n  return {\n    programAddress: instruction.programAddress,\n    accounts: {\n      mint: getNextAccount(),\n      destination: getNextAccount(),\n      instructionsSysvarOrContextState: getNextAccount(),\n      record: getNextOptionalAccount(),\n      authority: getNextAccount(),\n    },\n    data: getWithdrawWithheldTokensFromMintForConfidentialTransferFeeInstructionDataDecoder().decode(\n      instruction.data\n    ),\n  };\n}\n","import {\n  type GetAccountInfoApi,\n  type Rpc,\n  Address,\n  UnixTimestamp,\n  unwrapOption,\n} from '@solana/kit';\nimport { fetchSysvarClock } from '@solana/sysvars';\nimport { fetchMint } from './generated';\n\n// Constants\nconst ONE_IN_BASIS_POINTS = 10000;\nconst SECONDS_PER_YEAR = 60 * 60 * 24 * 365.24;\n\n/**\n * Calculates the exponent for the interest rate formula.\n * @param t1 - The start time in seconds.\n * @param t2 - The end time in seconds.\n * @param r  - The interest rate in basis points.\n *\n * @returns The calculated exponent.\n */\nfunction calculateExponentForTimesAndRate(t1: number, t2: number, r: number) {\n  const timespan = t2 - t1;\n  if (timespan < 0) {\n    throw new Error('Invalid timespan: end time before start time');\n  }\n\n  const numerator = r * timespan;\n  const exponent = numerator / (SECONDS_PER_YEAR * ONE_IN_BASIS_POINTS);\n  return Math.exp(exponent);\n}\n\n/**\n * Calculates the total scale factor for an interest bearing token by combining two exponential functions:\n * One for the period between initialization and last update using the pre-update average rate,\n * and another for the period between last update and current time using the current rate.\n *\n * @param currentTimestamp         Current timestamp in seconds\n * @param lastUpdateTimestamp      Last time the interest rate was updated in seconds\n * @param initializationTimestamp  Time the interest bearing extension was initialized in seconds\n * @param preUpdateAverageRate     Interest rate in basis points before last update\n * @param currentRate              Current interest rate in basis points\n *\n * @returns The total scale factor as a product of the two exponential functions\n */\nfunction calculateTotalScale({\n  currentTimestamp,\n  lastUpdateTimestamp,\n  initializationTimestamp,\n  preUpdateAverageRate,\n  currentRate,\n}: {\n  currentTimestamp: number;\n  lastUpdateTimestamp: number;\n  initializationTimestamp: number;\n  preUpdateAverageRate: number;\n  currentRate: number;\n}): number {\n  // Calculate pre-update exponent\n  const preUpdateExp = calculateExponentForTimesAndRate(\n    initializationTimestamp,\n    lastUpdateTimestamp,\n    preUpdateAverageRate\n  );\n\n  // Calculate post-update exponent\n  const postUpdateExp = calculateExponentForTimesAndRate(\n    lastUpdateTimestamp,\n    currentTimestamp,\n    currentRate\n  );\n\n  return preUpdateExp * postUpdateExp;\n}\n\n/**\n * Calculates the decimal factor for a given number of decimals\n * @param decimals - Number of decimals\n * @returns The decimal factor (e.g., 100 for 2 decimals)\n */\nfunction getDecimalFactor(decimals: number): number {\n  return Math.pow(10, decimals);\n}\n\n/**\n * Retrieves the current timestamp from the Solana clock sysvar.\n * @param rpc - The Solana rpc object.\n * @returns A promise that resolves to the current timestamp in seconds.\n * @throws An error if the sysvar clock cannot be fetched or parsed.\n */\nasync function getSysvarClockTimestamp(\n  rpc: Rpc<GetAccountInfoApi>\n): Promise<UnixTimestamp> {\n  const info = await fetchSysvarClock(rpc);\n  if (!info) {\n    throw new Error('Failed to fetch sysvar clock');\n  }\n  return info.unixTimestamp;\n}\n\n// ========== INTEREST BEARING MINT FUNCTIONS ==========\n\n/**\n * Convert amount to UiAmount for a mint with interest bearing extension without simulating a transaction\n * This implements the same logic as the CPI instruction available in /token/program-2022/src/extension/interest_bearing_mint/mod.rs\n * In general to calculate compounding interest over a period of time, the formula is:\n * A = P * e^(r * t) where\n * A = final amount after interest\n * P = principal amount (initial investment)\n * r = annual interest rate (as a decimal, e.g., 5% = 0.05)\n * t = time in years\n * e = mathematical constant (~2.718)\n *\n * In this case, we are calculating the total scale factor for the interest bearing extension which is the product of two exponential functions:\n * totalScale = e^(r1 * t1) * e^(r2 * t2)\n * where r1 and r2 are the interest rates before and after the last update, and t1 and t2 are the times in years between\n * the initialization timestamp and the last update timestamp, and between the last update timestamp and the current timestamp.\n *\n * @param amount                   Amount of tokens to be converted\n * @param decimals                 Number of decimals of the mint\n * @param currentTimestamp         Current timestamp in seconds\n * @param lastUpdateTimestamp      Last time the interest rate was updated in seconds\n * @param initializationTimestamp  Time the interest bearing extension was initialized in seconds\n * @param preUpdateAverageRate     Interest rate in basis points (1 basis point = 0.01%) before last update\n * @param currentRate              Current interest rate in basis points\n *\n * @return Amount scaled by accrued interest as a string with appropriate decimal places\n */\nexport function amountToUiAmountForInterestBearingMintWithoutSimulation(\n  amount: bigint,\n  decimals: number,\n  currentTimestamp: number,\n  lastUpdateTimestamp: number,\n  initializationTimestamp: number,\n  preUpdateAverageRate: number,\n  currentRate: number\n): string {\n  const totalScale = calculateTotalScale({\n    currentTimestamp,\n    lastUpdateTimestamp,\n    initializationTimestamp,\n    preUpdateAverageRate,\n    currentRate,\n  });\n\n  // Scale the amount by the total interest factor\n  const scaledAmount = Number(amount) * totalScale;\n  const decimalFactor = getDecimalFactor(decimals);\n\n  return (Math.trunc(scaledAmount) / decimalFactor).toString();\n}\n\n/**\n * Convert an amount with interest back to the original amount without interest\n * This implements the same logic as the CPI instruction available in /token/program-2022/src/extension/interest_bearing_mint/mod.rs\n *\n * @param uiAmount                  UI Amount (principal plus continuously compounding interest) to be converted back to original principal\n * @param decimals                  Number of decimals for the mint\n * @param currentTimestamp          Current timestamp in seconds\n * @param lastUpdateTimestamp       Last time the interest rate was updated in seconds\n * @param initializationTimestamp   Time the interest bearing extension was initialized in seconds\n * @param preUpdateAverageRate      Interest rate in basis points (hundredths of a percent) before the last update\n * @param currentRate              Current interest rate in basis points\n *\n * In general to calculate the principal from the UI amount, the formula is:\n * P = A / (e^(r * t)) where\n * P = principal\n * A = UI amount\n * r = annual interest rate (as a decimal, e.g., 5% = 0.05)\n * t = time in years\n *\n * In this case, we are calculating the principal by dividing the UI amount by the total scale factor which is the product of two exponential functions:\n * totalScale = e^(r1 * t1) * e^(r2 * t2)\n * where r1 is the pre-update average rate, r2 is the current rate, t1 is the time in years between the initialization timestamp and the last update timestamp,\n * and t2 is the time in years between the last update timestamp and the current timestamp.\n * then to calculate the principal, we divide the UI amount by the total scale factor:\n * P = A / totalScale\n *\n * @return Original amount (principal) without interest\n */\nexport function uiAmountToAmountForInterestBearingMintWithoutSimulation(\n  uiAmount: string,\n  decimals: number,\n  currentTimestamp: number,\n  lastUpdateTimestamp: number,\n  initializationTimestamp: number,\n  preUpdateAverageRate: number,\n  currentRate: number\n): bigint {\n  const uiAmountNumber = parseFloat(uiAmount);\n  const decimalsFactor = getDecimalFactor(decimals);\n  const uiAmountScaled = uiAmountNumber * decimalsFactor;\n\n  const totalScale = calculateTotalScale({\n    currentTimestamp,\n    lastUpdateTimestamp,\n    initializationTimestamp,\n    preUpdateAverageRate,\n    currentRate,\n  });\n\n  // Calculate original principal by dividing the UI amount by the total scale\n  const originalPrincipal = uiAmountScaled / totalScale;\n  return BigInt(Math.trunc(originalPrincipal));\n}\n\n// ========== SCALED UI AMOUNT MINT FUNCTIONS ==========\n\n/**\n * Convert amount to UiAmount for a mint with scaled UI amount extension\n * @param amount     Amount of tokens to be converted\n * @param decimals   Number of decimals of the mint\n * @param multiplier Multiplier to scale the amount\n * @return Scaled UI amount as a string\n */\nexport function amountToUiAmountForScaledUiAmountMintWithoutSimulation(\n  amount: bigint,\n  decimals: number,\n  multiplier: number\n): string {\n  const scaledAmount = Number(amount) * multiplier;\n  const decimalFactor = getDecimalFactor(decimals);\n  return (Math.trunc(scaledAmount) / decimalFactor).toString();\n}\n\n/**\n * Convert a UI amount back to the raw amount for a mint with a scaled UI amount extension\n * @param uiAmount       UI Amount to be converted back to raw amount\n * @param decimals       Number of decimals for the mint\n * @param multiplier     Multiplier for the scaled UI amount\n *\n * @return Raw amount\n */\nexport function uiAmountToAmountForScaledUiAmountMintWithoutSimulation(\n  uiAmount: string,\n  decimals: number,\n  multiplier: number\n): bigint {\n  const uiAmountNumber = parseFloat(uiAmount);\n  const decimalsFactor = getDecimalFactor(decimals);\n  const uiAmountScaled = uiAmountNumber * decimalsFactor;\n  const rawAmount = uiAmountScaled / multiplier;\n  return BigInt(Math.trunc(rawAmount));\n}\n\n// ========== MAIN ENTRY POINT FUNCTIONS ==========\n\n/**\n * Convert amount to UiAmount for a mint without simulating a transaction\n * This implements the same logic as `process_amount_to_ui_amount` in\n * solana-labs/solana-program-library/token/program-2022/src/processor.rs\n * and `process_amount_to_ui_amount` in solana-labs/solana-program-library/token/program/src/processor.rs\n *\n * @param rpc     Rpc to use\n * @param mint    Mint to use for calculations\n * @param amount  Amount of tokens to be converted to Ui Amount\n *\n * @return Ui Amount generated\n */\nexport async function amountToUiAmountForMintWithoutSimulation(\n  rpc: Rpc<GetAccountInfoApi>,\n  mint: Address,\n  amount: bigint\n): Promise<string> {\n  const accountInfo = await fetchMint(rpc, mint);\n  const extensions = unwrapOption(accountInfo.data.extensions);\n\n  // Check for interest bearing mint extension\n  const interestBearingMintConfigState = extensions?.find(\n    (ext) => ext.__kind === 'InterestBearingConfig'\n  );\n\n  // Check for scaled UI amount extension\n  const scaledUiAmountConfig = extensions?.find(\n    (ext) => ext.__kind === 'ScaledUiAmountConfig'\n  );\n\n  // If no special extension, do standard conversion\n  if (!interestBearingMintConfigState && !scaledUiAmountConfig) {\n    const amountNumber = Number(amount);\n    const decimalsFactor = getDecimalFactor(accountInfo.data.decimals);\n    return (amountNumber / decimalsFactor).toString();\n  }\n\n  // Get timestamp if needed for special mint types\n  const timestamp = await getSysvarClockTimestamp(rpc);\n\n  // Handle interest bearing mint\n  if (interestBearingMintConfigState) {\n    return amountToUiAmountForInterestBearingMintWithoutSimulation(\n      amount,\n      accountInfo.data.decimals,\n      Number(timestamp),\n      Number(interestBearingMintConfigState.lastUpdateTimestamp),\n      Number(interestBearingMintConfigState.initializationTimestamp),\n      interestBearingMintConfigState.preUpdateAverageRate,\n      interestBearingMintConfigState.currentRate\n    );\n  }\n\n  // At this point, we know it must be a scaled UI amount mint\n  if (scaledUiAmountConfig) {\n    let multiplier = scaledUiAmountConfig.multiplier;\n    // Use new multiplier if it's effective\n    if (timestamp >= scaledUiAmountConfig.newMultiplierEffectiveTimestamp) {\n      multiplier = scaledUiAmountConfig.newMultiplier;\n    }\n    return amountToUiAmountForScaledUiAmountMintWithoutSimulation(\n      amount,\n      accountInfo.data.decimals,\n      multiplier\n    );\n  }\n\n  // This should never happen due to the conditions above\n  throw new Error('Unknown mint extension type');\n}\n\n/**\n * Convert a UI amount back to the raw amount\n *\n * @param rpc      Rpc to use\n * @param mint     Mint to use for calculations\n * @param uiAmount UI Amount to be converted back to raw amount\n *\n * @return Raw amount\n */\nexport async function uiAmountToAmountForMintWithoutSimulation(\n  rpc: Rpc<GetAccountInfoApi>,\n  mint: Address,\n  uiAmount: string\n): Promise<bigint> {\n  const accountInfo = await fetchMint(rpc, mint);\n  const extensions = unwrapOption(accountInfo.data.extensions);\n\n  // Check for interest bearing mint extension\n  const interestBearingMintConfigState = extensions?.find(\n    (ext) => ext.__kind === 'InterestBearingConfig'\n  );\n\n  // Check for scaled UI amount extension\n  const scaledUiAmountConfig = extensions?.find(\n    (ext) => ext.__kind === 'ScaledUiAmountConfig'\n  );\n\n  // If no special extension, do standard conversion\n  if (!interestBearingMintConfigState && !scaledUiAmountConfig) {\n    const uiAmountScaled =\n      parseFloat(uiAmount) * getDecimalFactor(accountInfo.data.decimals);\n    return BigInt(Math.trunc(uiAmountScaled));\n  }\n\n  // Get timestamp if needed for special mint types\n  const timestamp = await getSysvarClockTimestamp(rpc);\n\n  // Handle interest bearing mint\n  if (interestBearingMintConfigState) {\n    return uiAmountToAmountForInterestBearingMintWithoutSimulation(\n      uiAmount,\n      accountInfo.data.decimals,\n      Number(timestamp),\n      Number(interestBearingMintConfigState.lastUpdateTimestamp),\n      Number(interestBearingMintConfigState.initializationTimestamp),\n      interestBearingMintConfigState.preUpdateAverageRate,\n      interestBearingMintConfigState.currentRate\n    );\n  }\n\n  // At this point, we know it must be a scaled UI amount mint\n  if (scaledUiAmountConfig) {\n    let multiplier = scaledUiAmountConfig.multiplier;\n    // Use new multiplier if it's effective\n    if (timestamp >= scaledUiAmountConfig.newMultiplierEffectiveTimestamp) {\n      multiplier = scaledUiAmountConfig.newMultiplier;\n    }\n    return uiAmountToAmountForScaledUiAmountMintWithoutSimulation(\n      uiAmount,\n      accountInfo.data.decimals,\n      multiplier\n    );\n  }\n\n  // This should never happen due to the conditions above\n  throw new Error('Unknown mint extension type');\n}\n","import {\n  Address,\n  Instruction,\n  isNone,\n  isOption,\n  TransactionSigner,\n  wrapNullable,\n} from '@solana/kit';\nimport {\n  ExtensionArgs,\n  getDisableMemoTransfersInstruction,\n  getEnableMemoTransfersInstruction,\n  getEnableCpiGuardInstruction,\n  getDisableCpiGuardInstruction,\n  getInitializeConfidentialTransferMintInstruction,\n  getInitializeDefaultAccountStateInstruction,\n  getInitializeGroupMemberPointerInstruction,\n  getInitializeGroupPointerInstruction,\n  getInitializeInterestBearingMintInstruction,\n  getInitializeMetadataPointerInstruction,\n  getInitializeMintCloseAuthorityInstruction,\n  getInitializeTokenGroupInstruction,\n  getInitializeTokenMetadataInstruction,\n  getInitializeTransferFeeConfigInstruction,\n  getInitializeNonTransferableMintInstruction,\n  getInitializeTransferHookInstruction,\n  getInitializePermanentDelegateInstruction,\n  getInitializeScaledUiAmountMintInstruction,\n  getInitializeConfidentialTransferFeeInstruction,\n  getInitializePausableConfigInstruction,\n} from './generated';\n\n/**\n * Given a mint address and a list of mint extensions, returns a list of\n * instructions that MUST be run _before_ the `initializeMint` instruction\n * to properly initialize the given extensions on the mint account.\n */\nexport function getPreInitializeInstructionsForMintExtensions(\n  mint: Address,\n  extensions: ExtensionArgs[]\n): Instruction[] {\n  return extensions.flatMap((extension) => {\n    switch (extension.__kind) {\n      case 'ConfidentialTransferMint':\n        return [\n          getInitializeConfidentialTransferMintInstruction({\n            mint,\n            ...extension,\n          }),\n        ];\n      case 'DefaultAccountState':\n        return [\n          getInitializeDefaultAccountStateInstruction({\n            mint,\n            state: extension.state,\n          }),\n        ];\n      case 'TransferFeeConfig':\n        return [\n          getInitializeTransferFeeConfigInstruction({\n            mint,\n            transferFeeConfigAuthority: extension.transferFeeConfigAuthority,\n            withdrawWithheldAuthority: extension.withdrawWithheldAuthority,\n            transferFeeBasisPoints:\n              extension.newerTransferFee.transferFeeBasisPoints,\n            maximumFee: extension.newerTransferFee.maximumFee,\n          }),\n        ];\n      case 'MetadataPointer':\n        return [\n          getInitializeMetadataPointerInstruction({\n            mint,\n            authority: extension.authority,\n            metadataAddress: extension.metadataAddress,\n          }),\n        ];\n      case 'InterestBearingConfig':\n        return [\n          getInitializeInterestBearingMintInstruction({\n            mint,\n            rateAuthority: extension.rateAuthority,\n            rate: extension.currentRate,\n          }),\n        ];\n      case 'ScaledUiAmountConfig':\n        return [\n          getInitializeScaledUiAmountMintInstruction({\n            mint,\n            authority: extension.authority,\n            multiplier: extension.multiplier,\n          }),\n        ];\n      case 'PausableConfig':\n        return [\n          getInitializePausableConfigInstruction({\n            mint,\n            authority: extension.authority,\n          }),\n        ];\n      case 'GroupPointer':\n        return [\n          getInitializeGroupPointerInstruction({\n            mint,\n            authority: extension.authority,\n            groupAddress: extension.groupAddress,\n          }),\n        ];\n      case 'GroupMemberPointer':\n        return [\n          getInitializeGroupMemberPointerInstruction({\n            mint,\n            authority: extension.authority,\n            memberAddress: extension.memberAddress,\n          }),\n        ];\n      case 'NonTransferable':\n        return getInitializeNonTransferableMintInstruction({ mint });\n      case 'TransferHook':\n        return [\n          getInitializeTransferHookInstruction({\n            mint,\n            authority: extension.authority,\n            programId: extension.programId,\n          }),\n        ];\n      case 'PermanentDelegate':\n        return getInitializePermanentDelegateInstruction({\n          mint,\n          delegate: extension.delegate,\n        });\n      case 'ConfidentialTransferFee':\n        return [\n          getInitializeConfidentialTransferFeeInstruction({\n            mint,\n            authority: extension.authority,\n            withdrawWithheldAuthorityElGamalPubkey: extension.elgamalPubkey,\n          }),\n        ];\n      case 'MintCloseAuthority':\n        return getInitializeMintCloseAuthorityInstruction({\n          closeAuthority: extension.closeAuthority,\n          mint,\n        });\n      default:\n        return [];\n    }\n  });\n}\n\n/**\n * Given a mint address and a list of mint extensions, returns a list of\n * instructions that MUST be run _after_ the `initializeMint` instruction\n * to properly initialize the given extensions on the mint account.\n */\nexport function getPostInitializeInstructionsForMintExtensions(\n  mint: Address,\n  authority: TransactionSigner,\n  extensions: ExtensionArgs[]\n): Instruction[] {\n  return extensions.flatMap((extension): Instruction[] => {\n    switch (extension.__kind) {\n      case 'TokenMetadata':\n        // eslint-disable-next-line no-case-declarations\n        const tokenMetadataUpdateAuthority = isOption(extension.updateAuthority)\n          ? extension.updateAuthority\n          : wrapNullable(extension.updateAuthority);\n        if (isNone(tokenMetadataUpdateAuthority)) {\n          return [];\n        }\n        return [\n          getInitializeTokenMetadataInstruction({\n            metadata: mint,\n            updateAuthority: tokenMetadataUpdateAuthority.value,\n            mint,\n            mintAuthority: authority,\n            name: extension.name,\n            symbol: extension.symbol,\n            uri: extension.uri,\n          }),\n        ];\n      case 'TokenGroup':\n        return [\n          getInitializeTokenGroupInstruction({\n            group: mint,\n            updateAuthority: isOption(extension.updateAuthority)\n              ? extension.updateAuthority\n              : wrapNullable(extension.updateAuthority),\n            mint,\n            mintAuthority: authority,\n            maxSize: extension.maxSize,\n          }),\n        ];\n      default:\n        return [];\n    }\n  });\n}\n\n/**\n * Given a token address, its owner and a list of token extensions, returns a list\n * of instructions that MUST be run _after_ the `initializeAccount` instruction\n * to properly initialize the given extensions on the token account.\n */\nexport function getPostInitializeInstructionsForTokenExtensions(\n  token: Address,\n  owner: TransactionSigner | Address,\n  extensions: ExtensionArgs[],\n  multiSigners?: TransactionSigner[]\n): Instruction[] {\n  return extensions.flatMap((extension) => {\n    switch (extension.__kind) {\n      case 'MemoTransfer':\n        return [\n          extension.requireIncomingTransferMemos\n            ? getEnableMemoTransfersInstruction({ owner, token, multiSigners })\n            : getDisableMemoTransfersInstruction({\n                owner,\n                token,\n                multiSigners,\n              }),\n        ];\n      case 'CpiGuard':\n        return [\n          extension.lockCpi\n            ? getEnableCpiGuardInstruction({ owner, token, multiSigners })\n            : getDisableCpiGuardInstruction({\n                owner,\n                token,\n                multiSigners,\n              }),\n        ];\n      default:\n        return [];\n    }\n  });\n}\n","import {\n  getArrayEncoder,\n  getConstantEncoder,\n  getHiddenPrefixEncoder,\n  getU8Encoder,\n} from '@solana/kit';\nimport { ExtensionArgs, getExtensionEncoder } from './generated';\n\nconst TOKEN_BASE_SIZE = 165;\n\nexport function getTokenSize(extensions?: ExtensionArgs[]): number {\n  if (extensions == null) return TOKEN_BASE_SIZE;\n  const tvlEncoder = getHiddenPrefixEncoder(\n    getArrayEncoder(getExtensionEncoder(), { size: 'remainder' }),\n    [getConstantEncoder(getU8Encoder().encode(2))]\n  );\n  return TOKEN_BASE_SIZE + tvlEncoder.encode(extensions).length;\n}\n","import {\n  getArrayEncoder,\n  getConstantEncoder,\n  getHiddenPrefixEncoder,\n  getU8Encoder,\n  padLeftEncoder,\n} from '@solana/kit';\nimport { ExtensionArgs, getExtensionEncoder } from './generated';\n\nconst MINT_BASE_SIZE = 82;\n\nexport function getMintSize(extensions?: ExtensionArgs[]): number {\n  if (extensions == null) return MINT_BASE_SIZE;\n  const tvlEncoder = getHiddenPrefixEncoder(\n    getArrayEncoder(getExtensionEncoder(), { size: 'remainder' }),\n    [getConstantEncoder(padLeftEncoder(getU8Encoder(), 83).encode(1))]\n  );\n  return MINT_BASE_SIZE + tvlEncoder.encode(extensions).length;\n}\n","import { createEncoder, getEncodedSize, createDecoder, combineCodec, assertByteArrayHasEnoughBytesForCodec, transformEncoder, transformDecoder, containsBytes, isFixedSize, assertIsFixedSize, fixEncoderSize, fixDecoderSize } from '@solana/codecs-core';\nimport { getU32Encoder, getU32Decoder, getU8Encoder, getU8Decoder } from '@solana/codecs-numbers';\nimport { SolanaError, SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, SOLANA_ERROR__CODECS__INVALID_CONSTANT, SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT, SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE } from '@solana/errors';\n\n// src/array.ts\nfunction assertValidNumberOfItemsForCodec(codecDescription, expected, actual) {\n  if (expected !== actual) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n      actual,\n      codecDescription,\n      expected\n    });\n  }\n}\nfunction maxCodecSizes(sizes) {\n  return sizes.reduce(\n    (all, size) => all === null || size === null ? null : Math.max(all, size),\n    0\n  );\n}\nfunction sumCodecSizes(sizes) {\n  return sizes.reduce((all, size) => all === null || size === null ? null : all + size, 0);\n}\nfunction getFixedSize(codec) {\n  return isFixedSize(codec) ? codec.fixedSize : null;\n}\nfunction getMaxSize(codec) {\n  return isFixedSize(codec) ? codec.fixedSize : codec.maxSize ?? null;\n}\n\n// src/array.ts\nfunction getArrayEncoder(item, config = {}) {\n  const size = config.size ?? getU32Encoder();\n  const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));\n  const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? void 0;\n  return createEncoder({\n    ...fixedSize !== null ? { fixedSize } : {\n      getSizeFromValue: (array) => {\n        const prefixSize = typeof size === \"object\" ? getEncodedSize(array.length, size) : 0;\n        return prefixSize + [...array].reduce((all, value) => all + getEncodedSize(value, item), 0);\n      },\n      maxSize\n    },\n    write: (array, bytes, offset) => {\n      if (typeof size === \"number\") {\n        assertValidNumberOfItemsForCodec(\"array\", size, array.length);\n      }\n      if (typeof size === \"object\") {\n        offset = size.write(array.length, bytes, offset);\n      }\n      array.forEach((value) => {\n        offset = item.write(value, bytes, offset);\n      });\n      return offset;\n    }\n  });\n}\nfunction getArrayDecoder(item, config = {}) {\n  const size = config.size ?? getU32Decoder();\n  const itemSize = getFixedSize(item);\n  const fixedSize = computeArrayLikeCodecSize(size, itemSize);\n  const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? void 0;\n  return createDecoder({\n    ...fixedSize !== null ? { fixedSize } : { maxSize },\n    read: (bytes, offset) => {\n      const array = [];\n      if (typeof size === \"object\" && bytes.slice(offset).length === 0) {\n        return [array, offset];\n      }\n      if (size === \"remainder\") {\n        while (offset < bytes.length) {\n          const [value, newOffset2] = item.read(bytes, offset);\n          offset = newOffset2;\n          array.push(value);\n        }\n        return [array, offset];\n      }\n      const [resolvedSize, newOffset] = typeof size === \"number\" ? [size, offset] : size.read(bytes, offset);\n      offset = newOffset;\n      for (let i = 0; i < resolvedSize; i += 1) {\n        const [value, newOffset2] = item.read(bytes, offset);\n        offset = newOffset2;\n        array.push(value);\n      }\n      return [array, offset];\n    }\n  });\n}\nfunction getArrayCodec(item, config = {}) {\n  return combineCodec(getArrayEncoder(item, config), getArrayDecoder(item, config));\n}\nfunction computeArrayLikeCodecSize(size, itemSize) {\n  if (typeof size !== \"number\") return null;\n  if (size === 0) return 0;\n  return itemSize === null ? null : itemSize * size;\n}\nfunction getBitArrayEncoder(size, config = {}) {\n  const parsedConfig = typeof config === \"boolean\" ? { backward: config } : config;\n  const backward = parsedConfig.backward ?? false;\n  return createEncoder({\n    fixedSize: size,\n    write(value, bytes, offset) {\n      const bytesToAdd = [];\n      for (let i = 0; i < size; i += 1) {\n        let byte = 0;\n        for (let j = 0; j < 8; j += 1) {\n          const feature = Number(value[i * 8 + j] ?? 0);\n          byte |= feature << (backward ? j : 7 - j);\n        }\n        if (backward) {\n          bytesToAdd.unshift(byte);\n        } else {\n          bytesToAdd.push(byte);\n        }\n      }\n      bytes.set(bytesToAdd, offset);\n      return size;\n    }\n  });\n}\nfunction getBitArrayDecoder(size, config = {}) {\n  const parsedConfig = typeof config === \"boolean\" ? { backward: config } : config;\n  const backward = parsedConfig.backward ?? false;\n  return createDecoder({\n    fixedSize: size,\n    read(bytes, offset) {\n      assertByteArrayHasEnoughBytesForCodec(\"bitArray\", size, bytes, offset);\n      const booleans = [];\n      let slice = bytes.slice(offset, offset + size);\n      slice = backward ? slice.reverse() : slice;\n      slice.forEach((byte) => {\n        for (let i = 0; i < 8; i += 1) {\n          if (backward) {\n            booleans.push(Boolean(byte & 1));\n            byte >>= 1;\n          } else {\n            booleans.push(Boolean(byte & 128));\n            byte <<= 1;\n          }\n        }\n      });\n      return [booleans, offset + size];\n    }\n  });\n}\nfunction getBitArrayCodec(size, config = {}) {\n  return combineCodec(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));\n}\nfunction getBooleanEncoder(config = {}) {\n  return transformEncoder(config.size ?? getU8Encoder(), (value) => value ? 1 : 0);\n}\nfunction getBooleanDecoder(config = {}) {\n  return transformDecoder(config.size ?? getU8Decoder(), (value) => Number(value) === 1);\n}\nfunction getBooleanCodec(config = {}) {\n  return combineCodec(getBooleanEncoder(config), getBooleanDecoder(config));\n}\nfunction getBytesEncoder() {\n  return createEncoder({\n    getSizeFromValue: (value) => value.length,\n    write: (value, bytes, offset) => {\n      bytes.set(value, offset);\n      return offset + value.length;\n    }\n  });\n}\nfunction getBytesDecoder() {\n  return createDecoder({\n    read: (bytes, offset) => {\n      const slice = bytes.slice(offset);\n      return [slice, offset + slice.length];\n    }\n  });\n}\nfunction getBytesCodec() {\n  return combineCodec(getBytesEncoder(), getBytesDecoder());\n}\nvar getBase16Decoder = () => createDecoder({\n  read(bytes, offset) {\n    const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n    return [value, bytes.length];\n  }\n});\nfunction getConstantEncoder(constant) {\n  return createEncoder({\n    fixedSize: constant.length,\n    write: (_, bytes, offset) => {\n      bytes.set(constant, offset);\n      return offset + constant.length;\n    }\n  });\n}\nfunction getConstantDecoder(constant) {\n  return createDecoder({\n    fixedSize: constant.length,\n    read: (bytes, offset) => {\n      const base16 = getBase16Decoder();\n      if (!containsBytes(bytes, constant, offset)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_CONSTANT, {\n          constant,\n          data: bytes,\n          hexConstant: base16.decode(constant),\n          hexData: base16.decode(bytes),\n          offset\n        });\n      }\n      return [void 0, offset + constant.length];\n    }\n  });\n}\nfunction getConstantCodec(constant) {\n  return combineCodec(getConstantEncoder(constant), getConstantDecoder(constant));\n}\nfunction getTupleEncoder(items) {\n  const fixedSize = sumCodecSizes(items.map(getFixedSize));\n  const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? void 0;\n  return createEncoder({\n    ...fixedSize === null ? {\n      getSizeFromValue: (value) => items.map((item, index) => getEncodedSize(value[index], item)).reduce((all, one) => all + one, 0),\n      maxSize\n    } : { fixedSize },\n    write: (value, bytes, offset) => {\n      assertValidNumberOfItemsForCodec(\"tuple\", items.length, value.length);\n      items.forEach((item, index) => {\n        offset = item.write(value[index], bytes, offset);\n      });\n      return offset;\n    }\n  });\n}\nfunction getTupleDecoder(items) {\n  const fixedSize = sumCodecSizes(items.map(getFixedSize));\n  const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? void 0;\n  return createDecoder({\n    ...fixedSize === null ? { maxSize } : { fixedSize },\n    read: (bytes, offset) => {\n      const values = [];\n      items.forEach((item) => {\n        const [newValue, newOffset] = item.read(bytes, offset);\n        values.push(newValue);\n        offset = newOffset;\n      });\n      return [values, offset];\n    }\n  });\n}\nfunction getTupleCodec(items) {\n  return combineCodec(\n    getTupleEncoder(items),\n    getTupleDecoder(items)\n  );\n}\nfunction getUnionEncoder(variants, getIndexFromValue) {\n  const fixedSize = getUnionFixedSize(variants);\n  const write = (variant, bytes, offset) => {\n    const index = getIndexFromValue(variant);\n    assertValidVariantIndex(variants, index);\n    return variants[index].write(variant, bytes, offset);\n  };\n  if (fixedSize !== null) {\n    return createEncoder({ fixedSize, write });\n  }\n  const maxSize = getUnionMaxSize(variants);\n  return createEncoder({\n    ...maxSize !== null ? { maxSize } : {},\n    getSizeFromValue: (variant) => {\n      const index = getIndexFromValue(variant);\n      assertValidVariantIndex(variants, index);\n      return getEncodedSize(variant, variants[index]);\n    },\n    write\n  });\n}\nfunction getUnionDecoder(variants, getIndexFromBytes) {\n  const fixedSize = getUnionFixedSize(variants);\n  const read = (bytes, offset) => {\n    const index = getIndexFromBytes(bytes, offset);\n    assertValidVariantIndex(variants, index);\n    return variants[index].read(bytes, offset);\n  };\n  if (fixedSize !== null) {\n    return createDecoder({ fixedSize, read });\n  }\n  const maxSize = getUnionMaxSize(variants);\n  return createDecoder({ ...maxSize !== null ? { maxSize } : {}, read });\n}\nfunction getUnionCodec(variants, getIndexFromValue, getIndexFromBytes) {\n  return combineCodec(\n    getUnionEncoder(variants, getIndexFromValue),\n    getUnionDecoder(variants, getIndexFromBytes)\n  );\n}\nfunction assertValidVariantIndex(variants, index) {\n  if (typeof variants[index] === \"undefined\") {\n    throw new SolanaError(SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, {\n      maxRange: variants.length - 1,\n      minRange: 0,\n      variant: index\n    });\n  }\n}\nfunction getUnionFixedSize(variants) {\n  if (variants.length === 0) return 0;\n  if (!isFixedSize(variants[0])) return null;\n  const variantSize = variants[0].fixedSize;\n  const sameSizedVariants = variants.every((variant) => isFixedSize(variant) && variant.fixedSize === variantSize);\n  return sameSizedVariants ? variantSize : null;\n}\nfunction getUnionMaxSize(variants) {\n  return maxCodecSizes(variants.map((variant) => getMaxSize(variant)));\n}\n\n// src/discriminated-union.ts\nfunction getDiscriminatedUnionEncoder(variants, config = {}) {\n  const discriminatorProperty = config.discriminator ?? \"__kind\";\n  const prefix = config.size ?? getU8Encoder();\n  return getUnionEncoder(\n    variants.map(\n      ([, variant], index) => transformEncoder(getTupleEncoder([prefix, variant]), (value) => [index, value])\n    ),\n    (value) => getVariantDiscriminator(variants, value[discriminatorProperty])\n  );\n}\nfunction getDiscriminatedUnionDecoder(variants, config = {}) {\n  const discriminatorProperty = config.discriminator ?? \"__kind\";\n  const prefix = config.size ?? getU8Decoder();\n  return getUnionDecoder(\n    variants.map(\n      ([discriminator, variant]) => transformDecoder(getTupleDecoder([prefix, variant]), ([, value]) => ({\n        [discriminatorProperty]: discriminator,\n        ...value\n      }))\n    ),\n    (bytes, offset) => Number(prefix.read(bytes, offset)[0])\n  );\n}\nfunction getDiscriminatedUnionCodec(variants, config = {}) {\n  return combineCodec(\n    getDiscriminatedUnionEncoder(variants, config),\n    getDiscriminatedUnionDecoder(variants, config)\n  );\n}\nfunction getVariantDiscriminator(variants, discriminatorValue) {\n  const discriminator = variants.findIndex(([key]) => discriminatorValue === key);\n  if (discriminator < 0) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, {\n      value: discriminatorValue,\n      variants: variants.map(([key]) => key)\n    });\n  }\n  return discriminator;\n}\n\n// src/enum-helpers.ts\nfunction getEnumStats(constructor) {\n  const numericalValues = [...new Set(Object.values(constructor).filter((v) => typeof v === \"number\"))].sort();\n  const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length));\n  const enumKeys = Object.keys(enumRecord);\n  const enumValues = Object.values(enumRecord);\n  const stringValues = [\n    .../* @__PURE__ */ new Set([...enumKeys, ...enumValues.filter((v) => typeof v === \"string\")])\n  ];\n  return { enumKeys, enumRecord, enumValues, numericalValues, stringValues };\n}\nfunction getEnumIndexFromVariant({\n  enumKeys,\n  enumValues,\n  variant\n}) {\n  const valueIndex = findLastIndex(enumValues, (value) => value === variant);\n  if (valueIndex >= 0) return valueIndex;\n  return enumKeys.findIndex((key) => key === variant);\n}\nfunction getEnumIndexFromDiscriminator({\n  discriminator,\n  enumKeys,\n  enumValues,\n  useValuesAsDiscriminators\n}) {\n  if (!useValuesAsDiscriminators) {\n    return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;\n  }\n  return findLastIndex(enumValues, (value) => value === discriminator);\n}\nfunction findLastIndex(array, predicate) {\n  let l = array.length;\n  while (l--) {\n    if (predicate(array[l], l, array)) return l;\n  }\n  return -1;\n}\nfunction formatNumericalValues(values) {\n  if (values.length === 0) return \"\";\n  let range = [values[0], values[0]];\n  const ranges = [];\n  for (let index = 1; index < values.length; index++) {\n    const value = values[index];\n    if (range[1] + 1 === value) {\n      range[1] = value;\n    } else {\n      ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n      range = [value, value];\n    }\n  }\n  ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n  return ranges.join(\", \");\n}\n\n// src/enum.ts\nfunction getEnumEncoder(constructor, config = {}) {\n  const prefix = config.size ?? getU8Encoder();\n  const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n  const { enumKeys, enumValues, numericalValues, stringValues } = getEnumStats(constructor);\n  if (useValuesAsDiscriminators && enumValues.some((value) => typeof value === \"string\")) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n      stringValues: enumValues.filter((v) => typeof v === \"string\")\n    });\n  }\n  return transformEncoder(prefix, (variant) => {\n    const index = getEnumIndexFromVariant({ enumKeys, enumValues, variant });\n    if (index < 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, {\n        formattedNumericalValues: formatNumericalValues(numericalValues),\n        numericalValues,\n        stringValues,\n        variant\n      });\n    }\n    return useValuesAsDiscriminators ? enumValues[index] : index;\n  });\n}\nfunction getEnumDecoder(constructor, config = {}) {\n  const prefix = config.size ?? getU8Decoder();\n  const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n  const { enumKeys, enumValues, numericalValues } = getEnumStats(constructor);\n  if (useValuesAsDiscriminators && enumValues.some((value) => typeof value === \"string\")) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n      stringValues: enumValues.filter((v) => typeof v === \"string\")\n    });\n  }\n  return transformDecoder(prefix, (value) => {\n    const discriminator = Number(value);\n    const index = getEnumIndexFromDiscriminator({\n      discriminator,\n      enumKeys,\n      enumValues,\n      useValuesAsDiscriminators\n    });\n    if (index < 0) {\n      const validDiscriminators = useValuesAsDiscriminators ? numericalValues : [...Array(enumKeys.length).keys()];\n      throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n        discriminator,\n        formattedValidDiscriminators: formatNumericalValues(validDiscriminators),\n        validDiscriminators\n      });\n    }\n    return enumValues[index];\n  });\n}\nfunction getEnumCodec(constructor, config = {}) {\n  return combineCodec(getEnumEncoder(constructor, config), getEnumDecoder(constructor, config));\n}\nfunction getHiddenPrefixEncoder(encoder, prefixedEncoders) {\n  return transformEncoder(\n    getTupleEncoder([...prefixedEncoders, encoder]),\n    (value) => [...prefixedEncoders.map(() => void 0), value]\n  );\n}\nfunction getHiddenPrefixDecoder(decoder, prefixedDecoders) {\n  return transformDecoder(\n    getTupleDecoder([...prefixedDecoders, decoder]),\n    (tuple) => tuple[tuple.length - 1]\n  );\n}\nfunction getHiddenPrefixCodec(codec, prefixedCodecs) {\n  return combineCodec(getHiddenPrefixEncoder(codec, prefixedCodecs), getHiddenPrefixDecoder(codec, prefixedCodecs));\n}\nfunction getHiddenSuffixEncoder(encoder, suffixedEncoders) {\n  return transformEncoder(\n    getTupleEncoder([encoder, ...suffixedEncoders]),\n    (value) => [value, ...suffixedEncoders.map(() => void 0)]\n  );\n}\nfunction getHiddenSuffixDecoder(decoder, suffixedDecoders) {\n  return transformDecoder(\n    getTupleDecoder([decoder, ...suffixedDecoders]),\n    (tuple) => tuple[0]\n  );\n}\nfunction getHiddenSuffixCodec(codec, suffixedCodecs) {\n  return combineCodec(getHiddenSuffixEncoder(codec, suffixedCodecs), getHiddenSuffixDecoder(codec, suffixedCodecs));\n}\nfunction getLiteralUnionEncoder(variants, config = {}) {\n  const discriminator = config.size ?? getU8Encoder();\n  return transformEncoder(discriminator, (variant) => {\n    const index = variants.indexOf(variant);\n    if (index < 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT, {\n        value: variant,\n        variants\n      });\n    }\n    return index;\n  });\n}\nfunction getLiteralUnionDecoder(variants, config = {}) {\n  const discriminator = config.size ?? getU8Decoder();\n  return transformDecoder(discriminator, (index) => {\n    if (index < 0 || index >= variants.length) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE, {\n        discriminator: index,\n        maxRange: variants.length - 1,\n        minRange: 0\n      });\n    }\n    return variants[Number(index)];\n  });\n}\nfunction getLiteralUnionCodec(variants, config = {}) {\n  return combineCodec(getLiteralUnionEncoder(variants, config), getLiteralUnionDecoder(variants, config));\n}\nfunction getMapEncoder(key, value, config = {}) {\n  return transformEncoder(\n    getArrayEncoder(getTupleEncoder([key, value]), config),\n    (map) => [...map.entries()]\n  );\n}\nfunction getMapDecoder(key, value, config = {}) {\n  return transformDecoder(\n    getArrayDecoder(getTupleDecoder([key, value]), config),\n    (entries) => new Map(entries)\n  );\n}\nfunction getMapCodec(key, value, config = {}) {\n  return combineCodec(getMapEncoder(key, value, config), getMapDecoder(key, value, config));\n}\nfunction getUnitEncoder() {\n  return createEncoder({\n    fixedSize: 0,\n    write: (_value, _bytes, offset) => offset\n  });\n}\nfunction getUnitDecoder() {\n  return createDecoder({\n    fixedSize: 0,\n    read: (_bytes, offset) => [void 0, offset]\n  });\n}\nfunction getUnitCodec() {\n  return combineCodec(getUnitEncoder(), getUnitDecoder());\n}\n\n// src/nullable.ts\nfunction getNullableEncoder(item, config = {}) {\n  const prefix = (() => {\n    if (config.prefix === null) {\n      return transformEncoder(getUnitEncoder(), (_boolean) => void 0);\n    }\n    return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n  })();\n  const noneValue = (() => {\n    if (config.noneValue === \"zeroes\") {\n      assertIsFixedSize(item);\n      return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n    }\n    if (!config.noneValue) {\n      return getUnitEncoder();\n    }\n    return getConstantEncoder(config.noneValue);\n  })();\n  return getUnionEncoder(\n    [\n      transformEncoder(getTupleEncoder([prefix, noneValue]), (_value) => [\n        false,\n        void 0\n      ]),\n      transformEncoder(getTupleEncoder([prefix, item]), (value) => [true, value])\n    ],\n    (variant) => Number(variant !== null)\n  );\n}\nfunction getNullableDecoder(item, config = {}) {\n  const prefix = (() => {\n    if (config.prefix === null) {\n      return transformDecoder(getUnitDecoder(), () => false);\n    }\n    return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n  })();\n  const noneValue = (() => {\n    if (config.noneValue === \"zeroes\") {\n      assertIsFixedSize(item);\n      return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n    }\n    if (!config.noneValue) {\n      return getUnitDecoder();\n    }\n    return getConstantDecoder(config.noneValue);\n  })();\n  return getUnionDecoder(\n    [\n      transformDecoder(getTupleDecoder([prefix, noneValue]), () => null),\n      transformDecoder(getTupleDecoder([prefix, item]), ([, value]) => value)\n    ],\n    (bytes, offset) => {\n      if (config.prefix === null && !config.noneValue) {\n        return Number(offset < bytes.length);\n      }\n      if (config.prefix === null && config.noneValue != null) {\n        const zeroValue = config.noneValue === \"zeroes\" ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n        return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n      }\n      return Number(prefix.read(bytes, offset)[0]);\n    }\n  );\n}\nfunction getNullableCodec(item, config = {}) {\n  return combineCodec(\n    getNullableEncoder(item, config),\n    getNullableDecoder(item, config)\n  );\n}\nfunction getSetEncoder(item, config = {}) {\n  return transformEncoder(getArrayEncoder(item, config), (set) => [...set]);\n}\nfunction getSetDecoder(item, config = {}) {\n  return transformDecoder(getArrayDecoder(item, config), (entries) => new Set(entries));\n}\nfunction getSetCodec(item, config = {}) {\n  return combineCodec(getSetEncoder(item, config), getSetDecoder(item, config));\n}\nfunction getStructEncoder(fields) {\n  const fieldCodecs = fields.map(([, codec]) => codec);\n  const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n  const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? void 0;\n  return createEncoder({\n    ...fixedSize === null ? {\n      getSizeFromValue: (value) => fields.map(([key, codec]) => getEncodedSize(value[key], codec)).reduce((all, one) => all + one, 0),\n      maxSize\n    } : { fixedSize },\n    write: (struct, bytes, offset) => {\n      fields.forEach(([key, codec]) => {\n        offset = codec.write(struct[key], bytes, offset);\n      });\n      return offset;\n    }\n  });\n}\nfunction getStructDecoder(fields) {\n  const fieldCodecs = fields.map(([, codec]) => codec);\n  const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n  const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? void 0;\n  return createDecoder({\n    ...fixedSize === null ? { maxSize } : { fixedSize },\n    read: (bytes, offset) => {\n      const struct = {};\n      fields.forEach(([key, codec]) => {\n        const [value, newOffset] = codec.read(bytes, offset);\n        offset = newOffset;\n        struct[key] = value;\n      });\n      return [struct, offset];\n    }\n  });\n}\nfunction getStructCodec(fields) {\n  return combineCodec(\n    getStructEncoder(fields),\n    getStructDecoder(fields)\n  );\n}\n\nexport { assertValidNumberOfItemsForCodec, getArrayCodec, getArrayDecoder, getArrayEncoder, getBitArrayCodec, getBitArrayDecoder, getBitArrayEncoder, getBooleanCodec, getBooleanDecoder, getBooleanEncoder, getBytesCodec, getBytesDecoder, getBytesEncoder, getConstantCodec, getConstantDecoder, getConstantEncoder, getDiscriminatedUnionCodec, getDiscriminatedUnionDecoder, getDiscriminatedUnionEncoder, getEnumCodec, getEnumDecoder, getEnumEncoder, getHiddenPrefixCodec, getHiddenPrefixDecoder, getHiddenPrefixEncoder, getHiddenSuffixCodec, getHiddenSuffixDecoder, getHiddenSuffixEncoder, getLiteralUnionCodec, getLiteralUnionDecoder, getLiteralUnionEncoder, getMapCodec, getMapDecoder, getMapEncoder, getNullableCodec, getNullableDecoder, getNullableEncoder, getSetCodec, getSetDecoder, getSetEncoder, getStructCodec, getStructDecoder, getStructEncoder, getTupleCodec, getTupleDecoder, getTupleEncoder, getUnionCodec, getUnionDecoder, getUnionEncoder, getUnitCodec, getUnitDecoder, getUnitEncoder };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","import { SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, SolanaError } from '@solana/errors';\n\n/** Checks the number of items in an array-like structure is expected. */\nexport function assertValidNumberOfItemsForCodec(\n    codecDescription: string,\n    expected: bigint | number,\n    actual: bigint | number,\n) {\n    if (expected !== actual) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n            actual,\n            codecDescription,\n            expected,\n        });\n    }\n}\n","import { isFixedSize } from '@solana/codecs-core';\n\n/**\n * Functionally, this type helper is equivalent to the identity type  i.e. `type Identity<T> = T`.\n * However, wrapping generic object mappings in this type significantly reduces the number\n * of instantiation expressions processed, which increases TypeScript performance and\n * prevents \"Type instantiation is excessively deep and possibly infinite\" errors.\n *\n * This works because TypeScript doesn't create a new level of nesting when encountering conditional generic types.\n * @see https://github.com/microsoft/TypeScript/issues/34933\n * @see https://github.com/kysely-org/kysely/pull/483\n */\nexport type DrainOuterGeneric<T> = [T] extends [unknown] ? T : never;\n\nexport function maxCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce(\n        (all, size) => (all === null || size === null ? null : Math.max(all, size)),\n        0 as number | null,\n    );\n}\n\nexport function sumCodecSizes(sizes: (number | null)[]): number | null {\n    return sizes.reduce((all, size) => (all === null || size === null ? null : all + size), 0 as number | null);\n}\n\nexport function getFixedSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : null;\n}\n\nexport function getMaxSize(codec: { fixedSize: number } | { maxSize?: number }): number | null {\n    return isFixedSize(codec) ? codec.fixedSize : (codec.maxSize ?? null);\n}\n","import {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getU32Decoder, getU32Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { getFixedSize, getMaxSize } from './utils';\n\n/**\n * Defines the possible size strategies for array-like codecs (`array`, `map`, and `set`).\n *\n * The size of the collection can be determined using one of the following approaches:\n * - A {@link NumberCodec}, {@link NumberDecoder}, or {@link NumberEncoder} to store a size prefix.\n * - A fixed `number` of items, enforcing an exact length.\n * - The string `\"remainder\"`, which infers the number of items by consuming the rest of the available bytes.\n *   This option is only available when encoding fixed-size items.\n *\n * @typeParam TPrefix - A number codec, decoder, or encoder used for size prefixing.\n */\nexport type ArrayLikeCodecSize<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> =\n    | TPrefix\n    | number\n    | 'remainder';\n\n/**\n * Defines the configuration options for array codecs.\n *\n * @typeParam TPrefix - A number codec, decoder, or encoder used for size prefixing.\n */\nexport type ArrayCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Specifies how the size of the array is determined.\n     *\n     * - A {@link NumberCodec}, {@link NumberDecoder}, or {@link NumberEncoder} stores a size prefix before encoding the array.\n     * - A `number` enforces a fixed number of elements.\n     * - `\"remainder\"` uses all remaining bytes to infer the array length (only for fixed-size items).\n     *\n     * @defaultValue A `u32` size prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Returns an encoder for arrays of values.\n *\n * This encoder serializes arrays by encoding each element using the provided item encoder.\n * By default, a `u32` size prefix is included to indicate the number of items in the array.\n * The `size` option can be used to modify this behaviour.\n *\n * For more details, see {@link getArrayCodec}.\n *\n * @typeParam TFrom - The type of the elements in the array.\n *\n * @param item - The encoder for each item in the array.\n * @param config - Optional configuration for the size encoding strategy.\n * @returns A `VariableSizeEncoder<TFrom[]>` for encoding arrays.\n *\n * @example\n * Encoding an array of `u8` numbers.\n * ```ts\n * const encoder = getArrayEncoder(getU8Encoder());\n * const bytes = encoder.encode([1, 2, 3]);\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix telling us to read 3 items.\n * ```\n *\n * @see {@link getArrayCodec}\n */\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<TFrom[], 0>;\nexport function getArrayEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: ArrayCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<TFrom[]>;\nexport function getArrayEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: ArrayCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom[]> {\n    const size = config.size ?? getU32Encoder();\n    const fixedSize = computeArrayLikeCodecSize(size, getFixedSize(item));\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize !== null\n            ? { fixedSize }\n            : {\n                  getSizeFromValue: (array: TFrom[]) => {\n                      const prefixSize = typeof size === 'object' ? getEncodedSize(array.length, size) : 0;\n                      return prefixSize + [...array].reduce((all, value) => all + getEncodedSize(value, item), 0);\n                  },\n                  maxSize,\n              }),\n        write: (array: TFrom[], bytes, offset) => {\n            if (typeof size === 'number') {\n                assertValidNumberOfItemsForCodec('array', size, array.length);\n            }\n            if (typeof size === 'object') {\n                offset = size.write(array.length, bytes, offset);\n            }\n            array.forEach(value => {\n                offset = item.write(value, bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder for arrays of values.\n *\n * This decoder deserializes arrays by decoding each element using the provided item decoder.\n * By default, a `u32` size prefix is expected to indicate the number of items in the array.\n * The `size` option can be used to modify this behaviour.\n *\n * For more details, see {@link getArrayCodec}.\n *\n * @typeParam TTo - The type of the decoded elements in the array.\n *\n * @param item - The decoder for each item in the array.\n * @param config - Optional configuration for the size decoding strategy.\n * @returns A `VariableSizeDecoder<TTo[]>` for decoding arrays.\n *\n * @example\n * Decoding an array of `u8` numbers.\n * ```ts\n * const decoder = getArrayDecoder(getU8Decoder());\n * const array = decoder.decode(new Uint8Array([0x03, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03]));\n * // [1, 2, 3]\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix telling us to read 3 items.\n * ```\n *\n * @see {@link getArrayCodec}\n */\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<TTo[], 0>;\nexport function getArrayDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: ArrayCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: ArrayCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<TTo[]>;\nexport function getArrayDecoder<TTo>(item: Decoder<TTo>, config: ArrayCodecConfig<NumberDecoder> = {}): Decoder<TTo[]> {\n    const size = config.size ?? getU32Decoder();\n    const itemSize = getFixedSize(item);\n    const fixedSize = computeArrayLikeCodecSize(size, itemSize);\n    const maxSize = computeArrayLikeCodecSize(size, getMaxSize(item)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize !== null ? { fixedSize } : { maxSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const array: TTo[] = [];\n            if (typeof size === 'object' && bytes.slice(offset).length === 0) {\n                return [array, offset];\n            }\n\n            if (size === 'remainder') {\n                while (offset < bytes.length) {\n                    const [value, newOffset] = item.read(bytes, offset);\n                    offset = newOffset;\n                    array.push(value);\n                }\n                return [array, offset];\n            }\n\n            const [resolvedSize, newOffset] = typeof size === 'number' ? [size, offset] : size.read(bytes, offset);\n            offset = newOffset;\n            for (let i = 0; i < resolvedSize; i += 1) {\n                const [value, newOffset] = item.read(bytes, offset);\n                offset = newOffset;\n                array.push(value);\n            }\n            return [array, offset];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding arrays of values.\n *\n * This codec serializes arrays by encoding each element using the provided item codec.\n * By default, a `u32` size prefix is included to indicate the number of items in the array.\n * The `size` option can be used to modify this behaviour.\n *\n * @typeParam TFrom - The type of the elements to encode.\n * @typeParam TTo - The type of the decoded elements.\n *\n * @param item - The codec for each item in the array.\n * @param config - Optional configuration for the size encoding/decoding strategy.\n * @returns A `VariableSizeCodec<TFrom[], TTo[]>` for encoding and decoding arrays.\n *\n * @example\n * Encoding and decoding an array of `u8` numbers.\n * ```ts\n * const codec = getArrayCodec(getU8Codec());\n * const bytes = codec.encode([1, 2, 3]);\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix telling us to read 3 items.\n *\n * const array = codec.decode(bytes);\n * // [1, 2, 3]\n * ```\n *\n * @example\n * Using a `u16` size prefix instead of `u32`.\n * ```ts\n * const codec = getArrayCodec(getU8Codec(), { size: getU16Codec() });\n * const bytes = codec.encode([1, 2, 3]);\n * // 0x0300010203\n * //   |   -- 3 items of 1 byte each.\n * //   -- 2-byte prefix telling us to read 3 items.\n * ```\n *\n * @example\n * Using a fixed-size array of 3 items.\n * ```ts\n * const codec = getArrayCodec(getU8Codec(), { size: 3 });\n * codec.encode([1, 2, 3]);\n * // 0x010203\n * //   -- 3 items of 1 byte each. There must always be 3 items in the array.\n * ```\n *\n * @example\n * Using the `\"remainder\"` size strategy.\n * ```ts\n * const codec = getArrayCodec(getU8Codec(), { size: 'remainder' });\n * codec.encode([1, 2, 3]);\n * // 0x010203\n * //   -- 3 items of 1 byte each. The size is inferred from the remainder of the bytes.\n * ```\n *\n * @remarks\n * The size of the array can be controlled using the `size` option:\n * - A `Codec<number>` (e.g. `getU16Codec()`) stores a size prefix before the array.\n * - A `number` enforces a fixed number of elements.\n * - `\"remainder\"` uses all remaining bytes to infer the array length.\n *\n * Separate {@link getArrayEncoder} and {@link getArrayDecoder} functions are available.\n *\n * ```ts\n * const bytes = getArrayEncoder(getU8Encoder()).encode([1, 2, 3]);\n * const array = getArrayDecoder(getU8Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getArrayEncoder}\n * @see {@link getArrayDecoder}\n */\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<TFrom[], TTo[], 0>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: ArrayCodecConfig<NumberCodec>,\n): VariableSizeCodec<TFrom[], TTo[]>;\nexport function getArrayCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: ArrayCodecConfig<NumberCodec> = {},\n): Codec<TFrom[], TTo[]> {\n    return combineCodec(getArrayEncoder(item, config as object), getArrayDecoder(item, config as object));\n}\n\nfunction computeArrayLikeCodecSize(size: number | object | 'remainder', itemSize: number | null): number | null {\n    if (typeof size !== 'number') return null;\n    if (size === 0) return 0;\n    return itemSize === null ? null : itemSize * size;\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from '@solana/codecs-core';\n\n/**\n * Defines the configuration options for bit array codecs.\n *\n * A bit array codec encodes an array of booleans into bits, packing them into bytes.\n * This configuration allows adjusting the bit ordering.\n *\n * @see {@link getBitArrayEncoder}\n * @see {@link getBitArrayDecoder}\n * @see {@link getBitArrayCodec}\n */\nexport type BitArrayCodecConfig = {\n    /**\n     * Determines whether the bits should be read in reverse order.\n     *\n     * - `false` (default): The first boolean is stored in the most significant bit (MSB-first).\n     * - `true`: The first boolean is stored in the least significant bit (LSB-first).\n     *\n     * @defaultValue `false`\n     */\n    backward?: boolean;\n};\n\n/**\n * Returns an encoder that packs an array of booleans into bits.\n *\n * This encoder converts a list of `boolean` values into a compact bit representation,\n * storing 8 booleans per byte.\n *\n * The `backward` config option determines whether the bits are stored in MSB-first (`false`)\n * or LSB-first (`true`).\n *\n * For more details, see {@link getBitArrayCodec}.\n *\n * @typeParam TSize - The number of bytes used to store the bit array.\n *\n * @param size - The number of bytes allocated for the bit array (must be sufficient for the expected boolean count).\n * @param config - Configuration options for encoding the bit array.\n * @returns A `FixedSizeEncoder<boolean[], TSize>` for encoding bit arrays.\n *\n * @example\n * Encoding a bit array.\n * ```ts\n * const encoder = getBitArrayEncoder(1);\n *\n * encoder.encode([true, false, true, false, false, false, false, false]);\n * // 0xa0 (0b10100000)\n * ```\n *\n * @see {@link getBitArrayCodec}\n */\nexport function getBitArrayEncoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeEncoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createEncoder({\n        fixedSize: size,\n        write(value: boolean[], bytes, offset) {\n            const bytesToAdd: number[] = [];\n\n            for (let i = 0; i < size; i += 1) {\n                let byte = 0;\n                for (let j = 0; j < 8; j += 1) {\n                    const feature = Number(value[i * 8 + j] ?? 0);\n                    byte |= feature << (backward ? j : 7 - j);\n                }\n                if (backward) {\n                    bytesToAdd.unshift(byte);\n                } else {\n                    bytesToAdd.push(byte);\n                }\n            }\n\n            bytes.set(bytesToAdd, offset);\n            return size;\n        },\n    });\n}\n\n/**\n * Returns a decoder that unpacks bits into an array of booleans.\n *\n * This decoder converts a compact bit representation back into a list of `boolean` values.\n * Each byte is expanded into 8 booleans.\n *\n * The `backward` config option determines whether the bits are read in MSB-first (`false`)\n * or LSB-first (`true`).\n *\n * For more details, see {@link getBitArrayCodec}.\n *\n * @typeParam TSize - The number of bytes used to store the bit array.\n *\n * @param size - The number of bytes allocated for the bit array (must be sufficient for the expected boolean count).\n * @param config - Configuration options for decoding the bit array.\n * @returns A `FixedSizeDecoder<boolean[], TSize>` for decoding bit arrays.\n *\n * @example\n * Decoding a bit array.\n * ```ts\n * const decoder = getBitArrayDecoder(1);\n *\n * decoder.decode(new Uint8Array([0xa0]));\n * // [true, false, true, false, false, false, false, false]\n * ```\n *\n * @see {@link getBitArrayCodec}\n */\nexport function getBitArrayDecoder<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeDecoder<boolean[], TSize> {\n    const parsedConfig: BitArrayCodecConfig = typeof config === 'boolean' ? { backward: config } : config;\n    const backward = parsedConfig.backward ?? false;\n    return createDecoder({\n        fixedSize: size,\n        read(bytes, offset) {\n            assertByteArrayHasEnoughBytesForCodec('bitArray', size, bytes, offset);\n            const booleans: boolean[] = [];\n            let slice = bytes.slice(offset, offset + size);\n            slice = backward ? slice.reverse() : slice;\n\n            slice.forEach(byte => {\n                for (let i = 0; i < 8; i += 1) {\n                    if (backward) {\n                        booleans.push(Boolean(byte & 1));\n                        byte >>= 1;\n                    } else {\n                        booleans.push(Boolean(byte & 0b1000_0000));\n                        byte <<= 1;\n                    }\n                }\n            });\n\n            return [booleans, offset + size];\n        },\n    });\n}\n\n/**\n * Returns a codec that encodes and decodes boolean arrays as compact bit representations.\n *\n * This codec efficiently stores boolean arrays as bits, packing 8 values per byte.\n * The `backward` config option determines whether bits are stored in MSB-first (`false`)\n * or LSB-first (`true`).\n *\n * @typeParam TSize - The number of bytes used to store the bit array.\n *\n * @param size - The number of bytes allocated for the bit array (must be sufficient for the expected boolean count).\n * @param config - Configuration options for encoding and decoding the bit array.\n * @returns A `FixedSizeCodec<boolean[], boolean[], TSize>` for encoding and decoding bit arrays.\n *\n * @example\n * Encoding and decoding a bit array.\n * ```ts\n * const codec = getBitArrayCodec(1);\n *\n * codec.encode([true, false, true, false, false, false, false, false]);\n * // 0xa0 (0b10100000)\n *\n * codec.decode(new Uint8Array([0xa0]));\n * // [true, false, true, false, false, false, false, false]\n * ```\n *\n * @example\n * Encoding and decoding a bit array backwards.\n * ```ts\n * const codec = getBitArrayCodec(1, { backward: true });\n *\n * codec.encode([true, false, true, false, false, false, false, false]);\n * // 0x05 (0b00000101)\n *\n * codec.decode(new Uint8Array([0x05]));\n * // [true, false, true, false, false, false, false, false]\n * ```\n *\n * @remarks\n * Separate {@link getBitArrayEncoder} and {@link getBitArrayDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBitArrayEncoder(1).encode([true, false, true, false]);\n * const value = getBitArrayDecoder(1).decode(bytes);\n * ```\n *\n * @see {@link getBitArrayEncoder}\n * @see {@link getBitArrayDecoder}\n */\nexport function getBitArrayCodec<TSize extends number>(\n    size: TSize,\n    config: BitArrayCodecConfig | boolean = {},\n): FixedSizeCodec<boolean[], boolean[], TSize> {\n    return combineCodec(getBitArrayEncoder(size, config), getBitArrayDecoder(size, config));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\n/**\n * Defines the configuration options for boolean codecs.\n *\n * A boolean codec encodes `true` as `1` and `false` as `0`.\n * The `size` option allows customizing the number codec used for storage.\n *\n * @typeParam TSize - A number codec, encoder, or decoder used for boolean representation.\n *\n * @see {@link getBooleanEncoder}\n * @see {@link getBooleanDecoder}\n * @see {@link getBooleanCodec}\n */\nexport type BooleanCodecConfig<TSize extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The number codec used to store boolean values.\n     *\n     * - By default, booleans are stored as a `u8` (`1` for `true`, `0` for `false`).\n     * - A custom number codec can be provided to change the storage size.\n     *\n     * @defaultValue `u8`\n     */\n    size?: TSize;\n};\n\n/**\n * Returns an encoder for boolean values.\n *\n * This encoder converts `true` into `1` and `false` into `0`.\n * The `size` option allows customizing the number codec used for storage.\n *\n * For more details, see {@link getBooleanCodec}.\n *\n * @param config - Configuration options for encoding booleans.\n * @returns A `FixedSizeEncoder<boolean, N>` where `N` is the size of the number codec.\n *\n * @example\n * Encoding booleans.\n * ```ts\n * const encoder = getBooleanEncoder();\n *\n * encoder.encode(false); // 0x00\n * encoder.encode(true);  // 0x01\n * ```\n *\n * @see {@link getBooleanCodec}\n */\nexport function getBooleanEncoder(): FixedSizeEncoder<boolean, 1>;\nexport function getBooleanEncoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<boolean, TSize>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder>): VariableSizeEncoder<boolean>;\nexport function getBooleanEncoder(config: BooleanCodecConfig<NumberEncoder> = {}): Encoder<boolean> {\n    return transformEncoder(config.size ?? getU8Encoder(), (value: boolean) => (value ? 1 : 0));\n}\n\n/**\n * Returns a decoder for boolean values.\n *\n * This decoder reads a number and interprets `1` as `true` and `0` as `false`.\n * The `size` option allows customizing the number codec used for storage.\n *\n * For more details, see {@link getBooleanCodec}.\n *\n * @param config - Configuration options for decoding booleans.\n * @returns A `FixedSizeDecoder<boolean, N>` where `N` is the size of the number codec.\n *\n * @example\n * Decoding booleans.\n * ```ts\n * const decoder = getBooleanDecoder();\n *\n * decoder.decode(new Uint8Array([0x00])); // false\n * decoder.decode(new Uint8Array([0x01])); // true\n * ```\n *\n * @see {@link getBooleanCodec}\n */\nexport function getBooleanDecoder(): FixedSizeDecoder<boolean, 1>;\nexport function getBooleanDecoder<TSize extends number>(\n    config: BooleanCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<boolean, TSize>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder>): VariableSizeDecoder<boolean>;\nexport function getBooleanDecoder(config: BooleanCodecConfig<NumberDecoder> = {}): Decoder<boolean> {\n    return transformDecoder(config.size ?? getU8Decoder(), (value: bigint | number): boolean => Number(value) === 1);\n}\n\n/**\n * Returns a codec for encoding and decoding boolean values.\n *\n * By default, booleans are stored as a `u8` (`1` for `true`, `0` for `false`).\n * The `size` option allows customizing the number codec used for storage.\n *\n * @param config - Configuration options for encoding and decoding booleans.\n * @returns A `FixedSizeCodec<boolean, boolean, N>` where `N` is the size of the number codec.\n *\n * @example\n * Encoding and decoding booleans using a `u8` (default).\n * ```ts\n * const codec = getBooleanCodec();\n *\n * codec.encode(false); // 0x00\n * codec.encode(true);  // 0x01\n *\n * codec.decode(new Uint8Array([0x00])); // false\n * codec.decode(new Uint8Array([0x01])); // true\n * ```\n *\n * @example\n * Encoding and decoding booleans using a custom number codec.\n * ```ts\n * const codec = getBooleanCodec({ size: getU16Codec() });\n *\n * codec.encode(false); // 0x0000\n * codec.encode(true);  // 0x0100\n *\n * codec.decode(new Uint8Array([0x00, 0x00])); // false\n * codec.decode(new Uint8Array([0x01, 0x00])); // true\n * ```\n *\n * @remarks\n * Separate {@link getBooleanEncoder} and {@link getBooleanDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBooleanEncoder().encode(true);\n * const value = getBooleanDecoder().decode(bytes);\n * ```\n *\n * @see {@link getBooleanEncoder}\n * @see {@link getBooleanDecoder}\n */\nexport function getBooleanCodec(): FixedSizeCodec<boolean, boolean, 1>;\nexport function getBooleanCodec<TSize extends number>(\n    config: BooleanCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<boolean, boolean, TSize>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec>): VariableSizeCodec<boolean>;\nexport function getBooleanCodec(config: BooleanCodecConfig<NumberCodec> = {}): Codec<boolean> {\n    return combineCodec(getBooleanEncoder(config), getBooleanDecoder(config));\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\n/**\n * Returns an encoder for raw byte arrays.\n *\n * This encoder writes byte arrays exactly as provided without modification.\n *\n * The size of the encoded byte array is determined by the length of the input.\n * - To enforce a fixed size, consider using {@link fixEncoderSize}.\n * - To add a size prefix, use {@link addEncoderSizePrefix}.\n * - To add a sentinel value, use {@link addEncoderSentinel}.\n *\n * For more details, see {@link getBytesCodec}.\n *\n * @returns A `VariableSizeEncoder<ReadonlyUint8Array | Uint8Array>`.\n *\n * @example\n * Encoding a byte array as-is.\n * ```ts\n * const encoder = getBytesEncoder();\n *\n * encoder.encode(new Uint8Array([1, 2, 3])); // 0x010203\n * encoder.encode(new Uint8Array([255, 0, 127])); // 0xff007f\n * ```\n *\n * @see {@link getBytesCodec}\n */\nexport function getBytesEncoder(): VariableSizeEncoder<ReadonlyUint8Array | Uint8Array> {\n    return createEncoder({\n        getSizeFromValue: value => value.length,\n        write: (value, bytes, offset) => {\n            bytes.set(value, offset);\n            return offset + value.length;\n        },\n    });\n}\n\n/**\n * Returns a decoder for raw byte arrays.\n *\n * This decoder reads byte arrays exactly as provided without modification.\n *\n * The decoded byte array extends from the provided offset to the end of the input.\n * - To enforce a fixed size, consider using {@link fixDecoderSize}.\n * - To add a size prefix, use {@link addDecoderSizePrefix}.\n * - To add a sentinel value, use {@link addDecoderSentinel}.\n *\n * For more details, see {@link getBytesCodec}.\n *\n * @returns A `VariableSizeDecoder<ReadonlyUint8Array>`.\n *\n * @example\n * Decoding a byte array as-is.\n * ```ts\n * const decoder = getBytesDecoder();\n *\n * decoder.decode(new Uint8Array([1, 2, 3])); // Uint8Array([1, 2, 3])\n * decoder.decode(new Uint8Array([255, 0, 127])); // Uint8Array([255, 0, 127])\n * ```\n *\n * @see {@link getBytesCodec}\n */\nexport function getBytesDecoder(): VariableSizeDecoder<ReadonlyUint8Array> {\n    return createDecoder({\n        read: (bytes, offset) => {\n            const slice = bytes.slice(offset);\n            return [slice, offset + slice.length];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding raw byte arrays.\n *\n * This codec serializes and deserializes byte arrays without modification.\n *\n * The size of the encoded and decoded byte array is determined dynamically.\n * This means, when reading, the codec will consume all remaining bytes in the input.\n * - To enforce a fixed size, consider using {@link fixCodecSize}.\n * - To add a size prefix, use {@link addCodecSizePrefix}.\n * - To add a sentinel value, use {@link addCodecSentinel}.\n *\n * @returns A `VariableSizeCodec<ReadonlyUint8Array | Uint8Array, ReadonlyUint8Array>`.\n *\n * @example\n * Encoding and decoding a byte array.\n * ```ts\n * const codec = getBytesCodec();\n *\n * codec.encode(new Uint8Array([1, 2, 3])); // 0x010203\n * codec.decode(new Uint8Array([255, 0, 127])); // Uint8Array([255, 0, 127])\n * ```\n *\n * @remarks\n * Separate {@link getBytesEncoder} and {@link getBytesDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBytesEncoder().encode(new Uint8Array([1, 2, 3]));\n * const value = getBytesDecoder().decode(bytes);\n * ```\n *\n * @see {@link getBytesEncoder}\n * @see {@link getBytesDecoder}\n */\nexport function getBytesCodec(): VariableSizeCodec<ReadonlyUint8Array | Uint8Array, ReadonlyUint8Array> {\n    return combineCodec(getBytesEncoder(), getBytesDecoder());\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/**\n * Returns an encoder for base-16 (hexadecimal) strings.\n *\n * This encoder serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-16 strings.\n *\n * @example\n * Encoding a base-16 string.\n * ```ts\n * const encoder = getBase16Encoder();\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-16 (hexadecimal) strings.\n *\n * This decoder deserializes base-16 encoded strings from a byte array.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-16 strings.\n *\n * @example\n * Decoding a base-16 string.\n * ```ts\n * const decoder = getBase16Decoder();\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-16 (hexadecimal) strings.\n *\n * This codec serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-16 strings.\n *\n * @example\n * Encoding and decoding a base-16 string.\n * ```ts\n * const codec = getBase16Codec();\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-16 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase16Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-16 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase16Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase16Encoder} and {@link getBase16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase16Encoder().encode('deadface');\n * const value = getBase16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase16Encoder}\n * @see {@link getBase16Decoder}\n */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import {\n    combineCodec,\n    containsBytes,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { getBase16Decoder } from '@solana/codecs-strings';\nimport { SOLANA_ERROR__CODECS__INVALID_CONSTANT, SolanaError } from '@solana/errors';\n\n/**\n * Returns an encoder that always writes a predefined constant byte sequence.\n *\n * This encoder ensures that encoding always produces the specified byte array,\n * ignoring any input values.\n *\n * For more details, see {@link getConstantCodec}.\n *\n * @typeParam TConstant - The fixed byte sequence that will be written during encoding.\n *\n * @param constant - The predefined byte array to encode.\n * @returns A `FixedSizeEncoder<void, N>` where `N` is the length of the constant.\n *\n * @example\n * Encoding a constant magic number.\n * ```ts\n * const encoder = getConstantEncoder(new Uint8Array([1, 2, 3, 4]));\n *\n * const bytes = encoder.encode();\n * // 0x01020304\n * //    The predefined 4-byte constant.\n * ```\n *\n * @see {@link getConstantCodec}\n */\nexport function getConstantEncoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeEncoder<void, TConstant['length']> {\n    return createEncoder({\n        fixedSize: constant.length,\n        write: (_, bytes, offset) => {\n            bytes.set(constant, offset);\n            return offset + constant.length;\n        },\n    });\n}\n\n/**\n * Returns a decoder that verifies a predefined constant byte sequence.\n *\n * This decoder reads the next bytes and checks that they match the provided constant.\n * If the bytes differ, it throws an error.\n *\n * For more details, see {@link getConstantCodec}.\n *\n * @typeParam TConstant - The fixed byte sequence expected during decoding.\n *\n * @param constant - The predefined byte array to verify.\n * @returns A `FixedSizeDecoder<void, N>` where `N` is the length of the constant.\n *\n * @example\n * Decoding a constant magic number.\n * ```ts\n * const decoder = getConstantDecoder(new Uint8Array([1, 2, 3]));\n *\n * decoder.decode(new Uint8Array([1, 2, 3])); // Passes\n * decoder.decode(new Uint8Array([1, 2, 4])); // Throws an error\n * ```\n *\n * @see {@link getConstantCodec}\n */\nexport function getConstantDecoder<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeDecoder<void, TConstant['length']> {\n    return createDecoder({\n        fixedSize: constant.length,\n        read: (bytes, offset) => {\n            const base16 = getBase16Decoder();\n            if (!containsBytes(bytes, constant, offset)) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_CONSTANT, {\n                    constant,\n                    data: bytes,\n                    hexConstant: base16.decode(constant),\n                    hexData: base16.decode(bytes),\n                    offset,\n                });\n            }\n            return [undefined, offset + constant.length];\n        },\n    });\n}\n\n/**\n * Returns a codec that encodes and decodes a predefined constant byte sequence.\n *\n * - **Encoding:** Always writes the specified byte array.\n * - **Decoding:** Asserts that the next bytes match the constant, throwing an error if they do not.\n *\n * This is useful for encoding fixed byte patterns required in a binary format or to use in\n * conjunction with other codecs such as {@link getHiddenPrefixCodec} or {@link getHiddenSuffixCodec}.\n *\n * @typeParam TConstant - The fixed byte sequence to encode and verify during decoding.\n *\n * @param constant - The predefined byte array to encode and assert during decoding.\n * @returns A `FixedSizeCodec<void, void, N>` where `N` is the length of the constant.\n *\n * @example\n * Encoding and decoding a constant magic number.\n * ```ts\n * const codec = getConstantCodec(new Uint8Array([1, 2, 3]));\n *\n * codec.encode(); // 0x010203\n * codec.decode(new Uint8Array([1, 2, 3])); // Passes\n * codec.decode(new Uint8Array([1, 2, 4])); // Throws an error\n * ```\n *\n * @remarks\n * Separate {@link getConstantEncoder} and {@link getConstantDecoder} functions are available.\n *\n * ```ts\n * const bytes = getConstantEncoder(new Uint8Array([1, 2, 3])).encode();\n * getConstantDecoder(new Uint8Array([1, 2, 3])).decode(bytes);\n * ```\n *\n * @see {@link getConstantEncoder}\n * @see {@link getConstantDecoder}\n */\nexport function getConstantCodec<TConstant extends ReadonlyUint8Array>(\n    constant: TConstant,\n): FixedSizeCodec<void, void, TConstant['length']> {\n    return combineCodec(getConstantEncoder(constant), getConstantDecoder(constant));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidNumberOfItemsForCodec } from './assertions';\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\n/**\n * Infers the TypeScript type for a tuple that can be encoded using a tuple codec.\n *\n * This type maps each provided item encoder to its corresponding value type.\n *\n * @typeParam TItems - An array of encoders, each corresponding to a tuple element.\n */\ntype GetEncoderTypeFromItems<TItems extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\n/**\n * Infers the TypeScript type for a tuple that can be decoded using a tuple codec.\n *\n * This type maps each provided item decoder to its corresponding value type.\n *\n * @typeParam TItems - An array of decoders, each corresponding to a tuple element.\n */\ntype GetDecoderTypeFromItems<TItems extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TItems]: TItems[I] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Returns an encoder for tuples.\n *\n * This encoder serializes a fixed-size array (tuple) by encoding its items\n * sequentially using the provided item encoders.\n *\n * For more details, see {@link getTupleCodec}.\n *\n * @typeParam TItems - An array of encoders, each corresponding to a tuple element.\n *\n * @param items - The encoders for each item in the tuple.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding tuples.\n *\n * @example\n * Encoding a tuple with 2 items.\n * ```ts\n * const encoder = getTupleEncoder([fixCodecSize(getUtf8Encoder(), 5), getU8Encoder()]);\n *\n * const bytes = encoder.encode(['Alice', 42]);\n * // 0x416c6963652a\n * //   |          Second item (42)\n * //    First item (\"Alice\")\n * ```\n *\n * @see {@link getTupleCodec}\n */\nexport function getTupleEncoder<const TItems extends readonly FixedSizeEncoder<any>[]>(\n    items: TItems,\n): FixedSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): VariableSizeEncoder<GetEncoderTypeFromItems<TItems>>;\nexport function getTupleEncoder<const TItems extends readonly Encoder<any>[]>(\n    items: TItems,\n): Encoder<GetEncoderTypeFromItems<TItems>> {\n    type TFrom = GetEncoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      items.map((item, index) => getEncodedSize(value[index], item)).reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (value: TFrom, bytes, offset) => {\n            assertValidNumberOfItemsForCodec('tuple', items.length, value.length);\n            items.forEach((item, index) => {\n                offset = item.write(value[index], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder for tuples.\n *\n * This decoder deserializes a fixed-size array (tuple) by decoding its items\n * sequentially using the provided item decoders.\n *\n * For more details, see {@link getTupleCodec}.\n *\n * @typeParam TItems - An array of decoders, each corresponding to a tuple element.\n *\n * @param items - The decoders for each item in the tuple.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding tuples.\n *\n * @example\n * Decoding a tuple with 2 items.\n * ```ts\n * const decoder = getTupleDecoder([fixCodecSize(getUtf8Decoder(), 5), getU8Decoder()]);\n *\n * const tuple = decoder.decode(new Uint8Array([\n *   0x41,0x6c,0x69,0x63,0x65,0x2a\n * ]));\n * // ['Alice', 42]\n * ```\n *\n * @see {@link getTupleCodec}\n */\nexport function getTupleDecoder<const TItems extends readonly FixedSizeDecoder<any>[]>(\n    items: TItems,\n): FixedSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): VariableSizeDecoder<GetDecoderTypeFromItems<TItems>>;\nexport function getTupleDecoder<const TItems extends readonly Decoder<any>[]>(\n    items: TItems,\n): Decoder<GetDecoderTypeFromItems<TItems>> {\n    type TTo = GetDecoderTypeFromItems<TItems>;\n    const fixedSize = sumCodecSizes(items.map(getFixedSize));\n    const maxSize = sumCodecSizes(items.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const values = [] as Array<any> & TTo;\n            items.forEach(item => {\n                const [newValue, newOffset] = item.read(bytes, offset);\n                values.push(newValue);\n                offset = newOffset;\n            });\n            return [values, offset];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding tuples.\n *\n * This codec serializes tuples by encoding and decoding each item sequentially.\n *\n * Unlike the {@link getArrayCodec} codec, each item in the tuple has its own codec\n * and, therefore, can be of a different type.\n *\n * @typeParam TItems - An array of codecs, each corresponding to a tuple element.\n *\n * @param items - The codecs for each item in the tuple.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding tuples.\n *\n * @example\n * Encoding and decoding a tuple with 2 items.\n * ```ts\n * const codec = getTupleCodec([fixCodecSize(getUtf8Codec(), 5), getU8Codec()]);\n *\n * const bytes = codec.encode(['Alice', 42]);\n * // 0x416c6963652a\n * //   |          Second item (42)\n * //    First item (\"Alice\")\n *\n * const tuple = codec.decode(bytes);\n * // ['Alice', 42]\n * ```\n *\n * @remarks\n * Separate {@link getTupleEncoder} and {@link getTupleDecoder} functions are available.\n *\n * ```ts\n * const bytes = getTupleEncoder([fixCodecSize(getUtf8Encoder(), 5), getU8Encoder()])\n *   .encode(['Alice', 42]);\n *\n * const tuple = getTupleDecoder([fixCodecSize(getUtf8Decoder(), 5), getU8Decoder()])\n *   .decode(bytes);\n * ```\n *\n * @see {@link getTupleEncoder}\n * @see {@link getTupleDecoder}\n */\nexport function getTupleCodec<const TItems extends readonly FixedSizeCodec<any>[]>(\n    items: TItems,\n): FixedSizeCodec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): VariableSizeCodec<\n    GetEncoderTypeFromItems<TItems>,\n    GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>\n>;\nexport function getTupleCodec<const TItems extends readonly Codec<any>[]>(\n    items: TItems,\n): Codec<GetEncoderTypeFromItems<TItems>, GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>> {\n    return combineCodec(\n        getTupleEncoder(items),\n        getTupleDecoder(items) as Decoder<GetDecoderTypeFromItems<TItems> & GetEncoderTypeFromItems<TItems>>,\n    );\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\nimport { DrainOuterGeneric, getMaxSize, maxCodecSizes } from './utils';\n\n/**\n * Infers the TypeScript type for values that can be encoded using a union codec.\n *\n * This type maps the provided variant encoders to their corresponding value types.\n *\n * @typeParam TVariants - An array of encoders, each corresponding to a union variant.\n */\ntype GetEncoderTypeFromVariants<TVariants extends readonly Encoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Encoder<infer TFrom> ? TFrom : never;\n}>[number];\n\n/**\n * Infers the TypeScript type for values that can be decoded using a union codec.\n *\n * This type maps the provided variant decoders to their corresponding value types.\n *\n * @typeParam TVariants - An array of decoders, each corresponding to a union variant.\n */\ntype GetDecoderTypeFromVariants<TVariants extends readonly Decoder<any>[]> = DrainOuterGeneric<{\n    [I in keyof TVariants]: TVariants[I] extends Decoder<infer TFrom> ? TFrom : never;\n}>[number];\n\ntype UnionEncoder<TVariants extends readonly Encoder<unknown>[]> = TVariants extends readonly FixedSizeEncoder<any>[]\n    ? FixedSizeEncoder<GetEncoderTypeFromVariants<TVariants>>\n    : Encoder<GetEncoderTypeFromVariants<TVariants>>;\n\ntype UnionDecoder<TVariants extends readonly Decoder<unknown>[]> = TVariants extends readonly FixedSizeDecoder<any>[]\n    ? FixedSizeDecoder<GetDecoderTypeFromVariants<TVariants>>\n    : Decoder<GetDecoderTypeFromVariants<TVariants>>;\n\ntype UnionCodec<TVariants extends readonly Codec<unknown>[]> = TVariants extends readonly FixedSizeCodec<any>[]\n    ? FixedSizeCodec<\n          GetEncoderTypeFromVariants<TVariants>,\n          GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n      >\n    : Codec<\n          GetEncoderTypeFromVariants<TVariants>,\n          GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n      >;\n\n/**\n * Returns an encoder for union types.\n *\n * This encoder serializes values by selecting the correct variant encoder\n * based on the `getIndexFromValue` function.\n *\n * Unlike other codecs, this encoder does not store the variant index.\n * It is the user's responsibility to manage discriminators separately.\n *\n * For more details, see {@link getUnionCodec}.\n *\n * @typeParam TVariants - An array of encoders, each corresponding to a union variant.\n *\n * @param variants - The encoders for each variant of the union.\n * @param getIndexFromValue - A function that determines the variant index from the provided value.\n * @returns An `Encoder` for encoding union values.\n *\n * @example\n * Encoding a union of numbers and booleans.\n * ```ts\n * const encoder = getUnionEncoder(\n *   [getU16Encoder(), getBooleanEncoder()],\n *   value => (typeof value === 'number' ? 0 : 1)\n * );\n *\n * encoder.encode(42);\n * // 0x2a00\n * //    Encoded number (42) as `u16`\n *\n * encoder.encode(true);\n * // 0x01\n * //    Encoded boolean (`true`) as `u8`\n * ```\n *\n * @see {@link getUnionCodec}\n */\nexport function getUnionEncoder<const TVariants extends readonly Encoder<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n): UnionEncoder<TVariants> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const write: Encoder<TFrom>['write'] = (variant, bytes, offset) => {\n        const index = getIndexFromValue(variant);\n        assertValidVariantIndex(variants, index);\n        return variants[index].write(variant, bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createEncoder({ fixedSize, write }) as UnionEncoder<TVariants>;\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createEncoder({\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: variant => {\n            const index = getIndexFromValue(variant);\n            assertValidVariantIndex(variants, index);\n            return getEncodedSize(variant, variants[index]);\n        },\n        write,\n    }) as UnionEncoder<TVariants>;\n}\n\n/**\n * Returns a decoder for union types.\n *\n * This decoder deserializes values by selecting the correct variant decoder\n * based on the `getIndexFromBytes` function.\n *\n * Unlike other codecs, this decoder does not assume a stored discriminator.\n * It is the user's responsibility to manage discriminators separately.\n *\n * For more details, see {@link getUnionCodec}.\n *\n * @typeParam TVariants - An array of decoders, each corresponding to a union variant.\n *\n * @param variants - The decoders for each variant of the union.\n * @param getIndexFromBytes - A function that determines the variant index from the byte array.\n * @returns A `Decoder` for decoding union values.\n *\n * @example\n * Decoding a union of numbers and booleans.\n * ```ts\n * const decoder = getUnionDecoder(\n *   [getU16Decoder(), getBooleanDecoder()],\n *   (bytes, offset) => (bytes.length - offset > 1 ? 0 : 1)\n * );\n *\n * decoder.decode(new Uint8Array([0x2a, 0x00])); // 42\n * decoder.decode(new Uint8Array([0x01]));       // true\n * // Type is inferred as `number | boolean`\n * ```\n *\n * @see {@link getUnionCodec}\n */\nexport function getUnionDecoder<const TVariants extends readonly Decoder<any>[]>(\n    variants: TVariants,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): UnionDecoder<TVariants> {\n    type TTo = GetDecoderTypeFromVariants<TVariants>;\n    const fixedSize = getUnionFixedSize(variants);\n    const read: Decoder<TTo>['read'] = (bytes, offset) => {\n        const index = getIndexFromBytes(bytes, offset);\n        assertValidVariantIndex(variants, index);\n        return variants[index].read(bytes, offset);\n    };\n\n    if (fixedSize !== null) {\n        return createDecoder({ fixedSize, read }) as UnionDecoder<TVariants>;\n    }\n\n    const maxSize = getUnionMaxSize(variants);\n    return createDecoder({ ...(maxSize !== null ? { maxSize } : {}), read }) as UnionDecoder<TVariants>;\n}\n\n/**\n * Returns a codec for encoding and decoding union types.\n *\n * This codec serializes and deserializes union values by selecting the correct variant\n * based on the provided index functions.\n *\n * Unlike the {@link getDiscriminatedUnionCodec}, this codec does not assume a stored\n * discriminator and must be used with an explicit mechanism for managing discriminators.\n *\n * @typeParam TVariants - An array of codecs, each corresponding to a union variant.\n *\n * @param variants - The codecs for each variant of the union.\n * @param getIndexFromValue - A function that determines the variant index from the provided value.\n * @param getIndexFromBytes - A function that determines the variant index from the byte array.\n * @returns A `Codec` for encoding and decoding union values.\n *\n * @example\n * Encoding and decoding a union of numbers and booleans.\n * ```ts\n * const codec = getUnionCodec(\n *   [getU16Codec(), getBooleanCodec()],\n *   value => (typeof value === 'number' ? 0 : 1),\n *   (bytes, offset) => (bytes.length - offset > 1 ? 0 : 1)\n * );\n *\n * const bytes1 = codec.encode(42); // 0x2a00\n * const value1: number | boolean = codec.decode(bytes1); // 42\n *\n * const bytes2 = codec.encode(true); // 0x01\n * const value2: number | boolean = codec.decode(bytes2); // true\n * ```\n *\n * @remarks\n * If you need a codec that includes a stored discriminator,\n * consider using {@link getDiscriminatedUnionCodec}.\n *\n * Separate {@link getUnionEncoder} and {@link getUnionDecoder} functions are also available.\n *\n * ```ts\n * const bytes = getUnionEncoder(variantEncoders, getIndexFromValue).encode(42);\n * const value = getUnionDecoder(variantDecoders, getIndexFromBytes).decode(bytes);\n * ```\n *\n * @see {@link getUnionEncoder}\n * @see {@link getUnionDecoder}\n * @see {@link getDiscriminatedUnionCodec}\n */\nexport function getUnionCodec<const TVariants extends readonly Codec<any>[]>(\n    variants: TVariants,\n    getIndexFromValue: (value: GetEncoderTypeFromVariants<TVariants>) => number,\n    getIndexFromBytes: (bytes: ReadonlyUint8Array, offset: Offset) => number,\n): UnionCodec<TVariants> {\n    return combineCodec(\n        getUnionEncoder(variants, getIndexFromValue),\n        getUnionDecoder(variants as readonly Decoder<any>[], getIndexFromBytes) as Decoder<\n            GetDecoderTypeFromVariants<TVariants> & GetEncoderTypeFromVariants<TVariants>\n        >,\n    ) as UnionCodec<TVariants>;\n}\n\nfunction assertValidVariantIndex(variants: readonly unknown[], index: number) {\n    if (typeof variants[index] === 'undefined') {\n        throw new SolanaError(SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, {\n            maxRange: variants.length - 1,\n            minRange: 0,\n            variant: index,\n        });\n    }\n}\n\nfunction getUnionFixedSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    if (variants.length === 0) return 0;\n    if (!isFixedSize(variants[0])) return null;\n    const variantSize = variants[0].fixedSize;\n    const sameSizedVariants = variants.every(variant => isFixedSize(variant) && variant.fixedSize === variantSize);\n    return sameSizedVariants ? variantSize : null;\n}\n\nfunction getUnionMaxSize<const TVariants extends readonly (Decoder<any> | Encoder<any>)[]>(variants: TVariants) {\n    return maxCodecSizes(variants.map(variant => getMaxSize(variant)));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n} from '@solana/codecs-core';\nimport { getU8Decoder, getU8Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, SolanaError } from '@solana/errors';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { DrainOuterGeneric } from './utils';\n\n/**\n * Represents a discriminated union using a specific discriminator property.\n *\n * A discriminated union is a TypeScript-friendly way to represent Rust-like enums.\n * Each variant in the union is distinguished by a shared discriminator property.\n *\n * @typeParam TDiscriminatorProperty - The name of the discriminator property.\n * @typeParam TDiscriminatorValue - The type of the discriminator value.\n *\n * @example\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant\n * ```\n */\nexport type DiscriminatedUnion<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorValue extends string = string,\n> = {\n    [P in TDiscriminatorProperty]: TDiscriminatorValue;\n};\n\n/**\n * Extracts a variant from a discriminated union based on its discriminator value.\n *\n * @typeParam TUnion - The discriminated union type.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n * @typeParam TDiscriminatorValue - The specific variant to extract.\n *\n * @example\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' }\n *   | { __kind: 'Write'; fields: [string] }\n *   | { __kind: 'Move'; x: number; y: number };\n *\n * type ClickEvent = GetDiscriminatedUnionVariant<Message, '__kind', 'Move'>;\n * // -> { __kind: 'Move'; x: number; y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariant<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Extract<TUnion, DiscriminatedUnion<TDiscriminatorProperty, TDiscriminatorValue>>;\n\n/**\n * Extracts a variant from a discriminated union without its discriminator property.\n *\n * @typeParam TUnion - The discriminated union type.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n * @typeParam TDiscriminatorValue - The specific variant to extract.\n *\n * @example\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' }\n *   | { __kind: 'Write'; fields: [string] }\n *   | { __kind: 'Move'; x: number; y: number };\n *\n * type MoveContent = GetDiscriminatedUnionVariantContent<Message, '__kind', 'Move'>;\n * // -> { x: number; y: number }\n * ```\n */\nexport type GetDiscriminatedUnionVariantContent<\n    TUnion extends DiscriminatedUnion<TDiscriminatorProperty>,\n    TDiscriminatorProperty extends string,\n    TDiscriminatorValue extends TUnion[TDiscriminatorProperty],\n> = Omit<GetDiscriminatedUnionVariant<TUnion, TDiscriminatorProperty, TDiscriminatorValue>, TDiscriminatorProperty>;\n\n/**\n * Defines the configuration for discriminated union codecs.\n *\n * This configuration controls how the discriminator is stored and named.\n *\n * @typeParam TDiscriminatorProperty - The property name of the discriminator.\n * @typeParam TDiscriminatorSize - The codec used for the discriminator prefix.\n */\nexport type DiscriminatedUnionCodecConfig<\n    TDiscriminatorProperty extends string = '__kind',\n    TDiscriminatorSize = NumberCodec | NumberDecoder | NumberEncoder,\n> = {\n    /**\n     * The property name of the discriminator.\n     * @defaultValue `__kind`\n     */\n    discriminator?: TDiscriminatorProperty;\n    /**\n     * The codec used to encode/decode the discriminator prefix.\n     * @defaultValue `u8` prefix\n     */\n    size?: TDiscriminatorSize;\n};\n\ntype DiscriminatorValue = bigint | boolean | number | string | null | undefined;\ntype Variants<T> = readonly (readonly [DiscriminatorValue, T])[];\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\ntype GetEncoderTypeFromVariants<\n    TVariants extends Variants<Encoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Encoder<infer TFrom>\n        ? TFrom extends object\n            ? TFrom\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\ntype GetDecoderTypeFromVariants<\n    TVariants extends Variants<Decoder<any>>,\n    TDiscriminatorProperty extends string,\n> = DrainOuterGeneric<{\n    [I in ArrayIndices<TVariants>]: (TVariants[I][1] extends Decoder<infer TTo>\n        ? TTo extends object\n            ? TTo\n            : object\n        : never) & { [P in TDiscriminatorProperty]: TVariants[I][0] };\n}>[ArrayIndices<TVariants>];\n\ntype UnionEncoder<TVariants extends Variants<Encoder<unknown>>, TDiscriminatorProperty extends string> =\n    TVariants extends Variants<FixedSizeEncoder<any>>\n        ? FixedSizeEncoder<GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>>\n        : Encoder<GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>>;\n\ntype UnionDecoder<TVariants extends Variants<Decoder<unknown>>, TDiscriminatorProperty extends string> =\n    TVariants extends Variants<FixedSizeDecoder<any>>\n        ? FixedSizeDecoder<GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty>>\n        : Decoder<GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty>>;\n\ntype UnionCodec<TVariants extends Variants<Codec<unknown, unknown>>, TDiscriminatorProperty extends string> =\n    TVariants extends Variants<FixedSizeCodec<any, any>>\n        ? FixedSizeCodec<\n              GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>,\n              GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                  GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n          >\n        : Codec<\n              GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>,\n              GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                  GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n          >;\n\n/**\n * Returns an encoder for discriminated unions.\n *\n * This encoder serializes objects that follow the discriminated union pattern\n * by prefixing them with a numerical discriminator that represents their variant.\n *\n * Unlike {@link getUnionEncoder}, this encoder automatically extracts and processes\n * the discriminator property (default: `__kind`) from each variant.\n *\n * For more details, see {@link getDiscriminatedUnionCodec}.\n *\n * @typeParam TVariants - The variants of the discriminated union.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n *\n * @param variants - The variant encoders as `[discriminator, encoder]` pairs.\n * @param config - Configuration options for encoding.\n * @returns An `Encoder` for encoding discriminated union objects.\n *\n * @example\n * Encoding a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant.\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant.\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant.\n *\n * const messageEncoder = getDiscriminatedUnionEncoder([\n *   ['Quit', getUnitEncoder()],\n *   ['Write', getStructEncoder([['fields', getTupleEncoder([addCodecSizePrefix(getUtf8Encoder(), getU32Encoder())])]])],\n *   ['Move', getStructEncoder([['x', getI32Encoder()], ['y', getI32Encoder()]])]\n * ]);\n *\n * messageEncoder.encode({ __kind: 'Move', x: 5, y: 6 });\n * // 0x020500000006000000\n * //   | |        Field y (6)\n * //   |  Field x (5)\n * //    1-byte discriminator (Index 2  the \"Move\" variant)\n * ```\n *\n * @see {@link getDiscriminatedUnionCodec}\n */\nexport function getDiscriminatedUnionEncoder<\n    const TVariants extends Variants<Encoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberEncoder> = {},\n): UnionEncoder<TVariants, TDiscriminatorProperty> {\n    type TFrom = GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>;\n    const discriminatorProperty = (config.discriminator ?? '__kind') as TDiscriminatorProperty;\n    const prefix = config.size ?? getU8Encoder();\n    return getUnionEncoder(\n        variants.map(([, variant], index) =>\n            transformEncoder(getTupleEncoder([prefix, variant]), (value: TFrom): [number, TFrom] => [index, value]),\n        ),\n        value => getVariantDiscriminator(variants, value[discriminatorProperty]),\n    ) as UnionEncoder<TVariants, TDiscriminatorProperty>;\n}\n\n/**\n * Returns a decoder for discriminated unions.\n *\n * This decoder deserializes objects that follow the discriminated union pattern\n * by **reading a numerical discriminator** and mapping it to the corresponding variant.\n *\n * Unlike {@link getUnionDecoder}, this decoder automatically inserts the discriminator\n * property (default: `__kind`) into the decoded object.\n *\n * For more details, see {@link getDiscriminatedUnionCodec}.\n *\n * @typeParam TVariants - The variants of the discriminated union.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n *\n * @param variants - The variant decoders as `[discriminator, decoder]` pairs.\n * @param config - Configuration options for decoding.\n * @returns A `Decoder` for decoding discriminated union objects.\n *\n * @example\n * Decoding a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant.\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant.\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant.\n *\n * const messageDecoder = getDiscriminatedUnionDecoder([\n *   ['Quit', getUnitDecoder()],\n *   ['Write', getStructDecoder([['fields', getTupleDecoder([addCodecSizePrefix(getUtf8Decoder(), getU32Decoder())])]])],\n *   ['Move', getStructDecoder([['x', getI32Decoder()], ['y', getI32Decoder()]])]\n * ]);\n *\n * messageDecoder.decode(new Uint8Array([0x02,0x05,0x00,0x00,0x00,0x06,0x00,0x00,0x00]));\n * // { __kind: 'Move', x: 5, y: 6 }\n * ```\n *\n * @see {@link getDiscriminatedUnionCodec}\n */\nexport function getDiscriminatedUnionDecoder<\n    const TVariants extends Variants<Decoder<any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberDecoder> = {},\n): UnionDecoder<TVariants, TDiscriminatorProperty> {\n    const discriminatorProperty = config.discriminator ?? '__kind';\n    const prefix = config.size ?? getU8Decoder();\n    return getUnionDecoder(\n        variants.map(([discriminator, variant]) =>\n            transformDecoder(getTupleDecoder([prefix, variant]), ([, value]) => ({\n                [discriminatorProperty]: discriminator,\n                ...value,\n            })),\n        ),\n        (bytes, offset) => Number(prefix.read(bytes, offset)[0]),\n    ) as UnionDecoder<TVariants, TDiscriminatorProperty>;\n}\n\n/**\n * Returns a codec for encoding and decoding {@link DiscriminatedUnion}.\n *\n * A {@link DiscriminatedUnion} is a TypeScript representation of Rust-like enums, where\n * each variant is distinguished by a discriminator field (default: `__kind`).\n *\n * This codec inserts a numerical prefix to represent the variant index.\n *\n * @typeParam TVariants - The variants of the discriminated union.\n * @typeParam TDiscriminatorProperty - The property used as the discriminator.\n *\n * @param variants - The variant codecs as `[discriminator, codec]` pairs.\n * @param config - Configuration options for encoding/decoding.\n * @returns A `Codec` for encoding and decoding discriminated union objects.\n *\n * @example\n * Encoding and decoding a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Quit' } // Empty variant.\n *   | { __kind: 'Write'; fields: [string] } // Tuple variant.\n *   | { __kind: 'Move'; x: number; y: number }; // Struct variant.\n *\n * const messageCodec = getDiscriminatedUnionCodec([\n *   ['Quit', getUnitCodec()],\n *   ['Write', getStructCodec([['fields', getTupleCodec([addCodecSizePrefix(getUtf8Codec(), getU32Codec())])]])],\n *   ['Move', getStructCodec([['x', getI32Codec()], ['y', getI32Codec()]])]\n * ]);\n *\n * messageCodec.encode({ __kind: 'Move', x: 5, y: 6 });\n * // 0x020500000006000000\n * //   | |        Field y (6)\n * //   |  Field x (5)\n * //    1-byte discriminator (Index 2  the \"Move\" variant)\n *\n * const value = messageCodec.decode(bytes);\n * // { __kind: 'Move', x: 5, y: 6 }\n * ```\n *\n * @example\n * Using a `u32` discriminator instead of `u8`.\n * ```ts\n * const codec = getDiscriminatedUnionCodec([...], { size: getU32Codec() });\n *\n * codec.encode({ __kind: 'Quit' });\n * // 0x00000000\n * //   ------ 4-byte discriminator (Index 0)\n *\n * codec.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00]));\n * // { __kind: 'Quit' }\n * ```\n *\n * @example\n * Customizing the discriminator property.\n * ```ts\n * const codec = getDiscriminatedUnionCodec([...], { discriminator: 'message' });\n *\n * codec.encode({ message: 'Quit' }); // 0x00\n * codec.decode(new Uint8Array([0x00])); // { message: 'Quit' }\n * ```\n *\n * @remarks\n * Separate `getDiscriminatedUnionEncoder` and `getDiscriminatedUnionDecoder` functions are available.\n *\n * ```ts\n * const bytes = getDiscriminatedUnionEncoder(variantEncoders).encode({ __kind: 'Quit' });\n * const message = getDiscriminatedUnionDecoder(variantDecoders).decode(bytes);\n * ```\n *\n * @see {@link getDiscriminatedUnionEncoder}\n * @see {@link getDiscriminatedUnionDecoder}\n */\nexport function getDiscriminatedUnionCodec<\n    const TVariants extends Variants<Codec<any, any>>,\n    const TDiscriminatorProperty extends string = '__kind',\n>(\n    variants: TVariants,\n    config: DiscriminatedUnionCodecConfig<TDiscriminatorProperty, NumberCodec> = {},\n): UnionCodec<TVariants, TDiscriminatorProperty> {\n    return combineCodec(\n        getDiscriminatedUnionEncoder(variants, config) as Encoder<\n            GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n        >,\n        getDiscriminatedUnionDecoder(variants, config) as Decoder<\n            GetDecoderTypeFromVariants<TVariants, TDiscriminatorProperty> &\n                GetEncoderTypeFromVariants<TVariants, TDiscriminatorProperty>\n        >,\n    ) as UnionCodec<TVariants, TDiscriminatorProperty>;\n}\n\nfunction getVariantDiscriminator<const TVariants extends Variants<Decoder<any> | Encoder<any>>>(\n    variants: TVariants,\n    discriminatorValue: DiscriminatorValue,\n) {\n    const discriminator = variants.findIndex(([key]) => discriminatorValue === key);\n    if (discriminator < 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, {\n            value: discriminatorValue,\n            variants: variants.map(([key]) => key),\n        });\n    }\n    return discriminator;\n}\n","/**\n * Defines the \"lookup object\" of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * ```\n */\nexport type EnumLookupObject = { [key: string]: number | string };\n\n/**\n * Returns the allowed input for an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionInput = GetEnumFrom<Direction>; // \"Left\" | \"Right\" | 0 | 1\n * ```\n */\nexport type GetEnumFrom<TEnum extends EnumLookupObject> = TEnum[keyof TEnum] | keyof TEnum;\n\n/**\n * Returns all the available variants of an enum.\n *\n * @example\n * ```ts\n * enum Direction { Left, Right };\n * type DirectionOutput = GetEnumTo<Direction>; // 0 | 1\n * ```\n */\nexport type GetEnumTo<TEnum extends EnumLookupObject> = TEnum[keyof TEnum];\n\nexport function getEnumStats(constructor: EnumLookupObject) {\n    const numericalValues = [...new Set(Object.values(constructor).filter(v => typeof v === 'number'))].sort();\n    const enumRecord = Object.fromEntries(Object.entries(constructor).slice(numericalValues.length)) as Record<\n        string,\n        number | string\n    >;\n    const enumKeys = Object.keys(enumRecord);\n    const enumValues = Object.values(enumRecord);\n    const stringValues: string[] = [\n        ...new Set([...enumKeys, ...enumValues.filter((v): v is string => typeof v === 'string')]),\n    ];\n\n    return { enumKeys, enumRecord, enumValues, numericalValues, stringValues };\n}\n\nexport function getEnumIndexFromVariant({\n    enumKeys,\n    enumValues,\n    variant,\n}: {\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    variant: number | string | symbol;\n}): number {\n    const valueIndex = findLastIndex(enumValues, value => value === variant);\n    if (valueIndex >= 0) return valueIndex;\n    return enumKeys.findIndex(key => key === variant);\n}\n\nexport function getEnumIndexFromDiscriminator({\n    discriminator,\n    enumKeys,\n    enumValues,\n    useValuesAsDiscriminators,\n}: {\n    discriminator: number;\n    enumKeys: string[];\n    enumValues: (number | string)[];\n    useValuesAsDiscriminators: boolean;\n}): number {\n    if (!useValuesAsDiscriminators) {\n        return discriminator >= 0 && discriminator < enumKeys.length ? discriminator : -1;\n    }\n    return findLastIndex(enumValues, value => value === discriminator);\n}\n\nfunction findLastIndex<T>(array: Array<T>, predicate: (value: T, index: number, obj: T[]) => boolean): number {\n    let l = array.length;\n    while (l--) {\n        if (predicate(array[l], l, array)) return l;\n    }\n    return -1;\n}\n\nexport function formatNumericalValues(values: number[]): string {\n    if (values.length === 0) return '';\n    let range: [number, number] = [values[0], values[0]];\n    const ranges: string[] = [];\n    for (let index = 1; index < values.length; index++) {\n        const value = values[index];\n        if (range[1] + 1 === value) {\n            range[1] = value;\n        } else {\n            ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n            range = [value, value];\n        }\n    }\n    ranges.push(range[0] === range[1] ? `${range[0]}` : `${range[0]}-${range[1]}`);\n    return ranges.join(', ');\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    EnumLookupObject,\n    formatNumericalValues,\n    GetEnumFrom,\n    getEnumIndexFromDiscriminator,\n    getEnumIndexFromVariant,\n    getEnumStats,\n    GetEnumTo,\n} from './enum-helpers';\n\n/**\n * Defines the configuration options for enum codecs.\n *\n * The `size` option determines the numerical encoding used for the enum's discriminant.\n * By default, enums are stored as a `u8` (1 byte).\n *\n * The `useValuesAsDiscriminators` option allows mapping the actual enum values\n * as discriminators instead of using their positional index.\n *\n * @typeParam TDiscriminator - A number codec, encoder, or decoder used for the discriminant.\n */\nexport type EnumCodecConfig<TDiscriminator extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The codec used to encode/decode the enum discriminator.\n     * @defaultValue `u8` discriminator.\n     */\n    size?: TDiscriminator;\n\n    /**\n     * If set to `true`, the enum values themselves will be used as discriminators.\n     * This is only valid for numerical enum values.\n     *\n     * @defaultValue `false`\n     */\n    useValuesAsDiscriminators?: boolean;\n};\n\n/**\n * Returns an encoder for enums.\n *\n * This encoder serializes enums as a numerical discriminator.\n * By default, the discriminator is based on the positional index of the enum variants.\n *\n * For more details, see {@link getEnumCodec}.\n *\n * @typeParam TEnum - The TypeScript enum or object mapping enum keys to values.\n *\n * @param constructor - The constructor of the enum.\n * @param config - Configuration options for encoding the enum.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding enums.\n *\n * @example\n * Encoding enum values.\n * ```ts\n * enum Direction { Up,  Down, Left, Right }\n * const encoder = getEnumEncoder(Direction);\n *\n * encoder.encode(Direction.Up);    // 0x00\n * encoder.encode(Direction.Down);  // 0x01\n * encoder.encode(Direction.Left);  // 0x02\n * encoder.encode(Direction.Right); // 0x03\n * ```\n *\n * @see {@link getEnumCodec}\n */\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberEncoder>, 'size'>,\n): FixedSizeEncoder<GetEnumFrom<TEnum>, 1>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<GetEnumFrom<TEnum>, TSize>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<GetEnumFrom<TEnum>>;\nexport function getEnumEncoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberEncoder> = {},\n): Encoder<GetEnumFrom<TEnum>> {\n    const prefix = config.size ?? getU8Encoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues, stringValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformEncoder(prefix, (variant: GetEnumFrom<TEnum>): number => {\n        const index = getEnumIndexFromVariant({ enumKeys, enumValues, variant });\n        if (index < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, {\n                formattedNumericalValues: formatNumericalValues(numericalValues),\n                numericalValues,\n                stringValues,\n                variant,\n            });\n        }\n        return useValuesAsDiscriminators ? (enumValues[index] as number) : index;\n    });\n}\n\n/**\n * Returns a decoder for enums.\n *\n * This decoder deserializes enums from a numerical discriminator.\n * By default, the discriminator is based on the positional index of the enum variants.\n *\n * For more details, see {@link getEnumCodec}.\n *\n * @typeParam TEnum - The TypeScript enum or object mapping enum keys to values.\n *\n * @param constructor - The constructor of the enum.\n * @param config - Configuration options for decoding the enum.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding enums.\n *\n * @example\n * Decoding enum values.\n * ```ts\n * enum Direction { Up,  Down, Left, Right }\n * const decoder = getEnumDecoder(Direction);\n *\n * decoder.decode(new Uint8Array([0x00])); // Direction.Up\n * decoder.decode(new Uint8Array([0x01])); // Direction.Down\n * decoder.decode(new Uint8Array([0x02])); // Direction.Left\n * decoder.decode(new Uint8Array([0x03])); // Direction.Right\n * ```\n *\n * @see {@link getEnumCodec}\n */\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberDecoder>, 'size'>,\n): FixedSizeDecoder<GetEnumTo<TEnum>, 1>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<GetEnumTo<TEnum>, TSize>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<GetEnumTo<TEnum>>;\nexport function getEnumDecoder<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberDecoder> = {},\n): Decoder<GetEnumTo<TEnum>> {\n    const prefix = config.size ?? getU8Decoder();\n    const useValuesAsDiscriminators = config.useValuesAsDiscriminators ?? false;\n    const { enumKeys, enumValues, numericalValues } = getEnumStats(constructor);\n    if (useValuesAsDiscriminators && enumValues.some(value => typeof value === 'string')) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, {\n            stringValues: enumValues.filter((v): v is string => typeof v === 'string'),\n        });\n    }\n    return transformDecoder(prefix, (value: bigint | number): GetEnumTo<TEnum> => {\n        const discriminator = Number(value);\n        const index = getEnumIndexFromDiscriminator({\n            discriminator,\n            enumKeys,\n            enumValues,\n            useValuesAsDiscriminators,\n        });\n        if (index < 0) {\n            const validDiscriminators = useValuesAsDiscriminators\n                ? numericalValues\n                : [...Array(enumKeys.length).keys()];\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator,\n                formattedValidDiscriminators: formatNumericalValues(validDiscriminators),\n                validDiscriminators,\n            });\n        }\n        return enumValues[index] as GetEnumTo<TEnum>;\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding enums.\n *\n * This codec serializes enums as a numerical discriminator, allowing them\n * to be efficiently stored and reconstructed from binary data.\n *\n * By default, the discriminator is derived from the positional index\n * of the enum variant, but it can be configured to use the enum's numeric values instead.\n *\n * @typeParam TEnum - The TypeScript enum or object mapping enum keys to values.\n *\n * @param constructor - The constructor of the enum.\n * @param config - Configuration options for encoding and decoding the enum.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding enums.\n *\n * @example\n * Encoding and decoding enums using positional indexes.\n * ```ts\n * enum Direction { Up, Down, Left, Right }\n * const codec = getEnumCodec(Direction);\n *\n * codec.encode(Direction.Up);    // 0x00\n * codec.encode(Direction.Down);  // 0x01\n * codec.encode(Direction.Left);  // 0x02\n * codec.encode(Direction.Right); // 0x03\n *\n * codec.decode(new Uint8Array([0x00])); // Direction.Up\n * codec.decode(new Uint8Array([0x01])); // Direction.Down\n * codec.decode(new Uint8Array([0x02])); // Direction.Left\n * codec.decode(new Uint8Array([0x03])); // Direction.Right\n * ```\n *\n * @example\n * Encoding and decoding enums using their numeric values.\n * ```ts\n * enum GameDifficulty { Easy = 1, Normal = 4, Hard = 7, Expert = 9 }\n * const codec = getEnumCodec(GameDifficulty, { useValuesAsDiscriminators: true });\n *\n * codec.encode(GameDifficulty.Easy);   // 0x01\n * codec.encode(GameDifficulty.Normal); // 0x04\n * codec.encode(GameDifficulty.Hard);   // 0x07\n * codec.encode(GameDifficulty.Expert); // 0x09\n *\n * codec.decode(new Uint8Array([0x01])); // GameDifficulty.Easy\n * codec.decode(new Uint8Array([0x04])); // GameDifficulty.Normal\n * codec.decode(new Uint8Array([0x07])); // GameDifficulty.Hard\n * codec.decode(new Uint8Array([0x09])); // GameDifficulty.Expert\n * ```\n *\n * Note that, when using values as discriminators, the enum values must be numerical.\n * Otherwise, an error will be thrown.\n *\n * ```ts\n * enum GameDifficulty { Easy = 'EASY', Normal = 'NORMAL', Hard = 'HARD' }\n * getEnumCodec(GameDifficulty, { useValuesAsDiscriminators: true }); // Throws an error.\n * ```\n *\n * @example\n * Using a custom discriminator size.\n * ```ts\n * enum Status { Pending, Approved, Rejected }\n * const codec = getEnumCodec(Status, { size: getU16Codec() });\n *\n * codec.encode(Status.Pending);  // 0x0000\n * codec.encode(Status.Approved); // 0x0100\n * codec.encode(Status.Rejected); // 0x0200\n *\n * codec.decode(new Uint8Array([0x00, 0x00])); // Status.Pending\n * codec.decode(new Uint8Array([0x01, 0x00])); // Status.Approved\n * codec.decode(new Uint8Array([0x02, 0x00])); // Status.Rejected\n * ```\n *\n * @remarks\n * Separate {@link getEnumEncoder} and {@link getEnumDecoder} functions are available.\n *\n * ```ts\n * const bytes = getEnumEncoder(Direction).encode(Direction.Up);\n * const value = getEnumDecoder(Direction).decode(bytes);\n * ```\n *\n * @see {@link getEnumEncoder}\n * @see {@link getEnumDecoder}\n */\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: Omit<EnumCodecConfig<NumberCodec>, 'size'>,\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, 1>;\nexport function getEnumCodec<TEnum extends EnumLookupObject, TSize extends number>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>, TSize>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config?: EnumCodecConfig<NumberCodec>,\n): VariableSizeCodec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>>;\nexport function getEnumCodec<TEnum extends EnumLookupObject>(\n    constructor: TEnum,\n    config: EnumCodecConfig<NumberCodec> = {},\n): Codec<GetEnumFrom<TEnum>, GetEnumTo<TEnum>> {\n    return combineCodec(getEnumEncoder(constructor, config), getEnumDecoder(constructor, config));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Returns an encoder that prefixes encoded values with hidden data.\n *\n * This encoder applies a list of void encoders before encoding the main value.\n * The prefixed data is encoded before the main value without being exposed to the user.\n *\n * For more details, see {@link getHiddenPrefixCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param encoder - The encoder for the main value.\n * @param prefixedEncoders - A list of void encoders that produce the hidden prefix.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` that encodes the value with a hidden prefix.\n *\n * @example\n * Prefixing a value with constants.\n * ```ts\n * const encoder = getHiddenPrefixEncoder(getUtf8Encoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * encoder.encode('Hello');\n * // 0x01020304050648656c6c6f\n * //   |     |     -- Our encoded value (\"Hello\").\n * //   |     -- Our second hidden prefix.\n * //   -- Our first hidden prefix.\n * ```\n *\n * @see {@link getHiddenPrefixCodec}\n */\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenPrefixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    prefixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([...prefixedEncoders, encoder]) as Encoder<readonly [...void[], TFrom]>,\n        (value: TFrom) => [...prefixedEncoders.map(() => undefined), value] as const,\n    );\n}\n\n/**\n * Returns a decoder that skips hidden prefixed data before decoding the main value.\n *\n * This decoder applies a list of void decoders before decoding the main value.\n * The prefixed data is skipped during decoding without being exposed to the user.\n *\n * For more details, see {@link getHiddenPrefixCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param decoder - The decoder for the main value.\n * @param prefixedDecoders - A list of void decoders that produce the hidden prefix.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` that decodes values while ignoring the hidden prefix.\n *\n * @example\n * Decoding a value with prefixed constants.\n * ```ts\n * const decoder = getHiddenPrefixDecoder(getUtf8Decoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * decoder.decode(new Uint8Array([1, 2, 3, 4, 5, 6, 0x48, 0x65, 0x6C, 0x6C, 0x6F]));\n * // 'Hello'\n * ```\n *\n * @see {@link getHiddenPrefixCodec}\n */\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenPrefixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    prefixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([...prefixedDecoders, decoder]) as Decoder<readonly [...void[], TTo]>,\n        tuple => tuple[tuple.length - 1] as TTo,\n    );\n}\n\n/**\n * Returns a codec that encodes and decodes values with a hidden prefix.\n *\n * - **Encoding:** Prefixes the value with hidden data before encoding.\n * - **Decoding:** Skips the hidden prefix before decoding the main value.\n *\n * This is useful for any implicit metadata that should be present in\n * binary formats but omitted from the API.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param codec - The codec for the main value.\n * @param prefixedCodecs - A list of void codecs that produce the hidden prefix.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding values with a hidden prefix.\n *\n * @example\n * Encoding and decoding a value with prefixed constants.\n * ```ts\n * const codec = getHiddenPrefixCodec(getUtf8Codec(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * const bytes = codec.encode('Hello');\n * // 0x01020304050648656c6c6f\n * //   |     |     -- Our encoded value (\"Hello\").\n * //   |     -- Our second hidden prefix.\n * //   -- Our first hidden prefix.\n *\n * codec.decode(bytes);\n * // 'Hello'\n * ```\n *\n * @remarks\n * If all you need is padding zeroes before a value, consider using {@link padLeftCodec} instead.\n *\n * Separate {@link getHiddenPrefixEncoder} and {@link getHiddenPrefixDecoder} functions are available.\n *\n * ```ts\n * const bytes = getHiddenPrefixEncoder(getUtf8Encoder(), [\n *   getConstantEncoder(new Uint8Array([1, 2, 3])),\n *   getConstantEncoder(new Uint8Array([4, 5, 6])),\n * ]).encode('Hello');\n *\n * const value = getHiddenPrefixDecoder(getUtf8Decoder(), [\n *   getConstantDecoder(new Uint8Array([1, 2, 3])),\n *   getConstantDecoder(new Uint8Array([4, 5, 6])),\n * ]).decode(bytes);\n * ```\n *\n * @see {@link getHiddenPrefixEncoder}\n * @see {@link getHiddenPrefixDecoder}\n */\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenPrefixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenPrefixEncoder(codec, prefixedCodecs), getHiddenPrefixDecoder(codec, prefixedCodecs));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Returns an encoder that appends hidden data after the encoded value.\n *\n * This encoder applies a list of void encoders after encoding the main value.\n * The suffixed data is encoded after the main value without being exposed to the user.\n *\n * For more details, see {@link getHiddenSuffixCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param encoder - The encoder for the main value.\n * @param suffixedEncoders - A list of void encoders that produce the hidden suffix.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` that encodes the value with a hidden suffix.\n *\n * @example\n * Suffixing a value with constants.\n * ```ts\n * const encoder = getHiddenSuffixEncoder(getUtf8Encoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * encoder.encode('Hello');\n * // 0x48656c6c6f010203040506\n * //   |         |     -- Our second hidden suffix.\n * //   |         -- Our first hidden suffix.\n * //   -- Our encoded value (\"Hello\").\n * ```\n *\n * @see {@link getHiddenSuffixCodec}\n */\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    suffixedEncoders: readonly FixedSizeEncoder<void>[],\n): FixedSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): VariableSizeEncoder<TFrom>;\nexport function getHiddenSuffixEncoder<TFrom>(\n    encoder: Encoder<TFrom>,\n    suffixedEncoders: readonly Encoder<void>[],\n): Encoder<TFrom> {\n    return transformEncoder(\n        getTupleEncoder([encoder, ...suffixedEncoders]) as Encoder<readonly [TFrom, ...void[]]>,\n        (value: TFrom) => [value, ...suffixedEncoders.map(() => undefined)] as const,\n    );\n}\n\n/**\n * Returns a decoder that skips hidden suffixed data after decoding the main value.\n *\n * This decoder applies a list of void decoders after decoding the main value.\n * The suffixed data is skipped during decoding without being exposed to the user.\n *\n * For more details, see {@link getHiddenSuffixCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param decoder - The decoder for the main value.\n * @param suffixedDecoders - A list of void decoders that produce the hidden suffix.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` that decodes values while ignoring the hidden suffix.\n *\n * @example\n * Decoding a value with suffixed constants.\n * ```ts\n * const decoder = getHiddenSuffixDecoder(getUtf8Decoder(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * decoder.decode(new Uint8Array([0x48, 0x65, 0x6C, 0x6C, 0x6F, 1, 2, 3, 4, 5, 6]));\n * // 'Hello'\n * ```\n *\n * @see {@link getHiddenSuffixCodec}\n */\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    suffixedDecoders: readonly FixedSizeDecoder<void>[],\n): FixedSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): VariableSizeDecoder<TTo>;\nexport function getHiddenSuffixDecoder<TTo>(\n    decoder: Decoder<TTo>,\n    suffixedDecoders: readonly Decoder<void>[],\n): Decoder<TTo> {\n    return transformDecoder(\n        getTupleDecoder([decoder, ...suffixedDecoders]) as Decoder<readonly [TTo, ...void[]]>,\n        tuple => tuple[0],\n    );\n}\n\n/**\n * Returns a codec that encodes and decodes values with a hidden suffix.\n *\n * - **Encoding:** Appends hidden data after encoding the main value.\n * - **Decoding:** Skips the hidden suffix after decoding the main value.\n *\n * This is useful for any implicit metadata that should be present in\n * binary formats but omitted from the API.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param codec - The codec for the main value.\n * @param suffixedCodecs - A list of void codecs that produce the hidden suffix.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding values with a hidden suffix.\n *\n * @example\n * Encoding and decoding a value with suffixed constants.\n * ```ts\n * const codec = getHiddenSuffixCodec(getUtf8Codec(), [\n *   getConstantCodec(new Uint8Array([1, 2, 3])),\n *   getConstantCodec(new Uint8Array([4, 5, 6])),\n * ]);\n *\n * const bytes = codec.encode('Hello');\n * // 0x48656c6c6f010203040506\n * //   |         |     -- Our second hidden suffix.\n * //   |         -- Our first hidden suffix.\n * //   -- Our encoded value (\"Hello\").\n *\n * codec.decode(bytes);\n * // 'Hello'\n * ```\n *\n * @remarks\n * If all you need is padding zeroes after a value, consider using {@link padRightCodec} instead.\n *\n * Separate {@link getHiddenSuffixEncoder} and {@link getHiddenSuffixDecoder} functions are available.\n *\n * ```ts\n * const bytes = getHiddenSuffixEncoder(getUtf8Encoder(), [\n *   getConstantEncoder(new Uint8Array([1, 2, 3])),\n *   getConstantEncoder(new Uint8Array([4, 5, 6])),\n * ]).encode('Hello');\n *\n * const value = getHiddenSuffixDecoder(getUtf8Decoder(), [\n *   getConstantDecoder(new Uint8Array([1, 2, 3])),\n *   getConstantDecoder(new Uint8Array([4, 5, 6])),\n * ]).decode(bytes);\n * ```\n *\n * @see {@link getHiddenSuffixEncoder}\n * @see {@link getHiddenSuffixDecoder}\n */\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    suffixedCodecs: readonly FixedSizeCodec<void>[],\n): FixedSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): VariableSizeCodec<TFrom, TTo>;\nexport function getHiddenSuffixCodec<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    suffixedCodecs: readonly Codec<void>[],\n): Codec<TFrom, TTo> {\n    return combineCodec(getHiddenSuffixEncoder(codec, suffixedCodecs), getHiddenSuffixDecoder(codec, suffixedCodecs));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\nimport {\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\n/**\n * Defines the configuration options for literal union codecs.\n *\n * A literal union codec encodes values from a predefined set of literals.\n * The `size` option determines the numerical encoding used for the discriminant.\n * By default, literals are stored as a `u8` (1 byte).\n *\n * @typeParam TDiscriminator - A number codec, encoder, or decoder used for the discriminant.\n */\nexport type LiteralUnionCodecConfig<TDiscriminator = NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The codec used to encode/decode the discriminator.\n     * @defaultValue `u8` discriminator.\n     */\n    size?: TDiscriminator;\n};\n\ntype Variant = bigint | boolean | number | string | null | undefined;\ntype GetTypeFromVariants<TVariants extends readonly Variant[]> = TVariants[number];\n\n/**\n * Returns an encoder for literal unions.\n *\n * This encoder serializes a value from a predefined set of literals\n * as a numerical index representing its position in the `variants` array.\n *\n * For more details, see {@link getLiteralUnionCodec}.\n *\n * @typeParam TVariants - A tuple of allowed literal values.\n *\n * @param variants - The possible literal values for the union.\n * @param config - Configuration options for encoding the literal union.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding literal unions.\n *\n * @example\n * Encoding a union of string literals.\n * ```ts\n * type Size = 'small' | 'medium' | 'large';\n * const sizeEncoder = getLiteralUnionEncoder(['small', 'medium', 'large']);\n *\n * sizeEncoder.encode('small');  // 0x00\n * sizeEncoder.encode('medium'); // 0x01\n * sizeEncoder.encode('large');  // 0x02\n * ```\n *\n * @see {@link getLiteralUnionCodec}\n */\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n): FixedSizeEncoder<GetTypeFromVariants<TVariants>, 1>;\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[], TSize extends number>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberEncoder> & { size: FixedSizeNumberEncoder<TSize> },\n): FixedSizeEncoder<GetTypeFromVariants<TVariants>, TSize>;\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config?: LiteralUnionCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<GetTypeFromVariants<TVariants>>;\nexport function getLiteralUnionEncoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberEncoder> = {},\n): Encoder<GetTypeFromVariants<TVariants>> {\n    const discriminator = config.size ?? getU8Encoder();\n    return transformEncoder(discriminator, variant => {\n        const index = variants.indexOf(variant);\n        if (index < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT, {\n                value: variant,\n                variants,\n            });\n        }\n        return index;\n    });\n}\n\n/**\n * Returns a decoder for literal unions.\n *\n * This decoder deserializes a numerical index into a corresponding\n * value from a predefined set of literals.\n *\n * For more details, see {@link getLiteralUnionCodec}.\n *\n * @typeParam TVariants - A tuple of allowed literal values.\n *\n * @param variants - The possible literal values for the union.\n * @param config - Configuration options for decoding the literal union.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding literal unions.\n *\n * @example\n * Decoding a union of string literals.\n * ```ts\n * type Size = 'small' | 'medium' | 'large';\n * const sizeDecoder = getLiteralUnionDecoder(['small', 'medium', 'large']);\n *\n * sizeDecoder.decode(new Uint8Array([0x00])); // 'small'\n * sizeDecoder.decode(new Uint8Array([0x01])); // 'medium'\n * sizeDecoder.decode(new Uint8Array([0x02])); // 'large'\n * ```\n *\n * @see {@link getLiteralUnionCodec}\n */\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n): FixedSizeDecoder<GetTypeFromVariants<TVariants>, 1>;\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[], TSize extends number>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberDecoder> & { size: FixedSizeNumberDecoder<TSize> },\n): FixedSizeDecoder<GetTypeFromVariants<TVariants>, TSize>;\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config?: LiteralUnionCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<GetTypeFromVariants<TVariants>>;\nexport function getLiteralUnionDecoder<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberDecoder> = {},\n): Decoder<GetTypeFromVariants<TVariants>> {\n    const discriminator = config.size ?? getU8Decoder();\n    return transformDecoder(discriminator, (index: bigint | number) => {\n        if (index < 0 || index >= variants.length) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE, {\n                discriminator: index,\n                maxRange: variants.length - 1,\n                minRange: 0,\n            });\n        }\n        return variants[Number(index)];\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding literal unions.\n *\n * A literal union codec serializes and deserializes values\n * from a predefined set of literals, using a numerical index\n * to represent each value in the `variants` array.\n *\n * This allows efficient storage and retrieval of common\n * predefined values such as enum-like structures in TypeScript.\n *\n * @typeParam TVariants - A tuple of allowed literal values.\n *\n * @param variants - The possible literal values for the union.\n * @param config - Configuration options for encoding and decoding the literal union.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding literal unions.\n *\n * @example\n * Encoding and decoding a union of string literals.\n * ```ts\n * type Size = 'small' | 'medium' | 'large';\n * const sizeCodec = getLiteralUnionCodec(['small', 'medium', 'large']);\n *\n * sizeCodec.encode('small');  // 0x00\n * sizeCodec.encode('medium'); // 0x01\n * sizeCodec.encode('large');  // 0x02\n *\n * sizeCodec.decode(new Uint8Array([0x00])); // 'small'\n * sizeCodec.decode(new Uint8Array([0x01])); // 'medium'\n * sizeCodec.decode(new Uint8Array([0x02])); // 'large'\n * ```\n *\n * @example\n * Encoding and decoding a union of number literals.\n * ```ts\n * type Level = 10 | 20 | 30;\n * const levelCodec = getLiteralUnionCodec([10, 20, 30]);\n *\n * levelCodec.encode(10);  // 0x00\n * levelCodec.encode(20);  // 0x01\n * levelCodec.encode(30);  // 0x02\n *\n * levelCodec.decode(new Uint8Array([0x00])); // 10\n * levelCodec.decode(new Uint8Array([0x01])); // 20\n * levelCodec.decode(new Uint8Array([0x02])); // 30\n * ```\n *\n * @example\n * Using a custom discriminator size with different variant types.\n * ```ts\n * type MaybeBoolean = false | true | \"either\";\n * const codec = getLiteralUnionCodec([false, true, 'either'], { size: getU16Codec() });\n *\n * codec.encode(false);    // 0x0000\n * codec.encode(true);     // 0x0100\n * codec.encode('either'); // 0x0200\n *\n * codec.decode(new Uint8Array([0x00, 0x00])); // false\n * codec.decode(new Uint8Array([0x01, 0x00])); // true\n * codec.decode(new Uint8Array([0x02, 0x00])); // 'either'\n * ```\n *\n * @remarks\n * Separate {@link getLiteralUnionEncoder} and {@link getLiteralUnionDecoder} functions are available.\n *\n * ```ts\n * const bytes = getLiteralUnionEncoder(['red', 'green', 'blue']).encode('green');\n * const value = getLiteralUnionDecoder(['red', 'green', 'blue']).decode(bytes);\n * ```\n *\n * @see {@link getLiteralUnionEncoder}\n * @see {@link getLiteralUnionDecoder}\n */\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n): FixedSizeCodec<GetTypeFromVariants<TVariants>, GetTypeFromVariants<TVariants>, 1>;\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[], TSize extends number>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberCodec> & { size: FixedSizeNumberCodec<TSize> },\n): FixedSizeCodec<GetTypeFromVariants<TVariants>, GetTypeFromVariants<TVariants>, TSize>;\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config?: LiteralUnionCodecConfig<NumberCodec>,\n): VariableSizeCodec<GetTypeFromVariants<TVariants>>;\nexport function getLiteralUnionCodec<const TVariants extends readonly Variant[]>(\n    variants: TVariants,\n    config: LiteralUnionCodecConfig<NumberCodec> = {},\n): Codec<GetTypeFromVariants<TVariants>> {\n    return combineCodec(getLiteralUnionEncoder(variants, config), getLiteralUnionDecoder(variants, config));\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\n\n/**\n * Defines the configuration options for map codecs.\n *\n * The `size` option determines how the number of entries in the map is stored.\n * It can be:\n * - A {@link NumberCodec} to prefix the map with its size.\n * - A fixed number of entries.\n * - `'remainder'`, which infers the number of entries based on the remaining bytes.\n *   This option is only available for fixed-size keys and values.\n *\n * @typeParam TPrefix - A number codec, encoder, or decoder used for the size prefix.\n */\nexport type MapCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size of the map.\n     * @defaultValue u32 prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Returns an encoder for maps.\n *\n * This encoder serializes maps where the keys and values are encoded\n * using the provided key and value encoders. The number of entries\n * is determined by the `size` configuration.\n *\n * For more details, see {@link getMapCodec}.\n *\n * @typeParam TFromKey - The type of the keys before encoding.\n * @typeParam TFromValue - The type of the values before encoding.\n *\n * @param key - The encoder for the map's keys.\n * @param value - The encoder for the map's values.\n * @param config - Configuration options for encoding the map.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding maps.\n *\n * @example\n * Encoding a map with a `u32` size prefix.\n * ```ts\n * const encoder = getMapEncoder(fixCodecSize(getUtf8Encoder(), 5), getU8Encoder());\n * const bytes = encoder.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x02000000616c6963652a626f62000005\n * //   |       |         | |          Value (5)\n * //   |       |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |       |          Value (42)\n * //   |        Key (\"alice\", 5 bytes fixed)\n * //    4-byte prefix (2 entries)\n * ```\n *\n * @see {@link getMapCodec}\n */\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>, 0>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: FixedSizeEncoder<TFromKey>,\n    value: FixedSizeEncoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config?: MapCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Map<TFromKey, TFromValue>>;\nexport function getMapEncoder<TFromKey, TFromValue>(\n    key: Encoder<TFromKey>,\n    value: Encoder<TFromValue>,\n    config: MapCodecConfig<NumberEncoder> = {},\n): Encoder<Map<TFromKey, TFromValue>> {\n    return transformEncoder(\n        getArrayEncoder(getTupleEncoder([key, value]), config as object),\n        (map: Map<TFromKey, TFromValue>): [TFromKey, TFromValue][] => [...map.entries()],\n    );\n}\n\n/**\n * Returns a decoder for maps.\n *\n * This decoder deserializes maps where the keys and values are decoded\n * using the provided key and value decoders. The number of entries\n * is determined by the `size` configuration.\n *\n * For more details, see {@link getMapCodec}.\n *\n * @typeParam TToKey - The type of the keys after decoding.\n * @typeParam TToValue - The type of the values after decoding.\n *\n * @param key - The decoder for the map's keys.\n * @param value - The decoder for the map's values.\n * @param config - Configuration options for decoding the map.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding maps.\n *\n * @example\n * Decoding a map with a `u32` size prefix.\n * ```ts\n * const decoder = getMapDecoder(fixCodecSize(getUtf8Decoder(), 5), getU8Decoder());\n * const map = decoder.decode(new Uint8Array([\n *   0x02,0x00,0x00,0x00,0x61,0x6c,0x69,0x63,0x65,0x2a,0x62,0x6f,0x62,0x00,0x00,0x05\n * ]));\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @see {@link getMapCodec}\n */\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Map<TToKey, TToValue>, 0>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: FixedSizeDecoder<TToKey>,\n    value: FixedSizeDecoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config?: MapCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Map<TToKey, TToValue>>;\nexport function getMapDecoder<TToKey, TToValue>(\n    key: Decoder<TToKey>,\n    value: Decoder<TToValue>,\n    config: MapCodecConfig<NumberDecoder> = {},\n): Decoder<Map<TToKey, TToValue>> {\n    return transformDecoder(\n        getArrayDecoder(getTupleDecoder([key, value]), config as object) as Decoder<[TToKey, TToValue][]>,\n        (entries: [TToKey, TToValue][]): Map<TToKey, TToValue> => new Map(entries),\n    );\n}\n\n/**\n * Returns a codec for encoding and decoding maps.\n *\n * This codec serializes maps where the key/value pairs are encoded\n * and decoded one after another using the provided key and value codecs.\n * The number of entries is determined by the `size` configuration and\n * defaults to a `u32` size prefix.\n *\n * @typeParam TFromKey - The type of the keys before encoding.\n * @typeParam TFromValue - The type of the values before encoding.\n * @typeParam TToKey - The type of the keys after decoding.\n * @typeParam TToValue - The type of the values after decoding.\n *\n * @param key - The codec for the map's keys.\n * @param value - The codec for the map's values.\n * @param config - Configuration options for encoding and decoding the map.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding maps.\n *\n * @example\n * Encoding and decoding a map with a `u32` size prefix (default).\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec());\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x02000000616c6963652a626f62000005\n * //   |       |         | |          Value (5)\n * //   |       |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |       |          Value (42)\n * //   |        Key (\"alice\", 5 bytes fixed)\n * //    4-byte prefix (2 entries)\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @example\n * Encoding and decoding a map with a `u16` size prefix.\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec(), { size: getU16Codec() });\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x0200616c6963652a626f62000005\n * //   |   |         | |          Value (5)\n * //   |   |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |   |          Value (42)\n * //   |    Key (\"alice\", 5 bytes fixed)\n * //    2-byte prefix (2 entries)\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @example\n * Encoding and decoding a fixed-size map.\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec(), { size: 2 });\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x616c6963652a626f62000005\n * //   |         | |          Value (5)\n * //   |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |          Value (42)\n * //    Key (\"alice\", 5 bytes fixed)\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @example\n * Encoding and decoding a map with remainder size.\n * ```ts\n * const codec = getMapCodec(fixCodecSize(getUtf8Codec(), 5), getU8Codec(), { size: 'remainder' });\n * const bytes = codec.encode(new Map([['alice', 42], ['bob', 5]]));\n * // 0x616c6963652a626f62000005\n * //   |         | |          Value (5)\n * //   |         |  Key (\"bob\", 5 bytes fixed, null-padded)\n * //   |          Value (42)\n * //    Key (\"alice\", 5 bytes fixed)\n * // No size prefix, the size is inferred from the remaining bytes.\n *\n * const map = codec.decode(bytes);\n * // new Map([['alice', 42], ['bob', 5]])\n * ```\n *\n * @remarks\n * Separate {@link getMapEncoder} and {@link getMapDecoder} functions are available.\n * ```ts\n * const bytes = getMapEncoder(fixCodecSize(getUtf8Encoder(), 5), getU8Encoder()).encode(new Map([['alice', 42]]));\n * const map = getMapDecoder(fixCodecSize(getUtf8Decoder(), 5), getU8Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getMapEncoder}\n * @see {@link getMapDecoder}\n */\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>, 0>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: FixedSizeCodec<TFromKey, TToKey>,\n    value: FixedSizeCodec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config?: MapCodecConfig<NumberCodec>,\n): VariableSizeCodec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>>;\nexport function getMapCodec<\n    TFromKey,\n    TFromValue,\n    TToKey extends TFromKey = TFromKey,\n    TToValue extends TFromValue = TFromValue,\n>(\n    key: Codec<TFromKey, TToKey>,\n    value: Codec<TFromValue, TToValue>,\n    config: MapCodecConfig<NumberCodec> = {},\n): Codec<Map<TFromKey, TFromValue>, Map<TToKey, TToValue>> {\n    return combineCodec(getMapEncoder(key, value, config as object), getMapDecoder(key, value, config as object));\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\n/**\n * Returns an encoder for `void` values.\n *\n * This encoder writes nothing to the byte array and has a fixed size of 0 bytes.\n * It is useful when working with structures that require a no-op encoder,\n * such as empty variants in {@link getDiscriminatedUnionEncoder}.\n *\n * For more details, see {@link getUnitCodec}.\n *\n * @returns A `FixedSizeEncoder<void, 0>`, representing an empty encoder.\n *\n * @example\n * Encoding a `void` value.\n * ```ts\n * getUnitEncoder().encode(undefined); // Produces an empty byte array.\n * ```\n *\n * @see {@link getUnitCodec}\n */\nexport function getUnitEncoder(): FixedSizeEncoder<void, 0> {\n    return createEncoder({\n        fixedSize: 0,\n        write: (_value, _bytes, offset) => offset,\n    });\n}\n\n/**\n * Returns a decoder for `void` values.\n *\n * This decoder always returns `undefined` and has a fixed size of 0 bytes.\n * It is useful when working with structures that require a no-op decoder,\n * such as empty variants in {@link getDiscriminatedUnionDecoder}.\n *\n * For more details, see {@link getUnitCodec}.\n *\n * @returns A `FixedSizeDecoder<void, 0>`, representing an empty decoder.\n *\n * @example\n * Decoding a `void` value.\n * ```ts\n * getUnitDecoder().decode(anyBytes); // Returns `undefined`.\n * ```\n *\n * @see {@link getUnitCodec}\n */\nexport function getUnitDecoder(): FixedSizeDecoder<void, 0> {\n    return createDecoder({\n        fixedSize: 0,\n        read: (_bytes: ReadonlyUint8Array | Uint8Array, offset) => [undefined, offset],\n    });\n}\n\n/**\n * Returns a codec for `void` values.\n *\n * This codec does nothing when encoding or decoding and has a fixed size of 0 bytes.\n * Namely, it always returns `undefined` when decoding and produces an empty byte array when encoding.\n *\n * This can be useful when working with structures that require a no-op codec,\n * such as empty variants in {@link getDiscriminatedUnionCodec}.\n *\n * @returns A `FixedSizeCodec<void, void, 0>`, representing an empty codec.\n *\n * @example\n * Encoding and decoding a `void` value.\n * ```ts\n * const codec = getUnitCodec();\n *\n * codec.encode(undefined); // Produces an empty byte array.\n * codec.decode(new Uint8Array([])); // Returns `undefined`.\n * ```\n *\n * @example\n * Using unit codecs as empty variants in a discriminated union.\n * ```ts\n * type Message =\n *   | { __kind: 'Enter' }\n *   | { __kind: 'Leave' }\n *   | { __kind: 'Move'; x: number; y: number };\n *\n * const messageCodec = getDiscriminatedUnionCodec([\n *   ['Enter', getUnitCodec()], // <- No-op codec for empty data\n *   ['Leave', getUnitCodec()], // <- No-op codec for empty data\n *   ['Move', getStructCodec([...])]\n * ]);\n * ```\n *\n * @remarks\n * Separate {@link getUnitEncoder} and {@link getUnitDecoder} functions are available.\n *\n * ```ts\n * const bytes = getUnitEncoder().encode();\n * const value = getUnitDecoder().decode(bytes);\n * ```\n *\n * @see {@link getUnitEncoder}\n * @see {@link getUnitDecoder}\n */\nexport function getUnitCodec(): FixedSizeCodec<void, void, 0> {\n    return combineCodec(getUnitEncoder(), getUnitDecoder());\n}\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    containsBytes,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { getBooleanDecoder, getBooleanEncoder } from './boolean';\nimport { getConstantDecoder, getConstantEncoder } from './constant';\nimport { getTupleDecoder, getTupleEncoder } from './tuple';\nimport { getUnionDecoder, getUnionEncoder } from './union';\nimport { getUnitDecoder, getUnitEncoder } from './unit';\n\n/**\n * Defines the configuration options for nullable codecs.\n *\n * This configuration controls how nullable values are encoded and decoded.\n *\n * By default, nullable values are prefixed with a `u8` (0 = `null`, 1 = present).\n * The `noneValue` and `prefix` options allow customizing this behavior.\n *\n * @typeParam TPrefix - A number codec, encoder, or decoder used as the presence prefix.\n *\n * @see {@link getNullableEncoder}\n * @see {@link getNullableDecoder}\n * @see {@link getNullableCodec}\n */\nexport type NullableCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Specifies how `null` values are represented in the encoded data.\n     *\n     * - By default, `null` values are omitted from encoding.\n     * - `'zeroes'`: The bytes allocated for the value are filled with zeroes. This requires a fixed-size codec.\n     * - Custom byte array: `null` values are replaced with a predefined byte sequence. This results in a variable-size codec.\n     *\n     * @defaultValue No explicit `noneValue` is used; `null` values are omitted.\n     */\n    noneValue?: ReadonlyUint8Array | 'zeroes';\n\n    /**\n     * The presence prefix used to distinguish between `null` and present values.\n     *\n     * - By default, a `u8` prefix is used (`0 = null`, `1 = present`).\n     * - Custom number codec: Allows defining a different number size for the prefix.\n     * - `null`: No prefix is used; `noneValue` (if provided) determines `null`.\n     *   If no `noneValue` is set, `null` is identified by the absence of bytes.\n     *\n     * @defaultValue `u8` prefix.\n     */\n    prefix?: TPrefix | null;\n};\n\n/**\n * Returns an encoder for optional values, allowing `null` values to be encoded.\n *\n * This encoder serializes an optional value using a configurable approach:\n * - By default, a `u8` prefix is used (0 = `null`, 1 = present). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, `null` values are encoded as zeroes.\n * - If `noneValue` is a byte array, `null` values are replaced with the provided constant.\n *\n * For more details, see {@link getNullableCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param item - The encoder for the value that may be present.\n * @param config - Configuration options for encoding optional values.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding nullable values.\n *\n * @example\n * Encoding an optional number.\n * ```ts\n * const encoder = getNullableEncoder(getU32Encoder());\n *\n * encoder.encode(null); // 0x00\n * encoder.encode(42);   // 0x012a000000\n * ```\n *\n * @see {@link getNullableCodec}\n */\nexport function getNullableEncoder<TFrom, TSize extends number>(\n    item: FixedSizeEncoder<TFrom, TSize>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeEncoder<TFrom | null, TSize>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<FixedSizeNumberEncoder> & { noneValue: 'zeroes' },\n): FixedSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> & { noneValue: 'zeroes' },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: NullableCodecConfig<NumberEncoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeEncoder<TFrom | null>;\nexport function getNullableEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: NullableCodecConfig<NumberEncoder> = {},\n): Encoder<TFrom | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformEncoder(getUnitEncoder(), (_boolean: boolean) => undefined);\n        }\n        return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitEncoder();\n        }\n        return getConstantEncoder(config.noneValue);\n    })();\n\n    return getUnionEncoder(\n        [\n            transformEncoder(getTupleEncoder([prefix, noneValue]), (_value: null): [boolean, void] => [\n                false,\n                undefined,\n            ]),\n            transformEncoder(getTupleEncoder([prefix, item]), (value: TFrom): [boolean, TFrom] => [true, value]),\n        ],\n        variant => Number(variant !== null),\n    );\n}\n\n/**\n * Returns a decoder for optional values, allowing `null` values to be recognized.\n *\n * This decoder deserializes an optional value using a configurable approach:\n * - By default, a `u8` prefix is used (0 = `null`, 1 = present). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, `null` values are identified by zeroes.\n * - If `noneValue` is a byte array, `null` values match the provided constant.\n *\n * For more details, see {@link getNullableCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The decoder for the value that may be present.\n * @param config - Configuration options for decoding optional values.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding nullable values.\n *\n * @example\n * Decoding an optional number.\n * ```ts\n * const decoder = getNullableDecoder(getU32Decoder());\n *\n * decoder.decode(new Uint8Array([0x00])); // null\n * decoder.decode(new Uint8Array([0x01, 0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @see {@link getNullableCodec}\n */\nexport function getNullableDecoder<TTo, TSize extends number>(\n    item: FixedSizeDecoder<TTo, TSize>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeDecoder<TTo | null, TSize>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<FixedSizeNumberDecoder> & { noneValue: 'zeroes' },\n): FixedSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> & { noneValue: 'zeroes' },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: NullableCodecConfig<NumberDecoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeDecoder<TTo | null>;\nexport function getNullableDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: NullableCodecConfig<NumberDecoder> = {},\n): Decoder<TTo | null> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformDecoder(getUnitDecoder(), () => false);\n        }\n        return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitDecoder();\n        }\n        return getConstantDecoder(config.noneValue);\n    })();\n\n    return getUnionDecoder(\n        [\n            transformDecoder(getTupleDecoder([prefix, noneValue]), () => null),\n            transformDecoder(getTupleDecoder([prefix, item]), ([, value]): TTo => value),\n        ],\n        (bytes, offset) => {\n            if (config.prefix === null && !config.noneValue) {\n                return Number(offset < bytes.length);\n            }\n            if (config.prefix === null && config.noneValue != null) {\n                const zeroValue =\n                    config.noneValue === 'zeroes' ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n                return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n            }\n            return Number(prefix.read(bytes, offset)[0]);\n        },\n    );\n}\n\n/**\n * Returns a codec for encoding and decoding optional values, allowing `null` values to be handled.\n *\n * This codec serializes and deserializes optional values using a configurable approach:\n * - By default, a `u8` prefix is used (0 = `null`, 1 = present).\n *    This can be customized using a custom number codec or even disabled by setting\n *    the `prefix` to `null`.\n * - If `noneValue: 'zeroes'` is set, `null` values are encoded/decoded as zeroes.\n * - If `noneValue` is a byte array, `null` values are represented by the provided constant.\n *\n * For more details on the configuration options, see {@link NullableCodecConfig}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The codec for the value that may be present.\n * @param config - Configuration options for encoding and decoding optional values.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding nullable values.\n *\n * @example\n * Encoding and decoding an optional number using a `u8` prefix (default).\n * ```ts\n * const codec = getNullableCodec(getU32Codec());\n *\n * codec.encode(null); // 0x00\n * codec.encode(42);   // 0x012a000000\n *\n * codec.decode(new Uint8Array([0x00])); // null\n * codec.decode(new Uint8Array([0x01, 0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @example\n * Encoding and decoding an optional number using a fixed-size codec, by filling `null` values with zeroes.\n * ```ts\n * const codec = getNullableCodec(getU32Codec(), { noneValue: 'zeroes' });\n *\n * codec.encode(null); // 0x0000000000\n * codec.encode(42);   // 0x012a000000\n *\n * codec.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00])); // null\n * codec.decode(new Uint8Array([0x01, 0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @example\n * Encoding and decoding `null` values with zeroes and no prefix.\n * ```ts\n * const codec = getNullableCodec(getU32Codec(), {\n *   noneValue: 'zeroes',\n *   prefix: null,\n * });\n *\n * codec.encode(null); // 0x00000000\n * codec.encode(42);   // 0x2a000000\n *\n * codec.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00])); // null\n * codec.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @example\n * Encoding and decoding `null` values with a custom byte sequence and no prefix.\n * ```ts\n * const codec = getNullableCodec(getU16Codec(), {\n *   noneValue: new Uint8Array([0xff, 0xff]),\n *   prefix: null,\n * });\n *\n * codec.encode(null); // 0xffff\n * codec.encode(42); // 0x2a00\n *\n * codec.decode(new Uint8Array([0xff, 0xff])); // null\n * codec.decode(new Uint8Array([0x2a, 0x00])); // 42\n * ```\n *\n * @example\n * Identifying `null` values by the absence of bytes.\n * ```ts\n * const codec = getNullableCodec(getU16Codec(), { prefix: null });\n *\n * codec.encode(null); // Empty bytes\n * codec.encode(42); // 0x2a00\n *\n * codec.decode(new Uint8Array([])); // null\n * codec.decode(new Uint8Array([0x2a, 0x00])); // 42\n * ```\n *\n * @remarks\n * Separate {@link getNullableEncoder} and {@link getNullableDecoder} functions are available.\n *\n * ```ts\n * const bytes = getNullableEncoder(getU32Encoder()).encode(42);\n * const value = getNullableDecoder(getU32Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getNullableEncoder}\n * @see {@link getNullableDecoder}\n */\nexport function getNullableCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    item: FixedSizeCodec<TFrom, TTo, TSize>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeCodec<TFrom | null, TTo | null, TSize>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<FixedSizeNumberCodec> & { noneValue: 'zeroes' },\n): FixedSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> & { noneValue: 'zeroes' },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeCodec<TFrom | null, TTo | null>;\nexport function getNullableCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: NullableCodecConfig<NumberCodec> = {},\n): Codec<TFrom | null, TTo | null> {\n    type ConfigCast = NullableCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array };\n    return combineCodec(\n        getNullableEncoder<TFrom>(item, config as ConfigCast),\n        getNullableDecoder<TTo>(item, config as ConfigCast),\n    );\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\n\nimport { ArrayLikeCodecSize, getArrayDecoder, getArrayEncoder } from './array';\n\n/**\n * Defines the configuration options for set codecs.\n *\n * This configuration allows specifying how the size of the set is encoded.\n * The `size` option can be:\n *\n * - A {@link NumberCodec}, {@link NumberEncoder}, or {@link NumberDecoder} to store the size as a prefix.\n * - A fixed number of items, enforcing a strict length.\n * - The string `'remainder'` to infer the set size from the remaining bytes (only for fixed-size items).\n *\n * @typeParam TPrefix - The type used for encoding the size of the set.\n */\nexport type SetCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * The size encoding strategy for the set.\n     * @defaultValue Uses a `u32` prefix.\n     */\n    size?: ArrayLikeCodecSize<TPrefix>;\n};\n\n/**\n * Returns an encoder for sets of items.\n *\n * This encoder serializes `Set<T>` values by encoding each item using the provided item encoder.\n * The number of items is stored as a prefix using a `u32` codec by default.\n *\n * For more details, see {@link getSetCodec}.\n *\n * @typeParam TFrom - The type of the items in the set before encoding.\n *\n * @param item - The encoder to use for each set item.\n * @param config - Optional configuration specifying the size strategy.\n * @returns An `Encoder<Set<TFrom>>` for encoding sets of items.\n *\n * @example\n * Encoding a set of `u8` numbers.\n * ```ts\n * const encoder = getSetEncoder(getU8Encoder());\n * const bytes = encoder.encode(new Set([1, 2, 3]));\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix indicating 3 items.\n * ```\n *\n * @see {@link getSetCodec}\n */\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: 0 },\n): FixedSizeEncoder<Set<TFrom>, 0>;\nexport function getSetEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> & { size: number },\n): FixedSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: SetCodecConfig<NumberEncoder>,\n): VariableSizeEncoder<Set<TFrom>>;\nexport function getSetEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: SetCodecConfig<NumberEncoder> = {},\n): Encoder<Set<TFrom>> {\n    return transformEncoder(getArrayEncoder(item, config as object), (set: Set<TFrom>): TFrom[] => [...set]);\n}\n\n/**\n * Returns a decoder for sets of items.\n *\n * This decoder deserializes a `Set<T>` from a byte array by decoding each item using the provided item decoder.\n * The number of items is determined by a `u32` size prefix by default.\n *\n * For more details, see {@link getSetCodec}.\n *\n * @typeParam TTo - The type of the items in the set after decoding.\n *\n * @param item - The decoder to use for each set item.\n * @param config - Optional configuration specifying the size strategy.\n * @returns A `Decoder<Set<TTo>>` for decoding sets of items.\n *\n * @example\n * Decoding a set of `u8` numbers.\n * ```ts\n * const decoder = getSetDecoder(getU8Decoder());\n * const value = decoder.decode(new Uint8Array([0x03, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03]));\n * // new Set([1, 2, 3])\n * ```\n *\n * @see {@link getSetCodec}\n */\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: 0 },\n): FixedSizeDecoder<Set<TTo>, 0>;\nexport function getSetDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: SetCodecConfig<NumberDecoder> & { size: number },\n): FixedSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: SetCodecConfig<NumberDecoder>,\n): VariableSizeDecoder<Set<TTo>>;\nexport function getSetDecoder<TTo>(item: Decoder<TTo>, config: SetCodecConfig<NumberDecoder> = {}): Decoder<Set<TTo>> {\n    return transformDecoder(getArrayDecoder(item, config as object), (entries: TTo[]): Set<TTo> => new Set(entries));\n}\n\n/**\n * Returns a codec for encoding and decoding sets of items.\n *\n * This codec serializes `Set<T>` values by encoding each item using the provided item codec.\n * The number of items is stored as a prefix using a `u32` codec by default.\n *\n * @typeParam TFrom - The type of the items in the set before encoding.\n * @typeParam TTo - The type of the items in the set after decoding.\n *\n * @param item - The codec to use for each set item.\n * @param config - Optional configuration specifying the size strategy.\n * @returns A `Codec<Set<TFrom>, Set<TTo>>` for encoding and decoding sets.\n *\n * @example\n * Encoding and decoding a set of `u8` numbers.\n * ```ts\n * const codec = getSetCodec(getU8Codec());\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x03000000010203\n * //   |       -- 3 items of 1 byte each.\n * //   -- 4-byte prefix indicating 3 items.\n *\n * const value = codec.decode(bytes);\n * // new Set([1, 2, 3])\n * ```\n *\n * @example\n * Using a `u16` prefix for size.\n * ```ts\n * const codec = getSetCodec(getU8Codec(), { size: getU16Codec() });\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x0300010203\n * //   |   -- 3 items of 1 byte each.\n * //   -- 2-byte prefix indicating 3 items.\n * ```\n *\n * @example\n * Using a fixed-size set.\n * ```ts\n * const codec = getSetCodec(getU8Codec(), { size: 3 });\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x010203\n * //   -- Exactly 3 items of 1 byte each.\n * ```\n *\n * @example\n * Using remainder to infer set size.\n * ```ts\n * const codec = getSetCodec(getU8Codec(), { size: 'remainder' });\n * const bytes = codec.encode(new Set([1, 2, 3]));\n * // 0x010203\n * //   -- 3 items of 1 byte each. The size is inferred from the remaining bytes.\n * ```\n *\n * @remarks\n * Separate {@link getSetEncoder} and {@link getSetDecoder} functions are available.\n *\n * ```ts\n * const bytes = getSetEncoder(getU8Encoder()).encode(new Set([1, 2, 3]));\n * const value = getSetDecoder(getU8Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getSetEncoder}\n * @see {@link getSetDecoder}\n */\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: 0 },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>, 0>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> & { size: number },\n): FixedSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: SetCodecConfig<NumberCodec>,\n): VariableSizeCodec<Set<TFrom>, Set<TTo>>;\nexport function getSetCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: SetCodecConfig<NumberCodec> = {},\n): Codec<Set<TFrom>, Set<TTo>> {\n    return combineCodec(getSetEncoder(item, config as object), getSetDecoder(item, config as object));\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport {\n    Codec,\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { DrainOuterGeneric, getFixedSize, getMaxSize, sumCodecSizes } from './utils';\n\n/**\n * Represents a collection of named fields used in struct codecs.\n *\n * Each field is defined as a tuple containing:\n * - A string key representing the field name.\n * - A codec used to encode and decode the field's value.\n *\n * @typeParam T - The codec type used for each field.\n */\ntype Fields<T> = readonly (readonly [string, T])[];\n\ntype ArrayIndices<T extends readonly unknown[]> = Exclude<Partial<T>['length'], T['length']> & number;\n\n/**\n * Infers the TypeScript type for an object that can be encoded using a struct codec.\n *\n * This type maps the provided field encoders to their corresponding values.\n *\n * @typeParam TFields - The fields of the struct, each paired with an encoder.\n */\ntype GetEncoderTypeFromFields<TFields extends Fields<Encoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Encoder<infer TFrom> ? TFrom : never;\n}>;\n\n/**\n * Infers the TypeScript type for an object that can be decoded using a struct codec.\n *\n * This type maps the provided field decoders to their corresponding values.\n *\n * @typeParam TFields - The fields of the struct, each paired with a decoder.\n */\ntype GetDecoderTypeFromFields<TFields extends Fields<Decoder<any>>> = DrainOuterGeneric<{\n    [I in ArrayIndices<TFields> as TFields[I][0]]: TFields[I][1] extends Decoder<infer TTo> ? TTo : never;\n}>;\n\n/**\n * Returns an encoder for custom objects.\n *\n * This encoder serializes an object by encoding its fields sequentially,\n * using the provided field encoders.\n *\n * For more details, see {@link getStructCodec}.\n *\n * @typeParam TFields - The fields of the struct, each paired with an encoder.\n *\n * @param fields - The name and encoder of each field.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding custom objects.\n *\n * @example\n * Encoding a custom struct.\n * ```ts\n * const encoder = getStructEncoder([\n *   ['name', fixCodecSize(getUtf8Encoder(), 5)],\n *   ['age', getU8Encoder()]\n * ]);\n *\n * const bytes = encoder.encode({ name: 'Alice', age: 42 });\n * // 0x416c6963652a\n * //   |          Age (42)\n * //    Name (\"Alice\")\n * ```\n *\n * @see {@link getStructCodec}\n */\nexport function getStructEncoder<const TFields extends Fields<FixedSizeEncoder<any>>>(\n    fields: TFields,\n): FixedSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): VariableSizeEncoder<GetEncoderTypeFromFields<TFields>>;\nexport function getStructEncoder<const TFields extends Fields<Encoder<any>>>(\n    fields: TFields,\n): Encoder<GetEncoderTypeFromFields<TFields>> {\n    type TFrom = GetEncoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createEncoder({\n        ...(fixedSize === null\n            ? {\n                  getSizeFromValue: (value: TFrom) =>\n                      fields\n                          .map(([key, codec]) => getEncodedSize(value[key as keyof TFrom], codec))\n                          .reduce((all, one) => all + one, 0),\n                  maxSize,\n              }\n            : { fixedSize }),\n        write: (struct: TFrom, bytes, offset) => {\n            fields.forEach(([key, codec]) => {\n                offset = codec.write(struct[key as keyof TFrom], bytes, offset);\n            });\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder for custom objects.\n *\n * This decoder deserializes an object by decoding its fields sequentially,\n * using the provided field decoders.\n *\n * For more details, see {@link getStructCodec}.\n *\n * @typeParam TFields - The fields of the struct, each paired with a decoder.\n *\n * @param fields - The name and decoder of each field.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding custom objects.\n *\n * @example\n * Decoding a custom struct.\n * ```ts\n * const decoder = getStructDecoder([\n *   ['name', fixCodecSize(getUtf8Decoder(), 5)],\n *   ['age', getU8Decoder()]\n * ]);\n *\n * const struct = decoder.decode(new Uint8Array([\n *   0x41,0x6c,0x69,0x63,0x65,0x2a\n * ]));\n * // { name: 'Alice', age: 42 }\n * ```\n *\n * @see {@link getStructCodec}\n */\nexport function getStructDecoder<const TFields extends Fields<FixedSizeDecoder<any>>>(\n    fields: TFields,\n): FixedSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): VariableSizeDecoder<GetDecoderTypeFromFields<TFields>>;\nexport function getStructDecoder<const TFields extends Fields<Decoder<any>>>(\n    fields: TFields,\n): Decoder<GetDecoderTypeFromFields<TFields>> {\n    type TTo = GetDecoderTypeFromFields<TFields>;\n    const fieldCodecs = fields.map(([, codec]) => codec);\n    const fixedSize = sumCodecSizes(fieldCodecs.map(getFixedSize));\n    const maxSize = sumCodecSizes(fieldCodecs.map(getMaxSize)) ?? undefined;\n\n    return createDecoder({\n        ...(fixedSize === null ? { maxSize } : { fixedSize }),\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const struct = {} as TTo;\n            fields.forEach(([key, codec]) => {\n                const [value, newOffset] = codec.read(bytes, offset);\n                offset = newOffset;\n                struct[key as keyof TTo] = value;\n            });\n            return [struct, offset];\n        },\n    });\n}\n\n/**\n * Returns a codec for encoding and decoding custom objects.\n *\n * This codec serializes objects by encoding and decoding each field sequentially.\n *\n * @typeParam TFields - The fields of the struct, each paired with a codec.\n *\n * @param fields - The name and codec of each field.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding custom objects.\n *\n * @example\n * Encoding and decoding a custom struct.\n * ```ts\n * const codec = getStructCodec([\n *   ['name', fixCodecSize(getUtf8Codec(), 5)],\n *   ['age', getU8Codec()]\n * ]);\n *\n * const bytes = codec.encode({ name: 'Alice', age: 42 });\n * // 0x416c6963652a\n * //   |          Age (42)\n * //    Name (\"Alice\")\n *\n * const struct = codec.decode(bytes);\n * // { name: 'Alice', age: 42 }\n * ```\n *\n * @remarks\n * Separate {@link getStructEncoder} and {@link getStructDecoder} functions are available.\n *\n * ```ts\n * const bytes = getStructEncoder([\n *   ['name', fixCodecSize(getUtf8Encoder(), 5)],\n *   ['age', getU8Encoder()]\n * ]).encode({ name: 'Alice', age: 42 });\n *\n * const struct = getStructDecoder([\n *   ['name', fixCodecSize(getUtf8Decoder(), 5)],\n *   ['age', getU8Decoder()]\n * ]).decode(bytes);\n * ```\n *\n * @see {@link getStructEncoder}\n * @see {@link getStructDecoder}\n */\nexport function getStructCodec<const TFields extends Fields<FixedSizeCodec<any>>>(\n    fields: TFields,\n): FixedSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): VariableSizeCodec<\n    GetEncoderTypeFromFields<TFields>,\n    GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>\n>;\nexport function getStructCodec<const TFields extends Fields<Codec<any>>>(\n    fields: TFields,\n): Codec<GetEncoderTypeFromFields<TFields>, GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>> {\n    return combineCodec(\n        getStructEncoder(fields),\n        getStructDecoder(fields) as Decoder<GetDecoderTypeFromFields<TFields> & GetEncoderTypeFromFields<TFields>>,\n    );\n}\n","import { SolanaError, SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH, SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH, SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH, SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY, SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL } from '@solana/errors';\n\n// src/add-codec-sentinel.ts\n\n// src/bytes.ts\nvar mergeBytes = (byteArrays) => {\n  const nonEmptyByteArrays = byteArrays.filter((arr) => arr.length);\n  if (nonEmptyByteArrays.length === 0) {\n    return byteArrays.length ? byteArrays[0] : new Uint8Array();\n  }\n  if (nonEmptyByteArrays.length === 1) {\n    return nonEmptyByteArrays[0];\n  }\n  const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  nonEmptyByteArrays.forEach((arr) => {\n    result.set(arr, offset);\n    offset += arr.length;\n  });\n  return result;\n};\nfunction padBytes(bytes, length) {\n  if (bytes.length >= length) return bytes;\n  const paddedBytes = new Uint8Array(length).fill(0);\n  paddedBytes.set(bytes);\n  return paddedBytes;\n}\nvar fixBytes = (bytes, length) => padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\nfunction containsBytes(data, bytes, offset) {\n  const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n  if (slice.length !== bytes.length) return false;\n  return bytes.every((b, i) => b === slice[i]);\n}\nfunction getEncodedSize(value, encoder) {\n  return \"fixedSize\" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\nfunction createEncoder(encoder) {\n  return Object.freeze({\n    ...encoder,\n    encode: (value) => {\n      const bytes = new Uint8Array(getEncodedSize(value, encoder));\n      encoder.write(value, bytes, 0);\n      return bytes;\n    }\n  });\n}\nfunction createDecoder(decoder) {\n  return Object.freeze({\n    ...decoder,\n    decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0]\n  });\n}\nfunction createCodec(codec) {\n  return Object.freeze({\n    ...codec,\n    decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n    encode: (value) => {\n      const bytes = new Uint8Array(getEncodedSize(value, codec));\n      codec.write(value, bytes, 0);\n      return bytes;\n    }\n  });\n}\nfunction isFixedSize(codec) {\n  return \"fixedSize\" in codec && typeof codec.fixedSize === \"number\";\n}\nfunction assertIsFixedSize(codec) {\n  if (!isFixedSize(codec)) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n  }\n}\nfunction isVariableSize(codec) {\n  return !isFixedSize(codec);\n}\nfunction assertIsVariableSize(codec) {\n  if (!isVariableSize(codec)) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n  }\n}\nfunction combineCodec(encoder, decoder) {\n  if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n  }\n  if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n      decoderFixedSize: decoder.fixedSize,\n      encoderFixedSize: encoder.fixedSize\n    });\n  }\n  if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n      decoderMaxSize: decoder.maxSize,\n      encoderMaxSize: encoder.maxSize\n    });\n  }\n  return {\n    ...decoder,\n    ...encoder,\n    decode: decoder.decode,\n    encode: encoder.encode,\n    read: decoder.read,\n    write: encoder.write\n  };\n}\n\n// src/add-codec-sentinel.ts\nfunction addEncoderSentinel(encoder, sentinel) {\n  const write = (value, bytes, offset) => {\n    const encoderBytes = encoder.encode(value);\n    if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n        encodedBytes: encoderBytes,\n        hexEncodedBytes: hexBytes(encoderBytes),\n        hexSentinel: hexBytes(sentinel),\n        sentinel\n      });\n    }\n    bytes.set(encoderBytes, offset);\n    offset += encoderBytes.length;\n    bytes.set(sentinel, offset);\n    offset += sentinel.length;\n    return offset;\n  };\n  if (isFixedSize(encoder)) {\n    return createEncoder({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write });\n  }\n  return createEncoder({\n    ...encoder,\n    ...encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {},\n    getSizeFromValue: (value) => encoder.getSizeFromValue(value) + sentinel.length,\n    write\n  });\n}\nfunction addDecoderSentinel(decoder, sentinel) {\n  const read = (bytes, offset) => {\n    const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n    const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n    if (sentinelIndex === -1) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n        decodedBytes: candidateBytes,\n        hexDecodedBytes: hexBytes(candidateBytes),\n        hexSentinel: hexBytes(sentinel),\n        sentinel\n      });\n    }\n    const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n    return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];\n  };\n  if (isFixedSize(decoder)) {\n    return createDecoder({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });\n  }\n  return createDecoder({\n    ...decoder,\n    ...decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {},\n    read\n  });\n}\nfunction addCodecSentinel(codec, sentinel) {\n  return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\nfunction findSentinelIndex(bytes, sentinel) {\n  return bytes.findIndex((byte, index, arr) => {\n    if (sentinel.length === 1) return byte === sentinel[0];\n    return containsBytes(arr, sentinel, index);\n  });\n}\nfunction hexBytes(bytes) {\n  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {\n  if (bytes.length - offset <= 0) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n      codecDescription\n    });\n  }\n}\nfunction assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {\n  const bytesLength = bytes.length - offset;\n  if (bytesLength < expected) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n      bytesLength,\n      codecDescription,\n      expected\n    });\n  }\n}\nfunction assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {\n  if (offset < 0 || offset > bytesLength) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n      bytesLength,\n      codecDescription,\n      offset\n    });\n  }\n}\n\n// src/add-codec-size-prefix.ts\nfunction addEncoderSizePrefix(encoder, prefix) {\n  const write = (value, bytes, offset) => {\n    const encoderBytes = encoder.encode(value);\n    offset = prefix.write(encoderBytes.length, bytes, offset);\n    bytes.set(encoderBytes, offset);\n    return offset + encoderBytes.length;\n  };\n  if (isFixedSize(prefix) && isFixedSize(encoder)) {\n    return createEncoder({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });\n  }\n  const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n  const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;\n  const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n  return createEncoder({\n    ...encoder,\n    ...maxSize !== null ? { maxSize } : {},\n    getSizeFromValue: (value) => {\n      const encoderSize = getEncodedSize(value, encoder);\n      return getEncodedSize(encoderSize, prefix) + encoderSize;\n    },\n    write\n  });\n}\nfunction addDecoderSizePrefix(decoder, prefix) {\n  const read = (bytes, offset) => {\n    const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n    const size = Number(bigintSize);\n    offset = decoderOffset;\n    if (offset > 0 || bytes.length > size) {\n      bytes = bytes.slice(offset, offset + size);\n    }\n    assertByteArrayHasEnoughBytesForCodec(\"addDecoderSizePrefix\", size, bytes);\n    return [decoder.decode(bytes), offset + size];\n  };\n  if (isFixedSize(prefix) && isFixedSize(decoder)) {\n    return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });\n  }\n  const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n  const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;\n  const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n  return createDecoder({ ...decoder, ...maxSize !== null ? { maxSize } : {}, read });\n}\nfunction addCodecSizePrefix(codec, prefix) {\n  return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\nfunction createDecoderThatConsumesEntireByteArray(decoder) {\n  return createDecoder({\n    ...decoder,\n    read(bytes, offset) {\n      const [value, newOffset] = decoder.read(bytes, offset);\n      if (bytes.length > newOffset) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY, {\n          expectedLength: newOffset,\n          numExcessBytes: bytes.length - newOffset\n        });\n      }\n      return [value, newOffset];\n    }\n  });\n}\n\n// src/fix-codec-size.ts\nfunction fixEncoderSize(encoder, fixedBytes) {\n  return createEncoder({\n    fixedSize: fixedBytes,\n    write: (value, bytes, offset) => {\n      const variableByteArray = encoder.encode(value);\n      const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n      bytes.set(fixedByteArray, offset);\n      return offset + fixedBytes;\n    }\n  });\n}\nfunction fixDecoderSize(decoder, fixedBytes) {\n  return createDecoder({\n    fixedSize: fixedBytes,\n    read: (bytes, offset) => {\n      assertByteArrayHasEnoughBytesForCodec(\"fixCodecSize\", fixedBytes, bytes, offset);\n      if (offset > 0 || bytes.length > fixedBytes) {\n        bytes = bytes.slice(offset, offset + fixedBytes);\n      }\n      if (isFixedSize(decoder)) {\n        bytes = fixBytes(bytes, decoder.fixedSize);\n      }\n      const [value] = decoder.read(bytes, 0);\n      return [value, offset + fixedBytes];\n    }\n  });\n}\nfunction fixCodecSize(codec, fixedBytes) {\n  return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n\n// src/offset-codec.ts\nfunction offsetEncoder(encoder, config) {\n  return createEncoder({\n    ...encoder,\n    write: (value, bytes, preOffset) => {\n      const wrapBytes = (offset) => modulo(offset, bytes.length);\n      const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPreOffset, bytes.length);\n      const postOffset = encoder.write(value, bytes, newPreOffset);\n      const newPostOffset = config.postOffset ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes }) : postOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPostOffset, bytes.length);\n      return newPostOffset;\n    }\n  });\n}\nfunction offsetDecoder(decoder, config) {\n  return createDecoder({\n    ...decoder,\n    read: (bytes, preOffset) => {\n      const wrapBytes = (offset) => modulo(offset, bytes.length);\n      const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPreOffset, bytes.length);\n      const [value, postOffset] = decoder.read(bytes, newPreOffset);\n      const newPostOffset = config.postOffset ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes }) : postOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPostOffset, bytes.length);\n      return [value, newPostOffset];\n    }\n  });\n}\nfunction offsetCodec(codec, config) {\n  return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config));\n}\nfunction modulo(dividend, divisor) {\n  if (divisor === 0) return 0;\n  return (dividend % divisor + divisor) % divisor;\n}\nfunction resizeEncoder(encoder, resize) {\n  if (isFixedSize(encoder)) {\n    const fixedSize = resize(encoder.fixedSize);\n    if (fixedSize < 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n        bytesLength: fixedSize,\n        codecDescription: \"resizeEncoder\"\n      });\n    }\n    return createEncoder({ ...encoder, fixedSize });\n  }\n  return createEncoder({\n    ...encoder,\n    getSizeFromValue: (value) => {\n      const newSize = resize(encoder.getSizeFromValue(value));\n      if (newSize < 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n          bytesLength: newSize,\n          codecDescription: \"resizeEncoder\"\n        });\n      }\n      return newSize;\n    }\n  });\n}\nfunction resizeDecoder(decoder, resize) {\n  if (isFixedSize(decoder)) {\n    const fixedSize = resize(decoder.fixedSize);\n    if (fixedSize < 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n        bytesLength: fixedSize,\n        codecDescription: \"resizeDecoder\"\n      });\n    }\n    return createDecoder({ ...decoder, fixedSize });\n  }\n  return decoder;\n}\nfunction resizeCodec(codec, resize) {\n  return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));\n}\n\n// src/pad-codec.ts\nfunction padLeftEncoder(encoder, offset) {\n  return offsetEncoder(\n    resizeEncoder(encoder, (size) => size + offset),\n    { preOffset: ({ preOffset }) => preOffset + offset }\n  );\n}\nfunction padRightEncoder(encoder, offset) {\n  return offsetEncoder(\n    resizeEncoder(encoder, (size) => size + offset),\n    { postOffset: ({ postOffset }) => postOffset + offset }\n  );\n}\nfunction padLeftDecoder(decoder, offset) {\n  return offsetDecoder(\n    resizeDecoder(decoder, (size) => size + offset),\n    { preOffset: ({ preOffset }) => preOffset + offset }\n  );\n}\nfunction padRightDecoder(decoder, offset) {\n  return offsetDecoder(\n    resizeDecoder(decoder, (size) => size + offset),\n    { postOffset: ({ postOffset }) => postOffset + offset }\n  );\n}\nfunction padLeftCodec(codec, offset) {\n  return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset));\n}\nfunction padRightCodec(codec, offset) {\n  return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset));\n}\n\n// src/reverse-codec.ts\nfunction copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {\n  while (sourceOffset < --sourceLength) {\n    const leftValue = source[sourceOffset];\n    target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n    target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n    sourceOffset++;\n  }\n  if (sourceOffset === sourceLength) {\n    target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n  }\n}\nfunction reverseEncoder(encoder) {\n  assertIsFixedSize(encoder);\n  return createEncoder({\n    ...encoder,\n    write: (value, bytes, offset) => {\n      const newOffset = encoder.write(value, bytes, offset);\n      copySourceToTargetInReverse(\n        bytes,\n        bytes,\n        offset,\n        offset + encoder.fixedSize\n      );\n      return newOffset;\n    }\n  });\n}\nfunction reverseDecoder(decoder) {\n  assertIsFixedSize(decoder);\n  return createDecoder({\n    ...decoder,\n    read: (bytes, offset) => {\n      const reversedBytes = bytes.slice();\n      copySourceToTargetInReverse(\n        bytes,\n        reversedBytes,\n        offset,\n        offset + decoder.fixedSize\n      );\n      return decoder.read(reversedBytes, offset);\n    }\n  });\n}\nfunction reverseCodec(codec) {\n  return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n\n// src/transform-codec.ts\nfunction transformEncoder(encoder, unmap) {\n  return createEncoder({\n    ...isVariableSize(encoder) ? { ...encoder, getSizeFromValue: (value) => encoder.getSizeFromValue(unmap(value)) } : encoder,\n    write: (value, bytes, offset) => encoder.write(unmap(value), bytes, offset)\n  });\n}\nfunction transformDecoder(decoder, map) {\n  return createDecoder({\n    ...decoder,\n    read: (bytes, offset) => {\n      const [value, newOffset] = decoder.read(bytes, offset);\n      return [map(value, bytes, offset), newOffset];\n    }\n  });\n}\nfunction transformCodec(codec, unmap, map) {\n  return createCodec({\n    ...transformEncoder(codec, unmap),\n    read: map ? transformDecoder(codec, map).read : codec.read\n  });\n}\n\nexport { addCodecSentinel, addCodecSizePrefix, addDecoderSentinel, addDecoderSizePrefix, addEncoderSentinel, addEncoderSizePrefix, assertByteArrayHasEnoughBytesForCodec, assertByteArrayIsNotEmptyForCodec, assertByteArrayOffsetIsNotOutOfRange, assertIsFixedSize, assertIsVariableSize, combineCodec, containsBytes, createCodec, createDecoder, createDecoderThatConsumesEntireByteArray, createEncoder, fixBytes, fixCodecSize, fixDecoderSize, fixEncoderSize, getEncodedSize, isFixedSize, isVariableSize, mergeBytes, offsetCodec, offsetDecoder, offsetEncoder, padBytes, padLeftCodec, padLeftDecoder, padLeftEncoder, padRightCodec, padRightDecoder, padRightEncoder, resizeCodec, resizeDecoder, resizeEncoder, reverseCodec, reverseDecoder, reverseEncoder, transformCodec, transformDecoder, transformEncoder };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","import { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Concatenates an array of `Uint8Array`s into a single `Uint8Array`.\n * Reuses the original byte array when applicable.\n *\n * @param byteArrays - The array of byte arrays to concatenate.\n *\n * @example\n * ```ts\n * const bytes1 = new Uint8Array([0x01, 0x02]);\n * const bytes2 = new Uint8Array([]);\n * const bytes3 = new Uint8Array([0x03, 0x04]);\n * const bytes = mergeBytes([bytes1, bytes2, bytes3]);\n * //    ^ [0x01, 0x02, 0x03, 0x04]\n * ```\n */\nexport const mergeBytes = (byteArrays: Uint8Array[]): Uint8Array => {\n    const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n\n    const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach(arr => {\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\n\n/**\n * Pads a `Uint8Array` with zeroes to the specified length.\n * If the array is longer than the specified length, it is returned as-is.\n *\n * @param bytes - The byte array to pad.\n * @param length - The desired length of the byte array.\n *\n * @example\n * Adds zeroes to the end of the byte array to reach the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const paddedBytes = padBytes(bytes, 4);\n * //    ^ [0x01, 0x02, 0x00, 0x00]\n * ```\n *\n * @example\n * Returns the original byte array if it is already at the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const paddedBytes = padBytes(bytes, 2);\n * // bytes === paddedBytes\n * ```\n */\nexport function padBytes(bytes: Uint8Array, length: number): Uint8Array;\nexport function padBytes(bytes: ReadonlyUint8Array, length: number): ReadonlyUint8Array;\nexport function padBytes(bytes: ReadonlyUint8Array, length: number): ReadonlyUint8Array {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n}\n\n/**\n * Fixes a `Uint8Array` to the specified length.\n * If the array is longer than the specified length, it is truncated.\n * If the array is shorter than the specified length, it is padded with zeroes.\n *\n * @param bytes - The byte array to truncate or pad.\n * @param length - The desired length of the byte array.\n *\n * @example\n * Truncates the byte array to the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const fixedBytes = fixBytes(bytes, 2);\n * //    ^ [0x01, 0x02]\n * ```\n *\n * @example\n * Adds zeroes to the end of the byte array to reach the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const fixedBytes = fixBytes(bytes, 4);\n * //    ^ [0x01, 0x02, 0x00, 0x00]\n * ```\n *\n * @example\n * Returns the original byte array if it is already at the desired length.\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02]);\n * const fixedBytes = fixBytes(bytes, 2);\n * // bytes === fixedBytes\n * ```\n */\nexport const fixBytes = (bytes: ReadonlyUint8Array | Uint8Array, length: number): ReadonlyUint8Array | Uint8Array =>\n    padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\n\n/**\n * Returns true if and only if the provided `data` byte array contains\n * the provided `bytes` byte array at the specified `offset`.\n *\n * @param data - The byte sequence to search for.\n * @param bytes - The byte array in which to search for `data`.\n * @param offset - The position in `bytes` where the search begins.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03, 0x04]);\n * const data = new Uint8Array([0x02, 0x03]);\n * containsBytes(bytes, data, 1); // true\n * containsBytes(bytes, data, 2); // false\n * ```\n */\nexport function containsBytes(\n    data: ReadonlyUint8Array | Uint8Array,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset: number,\n): boolean {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i) => b === slice[i]);\n}\n","import {\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Defines an offset in bytes.\n */\nexport type Offset = number;\n\n/**\n * An object that can encode a value of type {@link TFrom} into a {@link ReadonlyUint8Array}.\n *\n * This is a common interface for {@link FixedSizeEncoder} and {@link VariableSizeEncoder}.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n */\ntype BaseEncoder<TFrom> = {\n    /** Encode the provided value and return the encoded bytes directly. */\n    readonly encode: (value: TFrom) => ReadonlyUint8Array;\n    /**\n     * Writes the encoded value into the provided byte array at the given offset.\n     * Returns the offset of the next byte after the encoded value.\n     */\n    readonly write: (value: TFrom, bytes: Uint8Array, offset: Offset) => Offset;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a fixed-size {@link ReadonlyUint8Array}.\n *\n * See {@link Encoder} to learn more about creating and composing encoders.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const encoder: FixedSizeEncoder<number, 4>;\n * const bytes = encoder.encode(42);\n * const size = encoder.fixedSize; // 4\n * ```\n *\n * @see {@link Encoder}\n * @see {@link VariableSizeEncoder}\n */\nexport type FixedSizeEncoder<TFrom, TSize extends number = number> = BaseEncoder<TFrom> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a variable-size {@link ReadonlyUint8Array}.\n *\n * See {@link Encoder} to learn more about creating and composing encoders.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n *\n * @example\n * ```ts\n * const encoder: VariableSizeEncoder<string>;\n * const bytes = encoder.encode('hello');\n * const size = encoder.getSizeFromValue('hello');\n * ```\n *\n * @see {@link Encoder}\n * @see {@link FixedSizeEncoder}\n */\nexport type VariableSizeEncoder<TFrom> = BaseEncoder<TFrom> & {\n    /** Returns the size of the encoded value in bytes for a given input. */\n    readonly getSizeFromValue: (value: TFrom) => number;\n    /** The maximum possible size of an encoded value in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can encode a value of type {@link TFrom} into a {@link ReadonlyUint8Array}.\n *\n * An `Encoder` can be either:\n * - A {@link FixedSizeEncoder}, where all encoded values have the same fixed size.\n * - A {@link VariableSizeEncoder}, where encoded values can vary in size.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @example\n * Encoding a value into a new byte array.\n * ```ts\n * const encoder: Encoder<string>;\n * const bytes = encoder.encode('hello');\n * ```\n *\n * @example\n * Writing the encoded value into an existing byte array.\n * ```ts\n * const encoder: Encoder<string>;\n * const bytes = new Uint8Array(100);\n * const nextOffset = encoder.write('hello', bytes, 20);\n * ```\n *\n * @remarks\n * You may create `Encoders` manually using the {@link createEncoder} function but it is more common\n * to compose multiple `Encoders` together using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create an `Encoder` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructEncoder, addEncoderSizePrefix, getUtf8Encoder, getU32Encoder } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonEncoder = (): Encoder<Person> =>\n *     getStructEncoder([\n *         ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n *         ['age', getU32Encoder()],\n *     ]);\n * ```\n *\n * Note that composed `Encoder` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Encoder()` is\n * a fixed-size encoder, while `addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())`\n * is a variable-size encoder. This makes the final `Person` encoder a variable-size encoder.\n *\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n * @see {@link createEncoder}\n */\nexport type Encoder<TFrom> = FixedSizeEncoder<TFrom> | VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can decode a byte array into a value of type {@link TTo}.\n *\n * This is a common interface for {@link FixedSizeDecoder} and {@link VariableSizeDecoder}.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n */\ntype BaseDecoder<TTo> = {\n    /** Decodes the provided byte array at the given offset (or zero) and returns the value directly. */\n    readonly decode: (bytes: ReadonlyUint8Array | Uint8Array, offset?: Offset) => TTo;\n    /**\n     * Reads the encoded value from the provided byte array at the given offset.\n     * Returns the decoded value and the offset of the next byte after the encoded value.\n     */\n    readonly read: (bytes: ReadonlyUint8Array | Uint8Array, offset: Offset) => [TTo, Offset];\n};\n\n/**\n * An object that can decode a fixed-size byte array into a value of type {@link TTo}.\n *\n * See {@link Decoder} to learn more about creating and composing decoders.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const decoder: FixedSizeDecoder<number, 4>;\n * const value = decoder.decode(bytes);\n * const size = decoder.fixedSize; // 4\n * ```\n *\n * @see {@link Decoder}\n * @see {@link VariableSizeDecoder}\n */\nexport type FixedSizeDecoder<TTo, TSize extends number = number> = BaseDecoder<TTo> & {\n    /** The fixed size of the encoded value in bytes. */\n    readonly fixedSize: TSize;\n};\n\n/**\n * An object that can decode a variable-size byte array into a value of type {@link TTo}.\n *\n * See {@link Decoder} to learn more about creating and composing decoders.\n *\n * @interface\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const decoder: VariableSizeDecoder<number>;\n * const value = decoder.decode(bytes);\n * ```\n *\n * @see {@link Decoder}\n * @see {@link VariableSizeDecoder}\n */\nexport type VariableSizeDecoder<TTo> = BaseDecoder<TTo> & {\n    /** The maximum possible size of an encoded value in bytes, if applicable. */\n    readonly maxSize?: number;\n};\n\n/**\n * An object that can decode a byte array into a value of type {@link TTo}.\n *\n * An `Decoder` can be either:\n * - A {@link FixedSizeDecoder}, where all byte arrays have the same fixed size.\n * - A {@link VariableSizeDecoder}, where byte arrays can vary in size.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * Getting the decoded value from a byte array.\n * ```ts\n * const decoder: Decoder<string>;\n * const value = decoder.decode(bytes);\n * ```\n *\n * @example\n * Reading the decoded value from a byte array at a specific offset\n * and getting the offset of the next byte to read.\n * ```ts\n * const decoder: Decoder<string>;\n * const [value, nextOffset] = decoder.read('hello', bytes, 20);\n * ```\n *\n * @remarks\n * You may create `Decoders` manually using the {@link createDecoder} function but it is more common\n * to compose multiple `Decoders` together using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create an `Decoder` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructDecoder, addDecoderSizePrefix, getUtf8Decoder, getU32Decoder } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonDecoder = (): Decoder<Person> =>\n *     getStructDecoder([\n *         ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *         ['age', getU32Decoder()],\n *     ]);\n * ```\n *\n * Note that composed `Decoder` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Decoder()` is\n * a fixed-size decoder, while `addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())`\n * is a variable-size decoder. This makes the final `Person` decoder a variable-size decoder.\n *\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n * @see {@link createDecoder}\n */\nexport type Decoder<TTo> = FixedSizeDecoder<TTo> | VariableSizeDecoder<TTo>;\n\n/**\n * An object that can encode and decode a value to and from a fixed-size byte array.\n *\n * See {@link Codec} to learn more about creating and composing codecs.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const codec: FixedSizeCodec<number | bigint, bigint, 8>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * const size = codec.fixedSize; // 8\n * ```\n *\n * @see {@link Codec}\n * @see {@link VariableSizeCodec}\n */\nexport type FixedSizeCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number> = FixedSizeDecoder<\n    TTo,\n    TSize\n> &\n    FixedSizeEncoder<TFrom, TSize>;\n\n/**\n * An object that can encode and decode a value to and from a variable-size byte array.\n *\n * See {@link Codec} to learn more about creating and composing codecs.\n *\n * @interface\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const codec: VariableSizeCodec<number | bigint, bigint>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * const size = codec.getSizeFromValue(42);\n * ```\n *\n * @see {@link Codec}\n * @see {@link FixedSizeCodec}\n */\nexport type VariableSizeCodec<TFrom, TTo extends TFrom = TFrom> = VariableSizeDecoder<TTo> & VariableSizeEncoder<TFrom>;\n\n/**\n * An object that can encode and decode a value to and from a byte array.\n *\n * A `Codec` can be either:\n * - A {@link FixedSizeCodec}, where all encoded values have the same fixed size.\n * - A {@link VariableSizeCodec}, where encoded values can vary in size.\n *\n * @example\n * ```ts\n * const codec: Codec<string>;\n * const bytes = codec.encode('hello');\n * const value = codec.decode(bytes); // 'hello'\n * ```\n *\n * @remarks\n * For convenience, codecs can encode looser types than they decode.\n * That is, type {@link TFrom} can be a superset of type {@link TTo}.\n * For instance, a `Codec<bigint | number, bigint>` can encode both\n * `bigint` and `number` values, but will always decode to a `bigint`.\n *\n * ```ts\n * const codec: Codec<bigint | number, bigint>;\n * const bytes = codec.encode(42);\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * It is worth noting that codecs are the union of encoders and decoders.\n * This means that a `Codec<TFrom, TTo>` can be combined from an `Encoder<TFrom>`\n * and a `Decoder<TTo>` using the {@link combineCodec} function. This is particularly\n * useful for library authors who want to expose all three types of objects to their users.\n *\n * ```ts\n * const encoder: Encoder<bigint | number>;\n * const decoder: Decoder<bigint>;\n * const codec: Codec<bigint | number, bigint> = combineCodec(encoder, decoder);\n * ```\n *\n * Aside from combining encoders and decoders, codecs can also be created from scratch using\n * the {@link createCodec} function but it is more common to compose multiple codecs together\n * using the various helpers of the `@solana/codecs` package.\n *\n * For instance, here's how you might create a `Codec` for a `Person` object type that contains\n * a `name` string and an `age` number:\n *\n * ```ts\n * import { getStructCodec, addCodecSizePrefix, getUtf8Codec, getU32Codec } from '@solana/codecs';\n *\n * type Person = { name: string; age: number };\n * const getPersonCodec = (): Codec<Person> =>\n *     getStructCodec([\n *         ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n *         ['age', getU32Codec()],\n *     ]);\n * ```\n *\n * Note that composed `Codec` types are clever enough to understand whether\n * they are fixed-size or variable-size. In the example above, `getU32Codec()` is\n * a fixed-size codec, while `addCodecSizePrefix(getUtf8Codec(), getU32Codec())`\n * is a variable-size codec. This makes the final `Person` codec a variable-size codec.\n *\n * @see {@link FixedSizeCodec}\n * @see {@link VariableSizeCodec}\n * @see {@link combineCodec}\n * @see {@link createCodec}\n */\nexport type Codec<TFrom, TTo extends TFrom = TFrom> = FixedSizeCodec<TFrom, TTo> | VariableSizeCodec<TFrom, TTo>;\n\n/**\n * Gets the encoded size of a given value in bytes using the provided encoder.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @param value - The value to be encoded.\n * @param encoder - The encoder used to determine the encoded size.\n * @returns The size of the encoded value in bytes.\n *\n * @example\n * ```ts\n * const fixedSizeEncoder = { fixedSize: 4 };\n * getEncodedSize(123, fixedSizeEncoder); // Returns 4.\n *\n * const variableSizeEncoder = { getSizeFromValue: (value: string) => value.length };\n * getEncodedSize(\"hello\", variableSizeEncoder); // Returns 5.\n * ```\n *\n * @see {@link Encoder}\n */\nexport function getEncodedSize<TFrom>(\n    value: TFrom,\n    encoder: { fixedSize: number } | { getSizeFromValue: (value: TFrom) => number },\n): number {\n    return 'fixedSize' in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\n\n/**\n * Creates an `Encoder` by filling in the missing `encode` function using the provided `write` function and\n * either the `fixedSize` property (for {@link FixedSizeEncoder | FixedSizeEncoders}) or\n * the `getSizeFromValue` function (for {@link VariableSizeEncoder | VariableSizeEncoders}).\n *\n * Instead of manually implementing `encode`, this utility leverages the existing `write` function\n * and the size helpers to generate a complete encoder. The provided `encode` method will allocate\n * a new `Uint8Array` of the correct size and use `write` to populate it.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size encoders).\n *\n * @param encoder - An encoder object that implements `write`, but not `encode`.\n * - If the encoder has a `fixedSize` property, it is treated as a {@link FixedSizeEncoder}.\n * - Otherwise, it is treated as a {@link VariableSizeEncoder}.\n *\n * @returns A fully functional `Encoder` with both `write` and `encode` methods.\n *\n * @example\n * Creating a custom fixed-size encoder.\n * ```ts\n * const encoder = createEncoder({\n *     fixedSize: 4,\n *     write: (value: number, bytes, offset) => {\n *         bytes.set(new Uint8Array([value]), offset);\n *         return offset + 4;\n *     },\n * });\n *\n * const bytes = encoder.encode(42);\n * // 0x2a000000\n * ```\n *\n * @example\n * Creating a custom variable-size encoder:\n * ```ts\n * const encoder = createEncoder({\n *     getSizeFromValue: (value: string) => value.length,\n *     write: (value: string, bytes, offset) => {\n *         const encodedValue = new TextEncoder().encode(value);\n *         bytes.set(encodedValue, offset);\n *         return offset + encodedValue.length;\n *     },\n * });\n *\n * const bytes = encoder.encode(\"hello\");\n * // 0x68656c6c6f\n * ```\n *\n * @remarks\n * Note that, while `createEncoder` is useful for defining more complex encoders, it is more common to compose\n * encoders together using the various helpers and primitives of the `@solana/codecs` package.\n *\n * Here are some alternative examples using codec primitives instead of `createEncoder`.\n *\n * ```ts\n * // Fixed-size encoder for unsigned 32-bit integers.\n * const encoder = getU32Encoder();\n * const bytes = encoder.encode(42);\n * // 0x2a000000\n *\n * // Variable-size encoder for 32-bytes prefixed UTF-8 strings.\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * const bytes = encoder.encode(\"hello\");\n * // 0x0500000068656c6c6f\n *\n * // Variable-size encoder for custom objects.\n * type Person = { name: string; age: number };\n * const encoder: Encoder<Person> = getStructEncoder([\n *     ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],\n *     ['age', getU32Encoder()],\n * ]);\n * const bytes = encoder.encode({ name: \"Bob\", age: 42 });\n * // 0x03000000426f622a000000\n * ```\n *\n * @see {@link Encoder}\n * @see {@link FixedSizeEncoder}\n * @see {@link VariableSizeEncoder}\n * @see {@link getStructEncoder}\n * @see {@link getU32Encoder}\n * @see {@link getUtf8Encoder}\n * @see {@link addEncoderSizePrefix}\n */\nexport function createEncoder<TFrom, TSize extends number>(\n    encoder: Omit<FixedSizeEncoder<TFrom, TSize>, 'encode'>,\n): FixedSizeEncoder<TFrom, TSize>;\nexport function createEncoder<TFrom>(encoder: Omit<VariableSizeEncoder<TFrom>, 'encode'>): VariableSizeEncoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom>;\nexport function createEncoder<TFrom>(\n    encoder: Omit<FixedSizeEncoder<TFrom>, 'encode'> | Omit<VariableSizeEncoder<TFrom>, 'encode'>,\n): Encoder<TFrom> {\n    return Object.freeze({\n        ...encoder,\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/**\n * Creates a `Decoder` by filling in the missing `decode` function using the provided `read` function.\n *\n * Instead of manually implementing `decode`, this utility leverages the existing `read` function\n * and the size properties to generate a complete decoder. The provided `decode` method will read\n * from a `Uint8Array` at the given offset and return the decoded value.\n *\n * If the `fixedSize` property is provided, a {@link FixedSizeDecoder} will be created, otherwise\n * a {@link VariableSizeDecoder} will be created.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size decoders).\n *\n * @param decoder - A decoder object that implements `read`, but not `decode`.\n * - If the decoder has a `fixedSize` property, it is treated as a {@link FixedSizeDecoder}.\n * - Otherwise, it is treated as a {@link VariableSizeDecoder}.\n *\n * @returns A fully functional `Decoder` with both `read` and `decode` methods.\n *\n * @example\n * Creating a custom fixed-size decoder.\n * ```ts\n * const decoder = createDecoder({\n *     fixedSize: 4,\n *     read: (bytes, offset) => {\n *         const value = bytes[offset];\n *         return [value, offset + 4];\n *     },\n * });\n *\n * const value = decoder.decode(new Uint8Array([42, 0, 0, 0]));\n * // 42\n * ```\n *\n * @example\n * Creating a custom variable-size decoder:\n * ```ts\n * const decoder = createDecoder({\n *     read: (bytes, offset) => {\n *         const decodedValue = new TextDecoder().decode(bytes.subarray(offset));\n *         return [decodedValue, bytes.length];\n *     },\n * });\n *\n * const value = decoder.decode(new Uint8Array([104, 101, 108, 108, 111]));\n * // \"hello\"\n * ```\n *\n * @remarks\n * Note that, while `createDecoder` is useful for defining more complex decoders, it is more common to compose\n * decoders together using the various helpers and primitives of the `@solana/codecs` package.\n *\n * Here are some alternative examples using codec primitives instead of `createDecoder`.\n *\n * ```ts\n * // Fixed-size decoder for unsigned 32-bit integers.\n * const decoder = getU32Decoder();\n * const value = decoder.decode(new Uint8Array([42, 0, 0, 0]));\n * // 42\n *\n * // Variable-size decoder for 32-bytes prefixed UTF-8 strings.\n * const decoder = addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder());\n * const value = decoder.decode(new Uint8Array([5, 0, 0, 0, 104, 101, 108, 108, 111]));\n * // \"hello\"\n *\n * // Variable-size decoder for custom objects.\n * type Person = { name: string; age: number };\n * const decoder: Decoder<Person> = getStructDecoder([\n *     ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *     ['age', getU32Decoder()],\n * ]);\n * const value = decoder.decode(new Uint8Array([3, 0, 0, 0, 66, 111, 98, 42, 0, 0, 0]));\n * // { name: \"Bob\", age: 42 }\n * ```\n *\n * @see {@link Decoder}\n * @see {@link FixedSizeDecoder}\n * @see {@link VariableSizeDecoder}\n * @see {@link getStructDecoder}\n * @see {@link getU32Decoder}\n * @see {@link getUtf8Decoder}\n * @see {@link addDecoderSizePrefix}\n */\nexport function createDecoder<TTo, TSize extends number>(\n    decoder: Omit<FixedSizeDecoder<TTo, TSize>, 'decode'>,\n): FixedSizeDecoder<TTo, TSize>;\nexport function createDecoder<TTo>(decoder: Omit<VariableSizeDecoder<TTo>, 'decode'>): VariableSizeDecoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo>;\nexport function createDecoder<TTo>(\n    decoder: Omit<FixedSizeDecoder<TTo>, 'decode'> | Omit<VariableSizeDecoder<TTo>, 'decode'>,\n): Decoder<TTo> {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0],\n    });\n}\n\n/**\n * Creates a `Codec` by filling in the missing `encode` and `decode` functions using the provided `write` and `read` functions.\n *\n * This utility combines the behavior of {@link createEncoder} and {@link createDecoder} to produce a fully functional `Codec`.\n * The `encode` method is derived from the `write` function, while the `decode` method is derived from the `read` function.\n *\n * If the `fixedSize` property is provided, a {@link FixedSizeCodec} will be created, otherwise\n * a {@link VariableSizeCodec} will be created.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size codecs).\n *\n * @param codec - A codec object that implements `write` and `read`, but not `encode` or `decode`.\n * - If the codec has a `fixedSize` property, it is treated as a {@link FixedSizeCodec}.\n * - Otherwise, it is treated as a {@link VariableSizeCodec}.\n *\n * @returns A fully functional `Codec` with `write`, `read`, `encode`, and `decode` methods.\n *\n * @example\n * Creating a custom fixed-size codec.\n * ```ts\n * const codec = createCodec({\n *     fixedSize: 4,\n *     read: (bytes, offset) => {\n *         const value = bytes[offset];\n *         return [value, offset + 4];\n *     },\n *     write: (value: number, bytes, offset) => {\n *         bytes.set(new Uint8Array([value]), offset);\n *         return offset + 4;\n *     },\n * });\n *\n * const bytes = codec.encode(42);\n * // 0x2a000000\n * const value = codec.decode(bytes);\n * // 42\n * ```\n *\n * @example\n * Creating a custom variable-size codec:\n * ```ts\n * const codec = createCodec({\n *     getSizeFromValue: (value: string) => value.length,\n *     read: (bytes, offset) => {\n *         const decodedValue = new TextDecoder().decode(bytes.subarray(offset));\n *         return [decodedValue, bytes.length];\n *     },\n *     write: (value: string, bytes, offset) => {\n *         const encodedValue = new TextEncoder().encode(value);\n *         bytes.set(encodedValue, offset);\n *         return offset + encodedValue.length;\n *     },\n * });\n *\n * const bytes = codec.encode(\"hello\");\n * // 0x68656c6c6f\n * const value = codec.decode(bytes);\n * // \"hello\"\n * ```\n *\n * @remarks\n * This function effectively combines the behavior of {@link createEncoder} and {@link createDecoder}.\n * If you only need to encode or decode (but not both), consider using those functions instead.\n *\n * Here are some alternative examples using codec primitives instead of `createCodec`.\n *\n * ```ts\n * // Fixed-size codec for unsigned 32-bit integers.\n * const codec = getU32Codec();\n * const bytes = codec.encode(42);\n * // 0x2a000000\n * const value = codec.decode(bytes);\n * // 42\n *\n * // Variable-size codec for 32-bytes prefixed UTF-8 strings.\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const bytes = codec.encode(\"hello\");\n * // 0x0500000068656c6c6f\n * const value = codec.decode(bytes);\n * // \"hello\"\n *\n * // Variable-size codec for custom objects.\n * type Person = { name: string; age: number };\n * const codec: Codec<PersonInput, Person> = getStructCodec([\n *     ['name', addCodecSizePrefix(getUtf8Codec(), getU32Codec())],\n *     ['age', getU32Codec()],\n * ]);\n * const bytes = codec.encode({ name: \"Bob\", age: 42 });\n * // 0x03000000426f622a000000\n * const value = codec.decode(bytes);\n * // { name: \"Bob\", age: 42 }\n * ```\n *\n * @see {@link Codec}\n * @see {@link FixedSizeCodec}\n * @see {@link VariableSizeCodec}\n * @see {@link createEncoder}\n * @see {@link createDecoder}\n * @see {@link getStructCodec}\n * @see {@link getU32Codec}\n * @see {@link getUtf8Codec}\n * @see {@link addCodecSizePrefix}\n */\nexport function createCodec<TFrom, TTo extends TFrom = TFrom, TSize extends number = number>(\n    codec: Omit<FixedSizeCodec<TFrom, TTo, TSize>, 'decode' | 'encode'>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec: Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo>;\nexport function createCodec<TFrom, TTo extends TFrom = TFrom>(\n    codec:\n        | Omit<FixedSizeCodec<TFrom, TTo>, 'decode' | 'encode'>\n        | Omit<VariableSizeCodec<TFrom, TTo>, 'decode' | 'encode'>,\n): Codec<TFrom, TTo> {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n        encode: value => {\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        },\n    });\n}\n\n/**\n * Determines whether the given codec, encoder, or decoder is fixed-size.\n *\n * A fixed-size object is identified by the presence of a `fixedSize` property.\n * If this property exists, the object is considered a {@link FixedSizeCodec},\n * {@link FixedSizeEncoder}, or {@link FixedSizeDecoder}.\n * Otherwise, it is assumed to be a {@link VariableSizeCodec},\n * {@link VariableSizeEncoder}, or {@link VariableSizeDecoder}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @returns `true` if the object is fixed-size, `false` otherwise.\n *\n * @example\n * Checking a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * isFixedSize(encoder); // true\n * ```\n *\n * @example\n * Checking a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * isFixedSize(encoder); // false\n * ```\n *\n * @remarks\n * This function is commonly used to distinguish between fixed-size and variable-size objects at runtime.\n * If you need to enforce this distinction with type assertions, consider using {@link assertIsFixedSize}.\n *\n * @see {@link assertIsFixedSize}\n */\nexport function isFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function isFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): decoder is FixedSizeDecoder<TTo, TSize>;\nexport function isFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function isFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): codec is { fixedSize: TSize };\nexport function isFixedSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { fixedSize: number } {\n    return 'fixedSize' in codec && typeof codec.fixedSize === 'number';\n}\n\n/**\n * Asserts that the given codec, encoder, or decoder is fixed-size.\n *\n * If the object is not fixed-size (i.e., it lacks a `fixedSize` property),\n * this function throws a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @throws {SolanaError} If the object is not fixed-size.\n *\n * @example\n * Asserting a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * assertIsFixedSize(encoder); // Passes\n * ```\n *\n * @example\n * Attempting to assert a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * assertIsFixedSize(encoder); // Throws SolanaError\n * ```\n *\n * @remarks\n * This function is the assertion-based counterpart of {@link isFixedSize}.\n * If you only need to check whether an object is fixed-size without throwing an error, use {@link isFixedSize} instead.\n *\n * @see {@link isFixedSize}\n */\nexport function assertIsFixedSize<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize> | VariableSizeEncoder<TFrom>,\n): asserts encoder is FixedSizeEncoder<TFrom, TSize>;\nexport function assertIsFixedSize<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize> | VariableSizeDecoder<TTo>,\n): asserts decoder is FixedSizeDecoder<TTo, TSize>;\nexport function assertIsFixedSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize> | VariableSizeCodec<TFrom, TTo>,\n): asserts codec is FixedSizeCodec<TFrom, TTo, TSize>;\nexport function assertIsFixedSize<TSize extends number>(\n    codec: { fixedSize: TSize } | { maxSize?: number },\n): asserts codec is { fixedSize: TSize };\nexport function assertIsFixedSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { fixedSize: number } {\n    if (!isFixedSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\n\n/**\n * Determines whether the given codec, encoder, or decoder is variable-size.\n *\n * A variable-size object is identified by the absence of a `fixedSize` property.\n * If this property is missing, the object is considered a {@link VariableSizeCodec},\n * {@link VariableSizeEncoder}, or {@link VariableSizeDecoder}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @returns `true` if the object is variable-size, `false` otherwise.\n *\n * @example\n * Checking a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * isVariableSize(encoder); // true\n * ```\n *\n * @example\n * Checking a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * isVariableSize(encoder); // false\n * ```\n *\n * @remarks\n * This function is the inverse of {@link isFixedSize}.\n *\n * @see {@link isFixedSize}\n * @see {@link assertIsVariableSize}\n */\nexport function isVariableSize<TFrom>(encoder: Encoder<TFrom>): encoder is VariableSizeEncoder<TFrom>;\nexport function isVariableSize<TTo>(decoder: Decoder<TTo>): decoder is VariableSizeDecoder<TTo>;\nexport function isVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): codec is VariableSizeCodec<TFrom, TTo>;\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number };\nexport function isVariableSize(codec: { fixedSize: number } | { maxSize?: number }): codec is { maxSize?: number } {\n    return !isFixedSize(codec);\n}\n\n/**\n * Asserts that the given codec, encoder, or decoder is variable-size.\n *\n * If the object is not variable-size (i.e., it has a `fixedSize` property),\n * this function throws a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH`.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n * @throws {SolanaError} If the object is not variable-size.\n *\n * @example\n * Asserting a variable-size encoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * assertIsVariableSize(encoder); // Passes\n * ```\n *\n * @example\n * Attempting to assert a fixed-size encoder.\n * ```ts\n * const encoder = getU32Encoder();\n * assertIsVariableSize(encoder); // Throws SolanaError\n * ```\n *\n * @remarks\n * This function is the assertion-based counterpart of {@link isVariableSize}.\n * If you only need to check whether an object is variable-size without throwing an error, use {@link isVariableSize} instead.\n *\n * Also note that this function is the inverse of {@link assertIsFixedSize}.\n *\n * @see {@link isVariableSize}\n * @see {@link assertIsFixedSize}\n */\nexport function assertIsVariableSize<TFrom>(encoder: Encoder<TFrom>): asserts encoder is VariableSizeEncoder<TFrom>;\nexport function assertIsVariableSize<TTo>(decoder: Decoder<TTo>): asserts decoder is VariableSizeDecoder<TTo>;\nexport function assertIsVariableSize<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n): asserts codec is VariableSizeCodec<TFrom, TTo>;\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number };\nexport function assertIsVariableSize(\n    codec: { fixedSize: number } | { maxSize?: number },\n): asserts codec is { maxSize?: number } {\n    if (!isVariableSize(codec)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport {\n    Codec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\n\n/**\n * Combines an `Encoder` and a `Decoder` into a `Codec`.\n *\n * That is, given a `Encoder<TFrom>` and a `Decoder<TTo>`, this function returns a `Codec<TFrom, TTo>`.\n *\n * This allows for modular composition by keeping encoding and decoding logic separate\n * while still offering a convenient way to bundle them into a single `Codec`.\n * This is particularly useful for library maintainers who want to expose `Encoders`,\n * `Decoders`, and `Codecs` separately, enabling tree-shaking of unused logic.\n *\n * The provided `Encoder` and `Decoder` must be compatible in terms of:\n * - **Fixed Size:** If both are fixed-size, they must have the same `fixedSize` value.\n * - **Variable Size:** If either has a `maxSize` attribute, it must match the other.\n *\n * If these conditions are not met, a {@link SolanaError} will be thrown.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes (for fixed-size codecs).\n *\n * @param encoder - The `Encoder` to combine.\n * @param decoder - The `Decoder` to combine.\n * @returns A `Codec` that provides both `encode` and `decode` methods.\n *\n * @throws {SolanaError}\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH`\n *   Thrown if the encoder and decoder have mismatched size types (fixed vs. variable).\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH`\n *   Thrown if both are fixed-size but have different `fixedSize` values.\n * - `SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH`\n *   Thrown if the `maxSize` attributes do not match.\n *\n * @example\n * Creating a fixed-size `Codec` from an encoder and a decoder.\n * ```ts\n * const encoder = getU32Encoder();\n * const decoder = getU32Decoder();\n * const codec = combineCodec(encoder, decoder);\n *\n * const bytes = codec.encode(42); // 0x2a000000\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Creating a variable-size `Codec` from an encoder and a decoder.\n * ```ts\n * const encoder = addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder());\n * const decoder = addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder());\n * const codec = combineCodec(encoder, decoder);\n *\n * const bytes = codec.encode(\"hello\"); // 0x0500000068656c6c6f\n * const value = codec.decode(bytes); // \"hello\"\n * ```\n *\n * @remarks\n * The recommended pattern for defining codecs in libraries is to expose separate functions for the encoder, decoder, and codec.\n * This allows users to import only what they need, improving tree-shaking efficiency.\n *\n * ```ts\n * type MyType = \\/* ... *\\/;\n * const getMyTypeEncoder = (): Encoder<MyType> => { \\/* ... *\\/ };\n * const getMyTypeDecoder = (): Decoder<MyType> => { \\/* ... *\\/ };\n * const getMyTypeCodec = (): Codec<MyType> =>\n *     combineCodec(getMyTypeEncoder(), getMyTypeDecoder());\n * ```\n *\n * @see {@link Codec}\n * @see {@link Encoder}\n * @see {@link Decoder}\n */\nexport function combineCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: VariableSizeEncoder<TFrom>,\n    decoder: VariableSizeDecoder<TTo>,\n): VariableSizeCodec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo>;\nexport function combineCodec<TFrom, TTo extends TFrom>(\n    encoder: Encoder<TFrom>,\n    decoder: Decoder<TTo>,\n): Codec<TFrom, TTo> {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize,\n        });\n    }\n\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize,\n        });\n    }\n\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write,\n    };\n}\n","import {\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SolanaError,\n} from '@solana/errors';\n\nimport { containsBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Creates an encoder that writes a `Uint8Array` sentinel after the encoded value.\n * This is useful to delimit the encoded value when being read by a decoder.\n *\n * See {@link addCodecSentinel} for more information.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link addCodecSentinel}\n */\nexport function addEncoderSentinel<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(\n    encoder: Encoder<TFrom>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeEncoder<TFrom>;\nexport function addEncoderSentinel<TFrom>(encoder: Encoder<TFrom>, sentinel: ReadonlyUint8Array): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds\n        // and to avoid writing the sentinel as part of the encoded value.\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write });\n    }\n\n    return createEncoder({\n        ...encoder,\n        ...(encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {}),\n        getSizeFromValue: value => encoder.getSizeFromValue(value) + sentinel.length,\n        write,\n    });\n}\n\n/**\n * Creates a decoder that continues reading until\n * a given `Uint8Array` sentinel is found.\n *\n * See {@link addCodecSentinel} for more information.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link addCodecSentinel}\n */\nexport function addDecoderSentinel<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): VariableSizeDecoder<TTo>;\nexport function addDecoderSentinel<TTo>(decoder: Decoder<TTo>, sentinel: ReadonlyUint8Array): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel,\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds\n        // and ensure that the sentinel is not part of the decoded value.\n        return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });\n    }\n\n    return createDecoder({\n        ...decoder,\n        ...(decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {}),\n        read,\n    });\n}\n\n/**\n * Creates a Codec that writes a given `Uint8Array` sentinel after the encoded\n * value and, when decoding, continues reading until the sentinel is found.\n *\n * This sets a limit on variable-size codecs and tells us when to stop decoding.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * ```ts\n * const codec = addCodecSentinel(getUtf8Codec(), new Uint8Array([255, 255]));\n * codec.encode('hello');\n * // 0x68656c6c6fffff\n * //   |        -- Our sentinel.\n * //   -- Our encoded string.\n * ```\n *\n * @remarks\n * Note that the sentinel _must not_ be present in the encoded data and\n * _must_ be present in the decoded data for this to work.\n * If this is not the case, dedicated errors will be thrown.\n *\n * ```ts\n * const sentinel = new Uint8Array([108, 108]); // 'll'\n * const codec = addCodecSentinel(getUtf8Codec(), sentinel);\n *\n * codec.encode('hello'); // Throws: sentinel is in encoded data.\n * codec.decode(new Uint8Array([1, 2, 3])); // Throws: sentinel missing in decoded data.\n * ```\n *\n * Separate {@link addEncoderSentinel} and {@link addDecoderSentinel} functions are also available.\n *\n * ```ts\n * const bytes = addEncoderSentinel(getUtf8Encoder(), sentinel).encode('hello');\n * const value = addDecoderSentinel(getUtf8Decoder(), sentinel).decode(bytes);\n * ```\n *\n * @see {@link addEncoderSentinel}\n * @see {@link addDecoderSentinel}\n */\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSentinel<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    sentinel: ReadonlyUint8Array,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\n\nfunction findSentinelIndex(bytes: ReadonlyUint8Array, sentinel: ReadonlyUint8Array) {\n    return bytes.findIndex((byte, index, arr) => {\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\n\nfunction hexBytes(bytes: ReadonlyUint8Array): string {\n    return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n}\n","import {\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Asserts that a given byte array is not empty (after the optional provided offset).\n *\n * Returns void if the byte array is not empty but throws a {@link SolanaError} otherwise.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param bytes - The byte array to check.\n * @param offset - The offset from which to start checking the byte array.\n * If provided, the byte array is considered empty if it has no bytes after the offset.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes); // OK\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes, 1); // OK\n * assertByteArrayIsNotEmptyForCodec('myCodec', bytes, 3); // Throws\n * ```\n */\nexport function assertByteArrayIsNotEmptyForCodec(\n    codecDescription: string,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    if (bytes.length - offset <= 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription,\n        });\n    }\n}\n\n/**\n * Asserts that a given byte array has enough bytes to decode\n * (after the optional provided offset).\n *\n * Returns void if the byte array has at least the expected number\n * of bytes but throws a {@link SolanaError} otherwise.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param expected - The minimum number of bytes expected in the byte array.\n * @param bytes - The byte array to check.\n * @param offset - The offset from which to start checking the byte array.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 3, bytes); // OK\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 4, bytes); // Throws\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 2, bytes, 1); // OK\n * assertByteArrayHasEnoughBytesForCodec('myCodec', 3, bytes, 1); // Throws\n * ```\n */\nexport function assertByteArrayHasEnoughBytesForCodec(\n    codecDescription: string,\n    expected: number,\n    bytes: ReadonlyUint8Array | Uint8Array,\n    offset = 0,\n) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected,\n        });\n    }\n}\n\n/**\n * Asserts that a given offset is within the byte array bounds.\n * This range is between 0 and the byte array length and is inclusive.\n * An offset equals to the byte array length is considered a valid offset\n * as it allows the post-offset of codecs to signal the end of the byte array.\n *\n * @param codecDescription - A description of the codec used by the assertion error.\n * @param offset - The offset to check.\n * @param bytesLength - The length of the byte array from which the offset should be within bounds.\n *\n * @example\n * ```ts\n * const bytes = new Uint8Array([0x01, 0x02, 0x03]);\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 0, bytes.length); // OK\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 3, bytes.length); // OK\n * assertByteArrayOffsetIsNotOutOfRange('myCodec', 4, bytes.length); // Throws\n * ```\n */\nexport function assertByteArrayOffsetIsNotOutOfRange(codecDescription: string, offset: number, bytesLength: number) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset,\n        });\n    }\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    getEncodedSize,\n    isFixedSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\ntype NumberEncoder = Encoder<bigint | number> | Encoder<number>;\ntype FixedSizeNumberEncoder<TSize extends number = number> =\n    | FixedSizeEncoder<bigint | number, TSize>\n    | FixedSizeEncoder<number, TSize>;\ntype NumberDecoder = Decoder<bigint> | Decoder<number>;\ntype FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\ntype NumberCodec = Codec<bigint | number, bigint> | Codec<number>;\ntype FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<number, number, TSize>;\n\n/**\n * Stores the size of the `encoder` in bytes as a prefix using the `prefix` encoder.\n *\n * See {@link addCodecSizePrefix} for more information.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @see {@link addCodecSizePrefix}\n */\nexport function addEncoderSizePrefix<TFrom>(\n    encoder: FixedSizeEncoder<TFrom>,\n    prefix: FixedSizeNumberEncoder,\n): FixedSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): VariableSizeEncoder<TFrom>;\nexport function addEncoderSizePrefix<TFrom>(encoder: Encoder<TFrom>, prefix: NumberEncoder): Encoder<TFrom> {\n    const write = ((value, bytes, offset) => {\n        // Here we exceptionally use the `encode` function instead of the `write`\n        // function to contain the content of the encoder within its own bounds.\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    }) as Encoder<TFrom>['write'];\n\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : (encoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n\n    return createEncoder({\n        ...encoder,\n        ...(maxSize !== null ? { maxSize } : {}),\n        getSizeFromValue: value => {\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write,\n    });\n}\n\n/**\n * Bounds the size of the nested `decoder` by reading its encoded `prefix`.\n *\n * See {@link addCodecSizePrefix} for more information.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @see {@link addCodecSizePrefix}\n */\nexport function addDecoderSizePrefix<TTo>(\n    decoder: FixedSizeDecoder<TTo>,\n    prefix: FixedSizeNumberDecoder,\n): FixedSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): VariableSizeDecoder<TTo>;\nexport function addDecoderSizePrefix<TTo>(decoder: Decoder<TTo>, prefix: NumberDecoder): Decoder<TTo> {\n    const read = ((bytes, offset) => {\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        // Slice the byte array to the contained size if necessary.\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec('addDecoderSizePrefix', size, bytes);\n        // Here we exceptionally use the `decode` function instead of the `read`\n        // function to contain the content of the decoder within its own bounds.\n        return [decoder.decode(bytes), offset + size];\n    }) as Decoder<TTo>['read'];\n\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });\n    }\n\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : (prefix.maxSize ?? null);\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : (decoder.maxSize ?? null);\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({ ...decoder, ...(maxSize !== null ? { maxSize } : {}), read });\n}\n\n/**\n * Stores the byte size of any given codec as an encoded number prefix.\n *\n * This sets a limit on variable-size codecs and tells us when to stop decoding.\n * When encoding, the size of the encoded data is stored before the encoded data itself.\n * When decoding, the size is read first to know how many bytes to read next.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @example\n * For example, say we want to bound a variable-size base-58 string using a `u32` size prefix.\n * Heres how you can use the `addCodecSizePrefix` function to achieve that.\n *\n * ```ts\n * const getU32Base58Codec = () => addCodecSizePrefix(getBase58Codec(), getU32Codec());\n *\n * getU32Base58Codec().encode('hello world');\n * // 0x0b00000068656c6c6f20776f726c64\n * //   |       -- Our encoded base-58 string.\n * //   -- Our encoded u32 size prefix.\n * ```\n *\n * @remarks\n * Separate {@link addEncoderSizePrefix} and {@link addDecoderSizePrefix} functions are also available.\n *\n * ```ts\n * const bytes = addEncoderSizePrefix(getBase58Encoder(), getU32Encoder()).encode('hello');\n * const value = addDecoderSizePrefix(getBase58Decoder(), getU32Decoder()).decode(bytes);\n * ```\n *\n * @see {@link addEncoderSizePrefix}\n * @see {@link addDecoderSizePrefix}\n */\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: FixedSizeCodec<TFrom, TTo>,\n    prefix: FixedSizeNumberCodec,\n): FixedSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): VariableSizeCodec<TFrom, TTo>;\nexport function addCodecSizePrefix<TFrom, TTo extends TFrom>(\n    codec: Codec<TFrom, TTo>,\n    prefix: NumberCodec,\n): Codec<TFrom, TTo> {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n","import { SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY, SolanaError } from '@solana/errors';\n\nimport { createDecoder, Decoder } from './codec';\n\n/**\n * Create a {@link Decoder} that asserts that the bytes provided to `decode` or `read` are fully consumed by the inner decoder\n * @param decoder A decoder to wrap\n * @returns A new decoder that will throw if provided with a byte array that it does not fully consume\n *\n * @typeParam T - The type of the decoder\n *\n * @remarks\n * Note that this compares the offset after encoding to the length of the input byte array\n *\n * The `offset` parameter to `decode` and `read` is still considered, and will affect the new offset that is compared to the byte array length\n *\n * The error that is thrown by the returned decoder is a {@link SolanaError} with the code `SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY`\n *\n * @example\n * Create a decoder that decodes a `u32` (4 bytes) and ensures the entire byte array is consumed\n * ```ts\n * const decoder = createDecoderThatUsesExactByteArray(getU32Decoder());\n * decoder.decode(new Uint8Array([0, 0, 0, 0])); // 0\n * decoder.decode(new Uint8Array([0, 0, 0, 0, 0])); // throws\n *\n * // with an offset\n * decoder.decode(new Uint8Array([0, 0, 0, 0, 0]), 1); // 0\n * decoder.decode(new Uint8Array([0, 0, 0, 0, 0, 0]), 1); // throws\n * ```\n */\nexport function createDecoderThatConsumesEntireByteArray<T>(decoder: Decoder<T>): Decoder<T> {\n    return createDecoder({\n        ...decoder,\n        read(bytes, offset) {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            if (bytes.length > newOffset) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY, {\n                    expectedLength: newOffset,\n                    numExcessBytes: bytes.length - newOffset,\n                });\n            }\n            return [value, newOffset];\n        },\n    });\n}\n","import { assertByteArrayHasEnoughBytesForCodec } from './assertions';\nimport { fixBytes } from './bytes';\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n    Offset,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n/**\n * Creates a fixed-size encoder from a given encoder.\n *\n * The resulting encoder ensures that encoded values always have the specified number of bytes.\n * If the original encoded value is larger than `fixedBytes`, it is truncated.\n * If it is smaller, it is padded with trailing zeroes.\n *\n * For more details, see {@link fixCodecSize}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param encoder - The encoder to wrap into a fixed-size encoder.\n * @param fixedBytes - The fixed number of bytes to write.\n * @returns A `FixedSizeEncoder` that ensures a consistent output size.\n *\n * @example\n * ```ts\n * const encoder = fixEncoderSize(getUtf8Encoder(), 4);\n * encoder.encode(\"Hello\"); // 0x48656c6c (truncated)\n * encoder.encode(\"Hi\");    // 0x48690000 (padded)\n * encoder.encode(\"Hiya\");  // 0x48697961 (same length)\n * ```\n *\n * @remarks\n * If you need a full codec with both encoding and decoding, use {@link fixCodecSize}.\n *\n * @see {@link fixCodecSize}\n * @see {@link fixDecoderSize}\n */\nexport function fixEncoderSize<TFrom, TSize extends number>(\n    encoder: Encoder<TFrom>,\n    fixedBytes: TSize,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value: TFrom, bytes: Uint8Array, offset: Offset) => {\n            // Here we exceptionally use the `encode` function instead of the `write`\n            // function as using the nested `write` function on a fixed-sized byte\n            // array may result in a out-of-bounds error on the nested encoder.\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray =\n                variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        },\n    });\n}\n\n/**\n * Creates a fixed-size decoder from a given decoder.\n *\n * The resulting decoder always reads exactly `fixedBytes` bytes from the input.\n * If the nested decoder is also fixed-size, the bytes are truncated or padded as needed.\n *\n * For more details, see {@link fixCodecSize}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param decoder - The decoder to wrap into a fixed-size decoder.\n * @param fixedBytes - The fixed number of bytes to read.\n * @returns A `FixedSizeDecoder` that ensures a consistent input size.\n *\n * @example\n * ```ts\n * const decoder = fixDecoderSize(getUtf8Decoder(), 4);\n * decoder.decode(new Uint8Array([72, 101, 108, 108, 111])); // \"Hell\" (truncated)\n * decoder.decode(new Uint8Array([72, 105, 0, 0]));          // \"Hi\" (zeroes ignored)\n * decoder.decode(new Uint8Array([72, 105, 121, 97]));       // \"Hiya\" (same length)\n * ```\n *\n * @remarks\n * If you need a full codec with both encoding and decoding, use {@link fixCodecSize}.\n *\n * @see {@link fixCodecSize}\n * @see {@link fixEncoderSize}\n */\nexport function fixDecoderSize<TTo, TSize extends number>(\n    decoder: Decoder<TTo>,\n    fixedBytes: TSize,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset) => {\n            assertByteArrayHasEnoughBytesForCodec('fixCodecSize', fixedBytes, bytes, offset);\n            // Slice the byte array to the fixed size if necessary.\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            // If the nested decoder is fixed-size, pad and truncate the byte array accordingly.\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            // Decode the value using the nested decoder.\n            const [value] = decoder.read(bytes, 0);\n            return [value, offset + fixedBytes];\n        },\n    });\n}\n\n/**\n * Creates a fixed-size codec from a given codec.\n *\n * The resulting codec ensures that both encoding and decoding operate on a fixed number of bytes.\n * When encoding:\n * - If the encoded value is larger than `fixedBytes`, it is truncated.\n * - If it is smaller, it is padded with trailing zeroes.\n * - If it is exactly `fixedBytes`, it remains unchanged.\n *\n * When decoding:\n * - Exactly `fixedBytes` bytes are read from the input.\n * - If the nested decoder has a smaller fixed size, bytes are truncated or padded as necessary.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param codec - The codec to wrap into a fixed-size codec.\n * @param fixedBytes - The fixed number of bytes to read/write.\n * @returns A `FixedSizeCodec` that ensures both encoding and decoding conform to a fixed size.\n *\n * @example\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 4);\n *\n * const bytes1 = codec.encode(\"Hello\"); // 0x48656c6c (truncated)\n * const value1 = codec.decode(bytes1);  // \"Hell\"\n *\n * const bytes2 = codec.encode(\"Hi\");    // 0x48690000 (padded)\n * const value2 = codec.decode(bytes2);  // \"Hi\"\n *\n * const bytes3 = codec.encode(\"Hiya\");  // 0x48697961 (same length)\n * const value3 = codec.decode(bytes3);  // \"Hiya\"\n * ```\n *\n * @remarks\n * If you only need to enforce a fixed size for encoding, use {@link fixEncoderSize}.\n * If you only need to enforce a fixed size for decoding, use {@link fixDecoderSize}.\n *\n * ```ts\n * const bytes = fixEncoderSize(getUtf8Encoder(), 4).encode(\"Hiya\");\n * const value = fixDecoderSize(getUtf8Decoder(), 4).decode(bytes);\n * ```\n *\n * @see {@link fixEncoderSize}\n * @see {@link fixDecoderSize}\n */\nexport function fixCodecSize<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: Codec<TFrom, TTo>,\n    fixedBytes: TSize,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n","import { assertByteArrayOffsetIsNotOutOfRange } from './assertions';\nimport { Codec, createDecoder, createEncoder, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Configuration object for modifying the offset of an encoder, decoder, or codec.\n *\n * This type defines optional functions for adjusting the **pre-offset** (before encoding/decoding)\n * and the **post-offset** (after encoding/decoding). These functions allow precise control\n * over where data is written or read within a byte array.\n *\n * @property preOffset - A function that modifies the offset before encoding or decoding.\n * @property postOffset - A function that modifies the offset after encoding or decoding.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * };\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const config: OffsetConfig = {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * };\n * ```\n *\n * @example\n * Using both pre-offset and post-offset together.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n *     postOffset: ({ postOffset }) => postOffset + 4,\n * };\n * ```\n *\n * @see {@link offsetEncoder}\n * @see {@link offsetDecoder}\n * @see {@link offsetCodec}\n */\ntype OffsetConfig = {\n    postOffset?: PostOffsetFunction;\n    preOffset?: PreOffsetFunction;\n};\n\n/**\n * Scope provided to the `preOffset` and `postOffset` functions,\n * containing contextual information about the current encoding or decoding process.\n *\n * The pre-offset function modifies where encoding or decoding begins,\n * while the post-offset function modifies where the next operation continues.\n *\n * @property bytes - The entire byte array being encoded or decoded.\n * @property preOffset - The original offset before encoding or decoding starts.\n * @property wrapBytes - A helper function that wraps offsets around the byte array length.\n *\n * @example\n * Using `wrapBytes` to wrap a negative offset to the end of the byte array.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves to last 4 bytes\n * };\n * ```\n *\n * @example\n * Adjusting the offset dynamically based on the byte array size.\n * ```ts\n * const config: OffsetConfig = {\n *     preOffset: ({ bytes }) => bytes.length > 10 ? 4 : 2,\n * };\n * ```\n *\n * @see {@link PreOffsetFunction}\n * @see {@link PostOffsetFunction}\n */\ntype PreOffsetFunctionScope = {\n    /** The entire byte array. */\n    bytes: ReadonlyUint8Array | Uint8Array;\n    /** The original offset prior to encode or decode. */\n    preOffset: Offset;\n    /** Wraps the offset to the byte array length. */\n    wrapBytes: (offset: Offset) => Offset;\n};\n\n/**\n * A function that modifies the pre-offset before encoding or decoding.\n *\n * This function is used to adjust the starting position before writing\n * or reading data in a byte array.\n *\n * @param scope - The current encoding or decoding context.\n * @returns The new offset at which encoding or decoding should start.\n *\n * @example\n * Skipping the first 2 bytes before writing or reading.\n * ```ts\n * const preOffset: PreOffsetFunction = ({ preOffset }) => preOffset + 2;\n * ```\n *\n * @example\n * Wrapping the offset to ensure it stays within bounds.\n * ```ts\n * const preOffset: PreOffsetFunction = ({ wrapBytes, preOffset }) => wrapBytes(preOffset + 10);\n * ```\n *\n * @see {@link OffsetConfig}\n * @see {@link PreOffsetFunctionScope}\n */\ntype PreOffsetFunction = (scope: PreOffsetFunctionScope) => Offset;\n\n/**\n * A function that modifies the post-offset after encoding or decoding.\n *\n * This function adjusts where the next encoder or decoder should start\n * after the current operation has completed.\n *\n * @param scope - The current encoding or decoding context, including the modified pre-offset\n * and the original post-offset.\n * @returns The new offset at which the next operation should begin.\n *\n * @example\n * Moving the post-offset forward by 4 bytes.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ postOffset }) => postOffset + 4;\n * ```\n *\n * @example\n * Wrapping the post-offset within the byte array length.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ wrapBytes, postOffset }) => wrapBytes(postOffset);\n * ```\n *\n * @example\n * Ensuring a minimum spacing of 8 bytes between values.\n * ```ts\n * const postOffset: PostOffsetFunction = ({ postOffset, newPreOffset }) =>\n *     Math.max(postOffset, newPreOffset + 8);\n * ```\n *\n * @see {@link OffsetConfig}\n * @see {@link PreOffsetFunctionScope}\n */\ntype PostOffsetFunction = (\n    scope: PreOffsetFunctionScope & {\n        /** The modified offset used to encode or decode. */\n        newPreOffset: Offset;\n        /** The original offset returned by the encoder or decoder. */\n        postOffset: Offset;\n    },\n) => Offset;\n\n/**\n * Moves the offset of a given encoder before and/or after encoding.\n *\n * This function allows an encoder to write its encoded value at a different offset\n * than the one originally provided. It supports both pre-offset adjustments\n * (before encoding) and post-offset adjustments (after encoding).\n *\n * The pre-offset function determines where encoding should start, while the\n * post-offset function adjusts where the next encoder should continue writing.\n *\n * For more details, see {@link offsetCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new encoder with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * encoder.write(42, bytes, 0); // Actually written at offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * const nextOffset = encoder.write(42, bytes, 0); // Next encoder starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to ensure an offset wraps around the byte array length.\n * ```ts\n * const encoder = offsetEncoder(getU32Encoder(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes of the array\n * });\n * const bytes = new Uint8Array(10);\n * encoder.write(42, bytes, 0); // Writes at bytes.length - 4\n * ```\n *\n * @remarks\n * If you need both encoding and decoding offsets to be adjusted, use {@link offsetCodec}.\n *\n * @see {@link offsetCodec}\n * @see {@link offsetDecoder}\n */\nexport function offsetEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, config: OffsetConfig): TEncoder {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetEncoder', newPostOffset, bytes.length);\n            return newPostOffset;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Moves the offset of a given decoder before and/or after decoding.\n *\n * This function allows a decoder to read its input from a different offset\n * than the one originally provided. It supports both pre-offset adjustments\n * (before decoding) and post-offset adjustments (after decoding).\n *\n * The pre-offset function determines where decoding should start, while the\n * post-offset function adjusts where the next decoder should continue reading.\n *\n * For more details, see {@link offsetCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new decoder with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array([0, 0, 42, 0]); // Value starts at offset 2\n * decoder.read(bytes, 0); // Actually reads from offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array([42, 0, 0, 0]);\n * const [value, nextOffset] = decoder.read(bytes, 0); // Next decoder starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to read from the last 4 bytes of an array.\n * ```ts\n * const decoder = offsetDecoder(getU32Decoder(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes of the array\n * });\n * const bytes = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 42]); // Value stored at the last 4 bytes\n * decoder.read(bytes, 0); // Reads from bytes.length - 4\n * ```\n *\n * @remarks\n * If you need both encoding and decoding offsets to be adjusted, use {@link offsetCodec}.\n *\n * @see {@link offsetCodec}\n * @see {@link offsetEncoder}\n */\nexport function offsetDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, config: OffsetConfig): TDecoder {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset) => {\n            const wrapBytes = (offset: Offset) => modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset\n                ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes })\n                : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange('offsetDecoder', newPostOffset, bytes.length);\n            return [value, newPostOffset];\n        },\n    }) as TDecoder;\n}\n\n/**\n * Moves the offset of a given codec before and/or after encoding and decoding.\n *\n * This function allows a codec to encode and decode values at custom offsets\n * within a byte array. It modifies both the **pre-offset** (where encoding/decoding starts)\n * and the **post-offset** (where the next operation should continue).\n *\n * This is particularly useful when working with structured binary formats\n * that require skipping reserved bytes, inserting padding, or aligning fields at\n * specific locations.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to adjust.\n * @param config - An object specifying how the offset should be modified.\n * @returns A new codec with adjusted offsets.\n *\n * @example\n * Moving the pre-offset forward by 2 bytes when encoding and decoding.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     preOffset: ({ preOffset }) => preOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0); // Actually written at offset 2\n * codec.read(bytes, 0);      // Actually read from offset 2\n * ```\n *\n * @example\n * Moving the post-offset forward by 2 bytes when encoding and decoding.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     postOffset: ({ postOffset }) => postOffset + 2,\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0);\n * // Next encoding starts at offset 6 instead of 4\n * codec.read(bytes, 0);\n * // Next decoding starts at offset 6 instead of 4\n * ```\n *\n * @example\n * Using `wrapBytes` to loop around negative offsets.\n * ```ts\n * const codec = offsetCodec(getU32Codec(), {\n *     preOffset: ({ wrapBytes }) => wrapBytes(-4), // Moves offset to last 4 bytes\n * });\n * const bytes = new Uint8Array(10);\n * codec.write(42, bytes, 0); // Writes at bytes.length - 4\n * codec.read(bytes, 0); // Reads from bytes.length - 4\n * ```\n *\n * @remarks\n * If you only need to adjust offsets for encoding, use {@link offsetEncoder}.\n * If you only need to adjust offsets for decoding, use {@link offsetDecoder}.\n *\n * ```ts\n * const bytes = new Uint8Array(10);\n * offsetEncoder(getU32Encoder(), { preOffset: ({ preOffset }) => preOffset + 2 }).write(42, bytes, 0);\n * const [value] = offsetDecoder(getU32Decoder(), { preOffset: ({ preOffset }) => preOffset + 2 }).read(bytes, 0);\n * ```\n *\n * @see {@link offsetEncoder}\n * @see {@link offsetDecoder}\n */\nexport function offsetCodec<TCodec extends AnyCodec>(codec: TCodec, config: OffsetConfig): TCodec {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config)) as TCodec;\n}\n\n/** A modulo function that handles negative dividends and zero divisors. */\nfunction modulo(dividend: number, divisor: number) {\n    if (divisor === 0) return 0;\n    return ((dividend % divisor) + divisor) % divisor;\n}\n","import { SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport {\n    Codec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isFixedSize,\n} from './codec';\nimport { combineCodec } from './combine-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Updates the size of a given encoder.\n *\n * This function modifies the size of an encoder using a provided transformation function.\n * For fixed-size encoders, it updates the `fixedSize` property, and for variable-size\n * encoders, it adjusts the size calculation based on the encoded value.\n *\n * If the new size is negative, an error will be thrown.\n *\n * For more details, see {@link resizeCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The original fixed size of the encoded value.\n * @typeParam TNewSize - The new fixed size after resizing.\n *\n * @param encoder - The encoder whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new encoder with the updated size.\n *\n * @example\n * Increasing the size of a `u16` encoder by 2 bytes.\n * ```ts\n * const encoder = resizeEncoder(getU16Encoder(), size => size + 2);\n * encoder.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * ```\n *\n * @example\n * Shrinking a `u32` encoder to only use 2 bytes.\n * ```ts\n * const encoder = resizeEncoder(getU32Encoder(), () => 2);\n * encoder.fixedSize; // 2\n * ```\n *\n * @see {@link resizeCodec}\n * @see {@link resizeDecoder}\n */\nexport function resizeEncoder<TFrom, TSize extends number, TNewSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeEncoder<TFrom, TNewSize>;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder;\nexport function resizeEncoder<TEncoder extends AnyEncoder>(\n    encoder: TEncoder,\n    resize: (size: number) => number,\n): TEncoder {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeEncoder',\n            });\n        }\n        return createEncoder({ ...encoder, fixedSize }) as TEncoder;\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: value => {\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: 'resizeEncoder',\n                });\n            }\n            return newSize;\n        },\n    }) as TEncoder;\n}\n\n/**\n * Updates the size of a given decoder.\n *\n * This function modifies the size of a decoder using a provided transformation function.\n * For fixed-size decoders, it updates the `fixedSize` property to reflect the new size.\n * Variable-size decoders remain unchanged, as their size is determined dynamically.\n *\n * If the new size is negative, an error will be thrown.\n *\n * For more details, see {@link resizeCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The original fixed size of the decoded value.\n * @typeParam TNewSize - The new fixed size after resizing.\n *\n * @param decoder - The decoder whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new decoder with the updated size.\n *\n * @example\n * Expanding a `u16` decoder to read 4 bytes instead of 2.\n * ```ts\n * const decoder = resizeDecoder(getU16Decoder(), size => size + 2);\n * decoder.fixedSize; // 4\n * ```\n *\n * @example\n * Shrinking a `u32` decoder to only read 2 bytes.\n * ```ts\n * const decoder = resizeDecoder(getU32Decoder(), () => 2);\n * decoder.fixedSize; // 2\n * ```\n *\n * @see {@link resizeCodec}\n * @see {@link resizeEncoder}\n */\nexport function resizeDecoder<TFrom, TSize extends number, TNewSize extends number>(\n    decoder: FixedSizeDecoder<TFrom, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeDecoder<TFrom, TNewSize>;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder;\nexport function resizeDecoder<TDecoder extends AnyDecoder>(\n    decoder: TDecoder,\n    resize: (size: number) => number,\n): TDecoder {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: 'resizeDecoder',\n            });\n        }\n        return createDecoder({ ...decoder, fixedSize }) as TDecoder;\n    }\n    return decoder;\n}\n\n/**\n * Updates the size of a given codec.\n *\n * This function modifies the size of both the codec using a provided\n * transformation function. It is useful for adjusting the allocated byte size for\n * encoding and decoding without altering the underlying data structure.\n *\n * If the new size is negative, an error will be thrown.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The original fixed size of the encoded/decoded value (for fixed-size codecs).\n * @typeParam TNewSize - The new fixed size after resizing (for fixed-size codecs).\n *\n * @param codec - The codec whose size will be updated.\n * @param resize - A function that takes the current size and returns the new size.\n * @returns A new codec with the updated size.\n *\n * @example\n * Expanding a `u16` codec from 2 to 4 bytes.\n * ```ts\n * const codec = resizeCodec(getU16Codec(), size => size + 2);\n * const bytes = codec.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * const value = codec.decode(bytes);  // 0xffff (reads original two bytes)\n * ```\n *\n * @example\n * Shrinking a `u32` codec to only use 2 bytes.\n * ```ts\n * const codec = resizeCodec(getU32Codec(), () => 2);\n * codec.fixedSize; // 2\n * ```\n *\n * @remarks\n * If you only need to resize an encoder, use {@link resizeEncoder}.\n * If you only need to resize a decoder, use {@link resizeDecoder}.\n *\n * ```ts\n * const bytes = resizeEncoder(getU32Encoder(), (size) => size + 2).encode(0xffff);\n * const value = resizeDecoder(getU32Decoder(), (size) => size + 2).decode(bytes);\n * ```\n *\n * @see {@link resizeEncoder}\n * @see {@link resizeDecoder}\n */\nexport function resizeCodec<TFrom, TTo extends TFrom, TSize extends number, TNewSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n    resize: (size: TSize) => TNewSize,\n): FixedSizeCodec<TFrom, TTo, TNewSize>;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec;\nexport function resizeCodec<TCodec extends AnyCodec>(codec: TCodec, resize: (size: number) => number): TCodec {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize)) as TCodec;\n}\n","import { Codec, Decoder, Encoder, Offset } from './codec';\nimport { combineCodec } from './combine-codec';\nimport { offsetDecoder, offsetEncoder } from './offset-codec';\nimport { resizeDecoder, resizeEncoder } from './resize-codec';\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyEncoder = Encoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyDecoder = Decoder<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype AnyCodec = Codec<any>;\n\n/**\n * Adds left padding to the given encoder, shifting the encoded value forward\n * by `offset` bytes whilst increasing the size of the encoder accordingly.\n *\n * For more details, see {@link padLeftCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to pad.\n * @param offset - The number of padding bytes to add before encoding.\n * @returns A new encoder with left padding applied.\n *\n * @example\n * ```ts\n * const encoder = padLeftEncoder(getU16Encoder(), 2);\n * const bytes = encoder.encode(0xffff); // 0x0000ffff (0xffff written at offset 2)\n * ```\n *\n * @see {@link padLeftCodec}\n * @see {@link padLeftDecoder}\n */\nexport function padLeftEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given encoder, extending the encoded value by `offset`\n * bytes whilst increasing the size of the encoder accordingly.\n *\n * For more details, see {@link padRightCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n *\n * @param encoder - The encoder to pad.\n * @param offset - The number of padding bytes to add after encoding.\n * @returns A new encoder with right padding applied.\n *\n * @example\n * ```ts\n * const encoder = padRightEncoder(getU16Encoder(), 2);\n * const bytes = encoder.encode(0xffff); // 0xffff0000 (two extra bytes added at the end)\n * ```\n *\n * @see {@link padRightCodec}\n * @see {@link padRightDecoder}\n */\nexport function padRightEncoder<TEncoder extends AnyEncoder>(encoder: TEncoder, offset: Offset): TEncoder {\n    return offsetEncoder(\n        resizeEncoder(encoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given decoder, shifting the decoding position forward\n * by `offset` bytes whilst increasing the size of the decoder accordingly.\n *\n * For more details, see {@link padLeftCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to pad.\n * @param offset - The number of padding bytes to skip before decoding.\n * @returns A new decoder with left padding applied.\n *\n * @example\n * ```ts\n * const decoder = padLeftDecoder(getU16Decoder(), 2);\n * const value = decoder.decode(new Uint8Array([0, 0, 0x12, 0x34])); // 0xffff (reads from offset 2)\n * ```\n *\n * @see {@link padLeftCodec}\n * @see {@link padLeftEncoder}\n */\nexport function padLeftDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { preOffset: ({ preOffset }) => preOffset + offset },\n    );\n}\n\n/**\n * Adds right padding to the given decoder, extending the post-offset by `offset`\n * bytes whilst increasing the size of the decoder accordingly.\n *\n * For more details, see {@link padRightCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n *\n * @param decoder - The decoder to pad.\n * @param offset - The number of padding bytes to skip after decoding.\n * @returns A new decoder with right padding applied.\n *\n * @example\n * ```ts\n * const decoder = padRightDecoder(getU16Decoder(), 2);\n * const value = decoder.decode(new Uint8Array([0x12, 0x34, 0, 0])); // 0xffff (ignores trailing bytes)\n * ```\n *\n * @see {@link padRightCodec}\n * @see {@link padRightEncoder}\n */\nexport function padRightDecoder<TDecoder extends AnyDecoder>(decoder: TDecoder, offset: Offset): TDecoder {\n    return offsetDecoder(\n        resizeDecoder(decoder, size => size + offset),\n        { postOffset: ({ postOffset }) => postOffset + offset },\n    );\n}\n\n/**\n * Adds left padding to the given codec, shifting the encoding and decoding positions\n * forward by `offset` bytes whilst increasing the size of the codec accordingly.\n *\n * This ensures that values are read and written at a later position in the byte array,\n * while the padding bytes remain unused.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to pad.\n * @param offset - The number of padding bytes to add before encoding and decoding.\n * @returns A new codec with left padding applied.\n *\n * @example\n * ```ts\n * const codec = padLeftCodec(getU16Codec(), 2);\n * const bytes = codec.encode(0xffff); // 0x0000ffff (0xffff written at offset 2)\n * const value = codec.decode(bytes);  // 0xffff (reads from offset 2)\n * ```\n *\n * @remarks\n * If you only need to apply padding for encoding, use {@link padLeftEncoder}.\n * If you only need to apply padding for decoding, use {@link padLeftDecoder}.\n *\n * ```ts\n * const bytes = padLeftEncoder(getU16Encoder(), 2).encode(0xffff);\n * const value = padLeftDecoder(getU16Decoder(), 2).decode(bytes);\n * ```\n *\n * @see {@link padLeftEncoder}\n * @see {@link padLeftDecoder}\n */\nexport function padLeftCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset)) as TCodec;\n}\n\n/**\n * Adds right padding to the given codec, extending the encoded and decoded value\n * by `offset` bytes whilst increasing the size of the codec accordingly.\n *\n * The extra bytes remain unused, ensuring that the next operation starts further\n * along the byte array.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n *\n * @param codec - The codec to pad.\n * @param offset - The number of padding bytes to add after encoding and decoding.\n * @returns A new codec with right padding applied.\n *\n * @example\n * ```ts\n * const codec = padRightCodec(getU16Codec(), 2);\n * const bytes = codec.encode(0xffff); // 0xffff0000 (two extra bytes added)\n * const value = codec.decode(bytes);  // 0xffff (ignores padding bytes)\n * ```\n *\n * @remarks\n * If you only need to apply padding for encoding, use {@link padRightEncoder}.\n * If you only need to apply padding for decoding, use {@link padRightDecoder}.\n *\n * ```ts\n * const bytes = padRightEncoder(getU16Encoder(), 2).encode(0xffff);\n * const value = padRightDecoder(getU16Decoder(), 2).decode(bytes);\n * ```\n *\n * @see {@link padRightEncoder}\n * @see {@link padRightDecoder}\n */\nexport function padRightCodec<TCodec extends AnyCodec>(codec: TCodec, offset: Offset): TCodec {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset)) as TCodec;\n}\n","import {\n    assertIsFixedSize,\n    createDecoder,\n    createEncoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n} from './codec';\nimport { combineCodec } from './combine-codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\nfunction copySourceToTargetInReverse(\n    source: ReadonlyUint8Array,\n    target_WILL_MUTATE: Uint8Array,\n    sourceOffset: number,\n    sourceLength: number,\n    targetOffset: number = 0,\n) {\n    while (sourceOffset < --sourceLength) {\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\n\n/**\n * Reverses the bytes of a fixed-size encoder.\n *\n * Given a `FixedSizeEncoder`, this function returns a new `FixedSizeEncoder` that\n * reverses the bytes within the fixed-size byte array when encoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * For more details, see {@link reverseCodec}.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TSize - The fixed size of the encoded value in bytes.\n *\n * @param encoder - The fixed-size encoder to reverse.\n * @returns A new encoder that writes bytes in reverse order.\n *\n * @example\n * Encoding a `u16` value in reverse order.\n * ```ts\n * const encoder = reverseEncoder(getU16Encoder({ endian: Endian.Big }));\n * const bytes = encoder.encode(0x1234); // 0x3412 (bytes are flipped)\n * ```\n *\n * @see {@link reverseCodec}\n * @see {@link reverseDecoder}\n */\nexport function reverseEncoder<TFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value: TFrom, bytes, offset) => {\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                bytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + encoder.fixedSize /* sourceLength */,\n            );\n            return newOffset;\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size decoder.\n *\n * Given a `FixedSizeDecoder`, this function returns a new `FixedSizeDecoder` that\n * reverses the bytes within the fixed-size byte array before decoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * For more details, see {@link reverseCodec}.\n *\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the decoded value in bytes.\n *\n * @param decoder - The fixed-size decoder to reverse.\n * @returns A new decoder that reads bytes in reverse order.\n *\n * @example\n * Decoding a reversed `u16` value.\n * ```ts\n * const decoder = reverseDecoder(getU16Decoder({ endian: Endian.Big }));\n * const value = decoder.decode(new Uint8Array([0x34, 0x12])); // 0x1234 (bytes are flipped back)\n * ```\n *\n * @see {@link reverseCodec}\n * @see {@link reverseEncoder}\n */\nexport function reverseDecoder<TTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset) => {\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(\n                bytes /* source */,\n                reversedBytes /* target_WILL_MUTATE */,\n                offset /* sourceOffset */,\n                offset + decoder.fixedSize /* sourceLength */,\n            );\n            return decoder.read(reversedBytes, offset);\n        },\n    });\n}\n\n/**\n * Reverses the bytes of a fixed-size codec.\n *\n * Given a `FixedSizeCodec`, this function returns a new `FixedSizeCodec` that\n * reverses the bytes within the fixed-size byte array during encoding and decoding.\n *\n * This can be useful to modify endianness or for other byte-order transformations.\n *\n * @typeParam TFrom - The type of the value to encode.\n * @typeParam TTo - The type of the decoded value.\n * @typeParam TSize - The fixed size of the encoded/decoded value in bytes.\n *\n * @param codec - The fixed-size codec to reverse.\n * @returns A new codec that encodes and decodes bytes in reverse order.\n *\n * @example\n * Reversing a `u16` codec.\n * ```ts\n * const codec = reverseCodec(getU16Codec({ endian: Endian.Big }));\n * const bytes = codec.encode(0x1234); // 0x3412 (bytes are flipped)\n * const value = codec.decode(bytes);  // 0x1234 (bytes are flipped back)\n * ```\n *\n * @remarks\n * If you only need to reverse an encoder, use {@link reverseEncoder}.\n * If you only need to reverse a decoder, use {@link reverseDecoder}.\n *\n * ```ts\n * const bytes = reverseEncoder(getU16Encoder()).encode(0x1234);\n * const value = reverseDecoder(getU16Decoder()).decode(bytes);\n * ```\n *\n * @see {@link reverseEncoder}\n * @see {@link reverseDecoder}\n */\nexport function reverseCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    codec: FixedSizeCodec<TFrom, TTo, TSize>,\n): FixedSizeCodec<TFrom, TTo, TSize> {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n","import {\n    Codec,\n    createCodec,\n    createDecoder,\n    createEncoder,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    isVariableSize,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from './codec';\nimport { ReadonlyUint8Array } from './readonly-uint8array';\n\n/**\n * Transforms an encoder by mapping its input values.\n *\n * This function takes an existing `Encoder<A>` and returns an `Encoder<B>`, allowing values of type `B`\n * to be converted into values of type `A` before encoding. The transformation is applied via the `unmap` function.\n *\n * This is useful for handling type conversions, applying default values, or structuring data before encoding.\n *\n * For more details, see {@link transformCodec}.\n *\n * @typeParam TOldFrom - The original type expected by the encoder.\n * @typeParam TNewFrom - The new type that will be transformed before encoding.\n *\n * @param encoder - The encoder to transform.\n * @param unmap - A function that converts values of `TNewFrom` into `TOldFrom` before encoding.\n * @returns A new encoder that accepts `TNewFrom` values and transforms them before encoding.\n *\n * @example\n * Encoding a string by counting its characters and storing the length as a `u32`.\n * ```ts\n * const encoder = transformEncoder(getU32Encoder(), (value: string) => value.length);\n * encoder.encode(\"hello\"); // 0x05000000 (stores length 5)\n * ```\n *\n * @see {@link transformCodec}\n * @see {@link transformDecoder}\n */\nexport function transformEncoder<TOldFrom, TNewFrom, TSize extends number>(\n    encoder: FixedSizeEncoder<TOldFrom, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeEncoder<TNewFrom, TSize>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: VariableSizeEncoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeEncoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom>;\nexport function transformEncoder<TOldFrom, TNewFrom>(\n    encoder: Encoder<TOldFrom>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Encoder<TNewFrom> {\n    return createEncoder({\n        ...(isVariableSize(encoder)\n            ? { ...encoder, getSizeFromValue: (value: TNewFrom) => encoder.getSizeFromValue(unmap(value)) }\n            : encoder),\n        write: (value: TNewFrom, bytes, offset) => encoder.write(unmap(value), bytes, offset),\n    });\n}\n\n/**\n * Transforms a decoder by mapping its output values.\n *\n * This function takes an existing `Decoder<A>` and returns a `Decoder<B>`, allowing values of type `A`\n * to be converted into values of type `B` after decoding. The transformation is applied via the `map` function.\n *\n * This is useful for post-processing, type conversions, or enriching decoded data.\n *\n * For more details, see {@link transformCodec}.\n *\n * @typeParam TOldTo - The original type returned by the decoder.\n * @typeParam TNewTo - The new type that will be transformed after decoding.\n *\n * @param decoder - The decoder to transform.\n * @param map - A function that converts values of `TOldTo` into `TNewTo` after decoding.\n * @returns A new decoder that decodes into `TNewTo`.\n *\n * @example\n * Decoding a stored `u32` length into a string of `'x'` characters.\n * ```ts\n * const decoder = transformDecoder(getU32Decoder(), (length) => 'x'.repeat(length));\n * decoder.decode(new Uint8Array([0x05, 0x00, 0x00, 0x00])); // \"xxxxx\"\n * ```\n *\n * @see {@link transformCodec}\n * @see {@link transformEncoder}\n */\nexport function transformDecoder<TOldTo, TNewTo, TSize extends number>(\n    decoder: FixedSizeDecoder<TOldTo, TSize>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeDecoder<TNewTo, TSize>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: VariableSizeDecoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeDecoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo>;\nexport function transformDecoder<TOldTo, TNewTo>(\n    decoder: Decoder<TOldTo>,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Decoder<TNewTo> {\n    return createDecoder({\n        ...decoder,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [map(value, bytes, offset), newOffset];\n        },\n    });\n}\n\n/**\n * Transforms a codec by mapping its input and output values.\n *\n * This function takes an existing `Codec<A, B>` and returns a `Codec<C, D>`, allowing:\n * - Values of type `C` to be transformed into `A` before encoding.\n * - Values of type `B` to be transformed into `D` after decoding.\n *\n * This is useful for adapting codecs to work with different representations, handling default values, or\n * converting between primitive and structured types.\n *\n * @typeParam TOldFrom - The original type expected by the codec.\n * @typeParam TNewFrom - The new type that will be transformed before encoding.\n * @typeParam TOldTo - The original type returned by the codec.\n * @typeParam TNewTo - The new type that will be transformed after decoding.\n *\n * @param codec - The codec to transform.\n * @param unmap - A function that converts values of `TNewFrom` into `TOldFrom` before encoding.\n * @param map - A function that converts values of `TOldTo` into `TNewTo` after decoding (optional).\n * @returns A new codec that encodes `TNewFrom` and decodes into `TNewTo`.\n *\n * @example\n * Mapping a `u32` codec to encode string lengths and decode them into `'x'` characters.\n * ```ts\n * const codec = transformCodec(\n *     getU32Codec(),\n *     (value: string) => value.length, // Encode string length\n *     (length) => 'x'.repeat(length)  // Decode length into a string of 'x's\n * );\n *\n * const bytes = codec.encode(\"hello\"); // 0x05000000 (stores length 5)\n * const value = codec.decode(bytes);   // \"xxxxx\"\n * ```\n *\n * @remarks\n * If only input transformation is needed, use {@link transformEncoder}.\n * If only output transformation is needed, use {@link transformDecoder}.\n *\n * ```ts\n * const bytes = transformEncoder(getU32Encoder(), (value: string) => value.length).encode(\"hello\");\n * const value = transformDecoder(getU32Decoder(), (length) => 'x'.repeat(length)).decode(bytes);\n * ```\n *\n * @see {@link transformEncoder}\n * @see {@link transformDecoder}\n */\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom, TSize extends number>(\n    codec: FixedSizeCodec<TOldFrom, TTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): FixedSizeCodec<TNewFrom, TTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: VariableSizeCodec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): VariableSizeCodec<TNewFrom, TTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TTo extends TNewFrom & TOldFrom>(\n    codec: Codec<TOldFrom, TTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n): Codec<TNewFrom, TTo>;\nexport function transformCodec<\n    TOldFrom,\n    TNewFrom,\n    TOldTo extends TOldFrom,\n    TNewTo extends TNewFrom,\n    TSize extends number,\n>(\n    codec: FixedSizeCodec<TOldFrom, TOldTo, TSize>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): FixedSizeCodec<TNewFrom, TNewTo, TSize>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: VariableSizeCodec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): VariableSizeCodec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo>;\nexport function transformCodec<TOldFrom, TNewFrom, TOldTo extends TOldFrom, TNewTo extends TNewFrom>(\n    codec: Codec<TOldFrom, TOldTo>,\n    unmap: (value: TNewFrom) => TOldFrom,\n    map?: (value: TOldTo, bytes: ReadonlyUint8Array | Uint8Array, offset: number) => TNewTo,\n): Codec<TNewFrom, TNewTo> {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : (codec.read as unknown as Decoder<TNewTo>['read']),\n    });\n}\n","// src/codes.ts\nvar SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;\nvar SOLANA_ERROR__INVALID_NONCE = 2;\nvar SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;\nvar SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;\nvar SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;\nvar SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;\nvar SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;\nvar SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;\nvar SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;\nvar SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10;\nvar SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;\nvar SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;\nvar SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;\nvar SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;\nvar SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE = -32019;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY = -32018;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE = -32017;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;\nvar SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;\nvar SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;\nvar SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 28e5;\nvar SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;\nvar SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;\nvar SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;\nvar SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;\nvar SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;\nvar SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;\nvar SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;\nvar SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;\nvar SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;\nvar SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;\nvar SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = 2800011;\nvar SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 323e4;\nvar SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;\nvar SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;\nvar SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;\nvar SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 361e4;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;\nvar SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;\nvar SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611e3;\nvar SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704e3;\nvar SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;\nvar SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;\nvar SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;\nvar SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;\nvar SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128e3;\nvar SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;\nvar SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615e3;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;\nvar SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;\nvar SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508e3;\nvar SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;\nvar SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;\nvar SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;\nvar SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;\nvar SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;\nvar SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;\nvar SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;\nvar SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;\nvar SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663e3;\nvar SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;\nvar SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;\nvar SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;\nvar SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;\nvar SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;\nvar SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;\nvar SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;\nvar SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;\nvar SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;\nvar SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;\nvar SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;\nvar SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;\nvar SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;\nvar SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;\nvar SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;\nvar SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = 5663020;\nvar SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED = 5663021;\nvar SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE = 5663022;\nvar SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 705e4;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;\nvar SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;\nvar SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;\nvar SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;\nvar SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;\nvar SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;\nvar SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;\nvar SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;\nvar SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;\nvar SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;\nvar SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;\nvar SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;\nvar SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;\nvar SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;\nvar SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;\nvar SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;\nvar SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;\nvar SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;\nvar SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN = 7618e3;\nvar SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE = 7618001;\nvar SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN = 7618002;\nvar SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN = 7618003;\nvar SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078e3;\nvar SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;\nvar SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;\nvar SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;\nvar SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;\nvar SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;\nvar SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;\nvar SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;\nvar SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;\nvar SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;\nvar SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;\nvar SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;\nvar SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;\nvar SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;\nvar SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;\nvar SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;\nvar SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;\nvar SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;\nvar SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;\nvar SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;\nvar SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;\nvar SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;\nvar SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;\nvar SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY = 8078023;\nvar SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 81e5;\nvar SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;\nvar SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;\nvar SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 819e4;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;\nvar SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 99e5;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND = 9900005;\nvar SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND = 9900006;\n\n// src/context.ts\nfunction encodeValue(value) {\n  if (Array.isArray(value)) {\n    const commaSeparatedValues = value.map(encodeValue).join(\n      \"%2C%20\"\n      /* \", \" */\n    );\n    return \"%5B\" + commaSeparatedValues + /* \"]\" */\n    \"%5D\";\n  } else if (typeof value === \"bigint\") {\n    return `${value}n`;\n  } else {\n    return encodeURIComponent(\n      String(\n        value != null && Object.getPrototypeOf(value) === null ? (\n          // Plain objects with no prototype don't have a `toString` method.\n          // Convert them before stringifying them.\n          { ...value }\n        ) : value\n      )\n    );\n  }\n}\nfunction encodeObjectContextEntry([key, value]) {\n  return `${key}=${encodeValue(value)}`;\n}\nfunction encodeContextObject(context) {\n  const searchParamsString = Object.entries(context).map(encodeObjectContextEntry).join(\"&\");\n  return btoa(searchParamsString);\n}\n\n// src/messages.ts\nvar SolanaErrorMessages = {\n  [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: \"Account not found at address: $address\",\n  [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: \"Not all accounts were decoded. Encoded accounts found at addresses: $addresses.\",\n  [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: \"Expected decoded account at address: $address\",\n  [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: \"Failed to decode account data at address: $address\",\n  [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: \"Accounts not found at addresses: $addresses\",\n  [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]: \"Unable to find a viable program address bump seed.\",\n  [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: \"$putativeAddress is not a base58-encoded address.\",\n  [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: \"Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.\",\n  [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: \"The `CryptoKey` must be an `Ed25519` public key.\",\n  [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS]: \"$putativeOffCurveAddress is not a base58-encoded off-curve address.\",\n  [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: \"Invalid seeds; point must fall off the Ed25519 curve.\",\n  [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]: \"Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].\",\n  [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: \"A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.\",\n  [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: \"The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.\",\n  [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: \"Expected program derived address bump to be in the range [0, 255], got: $bump.\",\n  [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: \"Program address cannot end with PDA marker.\",\n  [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.\",\n  [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.\",\n  [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: \"The network has progressed past the last block for which this transaction could have been committed.\",\n  [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: \"Codec [$codecDescription] cannot decode empty byte arrays.\",\n  [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: \"Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.\",\n  [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: \"Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].\",\n  [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: \"Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].\",\n  [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: \"Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].\",\n  [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]: \"Encoder and decoder must either both be fixed-size or variable-size.\",\n  [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: \"Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.\",\n  [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: \"Expected a fixed-size codec, got a variable-size one.\",\n  [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: \"Codec [$codecDescription] expected a positive byte length, got $bytesLength.\",\n  [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: \"Expected a variable-size codec, got a fixed-size one.\",\n  [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: \"Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].\",\n  [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: \"Codec [$codecDescription] expected $expected bytes, got $bytesLength.\",\n  [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: \"Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].\",\n  [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: \"Invalid discriminated union variant. Expected one of [$variants], got $value.\",\n  [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: \"Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.\",\n  [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: \"Invalid literal union variant. Expected one of [$variants], got $value.\",\n  [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: \"Expected [$codecDescription] to have $expected items, got $actual.\",\n  [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: \"Invalid value $value for base $base with alphabet $alphabet.\",\n  [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: \"Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.\",\n  [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: \"Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.\",\n  [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: \"Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.\",\n  [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: \"Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].\",\n  [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: \"Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.\",\n  [SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY]: \"This decoder expected a byte array of exactly $expectedLength bytes, but $numExcessBytes unexpected excess bytes remained after decoding. Are you sure that you have chosen the correct decoder for this data?\",\n  [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: \"No random values implementation could be found.\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: \"instruction requires an uninitialized account\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]: \"instruction tries to borrow reference for an account which is already borrowed\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: \"instruction left account with an outstanding borrowed reference\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]: \"program other than the account's owner changed the size of the account data\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: \"account data too small for instruction\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: \"instruction expected an executable account\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]: \"An account does not have enough lamports to be rent-exempt\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: \"Program arithmetic overflowed\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: \"Failed to serialize or deserialize account data: $encodedData\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]: \"Builtin programs must consume compute units\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: \"Cross-program invocation call depth too deep\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: \"Computational budget exceeded\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: \"custom program error: #$code\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: \"instruction contains duplicate accounts\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]: \"instruction modifications of multiply-passed account differ\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: \"executable accounts must be rent exempt\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: \"instruction changed executable accounts data\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]: \"instruction changed the balance of an executable account\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: \"instruction changed executable bit of an account\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]: \"instruction modified data of an account it does not own\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]: \"instruction spent from the balance of an account it does not own\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: \"generic instruction error\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: \"Provided owner is not allowed\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: \"Account is immutable\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: \"Incorrect authority provided\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: \"incorrect program id for instruction\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: \"insufficient funds for instruction\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: \"invalid account data for instruction\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: \"Invalid account owner\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: \"invalid program argument\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: \"program returned invalid error code\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: \"invalid instruction data\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: \"Failed to reallocate account data\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: \"Provided seeds do not result in a valid address\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]: \"Accounts data allocations exceeded the maximum allowed per transaction\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: \"Max accounts exceeded\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: \"Max instruction trace length exceeded\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]: \"Length of the seed is too long for address generation\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: \"An account required by the instruction is missing\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: \"missing required signature for instruction\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]: \"instruction illegally modified the program id of an account\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: \"insufficient account keys for instruction\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]: \"Cross-program invocation with unauthorized signer or writable account\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]: \"Failed to create program execution environment\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: \"Program failed to compile\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: \"Program failed to complete\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: \"instruction modified data of a read-only account\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]: \"instruction changed the balance of a read-only account\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]: \"Cross-program invocation reentrancy not allowed for this instruction\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: \"instruction modified rent epoch of an account\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]: \"sum of account balances before and after instruction do not match\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: \"instruction requires an initialized account\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: \"\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: \"Unsupported program id\",\n  [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: \"Unsupported sysvar\",\n  [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND]: \"Invalid instruction plan kind: $kind.\",\n  [SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN]: \"The provided instruction plan is empty.\",\n  [SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN]: \"The provided transaction plan failed to execute. See the `transactionPlanResult` attribute and the `cause` error for more details.\",\n  [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN]: \"The provided message has insufficient capacity to accommodate the next instruction(s) in this plan. Expected at least $numBytesRequired free byte(s), got $numFreeBytes byte(s).\",\n  [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND]: \"Invalid transaction plan kind: $kind.\",\n  [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE]: \"No more instructions to pack; the message packer has completed the instruction plan.\",\n  [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: \"The instruction does not have any accounts.\",\n  [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: \"The instruction does not have any data.\",\n  [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: \"Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.\",\n  [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: \"Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.\",\n  [SOLANA_ERROR__INVALID_NONCE]: \"The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`\",\n  [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: \"Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n  [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: \"Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.\",\n  [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]: \"Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n  [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]: \"Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n  [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: \"Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n  [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: \"JSON-RPC error: Internal JSON-RPC error ($__serverMessage)\",\n  [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: \"JSON-RPC error: Invalid method parameter(s) ($__serverMessage)\",\n  [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: \"JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)\",\n  [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: \"JSON-RPC error: The method does not exist / is not available ($__serverMessage)\",\n  [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: \"JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)\",\n  [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: \"$__serverMessage\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: \"$__serverMessage\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: \"$__serverMessage\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: \"$__serverMessage\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE]: \"Epoch rewards period still active at slot $slot\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: \"$__serverMessage\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: \"$__serverMessage\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE]: \"Failed to query long-term storage; please try again\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: \"Minimum context slot has not been reached\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: \"Node is unhealthy; behind by $numSlotsBehind slots\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: \"No snapshot\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: \"Transaction simulation failed\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY]: \"Rewards cannot be found because slot $slot is not the epoch boundary. This may be due to gap in the queried node's local ledger or long-term storage\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: \"$__serverMessage\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]: \"Transaction history is not available from this node\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: \"$__serverMessage\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: \"Transaction signature length mismatch\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]: \"Transaction signature verification failure\",\n  [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: \"$__serverMessage\",\n  [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: \"Key pair bytes must be of length 64, got $byteLength.\",\n  [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: \"Expected private key bytes with length 32. Actual length: $actualLength.\",\n  [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: \"Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.\",\n  [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]: \"The provided private key does not match the provided public key.\",\n  [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.\",\n  [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: \"Lamports value must be in the range [0, 2e64-1]\",\n  [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: \"`$value` cannot be parsed as a `BigInt`\",\n  [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: \"$message\",\n  [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: \"`$value` cannot be parsed as a `Number`\",\n  [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: \"No nonce account could be found at address `$nonceAccountAddress`\",\n  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: \"The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.\",\n  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]: \"WebSocket was closed before payload could be added to the send buffer\",\n  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: \"WebSocket connection closed\",\n  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: \"WebSocket failed to connect\",\n  [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]: \"Failed to obtain a subscription id from the server\",\n  [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: \"Could not find an API plan for RPC method: `$method`\",\n  [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: \"The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.\",\n  [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: \"HTTP error ($statusCode): $message\",\n  [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: \"HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.\",\n  [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: \"Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.\",\n  [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: \"The provided value does not implement the `KeyPairSigner` interface\",\n  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: \"The provided value does not implement the `MessageModifyingSigner` interface\",\n  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: \"The provided value does not implement the `MessagePartialSigner` interface\",\n  [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: \"The provided value does not implement any of the `MessageSigner` interfaces\",\n  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: \"The provided value does not implement the `TransactionModifyingSigner` interface\",\n  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: \"The provided value does not implement the `TransactionPartialSigner` interface\",\n  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: \"The provided value does not implement the `TransactionSendingSigner` interface\",\n  [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: \"The provided value does not implement any of the `TransactionSigner` interfaces\",\n  [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]: \"More than one `TransactionSendingSigner` was identified.\",\n  [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]: \"No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.\",\n  [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]: \"Wallet account signers do not support signing multiple messages/transactions in a single operation\",\n  [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: \"Cannot export a non-extractable key.\",\n  [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: \"No digest implementation could be found.\",\n  [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]: \"Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.\",\n  [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]: \"This runtime does not support the generation of Ed25519 key pairs.\\n\\nInstall @solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in environments that do not support Ed25519.\\n\\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.\",\n  [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]: \"No signature verification implementation could be found.\",\n  [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: \"No key generation implementation could be found.\",\n  [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: \"No signing implementation could be found.\",\n  [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: \"No key export implementation could be found.\",\n  [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: \"Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: \"Transaction processing left an account with an outstanding borrowed reference\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: \"Account in use\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: \"Account loaded twice\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]: \"Attempt to debit an account but found no record of a prior credit.\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]: \"Transaction loads an address table account that doesn't exist\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: \"This transaction has already been processed\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: \"Blockhash not found\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: \"Loader call chain is too deep\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]: \"Transactions are currently disabled due to cluster maintenance\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: \"Transaction contains a duplicate instruction ($index) that is not allowed\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: \"Insufficient funds for fee\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: \"Transaction results in an account ($accountIndex) with insufficient funds for rent\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: \"This account may not be used to pay transaction fees\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: \"Transaction contains an invalid account reference\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]: \"Transaction loads an address table account with invalid data\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]: \"Transaction address table lookup uses an invalid index\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]: \"Transaction loads an address table account with an invalid owner\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]: \"LoadedAccountsDataSizeLimit set for transaction must be greater than 0.\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]: \"This program may not be used for executing instructions\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]: \"Transaction leaves an account with a lower balance than rent-exempt minimum\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]: \"Transaction loads a writable account that cannot be written\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]: \"Transaction exceeded max loaded accounts data size cap\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]: \"Transaction requires a fee but has no signature present\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: \"Attempt to load a program that does not exist\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: \"Execution of the program referenced by account at index $accountIndex is temporarily restricted.\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: \"ResanitizationNeeded\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: \"Transaction failed to sanitize accounts offsets correctly\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: \"Transaction did not pass signature verification\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: \"Transaction locked too many accounts\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]: \"Sum of account balances before and after transaction do not match\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: \"The transaction failed with the error `$errorName`\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: \"Transaction version is unsupported\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]: \"Transaction would exceed account data limit within the block\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]: \"Transaction would exceed total account data limit\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]: \"Transaction would exceed max account limit within the block\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]: \"Transaction would exceed max Block Cost Limit\",\n  [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: \"Transaction would exceed max Vote Cost Limit\",\n  [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: \"Attempted to sign a transaction with an address that is not a signer for it\",\n  [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: \"Transaction is missing an address at index: $index.\",\n  [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]: \"Transaction has no expected signers therefore it cannot be encoded\",\n  [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]: \"Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes\",\n  [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: \"Transaction does not have a blockhash lifetime\",\n  [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: \"Transaction is not a durable nonce transaction\",\n  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: \"Contents of these address lookup tables unknown: $lookupTableAddresses\",\n  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: \"Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved\",\n  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: \"No fee payer set in CompiledTransaction\",\n  [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: \"Could not find program address at index $index\",\n  [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]: \"Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more\",\n  [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: \"Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more\",\n  [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: \"Transaction is missing a fee payer.\",\n  [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]: \"Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.\",\n  [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]: \"Transaction first instruction is not advance nonce account instruction.\",\n  [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]: \"Transaction with no instructions cannot be durable nonce transaction.\",\n  [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: \"This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees\",\n  [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: \"This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable\",\n  [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: \"The transaction message expected the transaction to have $numRequiredSignatures signatures, got $signaturesLength.\",\n  [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: \"Transaction is missing signatures for addresses: $addresses.\",\n  [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: \"Transaction version must be in the range [0, 127]. `$actualVersion` given\",\n  [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED]: \"This version of Kit does not support decoding transactions with version $unsupportedVersion. The current max supported version is 0.\",\n  [SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE]: \"The transaction has a durable nonce lifetime (with nonce `$nonce`), but the nonce account address is in a lookup table. The lifetime constraint cannot be constructed without fetching the lookup tables for the transaction.\"\n};\n\n// src/message-formatter.ts\nvar START_INDEX = \"i\";\nvar TYPE = \"t\";\nfunction getHumanReadableErrorMessage(code, context = {}) {\n  const messageFormatString = SolanaErrorMessages[code];\n  if (messageFormatString.length === 0) {\n    return \"\";\n  }\n  let state;\n  function commitStateUpTo(endIndex) {\n    if (state[TYPE] === 2 /* Variable */) {\n      const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);\n      fragments.push(\n        variableName in context ? (\n          // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n          `${context[variableName]}`\n        ) : `$${variableName}`\n      );\n    } else if (state[TYPE] === 1 /* Text */) {\n      fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));\n    }\n  }\n  const fragments = [];\n  messageFormatString.split(\"\").forEach((char, ii) => {\n    if (ii === 0) {\n      state = {\n        [START_INDEX]: 0,\n        [TYPE]: messageFormatString[0] === \"\\\\\" ? 0 /* EscapeSequence */ : messageFormatString[0] === \"$\" ? 2 /* Variable */ : 1 /* Text */\n      };\n      return;\n    }\n    let nextState;\n    switch (state[TYPE]) {\n      case 0 /* EscapeSequence */:\n        nextState = { [START_INDEX]: ii, [TYPE]: 1 /* Text */ };\n        break;\n      case 1 /* Text */:\n        if (char === \"\\\\\") {\n          nextState = { [START_INDEX]: ii, [TYPE]: 0 /* EscapeSequence */ };\n        } else if (char === \"$\") {\n          nextState = { [START_INDEX]: ii, [TYPE]: 2 /* Variable */ };\n        }\n        break;\n      case 2 /* Variable */:\n        if (char === \"\\\\\") {\n          nextState = { [START_INDEX]: ii, [TYPE]: 0 /* EscapeSequence */ };\n        } else if (char === \"$\") {\n          nextState = { [START_INDEX]: ii, [TYPE]: 2 /* Variable */ };\n        } else if (!char.match(/\\w/)) {\n          nextState = { [START_INDEX]: ii, [TYPE]: 1 /* Text */ };\n        }\n        break;\n    }\n    if (nextState) {\n      if (state !== nextState) {\n        commitStateUpTo(ii);\n      }\n      state = nextState;\n    }\n  });\n  commitStateUpTo();\n  return fragments.join(\"\");\n}\nfunction getErrorMessage(code, context = {}) {\n  if (process.env.NODE_ENV !== \"production\") {\n    return getHumanReadableErrorMessage(code, context);\n  } else {\n    let decodingAdviceMessage = `Solana error #${code}; Decode this error by running \\`npx @solana/errors decode -- ${code}`;\n    if (Object.keys(context).length) {\n      decodingAdviceMessage += ` '${encodeContextObject(context)}'`;\n    }\n    return `${decodingAdviceMessage}\\``;\n  }\n}\n\n// src/error.ts\nfunction isSolanaError(e, code) {\n  const isSolanaError2 = e instanceof Error && e.name === \"SolanaError\";\n  if (isSolanaError2) {\n    if (code !== void 0) {\n      return e.context.__code === code;\n    }\n    return true;\n  }\n  return false;\n}\nvar SolanaError = class extends Error {\n  /**\n   * Indicates the root cause of this {@link SolanaError}, if any.\n   *\n   * For example, a transaction error might have an instruction error as its root cause. In this\n   * case, you will be able to access the instruction error on the transaction error as `cause`.\n   */\n  cause = this.cause;\n  /**\n   * Contains context that can assist in understanding or recovering from a {@link SolanaError}.\n   */\n  context;\n  constructor(...[code, contextAndErrorOptions]) {\n    let context;\n    let errorOptions;\n    if (contextAndErrorOptions) {\n      Object.entries(Object.getOwnPropertyDescriptors(contextAndErrorOptions)).forEach(([name, descriptor]) => {\n        if (name === \"cause\") {\n          errorOptions = { cause: descriptor.value };\n        } else {\n          if (context === void 0) {\n            context = {};\n          }\n          Object.defineProperty(context, name, descriptor);\n        }\n      });\n    }\n    const message = getErrorMessage(code, context);\n    super(message, errorOptions);\n    this.context = context === void 0 ? {} : context;\n    this.context.__code = code;\n    this.name = \"SolanaError\";\n  }\n};\n\n// src/stack-trace.ts\nfunction safeCaptureStackTrace(...args) {\n  if (\"captureStackTrace\" in Error && typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(...args);\n  }\n}\n\n// src/rpc-enum-errors.ts\nfunction getSolanaErrorFromRpcError({ errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }, constructorOpt) {\n  let rpcErrorName;\n  let rpcErrorContext;\n  if (typeof rpcEnumError === \"string\") {\n    rpcErrorName = rpcEnumError;\n  } else {\n    rpcErrorName = Object.keys(rpcEnumError)[0];\n    rpcErrorContext = rpcEnumError[rpcErrorName];\n  }\n  const codeOffset = orderedErrorNames.indexOf(rpcErrorName);\n  const errorCode = errorCodeBaseOffset + codeOffset;\n  const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);\n  const err = new SolanaError(errorCode, errorContext);\n  safeCaptureStackTrace(err, constructorOpt);\n  return err;\n}\n\n// src/instruction-error.ts\nvar ORDERED_ERROR_NAMES = [\n  // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/program/src/instruction.rs\n  // If this list ever gets too large, consider implementing a compression strategy like this:\n  // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n  \"GenericError\",\n  \"InvalidArgument\",\n  \"InvalidInstructionData\",\n  \"InvalidAccountData\",\n  \"AccountDataTooSmall\",\n  \"InsufficientFunds\",\n  \"IncorrectProgramId\",\n  \"MissingRequiredSignature\",\n  \"AccountAlreadyInitialized\",\n  \"UninitializedAccount\",\n  \"UnbalancedInstruction\",\n  \"ModifiedProgramId\",\n  \"ExternalAccountLamportSpend\",\n  \"ExternalAccountDataModified\",\n  \"ReadonlyLamportChange\",\n  \"ReadonlyDataModified\",\n  \"DuplicateAccountIndex\",\n  \"ExecutableModified\",\n  \"RentEpochModified\",\n  \"NotEnoughAccountKeys\",\n  \"AccountDataSizeChanged\",\n  \"AccountNotExecutable\",\n  \"AccountBorrowFailed\",\n  \"AccountBorrowOutstanding\",\n  \"DuplicateAccountOutOfSync\",\n  \"Custom\",\n  \"InvalidError\",\n  \"ExecutableDataModified\",\n  \"ExecutableLamportChange\",\n  \"ExecutableAccountNotRentExempt\",\n  \"UnsupportedProgramId\",\n  \"CallDepth\",\n  \"MissingAccount\",\n  \"ReentrancyNotAllowed\",\n  \"MaxSeedLengthExceeded\",\n  \"InvalidSeeds\",\n  \"InvalidRealloc\",\n  \"ComputationalBudgetExceeded\",\n  \"PrivilegeEscalation\",\n  \"ProgramEnvironmentSetupFailure\",\n  \"ProgramFailedToComplete\",\n  \"ProgramFailedToCompile\",\n  \"Immutable\",\n  \"IncorrectAuthority\",\n  \"BorshIoError\",\n  \"AccountNotRentExempt\",\n  \"InvalidAccountOwner\",\n  \"ArithmeticOverflow\",\n  \"UnsupportedSysvar\",\n  \"IllegalOwner\",\n  \"MaxAccountsDataAllocationsExceeded\",\n  \"MaxAccountsExceeded\",\n  \"MaxInstructionTraceLengthExceeded\",\n  \"BuiltinProgramsMustConsumeComputeUnits\"\n];\nfunction getSolanaErrorFromInstructionError(index, instructionError) {\n  const numberIndex = Number(index);\n  return getSolanaErrorFromRpcError(\n    {\n      errorCodeBaseOffset: 4615001,\n      getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n        if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN) {\n          return {\n            errorName: rpcErrorName,\n            index: numberIndex,\n            ...rpcErrorContext !== void 0 ? { instructionErrorContext: rpcErrorContext } : null\n          };\n        } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM) {\n          return {\n            code: Number(rpcErrorContext),\n            index: numberIndex\n          };\n        } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR) {\n          return {\n            encodedData: rpcErrorContext,\n            index: numberIndex\n          };\n        }\n        return { index: numberIndex };\n      },\n      orderedErrorNames: ORDERED_ERROR_NAMES,\n      rpcEnumError: instructionError\n    },\n    getSolanaErrorFromInstructionError\n  );\n}\n\n// src/transaction-error.ts\nvar ORDERED_ERROR_NAMES2 = [\n  // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/src/transaction/error.rs\n  // If this list ever gets too large, consider implementing a compression strategy like this:\n  // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n  \"AccountInUse\",\n  \"AccountLoadedTwice\",\n  \"AccountNotFound\",\n  \"ProgramAccountNotFound\",\n  \"InsufficientFundsForFee\",\n  \"InvalidAccountForFee\",\n  \"AlreadyProcessed\",\n  \"BlockhashNotFound\",\n  // `InstructionError` intentionally omitted; delegated to `getSolanaErrorFromInstructionError`\n  \"CallChainTooDeep\",\n  \"MissingSignatureForFee\",\n  \"InvalidAccountIndex\",\n  \"SignatureFailure\",\n  \"InvalidProgramForExecution\",\n  \"SanitizeFailure\",\n  \"ClusterMaintenance\",\n  \"AccountBorrowOutstanding\",\n  \"WouldExceedMaxBlockCostLimit\",\n  \"UnsupportedVersion\",\n  \"InvalidWritableAccount\",\n  \"WouldExceedMaxAccountCostLimit\",\n  \"WouldExceedAccountDataBlockLimit\",\n  \"TooManyAccountLocks\",\n  \"AddressLookupTableNotFound\",\n  \"InvalidAddressLookupTableOwner\",\n  \"InvalidAddressLookupTableData\",\n  \"InvalidAddressLookupTableIndex\",\n  \"InvalidRentPayingAccount\",\n  \"WouldExceedMaxVoteCostLimit\",\n  \"WouldExceedAccountDataTotalLimit\",\n  \"DuplicateInstruction\",\n  \"InsufficientFundsForRent\",\n  \"MaxLoadedAccountsDataSizeExceeded\",\n  \"InvalidLoadedAccountsDataSizeLimit\",\n  \"ResanitizationNeeded\",\n  \"ProgramExecutionTemporarilyRestricted\",\n  \"UnbalancedTransaction\"\n];\nfunction getSolanaErrorFromTransactionError(transactionError) {\n  if (typeof transactionError === \"object\" && \"InstructionError\" in transactionError) {\n    return getSolanaErrorFromInstructionError(\n      ...transactionError.InstructionError\n    );\n  }\n  return getSolanaErrorFromRpcError(\n    {\n      errorCodeBaseOffset: 7050001,\n      getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n        if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN) {\n          return {\n            errorName: rpcErrorName,\n            ...rpcErrorContext !== void 0 ? { transactionErrorContext: rpcErrorContext } : null\n          };\n        } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION) {\n          return {\n            index: Number(rpcErrorContext)\n          };\n        } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT || errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED) {\n          return {\n            accountIndex: Number(rpcErrorContext.account_index)\n          };\n        }\n      },\n      orderedErrorNames: ORDERED_ERROR_NAMES2,\n      rpcEnumError: transactionError\n    },\n    getSolanaErrorFromTransactionError\n  );\n}\n\n// src/json-rpc-error.ts\nfunction getSolanaErrorFromJsonRpcError(putativeErrorResponse) {\n  let out;\n  if (isRpcErrorResponse(putativeErrorResponse)) {\n    const { code: rawCode, data, message } = putativeErrorResponse;\n    const code = Number(rawCode);\n    if (code === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE) {\n      const { err, ...preflightErrorContext } = data;\n      const causeObject = err ? { cause: getSolanaErrorFromTransactionError(err) } : null;\n      out = new SolanaError(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, {\n        ...preflightErrorContext,\n        ...causeObject\n      });\n    } else {\n      let errorContext;\n      switch (code) {\n        case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR:\n        case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS:\n        case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST:\n        case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND:\n        case SOLANA_ERROR__JSON_RPC__PARSE_ERROR:\n        case SOLANA_ERROR__JSON_RPC__SCAN_ERROR:\n        case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP:\n        case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE:\n        case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:\n        case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:\n        case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:\n        case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED:\n        case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:\n        case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:\n          errorContext = { __serverMessage: message };\n          break;\n        default:\n          if (typeof data === \"object\" && !Array.isArray(data)) {\n            errorContext = data;\n          }\n      }\n      out = new SolanaError(code, errorContext);\n    }\n  } else {\n    const message = typeof putativeErrorResponse === \"object\" && putativeErrorResponse !== null && \"message\" in putativeErrorResponse && typeof putativeErrorResponse.message === \"string\" ? putativeErrorResponse.message : \"Malformed JSON-RPC error with no message attribute\";\n    out = new SolanaError(SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR, { error: putativeErrorResponse, message });\n  }\n  safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);\n  return out;\n}\nfunction isRpcErrorResponse(value) {\n  return typeof value === \"object\" && value !== null && \"code\" in value && \"message\" in value && (typeof value.code === \"number\" || typeof value.code === \"bigint\") && typeof value.message === \"string\";\n}\n\nexport { SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND, SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED, SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT, SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT, SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND, SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED, SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH, SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY, SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE, SOLANA_ERROR__ADDRESSES__MALFORMED_PDA, SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED, SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE, SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE, SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE, SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED, SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS, SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH, SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY, SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH, SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH, SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE, SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, SOLANA_ERROR__CODECS__INVALID_CONSTANT, SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT, SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT, SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT, SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE, SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE, SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE, SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT, SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW, SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR, SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS, SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH, SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM, SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX, SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE, SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED, SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED, SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND, SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR, SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER, SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE, SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY, SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID, SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC, SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED, SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED, SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT, SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE, SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID, SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS, SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION, SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE, SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE, SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE, SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED, SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE, SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED, SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED, SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION, SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT, SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN, SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID, SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR, SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN, SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN, SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN, SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE, SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS, SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA, SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH, SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH, SOLANA_ERROR__INVALID_NONCE, SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING, SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED, SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND, SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND, SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE, SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING, SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR, SOLANA_ERROR__JSON_RPC__INVALID_PARAMS, SOLANA_ERROR__JSON_RPC__INVALID_REQUEST, SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND, SOLANA_ERROR__JSON_RPC__PARSE_ERROR, SOLANA_ERROR__JSON_RPC__SCAN_ERROR, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE, SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION, SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH, SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH, SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY, SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE, SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE, SOLANA_ERROR__MALFORMED_BIGINT_STRING, SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR, SOLANA_ERROR__MALFORMED_NUMBER_STRING, SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED, SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT, SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID, SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD, SOLANA_ERROR__RPC__INTEGER_OVERFLOW, SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR, SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN, SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS, SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING, SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY, SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT, SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE, SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND, SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND, SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED, SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND, SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP, SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE, SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION, SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE, SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT, SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT, SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED, SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE, SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND, SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED, SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED, SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE, SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE, SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS, SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION, SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN, SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT, SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT, SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION, SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING, SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES, SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME, SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND, SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT, SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT, SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING, SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING, SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE, SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING, SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES, SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING, SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED, SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, SolanaError, getSolanaErrorFromInstructionError, getSolanaErrorFromJsonRpcError, getSolanaErrorFromTransactionError, isSolanaError, safeCaptureStackTrace };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","/**\n * To add a new error, follow the instructions at\n * https://github.com/anza-xyz/kit/tree/main/packages/errors/#adding-a-new-error\n *\n * @module\n * @privateRemarks\n * WARNING:\n *   - Don't remove error codes\n *   - Don't change or reorder error codes.\n *\n * Good naming conventions:\n *   - Prefixing common errors  e.g. under the same package  can be a good way to namespace them. E.g. All codec-related errors start with `SOLANA_ERROR__CODECS__`.\n *   - Use consistent names  e.g. choose `PDA` or `PROGRAM_DERIVED_ADDRESS` and stick with it. Ensure your names are consistent with existing error codes. The decision might have been made for you.\n *   - Recommended prefixes and suffixes:\n *     - `MALFORMED_`: Some input was not constructed properly. E.g. `MALFORMED_BASE58_ENCODED_ADDRESS`.\n *     - `INVALID_`: Some input is invalid (other than because it was MALFORMED). E.g. `INVALID_NUMBER_OF_BYTES`.\n *     - `EXPECTED_`: Some input was different than expected, no need to specify the \"GOT\" part unless necessary. E.g. `EXPECTED_DECODED_ACCOUNT`.\n *     - `_CANNOT_`: Some operation cannot be performed or some input cannot be used due to some condition. E.g. `CANNOT_DECODE_EMPTY_BYTE_ARRAY` or `PDA_CANNOT_END_WITH_PDA_MARKER`.\n *     - `_MUST_BE_`: Some condition must be true. E.g. `NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE`.\n *     - `_FAILED_TO_`: Tried to perform some operation and failed. E.g. `FAILED_TO_DECODE_ACCOUNT`.\n *     - `_NOT_FOUND`: Some operation lead to not finding something. E.g. `ACCOUNT_NOT_FOUND`.\n *     - `_OUT_OF_RANGE`: Some value is out of range. E.g. `ENUM_DISCRIMINATOR_OUT_OF_RANGE`.\n *     - `_EXCEEDED`: Some limit was exceeded. E.g. `PDA_MAX_SEED_LENGTH_EXCEEDED`.\n *     - `_MISMATCH`: Some elements do not match. E.g. `ENCODER_DECODER_FIXED_SIZE_MISMATCH`.\n *     - `_MISSING`: Some required input is missing. E.g. `TRANSACTION_FEE_PAYER_MISSING`.\n *     - `_UNIMPLEMENTED`: Some required component is not available in the environment. E.g. `SUBTLE_CRYPTO_VERIFY_FUNCTION_UNIMPLEMENTED`.\n */\nexport const SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;\nexport const SOLANA_ERROR__INVALID_NONCE = 2;\nexport const SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;\nexport const SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;\nexport const SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;\nexport const SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;\nexport const SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;\nexport const SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;\nexport const SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;\nexport const SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10;\n\n// JSON-RPC-related errors.\n// Reserve error codes in the range [-32768, -32000]\n// Keep in sync with https://github.com/anza-xyz/agave/blob/master/rpc-client-api/src/custom_error.rs\nexport const SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;\nexport const SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;\nexport const SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;\nexport const SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;\nexport const SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE = -32019;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY = -32018;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE = -32017;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;\nexport const SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;\nexport const SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;\n\n// Addresses-related errors.\n// Reserve error codes in the range [2800000-2800999].\nexport const SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 2800000;\nexport const SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;\nexport const SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;\nexport const SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;\nexport const SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;\nexport const SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;\nexport const SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;\nexport const SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;\nexport const SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = 2800011;\n\n// Account-related errors.\n// Reserve error codes in the range [3230000-3230999].\nexport const SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 3230000;\nexport const SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;\nexport const SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;\nexport const SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;\nexport const SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;\n\n// Subtle-Crypto-related errors.\n// Reserve error codes in the range [3610000-3610999].\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 3610000;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;\nexport const SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;\n\n// Crypto-related errors.\n// Reserve error codes in the range [3611000-3611050].\nexport const SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611000;\n\n// Key-related errors.\n// Reserve error codes in the range [3704000-3704999].\nexport const SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704000;\nexport const SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;\nexport const SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;\nexport const SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;\nexport const SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;\n\n// Instruction-related errors.\n// Reserve error codes in the range [4128000-4128999].\nexport const SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128000;\nexport const SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;\nexport const SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;\n\n// Instruction errors.\n// Reserve error codes starting with [4615000-4615999] for the Rust enum `InstructionError`.\n// Error names here are dictated by the RPC (see ./instruction-error.ts).\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615000;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;\nexport const SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;\n\n// Signer-related errors.\n// Reserve error codes in the range [5508000-5508999].\nexport const SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508000;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;\nexport const SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;\nexport const SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;\nexport const SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;\nexport const SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;\n\n// Transaction-related errors.\n// Reserve error codes in the range [5663000-5663999].\nexport const SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663000;\nexport const SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;\nexport const SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;\nexport const SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;\nexport const SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;\nexport const SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;\nexport const SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;\nexport const SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;\nexport const SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;\nexport const SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;\nexport const SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;\nexport const SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;\nexport const SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;\nexport const SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;\nexport const SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;\nexport const SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = 5663020;\nexport const SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED = 5663021;\nexport const SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE = 5663022;\n\n// Transaction errors.\n// Reserve error codes starting with [7050000-7050999] for the Rust enum `TransactionError`.\n// Error names here are dictated by the RPC (see ./transaction-error.ts).\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 7050000;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;\n// `InstructionError` intentionally omitted.\nexport const SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;\nexport const SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;\n\n// Instruction plan related errors.\n// Reserve error codes in the range [7618000-7618999].\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN = 7618000;\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE = 7618001;\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN = 7618002;\nexport const SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN = 7618003;\n\n// Codec-related errors.\n// Reserve error codes in the range [8078000-8078999].\nexport const SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078000;\nexport const SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;\nexport const SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;\nexport const SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;\nexport const SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;\nexport const SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;\nexport const SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;\nexport const SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;\nexport const SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;\nexport const SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;\nexport const SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;\nexport const SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;\nexport const SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;\nexport const SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;\nexport const SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;\nexport const SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;\nexport const SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;\nexport const SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;\nexport const SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;\nexport const SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;\nexport const SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;\nexport const SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY = 8078023;\n\n// RPC-related errors.\n// Reserve error codes in the range [8100000-8100999].\nexport const SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 8100000;\nexport const SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;\nexport const SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;\nexport const SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;\n\n// RPC-Subscriptions-related errors.\n// Reserve error codes in the range [8190000-8190999].\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 8190000;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;\nexport const SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;\n\n// Invariant violation errors.\n// Reserve error codes in the range [9900000-9900999].\n// These errors should only be thrown when there is a bug with the\n// library itself and should, in theory, never reach the end user.\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 9900000;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND = 9900005;\nexport const SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND = 9900006;\n\n/**\n * A union of every Solana error code\n *\n * @privateRemarks\n * You might be wondering why this is not a TypeScript enum or const enum.\n *\n * One of the goals of this library is to enable people to use some or none of it without having to\n * bundle all of it.\n *\n * If we made the set of error codes an enum then anyone who imported it (even if to only use a\n * single error code) would be forced to bundle every code and its label.\n *\n * Const enums appear to solve this problem by letting the compiler inline only the codes that are\n * actually used. Unfortunately exporting ambient (const) enums from a library like `@solana/errors`\n * is not safe, for a variety of reasons covered here: https://stackoverflow.com/a/28818850\n */\nexport type SolanaErrorCode =\n    | typeof SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED\n    | typeof SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT\n    | typeof SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT\n    | typeof SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND\n    | typeof SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS\n    | typeof SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE\n    | typeof SOLANA_ERROR__ADDRESSES__MALFORMED_PDA\n    | typeof SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED\n    | typeof SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER\n    | typeof SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED\n    | typeof SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY\n    | typeof SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS\n    | typeof SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH\n    | typeof SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE\n    | typeof SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH\n    | typeof SOLANA_ERROR__CODECS__INVALID_CONSTANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT\n    | typeof SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS\n    | typeof SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE\n    | typeof SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES\n    | typeof SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS\n    | typeof SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID\n    | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN\n    | typeof SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE\n    | typeof SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH\n    | typeof SOLANA_ERROR__INVALID_NONCE\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING\n    | typeof SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE\n    | typeof SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__INVALID_PARAMS\n    | typeof SOLANA_ERROR__JSON_RPC__INVALID_REQUEST\n    | typeof SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND\n    | typeof SOLANA_ERROR__JSON_RPC__PARSE_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__SCAN_ERROR\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE\n    | typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION\n    | typeof SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH\n    | typeof SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY\n    | typeof SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__MALFORMED_BIGINT_STRING\n    | typeof SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR\n    | typeof SOLANA_ERROR__MALFORMED_NUMBER_STRING\n    | typeof SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD\n    | typeof SOLANA_ERROR__RPC__INTEGER_OVERFLOW\n    | typeof SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR\n    | typeof SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT\n    | typeof SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID\n    | typeof SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER\n    | typeof SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS\n    | typeof SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING\n    | typeof SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED\n    | typeof SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION\n    | typeof SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES\n    | typeof SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME\n    | typeof SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE\n    | typeof SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES\n    | typeof SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE\n    | typeof SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH\n    | typeof SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE\n    | typeof SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING\n    | typeof SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED\n    | typeof SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT\n    | typeof SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT;\n\n/**\n * Errors of this type are understood to have an optional {@link SolanaError} nested inside as\n * `cause`.\n */\nexport type SolanaErrorCodeWithCause = typeof SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE;\n","/**\n * To add a new error, follow the instructions at\n * https://github.com/anza-xyz/kit/tree/main/packages/errors/#adding-a-new-error\n *\n * @privateRemarks\n * WARNING:\n *   - Don't change or remove members of an error's context.\n */\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_CONSTANT,\n    SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND,\n    SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR,\n    SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SOLANA_ERROR__INVALID_NONCE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__MALFORMED_BIGINT_STRING,\n    SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR,\n    SOLANA_ERROR__MALFORMED_NUMBER_STRING,\n    SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD,\n    SOLANA_ERROR__RPC__INTEGER_OVERFLOW,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS,\n    SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER,\n    SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY,\n    SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING,\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH,\n    SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n    SolanaErrorCode,\n} from './codes';\nimport { RpcSimulateTransactionResult } from './json-rpc-error';\n\ntype BasicInstructionErrorContext<T extends SolanaErrorCode> = Readonly<{ [P in T]: { index: number } }>;\n\ntype DefaultUnspecifiedErrorContextToUndefined<T> = {\n    [P in SolanaErrorCode]: P extends keyof T ? T[P] : undefined;\n};\n\ntype TypedArrayMutableProperties = 'copyWithin' | 'fill' | 'reverse' | 'set' | 'sort';\ninterface ReadonlyUint8Array extends Omit<Uint8Array, TypedArrayMutableProperties> {\n    readonly [n: number]: number;\n}\n\n/** A amount of bytes. */\ntype Bytes = number;\n\n/**\n * A map of every {@link SolanaError} code to the type of its `context` property.\n */\nexport type SolanaErrorContext = DefaultUnspecifiedErrorContextToUndefined<\n    BasicInstructionErrorContext<\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID\n        | typeof SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR\n    > & {\n        [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: {\n            address: string;\n        };\n        [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: {\n            addresses: string[];\n        };\n        [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: {\n            address: string;\n        };\n        [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: {\n            address: string;\n        };\n        [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: {\n            addresses: string[];\n        };\n        [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: {\n            putativeAddress: string;\n        };\n        [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: {\n            actual: number;\n            maxSeeds: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: {\n            actual: number;\n            index: number;\n            maxSeedLength: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: {\n            bump: number;\n        };\n        [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: {\n            currentBlockHeight: bigint;\n            lastValidBlockHeight: bigint;\n        };\n        [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: {\n            codecDescription: string;\n        };\n        [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: {\n            stringValues: string[];\n        };\n        [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: {\n            encodedBytes: ReadonlyUint8Array;\n            hexEncodedBytes: string;\n            hexSentinel: string;\n            sentinel: ReadonlyUint8Array;\n        };\n        [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: {\n            decoderFixedSize: number;\n            encoderFixedSize: number;\n        };\n        [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: {\n            decoderMaxSize: number | undefined;\n            encoderMaxSize: number | undefined;\n        };\n        [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: {\n            discriminator: bigint | number;\n            formattedValidDiscriminators: string;\n            validDiscriminators: number[];\n        };\n        [SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY]: {\n            expectedLength: number;\n            numExcessBytes: number;\n        };\n        [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: {\n            bytesLength: number;\n            codecDescription: string;\n        };\n        [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: {\n            codecDescription: string;\n            expectedSize: number;\n            hexZeroValue: string;\n            zeroValue: ReadonlyUint8Array;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: {\n            bytesLength: number;\n            codecDescription: string;\n            expected: number;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: {\n            constant: ReadonlyUint8Array;\n            data: ReadonlyUint8Array;\n            hexConstant: string;\n            hexData: string;\n            offset: number;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: {\n            value: bigint | boolean | number | string | null | undefined;\n            variants: readonly (bigint | boolean | number | string | null | undefined)[];\n        };\n        [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: {\n            formattedNumericalValues: string;\n            numericalValues: number[];\n            stringValues: string[];\n            variant: number | string | symbol;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: {\n            value: bigint | boolean | number | string | null | undefined;\n            variants: readonly (bigint | boolean | number | string | null | undefined)[];\n        };\n        [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: {\n            actual: bigint | number;\n            codecDescription: string;\n            expected: bigint | number;\n        };\n        [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: {\n            alphabet: string;\n            base: number;\n            value: string;\n        };\n        [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: {\n            discriminator: bigint | number;\n            maxRange: number;\n            minRange: number;\n        };\n        [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: {\n            codecDescription: string;\n            max: bigint | number;\n            min: bigint | number;\n            value: bigint | number;\n        };\n        [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: {\n            bytesLength: number;\n            codecDescription: string;\n            offset: number;\n        };\n        [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: {\n            decodedBytes: ReadonlyUint8Array;\n            hexDecodedBytes: string;\n            hexSentinel: string;\n            sentinel: ReadonlyUint8Array;\n        };\n        [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: {\n            maxRange: number;\n            minRange: number;\n            variant: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: {\n            encodedData: string;\n            index: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: {\n            code: number;\n            index: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: {\n            errorName: string;\n            index: number;\n            instructionErrorContext?: unknown;\n        };\n        [SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN]: {\n            transactionPlanResult: unknown;\n        };\n        [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN]: {\n            numBytesRequired: number;\n            numFreeBytes: number;\n        };\n        [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: {\n            data?: ReadonlyUint8Array;\n            programAddress: string;\n        };\n        [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: {\n            accountAddresses?: string[];\n            programAddress: string;\n        };\n        [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: {\n            actualProgramAddress: string;\n            expectedProgramAddress: string;\n        };\n        [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__INVALID_NONCE]: {\n            actualNonceValue: string;\n            expectedNonceValue: string;\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: {\n            cacheKey: string;\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: {\n            channelName: string;\n            supportedChannelNames: string[];\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND]: {\n            kind: string;\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND]: {\n            kind: string;\n        };\n        [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: {\n            unexpectedValue: unknown;\n        };\n        [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE]: {\n            currentBlockHeight: bigint;\n            rewardsCompleteBlockHeight: bigint;\n            slot: bigint;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: {\n            contextSlot: bigint;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: {\n            numSlotsBehind?: number;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: Omit<\n            RpcSimulateTransactionResult,\n            'err'\n        >;\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY]: {\n            slot: bigint;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: {\n            __serverMessage: string;\n        };\n        [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: {\n            byteLength: number;\n        };\n        [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: {\n            actualLength: number;\n        };\n        [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: {\n            value: string;\n        };\n        [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: {\n            error: unknown;\n            message: string;\n        };\n        [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: {\n            value: string;\n        };\n        [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: {\n            nonceAccountAddress: string;\n        };\n        [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: {\n            notificationName: string;\n        };\n        [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: {\n            errorEvent: Event;\n        };\n        [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: {\n            method: string;\n            params: unknown[];\n        };\n        [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: {\n            argumentLabel: string;\n            keyPath: readonly (number | string | symbol)[];\n            methodName: string;\n            optionalPathLabel: string;\n            path?: string;\n            value: bigint;\n        };\n        [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: {\n            headers: Headers;\n            message: string;\n            statusCode: number;\n        };\n        [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: {\n            headers: string[];\n        };\n        [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: {\n            address: string;\n        };\n        [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: {\n            key: CryptoKey;\n        };\n        [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: {\n            value: bigint;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: {\n            index: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: {\n            accountIndex: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: {\n            accountIndex: number;\n        };\n        [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: {\n            errorName: string;\n            transactionErrorContext?: unknown;\n        };\n        [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: {\n            expectedAddresses: string[];\n            unexpectedAddresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: {\n            index: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]: {\n            transactionSize: Bytes;\n            transactionSizeLimit: Bytes;\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: {\n            lookupTableAddresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: {\n            highestKnownIndex: number;\n            highestRequestedIndex: number;\n            lookupTableAddress: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: {\n            index: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: {\n            unitsConsumed: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: {\n            programAddress: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: {\n            programAddress: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: {\n            numRequiredSignatures: number;\n            signaturesLength: number;\n            signerAddresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE]: {\n            nonce: string;\n        };\n        [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: {\n            addresses: string[];\n        };\n        [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED]: {\n            unsupportedVersion: number;\n        };\n        [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: {\n            actualVersion: number;\n        };\n    }\n>;\n\nexport function decodeEncodedContext(encodedContext: string): object {\n    const decodedUrlString = __NODEJS__ ? Buffer.from(encodedContext, 'base64').toString('utf8') : atob(encodedContext);\n    return Object.fromEntries(new URLSearchParams(decodedUrlString).entries());\n}\n\nfunction encodeValue(value: unknown): string {\n    if (Array.isArray(value)) {\n        const commaSeparatedValues = value.map(encodeValue).join('%2C%20' /* \", \" */);\n        return '%5B' /* \"[\" */ + commaSeparatedValues + /* \"]\" */ '%5D';\n    } else if (typeof value === 'bigint') {\n        return `${value}n`;\n    } else {\n        return encodeURIComponent(\n            String(\n                value != null && Object.getPrototypeOf(value) === null\n                    ? // Plain objects with no prototype don't have a `toString` method.\n                      // Convert them before stringifying them.\n                      { ...(value as object) }\n                    : value,\n            ),\n        );\n    }\n}\n\nfunction encodeObjectContextEntry([key, value]: [string, unknown]): `${typeof key}=${string}` {\n    return `${key}=${encodeValue(value)}`;\n}\n\nexport function encodeContextObject(context: object): string {\n    const searchParamsString = Object.entries(context).map(encodeObjectContextEntry).join('&');\n    return __NODEJS__ ? Buffer.from(searchParamsString, 'utf8').toString('base64') : btoa(searchParamsString);\n}\n","/* eslint-disable sort-keys-fix/sort-keys-fix */\n/**\n * To add a new error, follow the instructions at\n * https://github.com/anza-xyz/kit/tree/main/packages/errors#adding-a-new-error\n *\n * WARNING:\n *   - Don't change the meaning of an error message.\n */\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED,\n    SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY,\n    SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS,\n    SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE,\n    SOLANA_ERROR__ADDRESSES__MALFORMED_PDA,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS,\n    SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,\n    SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH,\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY,\n    SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH,\n    SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_CONSTANT,\n    SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE,\n    SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES,\n    SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE,\n    SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH,\n    SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX,\n    SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND,\n    SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC,\n    SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE,\n    SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR,\n    SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN,\n    SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SOLANA_ERROR__INVALID_NONCE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND,\n    SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING,\n    SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE,\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE,\n    SOLANA_ERROR__MALFORMED_BIGINT_STRING,\n    SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR,\n    SOLANA_ERROR__MALFORMED_NUMBER_STRING,\n    SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD,\n    SOLANA_ERROR__RPC__INTEGER_OVERFLOW,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR,\n    SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT,\n    SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID,\n    SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS,\n    SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER,\n    SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER,\n    SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS,\n    SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING,\n    SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT,\n    SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING,\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES,\n    SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n    SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE,\n    SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH,\n    SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE,\n    SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED,\n    SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP,\n    SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE,\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT,\n    SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT,\n    SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED,\n    SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED,\n    SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE,\n    SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE,\n    SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT,\n    SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT,\n    SolanaErrorCode,\n} from './codes';\n\n/**\n * A map of every {@link SolanaError} code to the error message shown to developers in development\n * mode.\n */\nexport const SolanaErrorMessages: Readonly<{\n    // This type makes this data structure exhaustive with respect to `SolanaErrorCode`.\n    // TypeScript will fail to build this project if add an error code without a message.\n    [P in SolanaErrorCode]: string;\n}> = {\n    [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: 'Account not found at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]:\n        'Not all accounts were decoded. Encoded accounts found at addresses: $addresses.',\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: 'Expected decoded account at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: 'Failed to decode account data at address: $address',\n    [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: 'Accounts not found at addresses: $addresses',\n    [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]:\n        'Unable to find a viable program address bump seed.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: '$putativeAddress is not a base58-encoded address.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]:\n        'Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: 'The `CryptoKey` must be an `Ed25519` public key.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS]:\n        '$putativeOffCurveAddress is not a base58-encoded off-curve address.',\n    [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: 'Invalid seeds; point must fall off the Ed25519 curve.',\n    [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]:\n        'Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].',\n    [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]:\n        'A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.',\n    [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]:\n        'The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.',\n    [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]:\n        'Expected program derived address bump to be in the range [0, 255], got: $bump.',\n    [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: 'Program address cannot end with PDA marker.',\n    [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.',\n    [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.',\n    [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]:\n        'The network has progressed past the last block for which this transaction could have been committed.',\n    [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]:\n        'Codec [$codecDescription] cannot decode empty byte arrays.',\n    [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]:\n        'Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.',\n    [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]:\n        'Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]:\n        'Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]:\n        'Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].',\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]:\n        'Encoder and decoder must either both be fixed-size or variable-size.',\n    [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]:\n        'Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.',\n    [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: 'Expected a fixed-size codec, got a variable-size one.',\n    [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]:\n        'Codec [$codecDescription] expected a positive byte length, got $bytesLength.',\n    [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: 'Expected a variable-size codec, got a fixed-size one.',\n    [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]:\n        'Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].',\n    [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]:\n        'Codec [$codecDescription] expected $expected bytes, got $bytesLength.',\n    [SOLANA_ERROR__CODECS__INVALID_CONSTANT]:\n        'Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].',\n    [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]:\n        'Invalid discriminated union variant. Expected one of [$variants], got $value.',\n    [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]:\n        'Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.',\n    [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]:\n        'Invalid literal union variant. Expected one of [$variants], got $value.',\n    [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]:\n        'Expected [$codecDescription] to have $expected items, got $actual.',\n    [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: 'Invalid value $value for base $base with alphabet $alphabet.',\n    [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]:\n        'Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.',\n    [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]:\n        'Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.',\n    [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]:\n        'Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.',\n    [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]:\n        'Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].',\n    [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]:\n        'Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.',\n    [SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY]:\n        'This decoder expected a byte array of exactly $expectedLength bytes, but $numExcessBytes unexpected excess bytes remained after decoding. Are you sure that you have chosen the correct decoder for this data?',\n    [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: 'No random values implementation could be found.',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: 'instruction requires an uninitialized account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]:\n        'instruction tries to borrow reference for an account which is already borrowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]:\n        'instruction left account with an outstanding borrowed reference',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]:\n        \"program other than the account's owner changed the size of the account data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: 'account data too small for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: 'instruction expected an executable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]:\n        'An account does not have enough lamports to be rent-exempt',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: 'Program arithmetic overflowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: 'Failed to serialize or deserialize account data: $encodedData',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]:\n        'Builtin programs must consume compute units',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: 'Cross-program invocation call depth too deep',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: 'Computational budget exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: 'custom program error: #$code',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: 'instruction contains duplicate accounts',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]:\n        'instruction modifications of multiply-passed account differ',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: 'executable accounts must be rent exempt',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: 'instruction changed executable accounts data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]:\n        'instruction changed the balance of an executable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: 'instruction changed executable bit of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]:\n        'instruction modified data of an account it does not own',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]:\n        'instruction spent from the balance of an account it does not own',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: 'generic instruction error',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: 'Provided owner is not allowed',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: 'Account is immutable',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: 'Incorrect authority provided',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: 'incorrect program id for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: 'insufficient funds for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: 'invalid account data for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: 'Invalid account owner',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: 'invalid program argument',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: 'program returned invalid error code',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: 'invalid instruction data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: 'Failed to reallocate account data',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: 'Provided seeds do not result in a valid address',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]:\n        'Accounts data allocations exceeded the maximum allowed per transaction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: 'Max accounts exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: 'Max instruction trace length exceeded',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]:\n        'Length of the seed is too long for address generation',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: 'An account required by the instruction is missing',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: 'missing required signature for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]:\n        'instruction illegally modified the program id of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: 'insufficient account keys for instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]:\n        'Cross-program invocation with unauthorized signer or writable account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]:\n        'Failed to create program execution environment',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: 'Program failed to compile',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: 'Program failed to complete',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: 'instruction modified data of a read-only account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]:\n        'instruction changed the balance of a read-only account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]:\n        'Cross-program invocation reentrancy not allowed for this instruction',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: 'instruction modified rent epoch of an account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]:\n        'sum of account balances before and after instruction do not match',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: 'instruction requires an initialized account',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: '',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: 'Unsupported program id',\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: 'Unsupported sysvar',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_INSTRUCTION_PLAN_KIND]: 'Invalid instruction plan kind: $kind.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__EMPTY_INSTRUCTION_PLAN]: 'The provided instruction plan is empty.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__FAILED_TO_EXECUTE_TRANSACTION_PLAN]:\n        'The provided transaction plan failed to execute. See the `transactionPlanResult` attribute and the `cause` error for more details.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_CANNOT_ACCOMMODATE_PLAN]:\n        'The provided message has insufficient capacity to accommodate the next instruction(s) in this plan. Expected at least $numBytesRequired free byte(s), got $numFreeBytes byte(s).',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__INVALID_TRANSACTION_PLAN_KIND]: 'Invalid transaction plan kind: $kind.',\n    [SOLANA_ERROR__INSTRUCTION_PLANS__MESSAGE_PACKER_ALREADY_COMPLETE]:\n        'No more instructions to pack; the message packer has completed the instruction plan.',\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: 'The instruction does not have any accounts.',\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: 'The instruction does not have any data.',\n    [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]:\n        'Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.',\n    [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]:\n        'Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__INVALID_NONCE]:\n        'The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]:\n        'Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It ' +\n        'should be impossible to hit this error; please file an issue at ' +\n        'https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]:\n        'Invariant violation: This data publisher does not publish to the channel named ' +\n        '`$channelName`. Supported channels include $supportedChannelNames.',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]:\n        'Invariant violation: WebSocket message iterator state is corrupt; iterated without first ' +\n        'resolving existing message promise. It should be impossible to hit this error; please ' +\n        'file an issue at https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]:\n        'Invariant violation: WebSocket message iterator is missing state storage. It should be ' +\n        'impossible to hit this error; please file an issue at https://sola.na/web3invariant',\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]:\n        'Invariant violation: Switch statement non-exhaustive. Received unexpected value ' +\n        '`$unexpectedValue`. It should be impossible to hit this error; please file an issue at ' +\n        'https://sola.na/web3invariant',\n    [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: 'JSON-RPC error: Internal JSON-RPC error ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: 'JSON-RPC error: Invalid method parameter(s) ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]:\n        'JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]:\n        'JSON-RPC error: The method does not exist / is not available ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]:\n        'JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)',\n    [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_EPOCH_REWARDS_PERIOD_ACTIVE]:\n        'Epoch rewards period still active at slot $slot',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_UNREACHABLE]:\n        'Failed to query long-term storage; please try again',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: 'Minimum context slot has not been reached',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: 'Node is unhealthy; behind by $numSlotsBehind slots',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: 'No snapshot',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: 'Transaction simulation failed',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_NOT_EPOCH_BOUNDARY]:\n        \"Rewards cannot be found because slot $slot is not the epoch boundary. This may be due to gap in the queried node's local ledger or long-term storage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]:\n        'Transaction history is not available from this node',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: '$__serverMessage',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: 'Transaction signature length mismatch',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]:\n        'Transaction signature verification failure',\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: '$__serverMessage',\n    [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: 'Key pair bytes must be of length 64, got $byteLength.',\n    [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]:\n        'Expected private key bytes with length 32. Actual length: $actualLength.',\n    [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]:\n        'Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.',\n    [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]:\n        'The provided private key does not match the provided public key.',\n    [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]:\n        'Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.',\n    [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: 'Lamports value must be in the range [0, 2e64-1]',\n    [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: '`$value` cannot be parsed as a `BigInt`',\n    [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: '$message',\n    [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: '`$value` cannot be parsed as a `Number`',\n    [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: 'No nonce account could be found at address `$nonceAccountAddress`',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]:\n        \"The notification name must end in 'Notifications' and the API must supply a \" +\n        \"subscription plan creator function for the notification '$notificationName'.\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]:\n        'WebSocket was closed before payload could be added to the send buffer',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: 'WebSocket connection closed',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: 'WebSocket failed to connect',\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]:\n        'Failed to obtain a subscription id from the server',\n    [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: 'Could not find an API plan for RPC method: `$method`',\n    [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]:\n        'The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was ' +\n        '`$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds ' +\n        '`Number.MAX_SAFE_INTEGER`.',\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: 'HTTP error ($statusCode): $message',\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]:\n        'HTTP header(s) forbidden: $headers. Learn more at ' +\n        'https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.',\n    [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]:\n        'Multiple distinct signers were identified for address `$address`. Please ensure that ' +\n        'you are using the same signer instance for each address.',\n    [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]:\n        'The provided value does not implement the `KeyPairSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]:\n        'The provided value does not implement the `MessageModifyingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]:\n        'The provided value does not implement the `MessagePartialSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]:\n        'The provided value does not implement any of the `MessageSigner` interfaces',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]:\n        'The provided value does not implement the `TransactionModifyingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]:\n        'The provided value does not implement the `TransactionPartialSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]:\n        'The provided value does not implement the `TransactionSendingSigner` interface',\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]:\n        'The provided value does not implement any of the `TransactionSigner` interfaces',\n    [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]:\n        'More than one `TransactionSendingSigner` was identified.',\n    [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]:\n        'No `TransactionSendingSigner` was identified. Please provide a valid ' +\n        '`TransactionWithSingleSendingSigner` transaction.',\n    [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]:\n        'Wallet account signers do not support signing multiple messages/transactions in a single operation',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: 'Cannot export a non-extractable key.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: 'No digest implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]:\n        'Cryptographic operations are only allowed in secure browser contexts. Read more ' +\n        'here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]:\n        'This runtime does not support the generation of Ed25519 key pairs.\\n\\nInstall ' +\n        '@solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in ' +\n        'environments that do not support Ed25519.\\n\\nFor a list of runtimes that ' +\n        'currently support Ed25519 operations, visit ' +\n        'https://github.com/WICG/webcrypto-secure-curves/issues/20.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]:\n        'No signature verification implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: 'No key generation implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: 'No signing implementation could be found.',\n    [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: 'No key export implementation could be found.',\n    [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]:\n        'Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]:\n        'Transaction processing left an account with an outstanding borrowed reference',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: 'Account in use',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: 'Account loaded twice',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]:\n        'Attempt to debit an account but found no record of a prior credit.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]:\n        \"Transaction loads an address table account that doesn't exist\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: 'This transaction has already been processed',\n    [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: 'Blockhash not found',\n    [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: 'Loader call chain is too deep',\n    [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]:\n        'Transactions are currently disabled due to cluster maintenance',\n    [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]:\n        'Transaction contains a duplicate instruction ($index) that is not allowed',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: 'Insufficient funds for fee',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]:\n        'Transaction results in an account ($accountIndex) with insufficient funds for rent',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: 'This account may not be used to pay transaction fees',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: 'Transaction contains an invalid account reference',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]:\n        'Transaction loads an address table account with invalid data',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]:\n        'Transaction address table lookup uses an invalid index',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]:\n        'Transaction loads an address table account with an invalid owner',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]:\n        'LoadedAccountsDataSizeLimit set for transaction must be greater than 0.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]:\n        'This program may not be used for executing instructions',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]:\n        'Transaction leaves an account with a lower balance than rent-exempt minimum',\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]:\n        'Transaction loads a writable account that cannot be written',\n    [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]:\n        'Transaction exceeded max loaded accounts data size cap',\n    [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]:\n        'Transaction requires a fee but has no signature present',\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: 'Attempt to load a program that does not exist',\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]:\n        'Execution of the program referenced by account at index $accountIndex is temporarily restricted.',\n    [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: 'ResanitizationNeeded',\n    [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: 'Transaction failed to sanitize accounts offsets correctly',\n    [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: 'Transaction did not pass signature verification',\n    [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: 'Transaction locked too many accounts',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]:\n        'Sum of account balances before and after transaction do not match',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: 'The transaction failed with the error `$errorName`',\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: 'Transaction version is unsupported',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]:\n        'Transaction would exceed account data limit within the block',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]:\n        'Transaction would exceed total account data limit',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]:\n        'Transaction would exceed max account limit within the block',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]:\n        'Transaction would exceed max Block Cost Limit',\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: 'Transaction would exceed max Vote Cost Limit',\n    [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]:\n        'Attempted to sign a transaction with an address that is not a signer for it',\n    [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: 'Transaction is missing an address at index: $index.',\n    [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]:\n        'Transaction has no expected signers therefore it cannot be encoded',\n    [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]:\n        'Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes',\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: 'Transaction does not have a blockhash lifetime',\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: 'Transaction is not a durable nonce transaction',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]:\n        'Contents of these address lookup tables unknown: $lookupTableAddresses',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]:\n        'Lookup of address at index $highestRequestedIndex failed for lookup table ' +\n        '`$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table ' +\n        'may have been extended since its contents were retrieved',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: 'No fee payer set in CompiledTransaction',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]:\n        'Could not find program address at index $index',\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]:\n        'Failed to estimate the compute unit consumption for this transaction message. This is ' +\n        'likely because simulating the transaction failed. Inspect the `cause` property of this ' +\n        'error to learn more',\n    [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]:\n        'Transaction failed when it was simulated in order to estimate the compute unit consumption. ' +\n        'The compute unit estimate provided is for a transaction that failed when simulated and may not ' +\n        'be representative of the compute units this transaction would consume if successful. Inspect the ' +\n        '`cause` property of this error to learn more',\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: 'Transaction is missing a fee payer.',\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]:\n        \"Could not determine this transaction's signature. Make sure that the transaction has \" +\n        'been signed by its fee payer.',\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]:\n        'Transaction first instruction is not advance nonce account instruction.',\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]:\n        'Transaction with no instructions cannot be durable nonce transaction.',\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]:\n        'This transaction includes an address (`$programAddress`) which is both ' +\n        'invoked and set as the fee payer. Program addresses may not pay fees',\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]:\n        'This transaction includes an address (`$programAddress`) which is both invoked and ' +\n        'marked writable. Program addresses may not be writable',\n    [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]:\n        'The transaction message expected the transaction to have $numRequiredSignatures signatures, got $signaturesLength.',\n    [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: 'Transaction is missing signatures for addresses: $addresses.',\n    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]:\n        'Transaction version must be in the range [0, 127]. `$actualVersion` given',\n    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED]:\n        'This version of Kit does not support decoding transactions with version $unsupportedVersion. The current max supported version is 0.',\n    [SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE]:\n        'The transaction has a durable nonce lifetime (with nonce `$nonce`), but the nonce account address is in a lookup table. The lifetime constraint cannot be constructed without fetching the lookup tables for the transaction.',\n};\n","import { SolanaErrorCode } from './codes';\nimport { encodeContextObject } from './context';\nimport { SolanaErrorMessages } from './messages';\n\nconst enum StateType {\n    EscapeSequence,\n    Text,\n    Variable,\n}\ntype State = Readonly<{\n    [START_INDEX]: number;\n    [TYPE]: StateType;\n}>;\nconst START_INDEX = 'i';\nconst TYPE = 't';\n\nexport function getHumanReadableErrorMessage<TErrorCode extends SolanaErrorCode>(\n    code: TErrorCode,\n    context: object = {},\n): string {\n    const messageFormatString = SolanaErrorMessages[code];\n    if (messageFormatString.length === 0) {\n        return '';\n    }\n    let state: State;\n    function commitStateUpTo(endIndex?: number) {\n        if (state[TYPE] === StateType.Variable) {\n            const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);\n\n            fragments.push(\n                variableName in context\n                    ? // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n                      `${context[variableName as keyof typeof context]}`\n                    : `$${variableName}`,\n            );\n        } else if (state[TYPE] === StateType.Text) {\n            fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));\n        }\n    }\n    const fragments: string[] = [];\n    messageFormatString.split('').forEach((char, ii) => {\n        if (ii === 0) {\n            state = {\n                [START_INDEX]: 0,\n                [TYPE]:\n                    messageFormatString[0] === '\\\\'\n                        ? StateType.EscapeSequence\n                        : messageFormatString[0] === '$'\n                          ? StateType.Variable\n                          : StateType.Text,\n            };\n            return;\n        }\n        let nextState;\n        switch (state[TYPE]) {\n            case StateType.EscapeSequence:\n                nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                break;\n            case StateType.Text:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                } else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                }\n                break;\n            case StateType.Variable:\n                if (char === '\\\\') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.EscapeSequence };\n                } else if (char === '$') {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Variable };\n                } else if (!char.match(/\\w/)) {\n                    nextState = { [START_INDEX]: ii, [TYPE]: StateType.Text };\n                }\n                break;\n        }\n        if (nextState) {\n            if (state !== nextState) {\n                commitStateUpTo(ii);\n            }\n            state = nextState;\n        }\n    });\n    commitStateUpTo();\n    return fragments.join('');\n}\n\nexport function getErrorMessage<TErrorCode extends SolanaErrorCode>(\n    code: TErrorCode,\n    context: Record<string, unknown> = {},\n): string {\n    if (process.env.NODE_ENV !== \"production\") {\n        return getHumanReadableErrorMessage(code, context);\n    } else {\n        let decodingAdviceMessage = `Solana error #${code}; Decode this error by running \\`npx @solana/errors decode -- ${code}`;\n        if (Object.keys(context).length) {\n            /**\n             * DANGER: Be sure that the shell command is escaped in such a way that makes it\n             *         impossible for someone to craft malicious context values that would result in\n             *         an exploit against anyone who bindly copy/pastes it into their terminal.\n             */\n            decodingAdviceMessage += ` '${encodeContextObject(context)}'`;\n        }\n        return `${decodingAdviceMessage}\\``;\n    }\n}\n","import { SolanaErrorCode, SolanaErrorCodeWithCause } from './codes';\nimport { SolanaErrorContext } from './context';\nimport { getErrorMessage } from './message-formatter';\n\n/**\n * A type guard that returns `true` if the input is a {@link SolanaError}, optionally with a\n * particular error code.\n *\n * When the `code` argument is supplied and the input is a {@link SolanaError}, TypeScript will\n * refine the error's {@link SolanaError#context | `context`} property to the type associated with\n * that error code. You can use that context to render useful error messages, or to make\n * context-aware decisions that help your application to recover from the error.\n *\n * @example\n * ```ts\n * import {\n *     SOLANA_ERROR__TRANSACTION__MISSING_SIGNATURE,\n *     SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n *     isSolanaError,\n * } from '@solana/errors';\n * import { assertIsFullySignedTransaction, getSignatureFromTransaction } from '@solana/transactions';\n *\n * try {\n *     const transactionSignature = getSignatureFromTransaction(tx);\n *     assertIsFullySignedTransaction(tx);\n *     /* ... *\\/\n * } catch (e) {\n *     if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING)) {\n *         displayError(\n *             \"We can't send this transaction without signatures for these addresses:\\n- %s\",\n *             // The type of the `context` object is now refined to contain `addresses`.\n *             e.context.addresses.join('\\n- '),\n *         );\n *         return;\n *     } else if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING)) {\n *         if (!tx.feePayer) {\n *             displayError('Choose a fee payer for this transaction before sending it');\n *         } else {\n *             displayError('The fee payer still needs to sign for this transaction');\n *         }\n *         return;\n *     }\n *     throw e;\n * }\n * ```\n */\nexport function isSolanaError<TErrorCode extends SolanaErrorCode>(\n    e: unknown,\n    /**\n     * When supplied, this function will require that the input is a {@link SolanaError} _and_ that\n     * its error code is exactly this value.\n     */\n    code?: TErrorCode,\n): e is SolanaError<TErrorCode> {\n    const isSolanaError = e instanceof Error && e.name === 'SolanaError';\n    if (isSolanaError) {\n        if (code !== undefined) {\n            return (e as SolanaError<TErrorCode>).context.__code === code;\n        }\n        return true;\n    }\n    return false;\n}\n\ntype SolanaErrorCodedContext = Readonly<{\n    [P in SolanaErrorCode]: (SolanaErrorContext[P] extends undefined ? object : SolanaErrorContext[P]) & {\n        __code: P;\n    };\n}>;\n\n/**\n * Encapsulates an error's stacktrace, a Solana-specific numeric code that indicates what went\n * wrong, and optional context if the type of error indicated by the code supports it.\n */\nexport class SolanaError<TErrorCode extends SolanaErrorCode = SolanaErrorCode> extends Error {\n    /**\n     * Indicates the root cause of this {@link SolanaError}, if any.\n     *\n     * For example, a transaction error might have an instruction error as its root cause. In this\n     * case, you will be able to access the instruction error on the transaction error as `cause`.\n     */\n    readonly cause?: TErrorCode extends SolanaErrorCodeWithCause ? SolanaError : unknown = this.cause;\n    /**\n     * Contains context that can assist in understanding or recovering from a {@link SolanaError}.\n     */\n    readonly context: SolanaErrorCodedContext[TErrorCode];\n    constructor(\n        ...[code, contextAndErrorOptions]: SolanaErrorContext[TErrorCode] extends undefined\n            ? [code: TErrorCode, errorOptions?: ErrorOptions | undefined]\n            : [code: TErrorCode, contextAndErrorOptions: SolanaErrorContext[TErrorCode] & (ErrorOptions | undefined)]\n    ) {\n        let context: SolanaErrorContext[TErrorCode] | undefined;\n        let errorOptions: ErrorOptions | undefined;\n        if (contextAndErrorOptions) {\n            Object.entries(Object.getOwnPropertyDescriptors(contextAndErrorOptions)).forEach(([name, descriptor]) => {\n                // If the `ErrorOptions` type ever changes, update this code.\n                if (name === 'cause') {\n                    errorOptions = { cause: descriptor.value };\n                } else {\n                    if (context === undefined) {\n                        context = {} as SolanaErrorContext[TErrorCode];\n                    }\n                    Object.defineProperty(context, name, descriptor);\n                }\n            });\n        }\n        const message = getErrorMessage(code, context);\n        super(message, errorOptions);\n        this.context = (context === undefined ? {} : context) as SolanaErrorCodedContext[TErrorCode];\n        this.context.__code = code;\n        // This is necessary so that `isSolanaError()` can identify a `SolanaError` without having\n        // to import the class for use in an `instanceof` check.\n        this.name = 'SolanaError';\n    }\n}\n","export function safeCaptureStackTrace(...args: Parameters<typeof Error.captureStackTrace>): void {\n    if ('captureStackTrace' in Error && typeof Error.captureStackTrace === 'function') {\n        Error.captureStackTrace(...args);\n    }\n}\n","import { SolanaErrorCode } from './codes';\nimport { SolanaErrorContext } from './context';\nimport { SolanaError } from './error';\nimport { safeCaptureStackTrace } from './stack-trace';\n\ntype Config = Readonly<{\n    /**\n     * Oh, hello. You might wonder what in tarnation is going on here. Allow us to explain.\n     *\n     * One of the goals of `@solana/errors` is to allow errors that are not interesting to your\n     * application to shake out of your app bundle in production. This means that we must never\n     * export large hardcoded maps of error codes/messages.\n     *\n     * Unfortunately, where instruction and transaction errors from the RPC are concerned, we have\n     * no choice but to keep a map between the RPC `rpcEnumError` enum name and its corresponding\n     * `SolanaError` code. In the interest of implementing that map in as few bytes of source code\n     * as possible, we do the following:\n     *\n     *   1. Reserve a block of sequential error codes for the enum in question\n     *   2. Hardcode the list of enum names in that same order\n     *   3. Match the enum error name from the RPC with its index in that list, and reconstruct the\n     *      `SolanaError` code by adding the `errorCodeBaseOffset` to that index\n     */\n    errorCodeBaseOffset: number;\n    getErrorContext: (\n        errorCode: SolanaErrorCode,\n        rpcErrorName: string,\n        rpcErrorContext?: unknown,\n    ) => SolanaErrorContext[SolanaErrorCode];\n    orderedErrorNames: string[];\n    rpcEnumError: string | { [key: string]: unknown };\n}>;\n\nexport function getSolanaErrorFromRpcError(\n    { errorCodeBaseOffset, getErrorContext, orderedErrorNames, rpcEnumError }: Config,\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    constructorOpt: Function,\n): SolanaError {\n    let rpcErrorName;\n    let rpcErrorContext;\n    if (typeof rpcEnumError === 'string') {\n        rpcErrorName = rpcEnumError;\n    } else {\n        rpcErrorName = Object.keys(rpcEnumError)[0];\n        rpcErrorContext = rpcEnumError[rpcErrorName];\n    }\n    const codeOffset = orderedErrorNames.indexOf(rpcErrorName);\n    const errorCode = (errorCodeBaseOffset + codeOffset) as SolanaErrorCode;\n    const errorContext = getErrorContext(errorCode, rpcErrorName, rpcErrorContext);\n    const err = new SolanaError(errorCode, errorContext);\n    safeCaptureStackTrace(err, constructorOpt);\n    return err;\n}\n","import {\n    SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR,\n    SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM,\n    SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN,\n} from './codes';\nimport { SolanaError } from './error';\nimport { getSolanaErrorFromRpcError } from './rpc-enum-errors';\n\nconst ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/program/src/instruction.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    'GenericError',\n    'InvalidArgument',\n    'InvalidInstructionData',\n    'InvalidAccountData',\n    'AccountDataTooSmall',\n    'InsufficientFunds',\n    'IncorrectProgramId',\n    'MissingRequiredSignature',\n    'AccountAlreadyInitialized',\n    'UninitializedAccount',\n    'UnbalancedInstruction',\n    'ModifiedProgramId',\n    'ExternalAccountLamportSpend',\n    'ExternalAccountDataModified',\n    'ReadonlyLamportChange',\n    'ReadonlyDataModified',\n    'DuplicateAccountIndex',\n    'ExecutableModified',\n    'RentEpochModified',\n    'NotEnoughAccountKeys',\n    'AccountDataSizeChanged',\n    'AccountNotExecutable',\n    'AccountBorrowFailed',\n    'AccountBorrowOutstanding',\n    'DuplicateAccountOutOfSync',\n    'Custom',\n    'InvalidError',\n    'ExecutableDataModified',\n    'ExecutableLamportChange',\n    'ExecutableAccountNotRentExempt',\n    'UnsupportedProgramId',\n    'CallDepth',\n    'MissingAccount',\n    'ReentrancyNotAllowed',\n    'MaxSeedLengthExceeded',\n    'InvalidSeeds',\n    'InvalidRealloc',\n    'ComputationalBudgetExceeded',\n    'PrivilegeEscalation',\n    'ProgramEnvironmentSetupFailure',\n    'ProgramFailedToComplete',\n    'ProgramFailedToCompile',\n    'Immutable',\n    'IncorrectAuthority',\n    'BorshIoError',\n    'AccountNotRentExempt',\n    'InvalidAccountOwner',\n    'ArithmeticOverflow',\n    'UnsupportedSysvar',\n    'IllegalOwner',\n    'MaxAccountsDataAllocationsExceeded',\n    'MaxAccountsExceeded',\n    'MaxInstructionTraceLengthExceeded',\n    'BuiltinProgramsMustConsumeComputeUnits',\n];\n\nexport function getSolanaErrorFromInstructionError(\n    /**\n     * The index of the instruction inside the transaction.\n     */\n    index: bigint | number,\n    instructionError: string | { [key: string]: unknown },\n): SolanaError {\n    const numberIndex = Number(index);\n    return getSolanaErrorFromRpcError(\n        {\n            errorCodeBaseOffset: 4615001,\n            getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n                if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN) {\n                    return {\n                        errorName: rpcErrorName,\n                        index: numberIndex,\n                        ...(rpcErrorContext !== undefined ? { instructionErrorContext: rpcErrorContext } : null),\n                    };\n                } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM) {\n                    return {\n                        code: Number(rpcErrorContext as bigint | number),\n                        index: numberIndex,\n                    };\n                } else if (errorCode === SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR) {\n                    return {\n                        encodedData: rpcErrorContext as string,\n                        index: numberIndex,\n                    };\n                }\n                return { index: numberIndex };\n            },\n            orderedErrorNames: ORDERED_ERROR_NAMES,\n            rpcEnumError: instructionError,\n        },\n        getSolanaErrorFromInstructionError,\n    );\n}\n","import {\n    SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION,\n    SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT,\n    SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED,\n    SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN,\n} from './codes';\nimport { SolanaError } from './error';\nimport { getSolanaErrorFromInstructionError } from './instruction-error';\nimport { getSolanaErrorFromRpcError } from './rpc-enum-errors';\n\n/**\n * How to add an error when an entry is added to the RPC `TransactionError` enum:\n *\n *   1. Follow the instructions in `./codes.ts` to add a corresponding Solana error code\n *   2. Add the `TransactionError` enum name in the same order as it appears in `./codes.ts`\n *   3. Add the new error name/code mapping to `./__tests__/transaction-error-test.ts`\n */\nconst ORDERED_ERROR_NAMES = [\n    // Keep synced with RPC source: https://github.com/anza-xyz/agave/blob/master/sdk/src/transaction/error.rs\n    // If this list ever gets too large, consider implementing a compression strategy like this:\n    // https://gist.github.com/steveluscher/aaa7cbbb5433b1197983908a40860c47\n    'AccountInUse',\n    'AccountLoadedTwice',\n    'AccountNotFound',\n    'ProgramAccountNotFound',\n    'InsufficientFundsForFee',\n    'InvalidAccountForFee',\n    'AlreadyProcessed',\n    'BlockhashNotFound',\n    // `InstructionError` intentionally omitted; delegated to `getSolanaErrorFromInstructionError`\n    'CallChainTooDeep',\n    'MissingSignatureForFee',\n    'InvalidAccountIndex',\n    'SignatureFailure',\n    'InvalidProgramForExecution',\n    'SanitizeFailure',\n    'ClusterMaintenance',\n    'AccountBorrowOutstanding',\n    'WouldExceedMaxBlockCostLimit',\n    'UnsupportedVersion',\n    'InvalidWritableAccount',\n    'WouldExceedMaxAccountCostLimit',\n    'WouldExceedAccountDataBlockLimit',\n    'TooManyAccountLocks',\n    'AddressLookupTableNotFound',\n    'InvalidAddressLookupTableOwner',\n    'InvalidAddressLookupTableData',\n    'InvalidAddressLookupTableIndex',\n    'InvalidRentPayingAccount',\n    'WouldExceedMaxVoteCostLimit',\n    'WouldExceedAccountDataTotalLimit',\n    'DuplicateInstruction',\n    'InsufficientFundsForRent',\n    'MaxLoadedAccountsDataSizeExceeded',\n    'InvalidLoadedAccountsDataSizeLimit',\n    'ResanitizationNeeded',\n    'ProgramExecutionTemporarilyRestricted',\n    'UnbalancedTransaction',\n];\n\nexport function getSolanaErrorFromTransactionError(transactionError: string | { [key: string]: unknown }): SolanaError {\n    if (typeof transactionError === 'object' && 'InstructionError' in transactionError) {\n        return getSolanaErrorFromInstructionError(\n            ...(transactionError.InstructionError as Parameters<typeof getSolanaErrorFromInstructionError>),\n        );\n    }\n    return getSolanaErrorFromRpcError(\n        {\n            errorCodeBaseOffset: 7050001,\n            getErrorContext(errorCode, rpcErrorName, rpcErrorContext) {\n                if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN) {\n                    return {\n                        errorName: rpcErrorName,\n                        ...(rpcErrorContext !== undefined ? { transactionErrorContext: rpcErrorContext } : null),\n                    };\n                } else if (errorCode === SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION) {\n                    return {\n                        index: Number(rpcErrorContext as bigint | number),\n                    };\n                } else if (\n                    errorCode === SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT ||\n                    errorCode === SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED\n                ) {\n                    return {\n                        accountIndex: Number((rpcErrorContext as { account_index: bigint | number }).account_index),\n                    };\n                }\n            },\n            orderedErrorNames: ORDERED_ERROR_NAMES,\n            rpcEnumError: transactionError,\n        },\n        getSolanaErrorFromTransactionError,\n    );\n}\n","import {\n    SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR,\n    SOLANA_ERROR__JSON_RPC__INVALID_PARAMS,\n    SOLANA_ERROR__JSON_RPC__INVALID_REQUEST,\n    SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND,\n    SOLANA_ERROR__JSON_RPC__PARSE_ERROR,\n    SOLANA_ERROR__JSON_RPC__SCAN_ERROR,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE,\n    SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION,\n    SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR,\n    SolanaErrorCode,\n} from './codes';\nimport { SolanaErrorContext } from './context';\nimport { SolanaError } from './error';\nimport { safeCaptureStackTrace } from './stack-trace';\nimport { getSolanaErrorFromTransactionError } from './transaction-error';\n\ninterface RpcErrorResponse {\n    code: bigint | number;\n    data?: unknown;\n    message: string;\n}\n\ntype TransactionError = string | { [key: string]: unknown };\n\n/**\n * Keep in sync with https://github.com/anza-xyz/agave/blob/master/rpc-client-types/src/response.rs\n * @hidden\n */\nexport interface RpcSimulateTransactionResult {\n    accounts:\n        | ({\n              data:\n                  | string // LegacyBinary\n                  | {\n                        // Json\n                        parsed: unknown;\n                        program: string;\n                        space: number;\n                    }\n                  // Binary\n                  | [encodedBytes: string, encoding: 'base58' | 'base64' | 'base64+zstd' | 'binary' | 'jsonParsed'];\n              executable: boolean;\n              lamports: number;\n              owner: string;\n              rentEpoch: number;\n              space?: number;\n          } | null)[]\n        | null;\n    err: TransactionError | null;\n    // Enabled by `enable_cpi_recording`\n    innerInstructions?:\n        | {\n              index: number;\n              instructions: (\n                  | {\n                        // Compiled\n                        accounts: number[];\n                        data: string;\n                        programIdIndex: number;\n                        stackHeight?: number;\n                    }\n                  | {\n                        // Parsed\n                        parsed: unknown;\n                        program: string;\n                        programId: string;\n                        stackHeight?: number;\n                    }\n                  | {\n                        // PartiallyDecoded\n                        accounts: string[];\n                        data: string;\n                        programId: string;\n                        stackHeight?: number;\n                    }\n              )[];\n          }[]\n        | null;\n    loadedAccountsDataSize: number | null;\n    logs: string[] | null;\n    replacementBlockhash: string | null;\n    returnData: {\n        data: [string, 'base64'];\n        programId: string;\n    } | null;\n    unitsConsumed: bigint | null;\n}\n\nexport function getSolanaErrorFromJsonRpcError(putativeErrorResponse: unknown): SolanaError {\n    let out: SolanaError;\n    if (isRpcErrorResponse(putativeErrorResponse)) {\n        const { code: rawCode, data, message } = putativeErrorResponse;\n        const code = Number(rawCode);\n        if (code === SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE) {\n            const { err, ...preflightErrorContext } = data as RpcSimulateTransactionResult;\n            const causeObject = err ? { cause: getSolanaErrorFromTransactionError(err) } : null;\n            out = new SolanaError(SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE, {\n                ...preflightErrorContext,\n                ...causeObject,\n            });\n        } else {\n            let errorContext;\n            switch (code) {\n                case SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR:\n                case SOLANA_ERROR__JSON_RPC__INVALID_PARAMS:\n                case SOLANA_ERROR__JSON_RPC__INVALID_REQUEST:\n                case SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND:\n                case SOLANA_ERROR__JSON_RPC__PARSE_ERROR:\n                case SOLANA_ERROR__JSON_RPC__SCAN_ERROR:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE:\n                case SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION:\n                    // The server supplies no structured data, but rather a pre-formatted message. Put\n                    // the server message in `context` so as not to completely lose the data. The long\n                    // term fix for this is to add data to the server responses and modify the\n                    // messages in `@solana/errors` to be actual format strings.\n                    errorContext = { __serverMessage: message };\n                    break;\n                default:\n                    if (typeof data === 'object' && !Array.isArray(data)) {\n                        errorContext = data;\n                    }\n            }\n            out = new SolanaError(code as SolanaErrorCode, errorContext as SolanaErrorContext[SolanaErrorCode]);\n        }\n    } else {\n        const message =\n            typeof putativeErrorResponse === 'object' &&\n            putativeErrorResponse !== null &&\n            'message' in putativeErrorResponse &&\n            typeof putativeErrorResponse.message === 'string'\n                ? putativeErrorResponse.message\n                : 'Malformed JSON-RPC error with no message attribute';\n        out = new SolanaError(SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR, { error: putativeErrorResponse, message });\n    }\n    safeCaptureStackTrace(out, getSolanaErrorFromJsonRpcError);\n    return out;\n}\n\nfunction isRpcErrorResponse(value: unknown): value is RpcErrorResponse {\n    return (\n        typeof value === 'object' &&\n        value !== null &&\n        'code' in value &&\n        'message' in value &&\n        (typeof value.code === 'number' || typeof value.code === 'bigint') &&\n        typeof value.message === 'string'\n    );\n}\n","import { SolanaError, SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE } from '@solana/errors';\nimport { combineCodec, createDecoder, createEncoder, assertByteArrayIsNotEmptyForCodec, assertByteArrayHasEnoughBytesForCodec } from '@solana/codecs-core';\n\n// src/assertions.ts\nfunction assertNumberIsBetweenForCodec(codecDescription, min, max, value) {\n  if (value < min || value > max) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n      codecDescription,\n      max,\n      min,\n      value\n    });\n  }\n}\n\n// src/common.ts\nvar Endian = /* @__PURE__ */ ((Endian2) => {\n  Endian2[Endian2[\"Little\"] = 0] = \"Little\";\n  Endian2[Endian2[\"Big\"] = 1] = \"Big\";\n  return Endian2;\n})(Endian || {});\nfunction isLittleEndian(config) {\n  return config?.endian === 1 /* Big */ ? false : true;\n}\nfunction numberEncoderFactory(input) {\n  return createEncoder({\n    fixedSize: input.size,\n    write(value, bytes, offset) {\n      if (input.range) {\n        assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n      }\n      const arrayBuffer = new ArrayBuffer(input.size);\n      input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n      bytes.set(new Uint8Array(arrayBuffer), offset);\n      return offset + input.size;\n    }\n  });\n}\nfunction numberDecoderFactory(input) {\n  return createDecoder({\n    fixedSize: input.size,\n    read(bytes, offset = 0) {\n      assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);\n      assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);\n      const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n      return [input.get(view, isLittleEndian(input.config)), offset + input.size];\n    }\n  });\n}\nfunction toArrayBuffer(bytes, offset, length) {\n  const bytesOffset = bytes.byteOffset + (offset ?? 0);\n  const bytesLength = length ?? bytes.byteLength;\n  return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n\n// src/f32.ts\nvar getF32Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"f32\",\n  set: (view, value, le) => view.setFloat32(0, Number(value), le),\n  size: 4\n});\nvar getF32Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getFloat32(0, le),\n  name: \"f32\",\n  size: 4\n});\nvar getF32Codec = (config = {}) => combineCodec(getF32Encoder(config), getF32Decoder(config));\nvar getF64Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"f64\",\n  set: (view, value, le) => view.setFloat64(0, Number(value), le),\n  size: 8\n});\nvar getF64Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getFloat64(0, le),\n  name: \"f64\",\n  size: 8\n});\nvar getF64Codec = (config = {}) => combineCodec(getF64Encoder(config), getF64Decoder(config));\nvar getI128Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"i128\",\n  range: [-BigInt(\"0x7fffffffffffffffffffffffffffffff\") - 1n, BigInt(\"0x7fffffffffffffffffffffffffffffff\")],\n  set: (view, value, le) => {\n    const leftOffset = le ? 8 : 0;\n    const rightOffset = le ? 0 : 8;\n    const rightMask = 0xffffffffffffffffn;\n    view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n    view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n  },\n  size: 16\n});\nvar getI128Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => {\n    const leftOffset = le ? 8 : 0;\n    const rightOffset = le ? 0 : 8;\n    const left = view.getBigInt64(leftOffset, le);\n    const right = view.getBigUint64(rightOffset, le);\n    return (left << 64n) + right;\n  },\n  name: \"i128\",\n  size: 16\n});\nvar getI128Codec = (config = {}) => combineCodec(getI128Encoder(config), getI128Decoder(config));\nvar getI16Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"i16\",\n  range: [-Number(\"0x7fff\") - 1, Number(\"0x7fff\")],\n  set: (view, value, le) => view.setInt16(0, Number(value), le),\n  size: 2\n});\nvar getI16Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getInt16(0, le),\n  name: \"i16\",\n  size: 2\n});\nvar getI16Codec = (config = {}) => combineCodec(getI16Encoder(config), getI16Decoder(config));\nvar getI32Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"i32\",\n  range: [-Number(\"0x7fffffff\") - 1, Number(\"0x7fffffff\")],\n  set: (view, value, le) => view.setInt32(0, Number(value), le),\n  size: 4\n});\nvar getI32Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getInt32(0, le),\n  name: \"i32\",\n  size: 4\n});\nvar getI32Codec = (config = {}) => combineCodec(getI32Encoder(config), getI32Decoder(config));\nvar getI64Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"i64\",\n  range: [-BigInt(\"0x7fffffffffffffff\") - 1n, BigInt(\"0x7fffffffffffffff\")],\n  set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),\n  size: 8\n});\nvar getI64Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getBigInt64(0, le),\n  name: \"i64\",\n  size: 8\n});\nvar getI64Codec = (config = {}) => combineCodec(getI64Encoder(config), getI64Decoder(config));\nvar getI8Encoder = () => numberEncoderFactory({\n  name: \"i8\",\n  range: [-Number(\"0x7f\") - 1, Number(\"0x7f\")],\n  set: (view, value) => view.setInt8(0, Number(value)),\n  size: 1\n});\nvar getI8Decoder = () => numberDecoderFactory({\n  get: (view) => view.getInt8(0),\n  name: \"i8\",\n  size: 1\n});\nvar getI8Codec = () => combineCodec(getI8Encoder(), getI8Decoder());\nvar getShortU16Encoder = () => createEncoder({\n  getSizeFromValue: (value) => {\n    if (value <= 127) return 1;\n    if (value <= 16383) return 2;\n    return 3;\n  },\n  maxSize: 3,\n  write: (value, bytes, offset) => {\n    assertNumberIsBetweenForCodec(\"shortU16\", 0, 65535, value);\n    const shortU16Bytes = [0];\n    for (let ii = 0; ; ii += 1) {\n      const alignedValue = Number(value) >> ii * 7;\n      if (alignedValue === 0) {\n        break;\n      }\n      const nextSevenBits = 127 & alignedValue;\n      shortU16Bytes[ii] = nextSevenBits;\n      if (ii > 0) {\n        shortU16Bytes[ii - 1] |= 128;\n      }\n    }\n    bytes.set(shortU16Bytes, offset);\n    return offset + shortU16Bytes.length;\n  }\n});\nvar getShortU16Decoder = () => createDecoder({\n  maxSize: 3,\n  read: (bytes, offset) => {\n    let value = 0;\n    let byteCount = 0;\n    while (++byteCount) {\n      const byteIndex = byteCount - 1;\n      const currentByte = bytes[offset + byteIndex];\n      const nextSevenBits = 127 & currentByte;\n      value |= nextSevenBits << byteIndex * 7;\n      if ((currentByte & 128) === 0) {\n        break;\n      }\n    }\n    return [value, offset + byteCount];\n  }\n});\nvar getShortU16Codec = () => combineCodec(getShortU16Encoder(), getShortU16Decoder());\nvar getU128Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"u128\",\n  range: [0n, BigInt(\"0xffffffffffffffffffffffffffffffff\")],\n  set: (view, value, le) => {\n    const leftOffset = le ? 8 : 0;\n    const rightOffset = le ? 0 : 8;\n    const rightMask = 0xffffffffffffffffn;\n    view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n    view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n  },\n  size: 16\n});\nvar getU128Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => {\n    const leftOffset = le ? 8 : 0;\n    const rightOffset = le ? 0 : 8;\n    const left = view.getBigUint64(leftOffset, le);\n    const right = view.getBigUint64(rightOffset, le);\n    return (left << 64n) + right;\n  },\n  name: \"u128\",\n  size: 16\n});\nvar getU128Codec = (config = {}) => combineCodec(getU128Encoder(config), getU128Decoder(config));\nvar getU16Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"u16\",\n  range: [0, Number(\"0xffff\")],\n  set: (view, value, le) => view.setUint16(0, Number(value), le),\n  size: 2\n});\nvar getU16Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getUint16(0, le),\n  name: \"u16\",\n  size: 2\n});\nvar getU16Codec = (config = {}) => combineCodec(getU16Encoder(config), getU16Decoder(config));\nvar getU32Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"u32\",\n  range: [0, Number(\"0xffffffff\")],\n  set: (view, value, le) => view.setUint32(0, Number(value), le),\n  size: 4\n});\nvar getU32Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getUint32(0, le),\n  name: \"u32\",\n  size: 4\n});\nvar getU32Codec = (config = {}) => combineCodec(getU32Encoder(config), getU32Decoder(config));\nvar getU64Encoder = (config = {}) => numberEncoderFactory({\n  config,\n  name: \"u64\",\n  range: [0n, BigInt(\"0xffffffffffffffff\")],\n  set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),\n  size: 8\n});\nvar getU64Decoder = (config = {}) => numberDecoderFactory({\n  config,\n  get: (view, le) => view.getBigUint64(0, le),\n  name: \"u64\",\n  size: 8\n});\nvar getU64Codec = (config = {}) => combineCodec(getU64Encoder(config), getU64Decoder(config));\nvar getU8Encoder = () => numberEncoderFactory({\n  name: \"u8\",\n  range: [0, Number(\"0xff\")],\n  set: (view, value) => view.setUint8(0, Number(value)),\n  size: 1\n});\nvar getU8Decoder = () => numberDecoderFactory({\n  get: (view) => view.getUint8(0),\n  name: \"u8\",\n  size: 1\n});\nvar getU8Codec = () => combineCodec(getU8Encoder(), getU8Decoder());\n\nexport { Endian, assertNumberIsBetweenForCodec, getF32Codec, getF32Decoder, getF32Encoder, getF64Codec, getF64Decoder, getF64Encoder, getI128Codec, getI128Decoder, getI128Encoder, getI16Codec, getI16Decoder, getI16Encoder, getI32Codec, getI32Decoder, getI32Encoder, getI64Codec, getI64Decoder, getI64Encoder, getI8Codec, getI8Decoder, getI8Encoder, getShortU16Codec, getShortU16Decoder, getShortU16Encoder, getU128Codec, getU128Decoder, getU128Encoder, getU16Codec, getU16Decoder, getU16Encoder, getU32Codec, getU32Decoder, getU32Encoder, getU64Codec, getU64Decoder, getU64Encoder, getU8Codec, getU8Decoder, getU8Encoder };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","import { SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, SolanaError } from '@solana/errors';\n\n/**\n * Ensures that a given number falls within a specified range.\n *\n * If the number is outside the allowed range, an error is thrown.\n * This function is primarily used to validate values before encoding them in a codec.\n *\n * @param codecDescription - A string describing the codec that is performing the validation.\n * @param min - The minimum allowed value (inclusive).\n * @param max - The maximum allowed value (inclusive).\n * @param value - The number to validate.\n *\n * @throws {@link SolanaError} if the value is out of range.\n *\n * @example\n * Validating a number within range.\n * ```ts\n * assertNumberIsBetweenForCodec('u8', 0, 255, 42); // Passes\n * ```\n *\n * @example\n * Throwing an error for an out-of-range value.\n * ```ts\n * assertNumberIsBetweenForCodec('u8', 0, 255, 300); // Throws\n * ```\n */\nexport function assertNumberIsBetweenForCodec(\n    codecDescription: string,\n    min: bigint | number,\n    max: bigint | number,\n    value: bigint | number,\n) {\n    if (value < min || value > max) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n            codecDescription,\n            max,\n            min,\n            value,\n        });\n    }\n}\n","import { Codec, Decoder, Encoder, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n/**\n * Represents an encoder for numbers and bigints.\n *\n * This type allows encoding values that are either `number` or `bigint`.\n * Depending on the specific implementation, the encoded output may have a fixed or variable size.\n *\n * @see {@link FixedSizeNumberEncoder}\n */\nexport type NumberEncoder = Encoder<bigint | number>;\n\n/**\n * Represents a fixed-size encoder for numbers and bigints.\n *\n * This encoder serializes values using an exact number of bytes, defined by `TSize`.\n *\n * @typeParam TSize - The number of bytes used for encoding.\n *\n * @see {@link NumberEncoder}\n */\nexport type FixedSizeNumberEncoder<TSize extends number = number> = FixedSizeEncoder<bigint | number, TSize>;\n\n/**\n * Represents a decoder for numbers and bigints.\n *\n * This type supports decoding values as either `number` or `bigint`, depending on the implementation.\n *\n * @see {@link FixedSizeNumberDecoder}\n */\nexport type NumberDecoder = Decoder<bigint> | Decoder<number>;\n\n/**\n * Represents a fixed-size decoder for numbers and bigints.\n *\n * This decoder reads a fixed number of bytes (`TSize`) and converts them into a `number` or `bigint`.\n *\n * @typeParam TSize - The number of bytes expected for decoding.\n *\n * @see {@link NumberDecoder}\n */\nexport type FixedSizeNumberDecoder<TSize extends number = number> =\n    | FixedSizeDecoder<bigint, TSize>\n    | FixedSizeDecoder<number, TSize>;\n\n/**\n * Represents a codec for encoding and decoding numbers and bigints.\n *\n * - The encoded value can be either a `number` or a `bigint`.\n * - The decoded value will always be either a `number` or `bigint`, depending on the implementation.\n *\n * @see {@link FixedSizeNumberCodec}\n */\nexport type NumberCodec = Codec<bigint | number, bigint> | Codec<bigint | number, number>;\n\n/**\n * Represents a fixed-size codec for encoding and decoding numbers and bigints.\n *\n * This codec uses a specific number of bytes (`TSize`) for serialization.\n * The encoded value can be either a `number` or `bigint`, but the decoded value will always be a `number` or `bigint`,\n * depending on the implementation.\n *\n * @typeParam TSize - The number of bytes used for encoding and decoding.\n *\n * @see {@link NumberCodec}\n */\nexport type FixedSizeNumberCodec<TSize extends number = number> =\n    | FixedSizeCodec<bigint | number, bigint, TSize>\n    | FixedSizeCodec<bigint | number, number, TSize>;\n\n/**\n * Configuration options for number codecs that use more than one byte.\n *\n * This configuration applies to all number codecs except `u8` and `i8`,\n * allowing the user to specify the endianness of serialization.\n */\nexport type NumberCodecConfig = {\n    /**\n     * Specifies whether numbers should be encoded in little-endian or big-endian format.\n     *\n     * @defaultValue `Endian.Little`\n     */\n    endian?: Endian;\n};\n\n/**\n * Defines the byte order used for number serialization.\n *\n * - `Little`: The least significant byte is stored first.\n * - `Big`: The most significant byte is stored first.\n */\nexport enum Endian {\n    Little,\n    Big,\n}\n","import {\n    assertByteArrayHasEnoughBytesForCodec,\n    assertByteArrayIsNotEmptyForCodec,\n    createDecoder,\n    createEncoder,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    Offset,\n    ReadonlyUint8Array,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\nimport { Endian, NumberCodecConfig } from './common';\n\ntype NumberFactorySharedInput<TSize extends number> = {\n    config?: NumberCodecConfig;\n    name: string;\n    size: TSize;\n};\n\ntype NumberFactoryEncoderInput<TFrom, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    range?: [bigint | number, bigint | number];\n    set: (view: DataView, value: TFrom, littleEndian?: boolean) => void;\n};\n\ntype NumberFactoryDecoderInput<TTo, TSize extends number> = NumberFactorySharedInput<TSize> & {\n    get: (view: DataView, littleEndian?: boolean) => TTo;\n};\n\nfunction isLittleEndian(config?: NumberCodecConfig): boolean {\n    return config?.endian === Endian.Big ? false : true;\n}\n\nexport function numberEncoderFactory<TFrom extends bigint | number, TSize extends number>(\n    input: NumberFactoryEncoderInput<TFrom, TSize>,\n): FixedSizeEncoder<TFrom, TSize> {\n    return createEncoder({\n        fixedSize: input.size,\n        write(value: TFrom, bytes: Uint8Array, offset: Offset): Offset {\n            if (input.range) {\n                assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n            }\n            const arrayBuffer = new ArrayBuffer(input.size);\n            input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n            bytes.set(new Uint8Array(arrayBuffer), offset);\n            return offset + input.size;\n        },\n    });\n}\n\nexport function numberDecoderFactory<TTo extends bigint | number, TSize extends number>(\n    input: NumberFactoryDecoderInput<TTo, TSize>,\n): FixedSizeDecoder<TTo, TSize> {\n    return createDecoder({\n        fixedSize: input.size,\n        read(bytes, offset = 0): [TTo, number] {\n            assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset);\n            assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset);\n            const view = new DataView(toArrayBuffer(bytes, offset, input.size));\n            return [input.get(view, isLittleEndian(input.config)), offset + input.size];\n        },\n    });\n}\n\n/**\n * Helper function to ensure that the ArrayBuffer is converted properly from a Uint8Array\n * Source: https://stackoverflow.com/questions/37228285/uint8array-to-arraybuffer\n */\nfunction toArrayBuffer(bytes: ReadonlyUint8Array | Uint8Array, offset?: number, length?: number): ArrayBuffer {\n    const bytesOffset = bytes.byteOffset + (offset ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n}\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit floating-point numbers (`f32`).\n *\n * This encoder serializes `f32` values using 4 bytes.\n * Floating-point values may lose precision when encoded.\n *\n * For more details, see {@link getF32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number, 4>` for encoding `f32` values.\n *\n * @example\n * Encoding an `f32` value.\n * ```ts\n * const encoder = getF32Encoder();\n * const bytes = encoder.encode(-1.5); // 0x0000c0bf\n * ```\n *\n * @see {@link getF32Codec}\n */\nexport const getF32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'f32',\n        set: (view, value, le) => view.setFloat32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit floating-point numbers (`f32`).\n *\n * This decoder deserializes `f32` values from 4 bytes.\n * Some precision may be lost during decoding due to floating-point representation.\n *\n * For more details, see {@link getF32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `f32` values.\n *\n * @example\n * Decoding an `f32` value.\n * ```ts\n * const decoder = getF32Decoder();\n * const value = decoder.decode(new Uint8Array([0x00, 0x00, 0xc0, 0xbf])); // -1.5\n * ```\n *\n * @see {@link getF32Codec}\n */\nexport const getF32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat32(0, le),\n        name: 'f32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit floating-point numbers (`f32`).\n *\n * This codec serializes `f32` values using 4 bytes.\n * Due to the IEEE 754 floating-point representation, some precision loss may occur.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number, number, 4>` for encoding and decoding `f32` values.\n *\n * @example\n * Encoding and decoding an `f32` value.\n * ```ts\n * const codec = getF32Codec();\n * const bytes = codec.encode(-1.5); // 0x0000c0bf\n * const value = codec.decode(bytes); // -1.5\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getF32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-1.5); // 0xbfc00000\n * ```\n *\n * @remarks\n * `f32` values follow the IEEE 754 single-precision floating-point standard.\n * Precision loss may occur for certain values.\n *\n * - If you need higher precision, consider using {@link getF64Codec}.\n * - If you need integer values, consider using {@link getI32Codec} or {@link getU32Codec}.\n *\n * Separate {@link getF32Encoder} and {@link getF32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getF32Encoder().encode(-1.5);\n * const value = getF32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getF32Encoder}\n * @see {@link getF32Decoder}\n */\nexport const getF32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getF32Encoder(config), getF32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit floating-point numbers (`f64`).\n *\n * This encoder serializes `f64` values using 8 bytes.\n * Floating-point values may lose precision when encoded.\n *\n * For more details, see {@link getF64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number, 8>` for encoding `f64` values.\n *\n * @example\n * Encoding an `f64` value.\n * ```ts\n * const encoder = getF64Encoder();\n * const bytes = encoder.encode(-1.5); // 0x000000000000f8bf\n * ```\n *\n * @see {@link getF64Codec}\n */\nexport const getF64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'f64',\n        set: (view, value, le) => view.setFloat64(0, Number(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit floating-point numbers (`f64`).\n *\n * This decoder deserializes `f64` values from 8 bytes.\n * Some precision may be lost during decoding due to floating-point representation.\n *\n * For more details, see {@link getF64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 8>` for decoding `f64` values.\n *\n * @example\n * Decoding an `f64` value.\n * ```ts\n * const decoder = getF64Decoder();\n * const value = decoder.decode(new Uint8Array([0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xbf])); // -1.5\n * ```\n *\n * @see {@link getF64Codec}\n */\nexport const getF64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getFloat64(0, le),\n        name: 'f64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit floating-point numbers (`f64`).\n *\n * This codec serializes `f64` values using 8 bytes.\n * Due to the IEEE 754 floating-point representation, some precision loss may occur.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number, number, 8>` for encoding and decoding `f64` values.\n *\n * @example\n * Encoding and decoding an `f64` value.\n * ```ts\n * const codec = getF64Codec();\n * const bytes = codec.encode(-1.5); // 0x000000000000f8bf\n * const value = codec.decode(bytes); // -1.5\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getF64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-1.5); // 0xbff8000000000000\n * ```\n *\n * @remarks\n * `f64` values follow the IEEE 754 double-precision floating-point standard.\n * Precision loss may still occur but is significantly lower than `f32`.\n *\n * - If you need smaller floating-point values, consider using {@link getF32Codec}.\n * - If you need integer values, consider using {@link getI64Codec} or {@link getU64Codec}.\n *\n * Separate {@link getF64Encoder} and {@link getF64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getF64Encoder().encode(-1.5);\n * const value = getF64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getF64Encoder}\n * @see {@link getF64Decoder}\n */\nexport const getF64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 8> =>\n    combineCodec(getF64Encoder(config), getF64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 128-bit signed integers (`i128`).\n *\n * This encoder serializes `i128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI128Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 16>` for encoding `i128` values.\n *\n * @example\n * Encoding an `i128` value.\n * ```ts\n * const encoder = getI128Encoder();\n * const bytes = encoder.encode(-42n); // 0xd6ffffffffffffffffffffffffffffff\n * ```\n *\n * @see {@link getI128Codec}\n */\nexport const getI128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'i128',\n        range: [-BigInt('0x7fffffffffffffffffffffffffffffff') - 1n, BigInt('0x7fffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigInt64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\n/**\n * Returns a decoder for 128-bit signed integers (`i128`).\n *\n * This decoder deserializes `i128` values from 16 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getI128Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 16>` for decoding `i128` values.\n *\n * @example\n * Decoding an `i128` value.\n * ```ts\n * const decoder = getI128Decoder();\n * const value = decoder.decode(new Uint8Array([\n *   0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n *   0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n * ])); // -42n\n * ```\n *\n * @see {@link getI128Codec}\n */\nexport const getI128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigInt64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'i128',\n        size: 16,\n    });\n\n/**\n * Returns a codec for encoding and decoding 128-bit signed integers (`i128`).\n *\n * This codec serializes `i128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 16>` for encoding and decoding `i128` values.\n *\n * @example\n * Encoding and decoding an `i128` value.\n * ```ts\n * const codec = getI128Codec();\n * const bytes = codec.encode(-42n); // 0xd6ffffffffffffffffffffffffffffff\n * const value = codec.decode(bytes); // -42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI128Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42n); // 0xffffffffffffffffffffffffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^127` and `2^127 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller signed integer, consider using {@link getI64Codec} or {@link getI32Codec}.\n * - If you need a larger signed integer, consider using a custom codec.\n * - If you need unsigned integers, consider using {@link getU128Codec}.\n *\n * Separate {@link getI128Encoder} and {@link getI128Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI128Encoder().encode(-42);\n * const value = getI128Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI128Encoder}\n * @see {@link getI128Decoder}\n */\nexport const getI128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getI128Encoder(config), getI128Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 16-bit signed integers (`i16`).\n *\n * This encoder serializes `i16` values using 2 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI16Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 2>` for encoding `i16` values.\n *\n * @example\n * Encoding an `i16` value.\n * ```ts\n * const encoder = getI16Encoder();\n * const bytes = encoder.encode(-42); // 0xd6ff\n * ```\n *\n * @see {@link getI16Codec}\n */\nexport const getI16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'i16',\n        range: [-Number('0x7fff') - 1, Number('0x7fff')],\n        set: (view, value, le) => view.setInt16(0, Number(value), le),\n        size: 2,\n    });\n\n/**\n * Returns a decoder for 16-bit signed integers (`i16`).\n *\n * This decoder deserializes `i16` values from 2 bytes.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI16Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 2>` for decoding `i16` values.\n *\n * @example\n * Decoding an `i16` value.\n * ```ts\n * const decoder = getI16Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6, 0xff])); // -42\n * ```\n *\n * @see {@link getI16Codec}\n */\nexport const getI16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt16(0, le),\n        name: 'i16',\n        size: 2,\n    });\n\n/**\n * Returns a codec for encoding and decoding 16-bit signed integers (`i16`).\n *\n * This codec serializes `i16` values using 2 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, number, 2>` for encoding and decoding `i16` values.\n *\n * @example\n * Encoding and decoding an `i16` value.\n * ```ts\n * const codec = getI16Codec();\n * const bytes = codec.encode(-42); // 0xd6ff\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI16Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42); // 0xffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^15` (`-32,768`) and `2^15 - 1` (`32,767`).\n *\n * - If you need a smaller signed integer, consider using {@link getI8Codec}.\n * - If you need a larger signed integer, consider using {@link getI32Codec}.\n * - If you need unsigned integers, consider using {@link getU16Codec}.\n *\n * Separate {@link getI16Encoder} and {@link getI16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI16Encoder().encode(-42);\n * const value = getI16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI16Encoder}\n * @see {@link getI16Decoder}\n */\nexport const getI16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getI16Encoder(config), getI16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit signed integers (`i32`).\n *\n * This encoder serializes `i32` values using 4 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 4>` for encoding `i32` values.\n *\n * @example\n * Encoding an `i32` value.\n * ```ts\n * const encoder = getI32Encoder();\n * const bytes = encoder.encode(-42); // 0xd6ffffff\n * ```\n *\n * @see {@link getI32Codec}\n */\nexport const getI32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'i32',\n        range: [-Number('0x7fffffff') - 1, Number('0x7fffffff')],\n        set: (view, value, le) => view.setInt32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit signed integers (`i32`).\n *\n * This decoder deserializes `i32` values from 4 bytes.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI32Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `i32` values.\n *\n * @example\n * Decoding an `i32` value.\n * ```ts\n * const decoder = getI32Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6, 0xff, 0xff, 0xff])); // -42\n * ```\n *\n * @see {@link getI32Codec}\n */\nexport const getI32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getInt32(0, le),\n        name: 'i32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit signed integers (`i32`).\n *\n * This codec serializes `i32` values using 4 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, number, 4>` for encoding and decoding `i32` values.\n *\n * @example\n * Encoding and decoding an `i32` value.\n * ```ts\n * const codec = getI32Codec();\n * const bytes = codec.encode(-42); // 0xd6ffffff\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42); // 0xffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^31` (`-2,147,483,648`) and `2^31 - 1` (`2,147,483,647`).\n *\n * - If you need a smaller signed integer, consider using {@link getI16Codec} or {@link getI8Codec}.\n * - If you need a larger signed integer, consider using {@link getI64Codec}.\n * - If you need unsigned integers, consider using {@link getU32Codec}.\n *\n * Separate {@link getI32Encoder} and {@link getI32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI32Encoder().encode(-42);\n * const value = getI32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI32Encoder}\n * @see {@link getI32Decoder}\n */\nexport const getI32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getI32Encoder(config), getI32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit signed integers (`i64`).\n *\n * This encoder serializes `i64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 8>` for encoding `i64` values.\n *\n * @example\n * Encoding an `i64` value.\n * ```ts\n * const encoder = getI64Encoder();\n * const bytes = encoder.encode(-42n); // 0xd6ffffffffffffff\n * ```\n *\n * @see {@link getI64Codec}\n */\nexport const getI64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'i64',\n        range: [-BigInt('0x7fffffffffffffff') - 1n, BigInt('0x7fffffffffffffff')],\n        set: (view, value, le) => view.setBigInt64(0, BigInt(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit signed integers (`i64`).\n *\n * This decoder deserializes `i64` values from 8 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getI64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 8>` for decoding `i64` values.\n *\n * @example\n * Decoding an `i64` value.\n * ```ts\n * const decoder = getI64Decoder();\n * const value = decoder.decode(new Uint8Array([\n *   0xd6, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff\n * ])); // -42n\n * ```\n *\n * @see {@link getI64Codec}\n */\nexport const getI64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigInt64(0, le),\n        name: 'i64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit signed integers (`i64`).\n *\n * This codec serializes `i64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 8>` for encoding and decoding `i64` values.\n *\n * @example\n * Encoding and decoding an `i64` value.\n * ```ts\n * const codec = getI64Codec();\n * const bytes = codec.encode(-42n); // 0xd6ffffffffffffff\n * const value = codec.decode(bytes); // -42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getI64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(-42n); // 0xffffffffffffffd6\n * ```\n *\n * @remarks\n * This codec supports values between `-2^63` and `2^63 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller signed integer, consider using {@link getI32Codec} or {@link getI16Codec}.\n * - If you need a larger signed integer, consider using {@link getI128Codec}.\n * - If you need unsigned integers, consider using {@link getU64Codec}.\n *\n * Separate {@link getI64Encoder} and {@link getI64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI64Encoder().encode(-42);\n * const value = getI64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI64Encoder}\n * @see {@link getI64Decoder}\n */\nexport const getI64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getI64Encoder(config), getI64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 8-bit signed integers (`i8`).\n *\n * This encoder serializes `i8` values using 1 byte.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getI8Codec}.\n *\n * @returns A `FixedSizeEncoder<number | bigint, 1>` for encoding `i8` values.\n *\n * @example\n * Encoding an `i8` value.\n * ```ts\n * const encoder = getI8Encoder();\n * const bytes = encoder.encode(-42); // 0xd6\n * ```\n *\n * @see {@link getI8Codec}\n */\nexport const getI8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'i8',\n        range: [-Number('0x7f') - 1, Number('0x7f')],\n        set: (view, value) => view.setInt8(0, Number(value)),\n        size: 1,\n    });\n\n/**\n * Returns a decoder for 8-bit signed integers (`i8`).\n *\n * This decoder deserializes `i8` values from 1 byte.\n * The decoded value is always a `number`.\n *\n * For more details, see {@link getI8Codec}.\n *\n * @returns A `FixedSizeDecoder<number, 1>` for decoding `i8` values.\n *\n * @example\n * Decoding an `i8` value.\n * ```ts\n * const decoder = getI8Decoder();\n * const value = decoder.decode(new Uint8Array([0xd6])); // -42\n * ```\n *\n * @see {@link getI8Codec}\n */\nexport const getI8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getInt8(0),\n        name: 'i8',\n        size: 1,\n    });\n\n/**\n * Returns a codec for encoding and decoding 8-bit signed integers (`i8`).\n *\n * This codec serializes `i8` values using 1 byte.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `number`.\n *\n * @returns A `FixedSizeCodec<number | bigint, number, 1>` for encoding and decoding `i8` values.\n *\n * @example\n * Encoding and decoding an `i8` value.\n * ```ts\n * const codec = getI8Codec();\n * const bytes = codec.encode(-42); // 0xd6\n * const value = codec.decode(bytes); // -42\n * ```\n *\n * @remarks\n * This codec supports values between `-2^7` (`-128`) and `2^7 - 1` (`127`).\n *\n * - If you need a larger signed integer, consider using {@link getI16Codec}.\n * - If you need an unsigned integer, consider using {@link getU8Codec}.\n *\n * Separate {@link getI8Encoder} and {@link getI8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getI8Encoder().encode(-42);\n * const value = getI8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getI8Encoder}\n * @see {@link getI8Decoder}\n */\nexport const getI8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getI8Encoder(), getI8Decoder());\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    Offset,\n    ReadonlyUint8Array,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertNumberIsBetweenForCodec } from './assertions';\n\n/**\n * Returns an encoder for `shortU16` values.\n *\n * This encoder serializes `shortU16` values using **1 to 3 bytes**.\n * Smaller values use fewer bytes, while larger values take up more space.\n *\n * For more details, see {@link getShortU16Codec}.\n *\n * @returns A `VariableSizeEncoder<number | bigint>` for encoding `shortU16` values.\n *\n * @example\n * Encoding a `shortU16` value.\n * ```ts\n * const encoder = getShortU16Encoder();\n * encoder.encode(42);    // 0x2a\n * encoder.encode(128);   // 0x8001\n * encoder.encode(16384); // 0x808001\n * ```\n *\n * @see {@link getShortU16Codec}\n */\nexport const getShortU16Encoder = (): VariableSizeEncoder<bigint | number> =>\n    createEncoder({\n        getSizeFromValue: (value: bigint | number): number => {\n            if (value <= 0b01111111) return 1;\n            if (value <= 0b0011111111111111) return 2;\n            return 3;\n        },\n        maxSize: 3,\n        write: (value: bigint | number, bytes: Uint8Array, offset: Offset): Offset => {\n            assertNumberIsBetweenForCodec('shortU16', 0, 65535, value);\n            const shortU16Bytes = [0];\n            for (let ii = 0; ; ii += 1) {\n                // Shift the bits of the value over such that the next 7 bits are at the right edge.\n                const alignedValue = Number(value) >> (ii * 7);\n                if (alignedValue === 0) {\n                    // No more bits to consume.\n                    break;\n                }\n                // Extract those 7 bits using a mask.\n                const nextSevenBits = 0b1111111 & alignedValue;\n                shortU16Bytes[ii] = nextSevenBits;\n                if (ii > 0) {\n                    // Set the continuation bit of the previous slice.\n                    shortU16Bytes[ii - 1] |= 0b10000000;\n                }\n            }\n            bytes.set(shortU16Bytes, offset);\n            return offset + shortU16Bytes.length;\n        },\n    });\n\n/**\n * Returns a decoder for `shortU16` values.\n *\n * This decoder deserializes `shortU16` values from **1 to 3 bytes**.\n * The number of bytes used depends on the encoded value.\n *\n * For more details, see {@link getShortU16Codec}.\n *\n * @returns A `VariableSizeDecoder<number>` for decoding `shortU16` values.\n *\n * @example\n * Decoding a `shortU16` value.\n * ```ts\n * const decoder = getShortU16Decoder();\n * decoder.decode(new Uint8Array([0x2a]));             // 42\n * decoder.decode(new Uint8Array([0x80, 0x01]));       // 128\n * decoder.decode(new Uint8Array([0x80, 0x80, 0x01])); // 16384\n * ```\n *\n * @see {@link getShortU16Codec}\n */\nexport const getShortU16Decoder = (): VariableSizeDecoder<number> =>\n    createDecoder({\n        maxSize: 3,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset): [number, Offset] => {\n            let value = 0;\n            let byteCount = 0;\n            while (++byteCount) {\n                const byteIndex = byteCount - 1;\n                const currentByte = bytes[offset + byteIndex];\n                const nextSevenBits = 0b1111111 & currentByte;\n                // Insert the next group of seven bits into the correct slot of the output value.\n                value |= nextSevenBits << (byteIndex * 7);\n                if ((currentByte & 0b10000000) === 0) {\n                    // This byte does not have its continuation bit set. We're done.\n                    break;\n                }\n            }\n            return [value, offset + byteCount];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding `shortU16` values.\n *\n * It serializes unsigned integers using **1 to 3 bytes** based on the encoded value.\n * The larger the value, the more bytes it uses.\n *\n * - If the value is `<= 0x7f` (127), it is stored in a **single byte**\n *   and the first bit is set to `0` to indicate the end of the value.\n * - Otherwise, the first bit is set to `1` to indicate that the value continues in the next byte, which follows the same pattern.\n * - This process repeats until the value is fully encoded in up to 3 bytes. The third and last byte, if needed, uses all 8 bits to store the remaining value.\n *\n * In other words, the encoding scheme follows this structure:\n *\n * ```txt\n * 0XXXXXXX                   <- Values 0 to 127 (1 byte)\n * 1XXXXXXX 0XXXXXXX          <- Values 128 to 16,383 (2 bytes)\n * 1XXXXXXX 1XXXXXXX XXXXXXXX <- Values 16,384 to 4,194,303 (3 bytes)\n * ```\n *\n * @returns A `VariableSizeCodec<number | bigint, number>` for encoding and decoding `shortU16` values.\n *\n * @example\n * Encoding and decoding `shortU16` values.\n * ```ts\n * const codec = getShortU16Codec();\n * const bytes1 = codec.encode(42);    // 0x2a\n * const bytes2 = codec.encode(128);   // 0x8001\n * const bytes3 = codec.encode(16384); // 0x808001\n *\n * codec.decode(bytes1); // 42\n * codec.decode(bytes2); // 128\n * codec.decode(bytes3); // 16384\n * ```\n *\n * @remarks\n * This codec efficiently stores small numbers, making it useful for transactions and compact representations.\n *\n * If you need a fixed-size `u16` codec, consider using {@link getU16Codec}.\n *\n * Separate {@link getShortU16Encoder} and {@link getShortU16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getShortU16Encoder().encode(42);\n * const value = getShortU16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getShortU16Encoder}\n * @see {@link getShortU16Decoder}\n */\nexport const getShortU16Codec = (): VariableSizeCodec<bigint | number, number> =>\n    combineCodec(getShortU16Encoder(), getShortU16Decoder());\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 128-bit unsigned integers (`u128`).\n *\n * This encoder serializes `u128` values using sixteen bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU128Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<number | bigint, 16>` for encoding `u128` values.\n *\n * @example\n * Encoding a `u128` value.\n * ```ts\n * const encoder = getU128Encoder();\n * const bytes = encoder.encode(42n); // 0x2a000000000000000000000000000000\n * ```\n *\n * @see {@link getU128Codec}\n */\nexport const getU128Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 16> =>\n    numberEncoderFactory({\n        config,\n        name: 'u128',\n        range: [0n, BigInt('0xffffffffffffffffffffffffffffffff')],\n        set: (view, value, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const rightMask = 0xffffffffffffffffn;\n            view.setBigUint64(leftOffset, BigInt(value) >> 64n, le);\n            view.setBigUint64(rightOffset, BigInt(value) & rightMask, le);\n        },\n        size: 16,\n    });\n\n/**\n * Returns a decoder for 128-bit unsigned integers (`u128`).\n *\n * This decoder deserializes `u128` values from sixteen bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU128Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<bigint, 16>` for decoding `u128` values.\n *\n * @example\n * Decoding a `u128` value.\n * ```ts\n * const decoder = getU128Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])); // 42n\n * ```\n *\n * @see {@link getU128Codec}\n */\nexport const getU128Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 16> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => {\n            const leftOffset = le ? 8 : 0;\n            const rightOffset = le ? 0 : 8;\n            const left = view.getBigUint64(leftOffset, le);\n            const right = view.getBigUint64(rightOffset, le);\n            return (left << 64n) + right;\n        },\n        name: 'u128',\n        size: 16,\n    });\n\n/**\n * Returns a codec for encoding and decoding 128-bit unsigned integers (`u128`).\n *\n * This codec serializes `u128` values using 16 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 16>` for encoding and decoding `u128` values.\n *\n * @example\n * Encoding and decoding a `u128` value.\n * ```ts\n * const codec = getU128Codec();\n * const bytes = codec.encode(42); // 0x2a000000000000000000000000000000\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getU128Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x0000000000000000000000000000002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^128 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller unsigned integer, consider using {@link getU64Codec} or {@link getU32Codec}.\n * - If you need signed integers, consider using {@link getI128Codec}.\n *\n * Separate {@link getU128Encoder} and {@link getU128Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU128Encoder().encode(42);\n * const value = getU128Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU128Encoder}\n * @see {@link getU128Decoder}\n */\nexport const getU128Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 16> =>\n    combineCodec(getU128Encoder(config), getU128Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 16-bit unsigned integers (`u16`).\n *\n * This encoder serializes `u16` values using two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU16Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<number | bigint, 2>` for encoding `u16` values.\n *\n * @example\n * Encoding a `u16` value.\n * ```ts\n * const encoder = getU16Encoder();\n * const bytes = encoder.encode(42); // 0x2a00\n * ```\n *\n * @see {@link getU16Codec}\n */\nexport const getU16Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 2> =>\n    numberEncoderFactory({\n        config,\n        name: 'u16',\n        range: [0, Number('0xffff')],\n        set: (view, value, le) => view.setUint16(0, Number(value), le),\n        size: 2,\n    });\n\n/**\n * Returns a decoder for 16-bit unsigned integers (`u16`).\n *\n * This decoder deserializes `u16` values from two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU16Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<number, 2>` for decoding `u16` values.\n *\n * @example\n * Decoding a `u16` value.\n * ```ts\n * const decoder = getU16Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00])); // 42\n * ```\n *\n * @see {@link getU16Codec}\n */\nexport const getU16Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 2> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint16(0, le),\n        name: 'u16',\n        size: 2,\n    });\n\n/**\n * Returns a codec for encoding and decoding 16-bit unsigned integers (`u16`).\n *\n * This codec serializes `u16` values using two bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeCodec<number | bigint, number, 2>` for encoding and decoding `u16` values.\n *\n * @example\n * Encoding and decoding a `u16` value.\n * ```ts\n * const codec = getU16Codec();\n * const bytes = codec.encode(42); // 0x2a00 (little-endian)\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Storing values in big-endian format.\n * ```ts\n * const codec = getU16Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^16 - 1`.\n * If you need a larger range, consider using {@link getU32Codec} or {@link getU64Codec}.\n * For signed integers, use {@link getI16Codec}.\n *\n * Separate {@link getU16Encoder} and {@link getU16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU16Encoder().encode(42);\n * const value = getU16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU16Encoder}\n * @see {@link getU16Decoder}\n */\nexport const getU16Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 2> =>\n    combineCodec(getU16Encoder(config), getU16Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 32-bit unsigned integers (`u32`).\n *\n * This encoder serializes `u32` values using four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU32Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeEncoder<bigint | number, 4>` for encoding `u32` values.\n *\n * @example\n * Encoding a `u32` value.\n * ```ts\n * const encoder = getU32Encoder();\n * const bytes = encoder.encode(42); // 0x2a000000\n * ```\n *\n * @see {@link getU32Codec}\n */\nexport const getU32Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 4> =>\n    numberEncoderFactory({\n        config,\n        name: 'u32',\n        range: [0, Number('0xffffffff')],\n        set: (view, value, le) => view.setUint32(0, Number(value), le),\n        size: 4,\n    });\n\n/**\n * Returns a decoder for 32-bit unsigned integers (`u32`).\n *\n * This decoder deserializes `u32` values from four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * For more details, see {@link getU32Codec}.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeDecoder<number, 4>` for decoding `u32` values.\n *\n * @example\n * Decoding a `u32` value.\n * ```ts\n * const decoder = getU32Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00])); // 42\n * ```\n *\n * @see {@link getU32Codec}\n */\nexport const getU32Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<number, 4> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getUint32(0, le),\n        name: 'u32',\n        size: 4,\n    });\n\n/**\n * Returns a codec for encoding and decoding 32-bit unsigned integers (`u32`).\n *\n * This codec serializes `u32` values using four bytes in little-endian format by default.\n * You may specify big-endian storage using the `endian` option.\n *\n * @param config - Optional settings for endianness.\n * @returns A `FixedSizeCodec<bigint | number, number, 4>` for encoding and decoding `u32` values.\n *\n * @example\n * Encoding and decoding a `u32` value.\n * ```ts\n * const codec = getU32Codec();\n * const bytes = codec.encode(42); // 0x2a000000 (little-endian)\n * const value = codec.decode(bytes); // 42\n * ```\n *\n * @example\n * Storing values in big-endian format.\n * ```ts\n * const codec = getU32Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x0000002a\n * ```\n *\n * @remarks\n * This codec only supports values between `0` and `2^32 - 1`.\n * If you need a larger range, consider using {@link getU64Codec} or {@link getU128Codec}.\n * For signed integers, use {@link getI32Codec}.\n *\n * Separate {@link getU32Encoder} and {@link getU32Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU32Encoder().encode(42);\n * const value = getU32Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU32Encoder}\n * @see {@link getU32Decoder}\n */\nexport const getU32Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, number, 4> =>\n    combineCodec(getU32Encoder(config), getU32Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { NumberCodecConfig } from './common';\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 64-bit unsigned integers (`u64`).\n *\n * This encoder serializes `u64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`.\n *\n * For more details, see {@link getU64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeEncoder<number | bigint, 8>` for encoding `u64` values.\n *\n * @example\n * Encoding a `u64` value.\n * ```ts\n * const encoder = getU64Encoder();\n * const bytes = encoder.encode(42); // 0x2a00000000000000\n * ```\n *\n * @see {@link getU64Codec}\n */\nexport const getU64Encoder = (config: NumberCodecConfig = {}): FixedSizeEncoder<bigint | number, 8> =>\n    numberEncoderFactory({\n        config,\n        name: 'u64',\n        range: [0n, BigInt('0xffffffffffffffff')],\n        set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),\n        size: 8,\n    });\n\n/**\n * Returns a decoder for 64-bit unsigned integers (`u64`).\n *\n * This decoder deserializes `u64` values from 8 bytes.\n * The decoded value is always a `bigint`.\n *\n * For more details, see {@link getU64Codec}.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeDecoder<bigint, 8>` for decoding `u64` values.\n *\n * @example\n * Decoding a `u64` value.\n * ```ts\n * const decoder = getU64Decoder();\n * const value = decoder.decode(new Uint8Array([0x2a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00])); // 42n\n * ```\n *\n * @see {@link getU64Codec}\n */\nexport const getU64Decoder = (config: NumberCodecConfig = {}): FixedSizeDecoder<bigint, 8> =>\n    numberDecoderFactory({\n        config,\n        get: (view, le) => view.getBigUint64(0, le),\n        name: 'u64',\n        size: 8,\n    });\n\n/**\n * Returns a codec for encoding and decoding 64-bit unsigned integers (`u64`).\n *\n * This codec serializes `u64` values using 8 bytes.\n * Values can be provided as either `number` or `bigint`, but the decoded value is always a `bigint`.\n *\n * @param config - Optional configuration to specify endianness (little by default).\n * @returns A `FixedSizeCodec<number | bigint, bigint, 8>` for encoding and decoding `u64` values.\n *\n * @example\n * Encoding and decoding a `u64` value.\n * ```ts\n * const codec = getU64Codec();\n * const bytes = codec.encode(42); // 0x2a00000000000000\n * const value = codec.decode(bytes); // 42n\n * ```\n *\n * @example\n * Using big-endian encoding.\n * ```ts\n * const codec = getU64Codec({ endian: Endian.Big });\n * const bytes = codec.encode(42); // 0x000000000000002a\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^64 - 1`.\n * Since JavaScript `number` cannot safely represent values beyond `2^53 - 1`, the decoded value is always a `bigint`.\n *\n * - If you need a smaller unsigned integer, consider using {@link getU32Codec} or {@link getU16Codec}.\n * - If you need a larger unsigned integer, consider using {@link getU128Codec}.\n * - If you need signed integers, consider using {@link getI64Codec}.\n *\n * Separate {@link getU64Encoder} and {@link getU64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU64Encoder().encode(42);\n * const value = getU64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU64Encoder}\n * @see {@link getU64Decoder}\n */\nexport const getU64Codec = (config: NumberCodecConfig = {}): FixedSizeCodec<bigint | number, bigint, 8> =>\n    combineCodec(getU64Encoder(config), getU64Decoder(config));\n","import { combineCodec, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\n\nimport { numberDecoderFactory, numberEncoderFactory } from './utils';\n\n/**\n * Returns an encoder for 8-bit unsigned integers (`u8`).\n *\n * This encoder serializes `u8` values using a single byte.\n *\n * For more details, see {@link getU8Codec}.\n *\n * @returns A `FixedSizeEncoder<number | bigint, 1>` for encoding `u8` values.\n *\n * @example\n * Encoding a `u8` value.\n * ```ts\n * const encoder = getU8Encoder();\n * const bytes = encoder.encode(42); // 0x2a\n * ```\n *\n * @see {@link getU8Codec}\n */\nexport const getU8Encoder = (): FixedSizeEncoder<bigint | number, 1> =>\n    numberEncoderFactory({\n        name: 'u8',\n        range: [0, Number('0xff')],\n        set: (view, value) => view.setUint8(0, Number(value)),\n        size: 1,\n    });\n\n/**\n * Returns a decoder for 8-bit unsigned integers (`u8`).\n *\n * This decoder deserializes `u8` values from a single byte.\n *\n * For more details, see {@link getU8Codec}.\n *\n * @returns A `FixedSizeDecoder<number, 1>` for decoding `u8` values.\n *\n * @example\n * Decoding a `u8` value.\n * ```ts\n * const decoder = getU8Decoder();\n * const value = decoder.decode(new Uint8Array([0xff])); // 255\n * ```\n *\n * @see {@link getU8Codec}\n */\nexport const getU8Decoder = (): FixedSizeDecoder<number, 1> =>\n    numberDecoderFactory({\n        get: view => view.getUint8(0),\n        name: 'u8',\n        size: 1,\n    });\n\n/**\n * Returns a codec for encoding and decoding 8-bit unsigned integers (`u8`).\n *\n * This codec serializes `u8` values using a single byte.\n *\n * @returns A `FixedSizeCodec<number | bigint, number, 1>` for encoding and decoding `u8` values.\n *\n * @example\n * Encoding and decoding a `u8` value.\n * ```ts\n * const codec = getU8Codec();\n * const bytes = codec.encode(255); // 0xff\n * const value = codec.decode(bytes); // 255\n * ```\n *\n * @remarks\n * This codec supports values between `0` and `2^8 - 1` (0 to 255).\n * If you need larger integers, consider using {@link getU16Codec}, {@link getU32Codec}, or {@link getU64Codec}.\n * For signed integers, use {@link getI8Codec}.\n *\n * Separate {@link getU8Encoder} and {@link getU8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getU8Encoder().encode(42);\n * const value = getU8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getU8Encoder}\n * @see {@link getU8Decoder}\n */\nexport const getU8Codec = (): FixedSizeCodec<bigint | number, number, 1> =>\n    combineCodec(getU8Encoder(), getU8Decoder());\n","import { transformEncoder, fixEncoderSize, fixDecoderSize, combineCodec } from '@solana/codecs-core';\nimport { getBase58Encoder, getBase58Decoder } from '@solana/codecs-strings';\nimport { SolanaError, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH, SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS, SOLANA_ERROR__ADDRESSES__MALFORMED_PDA, SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE, isSolanaError, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE, SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED, SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER, SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY, SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED } from '@solana/errors';\nimport { assertKeyExporterIsAvailable, assertDigestCapabilityIsAvailable } from '@solana/assertions';\n\n// src/address.ts\nvar memoizedBase58Encoder;\nvar memoizedBase58Decoder;\nfunction getMemoizedBase58Encoder() {\n  if (!memoizedBase58Encoder) memoizedBase58Encoder = getBase58Encoder();\n  return memoizedBase58Encoder;\n}\nfunction getMemoizedBase58Decoder() {\n  if (!memoizedBase58Decoder) memoizedBase58Decoder = getBase58Decoder();\n  return memoizedBase58Decoder;\n}\nfunction isAddress(putativeAddress) {\n  if (\n    // Lowest address (32 bytes of zeroes)\n    putativeAddress.length < 32 || // Highest address (32 bytes of 255)\n    putativeAddress.length > 44\n  ) {\n    return false;\n  }\n  const base58Encoder = getMemoizedBase58Encoder();\n  try {\n    return base58Encoder.encode(putativeAddress).byteLength === 32;\n  } catch {\n    return false;\n  }\n}\nfunction assertIsAddress(putativeAddress) {\n  if (\n    // Lowest address (32 bytes of zeroes)\n    putativeAddress.length < 32 || // Highest address (32 bytes of 255)\n    putativeAddress.length > 44\n  ) {\n    throw new SolanaError(SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE, {\n      actualLength: putativeAddress.length\n    });\n  }\n  const base58Encoder = getMemoizedBase58Encoder();\n  const bytes = base58Encoder.encode(putativeAddress);\n  const numBytes = bytes.byteLength;\n  if (numBytes !== 32) {\n    throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH, {\n      actualLength: numBytes\n    });\n  }\n}\nfunction address(putativeAddress) {\n  assertIsAddress(putativeAddress);\n  return putativeAddress;\n}\nfunction getAddressEncoder() {\n  return transformEncoder(\n    fixEncoderSize(getMemoizedBase58Encoder(), 32),\n    (putativeAddress) => address(putativeAddress)\n  );\n}\nfunction getAddressDecoder() {\n  return fixDecoderSize(getMemoizedBase58Decoder(), 32);\n}\nfunction getAddressCodec() {\n  return combineCodec(getAddressEncoder(), getAddressDecoder());\n}\nfunction getAddressComparator() {\n  return new Intl.Collator(\"en\", {\n    caseFirst: \"lower\",\n    ignorePunctuation: false,\n    localeMatcher: \"best fit\",\n    numeric: false,\n    sensitivity: \"variant\",\n    usage: \"sort\"\n  }).compare;\n}\n\n// src/vendor/noble/ed25519.ts\nvar D = 37095705934669439343138083508754565189542113879843219016388785533085940283555n;\nvar P = 57896044618658097711785492504343953926634992332820282019728792003956564819949n;\nvar RM1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n;\nfunction mod(a) {\n  const r = a % P;\n  return r >= 0n ? r : P + r;\n}\nfunction pow2(x, power) {\n  let r = x;\n  while (power-- > 0n) {\n    r *= r;\n    r %= P;\n  }\n  return r;\n}\nfunction pow_2_252_3(x) {\n  const x2 = x * x % P;\n  const b2 = x2 * x % P;\n  const b4 = pow2(b2, 2n) * b2 % P;\n  const b5 = pow2(b4, 1n) * x % P;\n  const b10 = pow2(b5, 5n) * b5 % P;\n  const b20 = pow2(b10, 10n) * b10 % P;\n  const b40 = pow2(b20, 20n) * b20 % P;\n  const b80 = pow2(b40, 40n) * b40 % P;\n  const b160 = pow2(b80, 80n) * b80 % P;\n  const b240 = pow2(b160, 80n) * b80 % P;\n  const b250 = pow2(b240, 10n) * b10 % P;\n  const pow_p_5_8 = pow2(b250, 2n) * x % P;\n  return pow_p_5_8;\n}\nfunction uvRatio(u, v) {\n  const v3 = mod(v * v * v);\n  const v7 = mod(v3 * v3 * v);\n  const pow = pow_2_252_3(u * v7);\n  let x = mod(u * v3 * pow);\n  const vx2 = mod(v * x * x);\n  const root1 = x;\n  const root2 = mod(x * RM1);\n  const useRoot1 = vx2 === u;\n  const useRoot2 = vx2 === mod(-u);\n  const noRoot = vx2 === mod(-u * RM1);\n  if (useRoot1) x = root1;\n  if (useRoot2 || noRoot) x = root2;\n  if ((mod(x) & 1n) === 1n) x = mod(-x);\n  if (!useRoot1 && !useRoot2) {\n    return null;\n  }\n  return x;\n}\nfunction pointIsOnCurve(y, lastByte) {\n  const y2 = mod(y * y);\n  const u = mod(y2 - 1n);\n  const v = mod(D * y2 + 1n);\n  const x = uvRatio(u, v);\n  if (x === null) {\n    return false;\n  }\n  const isLastByteOdd = (lastByte & 128) !== 0;\n  if (x === 0n && isLastByteOdd) {\n    return false;\n  }\n  return true;\n}\n\n// src/curve-internal.ts\nfunction byteToHex(byte) {\n  const hexString = byte.toString(16);\n  if (hexString.length === 1) {\n    return `0${hexString}`;\n  } else {\n    return hexString;\n  }\n}\nfunction decompressPointBytes(bytes) {\n  const hexString = bytes.reduce((acc, byte, ii) => `${byteToHex(ii === 31 ? byte & -129 : byte)}${acc}`, \"\");\n  const integerLiteralString = `0x${hexString}`;\n  return BigInt(integerLiteralString);\n}\nfunction compressedPointBytesAreOnCurve(bytes) {\n  if (bytes.byteLength !== 32) {\n    return false;\n  }\n  const y = decompressPointBytes(bytes);\n  return pointIsOnCurve(y, bytes[31]);\n}\n\n// src/curve.ts\nfunction isOffCurveAddress(putativeOffCurveAddress) {\n  const addressBytes = getAddressCodec().encode(putativeOffCurveAddress);\n  return compressedPointBytesAreOnCurve(addressBytes) === false;\n}\nfunction assertIsOffCurveAddress(putativeOffCurveAddress) {\n  if (!isOffCurveAddress(putativeOffCurveAddress)) {\n    throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS);\n  }\n}\nfunction offCurveAddress(putativeOffCurveAddress) {\n  assertIsOffCurveAddress(putativeOffCurveAddress);\n  return putativeOffCurveAddress;\n}\nfunction isProgramDerivedAddress(value) {\n  return Array.isArray(value) && value.length === 2 && typeof value[0] === \"string\" && typeof value[1] === \"number\" && value[1] >= 0 && value[1] <= 255 && isAddress(value[0]);\n}\nfunction assertIsProgramDerivedAddress(value) {\n  const validFormat = Array.isArray(value) && value.length === 2 && typeof value[0] === \"string\" && typeof value[1] === \"number\";\n  if (!validFormat) {\n    throw new SolanaError(SOLANA_ERROR__ADDRESSES__MALFORMED_PDA);\n  }\n  if (value[1] < 0 || value[1] > 255) {\n    throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE, {\n      bump: value[1]\n    });\n  }\n  assertIsAddress(value[0]);\n}\nvar MAX_SEED_LENGTH = 32;\nvar MAX_SEEDS = 16;\nvar PDA_MARKER_BYTES = [\n  // The string 'ProgramDerivedAddress'\n  80,\n  114,\n  111,\n  103,\n  114,\n  97,\n  109,\n  68,\n  101,\n  114,\n  105,\n  118,\n  101,\n  100,\n  65,\n  100,\n  100,\n  114,\n  101,\n  115,\n  115\n];\nasync function createProgramDerivedAddress({ programAddress, seeds }) {\n  assertDigestCapabilityIsAvailable();\n  if (seeds.length > MAX_SEEDS) {\n    throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED, {\n      actual: seeds.length,\n      maxSeeds: MAX_SEEDS\n    });\n  }\n  let textEncoder;\n  const seedBytes = seeds.reduce((acc, seed, ii) => {\n    const bytes = typeof seed === \"string\" ? (textEncoder ||= new TextEncoder()).encode(seed) : seed;\n    if (bytes.byteLength > MAX_SEED_LENGTH) {\n      throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n        actual: bytes.byteLength,\n        index: ii,\n        maxSeedLength: MAX_SEED_LENGTH\n      });\n    }\n    acc.push(...bytes);\n    return acc;\n  }, []);\n  const base58EncodedAddressCodec = getAddressCodec();\n  const programAddressBytes = base58EncodedAddressCodec.encode(programAddress);\n  const addressBytesBuffer = await crypto.subtle.digest(\n    \"SHA-256\",\n    new Uint8Array([...seedBytes, ...programAddressBytes, ...PDA_MARKER_BYTES])\n  );\n  const addressBytes = new Uint8Array(addressBytesBuffer);\n  if (compressedPointBytesAreOnCurve(addressBytes)) {\n    throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE);\n  }\n  return base58EncodedAddressCodec.decode(addressBytes);\n}\nasync function getProgramDerivedAddress({\n  programAddress,\n  seeds\n}) {\n  let bumpSeed = 255;\n  while (bumpSeed > 0) {\n    try {\n      const address2 = await createProgramDerivedAddress({\n        programAddress,\n        seeds: [...seeds, new Uint8Array([bumpSeed])]\n      });\n      return [address2, bumpSeed];\n    } catch (e) {\n      if (isSolanaError(e, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE)) {\n        bumpSeed--;\n      } else {\n        throw e;\n      }\n    }\n  }\n  throw new SolanaError(SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED);\n}\nasync function createAddressWithSeed({ baseAddress, programAddress, seed }) {\n  const { encode, decode } = getAddressCodec();\n  const seedBytes = typeof seed === \"string\" ? new TextEncoder().encode(seed) : seed;\n  if (seedBytes.byteLength > MAX_SEED_LENGTH) {\n    throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n      actual: seedBytes.byteLength,\n      index: 0,\n      maxSeedLength: MAX_SEED_LENGTH\n    });\n  }\n  const programAddressBytes = encode(programAddress);\n  if (programAddressBytes.length >= PDA_MARKER_BYTES.length && programAddressBytes.slice(-PDA_MARKER_BYTES.length).every((byte, index) => byte === PDA_MARKER_BYTES[index])) {\n    throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER);\n  }\n  const addressBytesBuffer = await crypto.subtle.digest(\n    \"SHA-256\",\n    new Uint8Array([...encode(baseAddress), ...seedBytes, ...programAddressBytes])\n  );\n  const addressBytes = new Uint8Array(addressBytesBuffer);\n  return decode(addressBytes);\n}\nasync function getAddressFromPublicKey(publicKey) {\n  assertKeyExporterIsAvailable();\n  if (publicKey.type !== \"public\" || publicKey.algorithm.name !== \"Ed25519\") {\n    throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY);\n  }\n  const publicKeyBytes = await crypto.subtle.exportKey(\"raw\", publicKey);\n  return getAddressDecoder().decode(new Uint8Array(publicKeyBytes));\n}\nasync function getPublicKeyFromAddress(address2) {\n  const addressBytes = getAddressEncoder().encode(address2);\n  return await crypto.subtle.importKey(\"raw\", addressBytes, { name: \"Ed25519\" }, true, [\"verify\"]);\n}\n\nexport { address, assertIsAddress, assertIsOffCurveAddress, assertIsProgramDerivedAddress, createAddressWithSeed, getAddressCodec, getAddressComparator, getAddressDecoder, getAddressEncoder, getAddressFromPublicKey, getProgramDerivedAddress, getPublicKeyFromAddress, isAddress, isOffCurveAddress, isProgramDerivedAddress, offCurveAddress };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","import {\n    combineCodec,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    transformEncoder,\n} from '@solana/codecs-core';\nimport { getBase58Decoder, getBase58Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\n/**\n * Represents a string that validates as a Solana address. Functions that require well-formed\n * addresses should specify their inputs in terms of this type.\n *\n * Whenever you need to validate an arbitrary string as a base58-encoded address, use the\n * {@link address}, {@link assertIsAddress}, or {@link isAddress} functions in this package.\n */\nexport type Address<TAddress extends string = string> = Brand<EncodedString<TAddress, 'base58'>, 'Address'>;\n\nlet memoizedBase58Encoder: Encoder<string> | undefined;\nlet memoizedBase58Decoder: Decoder<string> | undefined;\n\nfunction getMemoizedBase58Encoder(): Encoder<string> {\n    if (!memoizedBase58Encoder) memoizedBase58Encoder = getBase58Encoder();\n    return memoizedBase58Encoder;\n}\n\nfunction getMemoizedBase58Decoder(): Decoder<string> {\n    if (!memoizedBase58Decoder) memoizedBase58Decoder = getBase58Decoder();\n    return memoizedBase58Decoder;\n}\n\n/**\n * A type guard that returns `true` if the input string conforms to the {@link Address} type, and\n * refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isAddress } from '@solana/addresses';\n *\n * if (isAddress(ownerAddress)) {\n *     // At this point, `ownerAddress` has been refined to a\n *     // `Address` that can be used with the RPC.\n *     const { value: lamports } = await rpc.getBalance(ownerAddress).send();\n *     setBalanceLamports(lamports);\n * } else {\n *     setError(`${ownerAddress} is not an address`);\n * }\n * ```\n */\nexport function isAddress(putativeAddress: string): putativeAddress is Address<typeof putativeAddress> {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest address (32 bytes of zeroes)\n        putativeAddress.length < 32 ||\n        // Highest address (32 bytes of 255)\n        putativeAddress.length > 44\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    try {\n        return base58Encoder.encode(putativeAddress).byteLength === 32;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * From time to time you might acquire a string, that you expect to validate as an address or public\n * key, from an untrusted network API or user input. Use this function to assert that such an\n * arbitrary string is a base58-encoded address.\n *\n * @example\n * ```ts\n * import { assertIsAddress } from '@solana/addresses';\n *\n * // Imagine a function that fetches an account's balance when a user submits a form.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const address: string = accountAddressInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `address` to `Address`.\n *         assertIsAddress(address);\n *         // At this point, `address` is an `Address` that can be used with the RPC.\n *         const balanceInLamports = await rpc.getBalance(address).send();\n *     } catch (e) {\n *         // `address` turned out not to be a base58-encoded address\n *     }\n * }\n * ```\n */\nexport function assertIsAddress(putativeAddress: string): asserts putativeAddress is Address<typeof putativeAddress> {\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest address (32 bytes of zeroes)\n        putativeAddress.length < 32 ||\n        // Highest address (32 bytes of 255)\n        putativeAddress.length > 44\n    ) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeAddress.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const base58Encoder = getMemoizedBase58Encoder();\n    const bytes = base58Encoder.encode(putativeAddress);\n    const numBytes = bytes.byteLength;\n    if (numBytes !== 32) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\n/**\n * Combines _asserting_ that a string is an address with _coercing_ it to the {@link Address} type.\n * It's most useful with untrusted input.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n *\n * await transfer(address(fromAddress), address(toAddress), lamports(100000n));\n * ```\n *\n * > [!TIP]\n * > When starting from a known-good address as a string, it's more efficient to typecast it rather\n * than to use the {@link address} helper, because the helper unconditionally performs validation on\n * its input.\n * >\n * > ```ts\n * > import { Address } from '@solana/addresses';\n * >\n * > const MEMO_PROGRAM_ADDRESS =\n * >     'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr' as Address<'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'>;\n * > ```\n */\nexport function address<TAddress extends string = string>(putativeAddress: TAddress): Address<TAddress> {\n    assertIsAddress(putativeAddress);\n    return putativeAddress as Address<TAddress>;\n}\n\n/**\n * Returns an encoder that you can use to encode a base58-encoded address to a byte array.\n *\n * @example\n * ```ts\n * import { getAddressEncoder } from '@solana/addresses';\n *\n * const address = 'B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka' as Address;\n * const addressEncoder = getAddressEncoder();\n * const addressBytes = addressEncoder.encode(address);\n * // Uint8Array(32) [\n * //   150, 183, 190,  48, 171,   8, 39, 156,\n * //   122, 213, 172, 108, 193,  95, 26, 158,\n * //   149, 243, 115, 254,  20, 200, 36,  30,\n * //   248, 179, 178, 232, 220,  89, 53, 127\n * // ]\n * ```\n */\nexport function getAddressEncoder(): FixedSizeEncoder<Address, 32> {\n    return transformEncoder(fixEncoderSize(getMemoizedBase58Encoder(), 32), putativeAddress =>\n        address(putativeAddress),\n    );\n}\n\n/**\n * Returns a decoder that you can use to convert an array of 32 bytes representing an address to the\n * base58-encoded representation of that address.\n *\n * @example\n * ```ts\n * import { getAddressDecoder } from '@solana/addresses';\n *\n * const addressBytes = new Uint8Array([\n *     150, 183, 190,  48, 171,   8, 39, 156,\n *     122, 213, 172, 108, 193,  95, 26, 158,\n *     149, 243, 115, 254,  20, 200, 36,  30,\n *     248, 179, 178, 232, 220,  89, 53, 127\n * ]);\n * const addressDecoder = getAddressDecoder();\n * const address = addressDecoder.decode(addressBytes); // B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka\n * ```\n */\nexport function getAddressDecoder(): FixedSizeDecoder<Address, 32> {\n    return fixDecoderSize(getMemoizedBase58Decoder(), 32) as FixedSizeDecoder<Address, 32>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a base-58 encoded address.\n *\n * @see {@link getAddressDecoder}\n * @see {@link getAddressEncoder}\n */\nexport function getAddressCodec(): FixedSizeCodec<Address, Address, 32> {\n    return combineCodec(getAddressEncoder(), getAddressDecoder());\n}\n\nexport function getAddressComparator(): (x: string, y: string) => number {\n    return new Intl.Collator('en', {\n        caseFirst: 'lower',\n        ignorePunctuation: false,\n        localeMatcher: 'best fit',\n        numeric: false,\n        sensitivity: 'variant',\n        usage: 'sort',\n    }).compare;\n}\n","/**!\n * noble-ed25519\n *\n * The MIT License (MIT)\n *\n * Copyright (c) 2019 Paul Miller (https://paulmillr.com)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the Software), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\nconst D = 37095705934669439343138083508754565189542113879843219016388785533085940283555n;\nconst P = 57896044618658097711785492504343953926634992332820282019728792003956564819949n; // 2n ** 255n - 19n;  ed25519 is twisted edwards curve\nconst RM1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n; // -1\n\n// mod division\nfunction mod(a: bigint): bigint {\n    const r = a % P;\n    return r >= 0n ? r : P + r;\n}\nfunction pow2(x: bigint, power: bigint): bigint {\n    // pow2(x, 4) == x^(2^4)\n    let r = x;\n    while (power-- > 0n) {\n        r *= r;\n        r %= P;\n    }\n    return r;\n}\nfunction pow_2_252_3(x: bigint): bigint {\n    // x^(2^252-3) unrolled util for square root\n    const x2 = (x * x) % P; // x^2,       bits 1\n    const b2 = (x2 * x) % P; // x^3,       bits 11\n    const b4 = (pow2(b2, 2n) * b2) % P; // x^(2^4-1), bits 1111\n    const b5 = (pow2(b4, 1n) * x) % P; // x^(2^5-1), bits 11111\n    const b10 = (pow2(b5, 5n) * b5) % P; // x^(2^10)\n    const b20 = (pow2(b10, 10n) * b10) % P; // x^(2^20)\n    const b40 = (pow2(b20, 20n) * b20) % P; // x^(2^40)\n    const b80 = (pow2(b40, 40n) * b40) % P; // x^(2^80)\n    const b160 = (pow2(b80, 80n) * b80) % P; // x^(2^160)\n    const b240 = (pow2(b160, 80n) * b80) % P; // x^(2^240)\n    const b250 = (pow2(b240, 10n) * b10) % P; // x^(2^250)\n    const pow_p_5_8 = (pow2(b250, 2n) * x) % P; // < To pow to (p+3)/8, multiply it by x.\n    return pow_p_5_8;\n}\nfunction uvRatio(u: bigint, v: bigint): bigint | null {\n    // for sqrt comp\n    const v3 = mod(v * v * v); // v\n    const v7 = mod(v3 * v3 * v); // v\n    const pow = pow_2_252_3(u * v7); // (uv)^(p-5)/8\n    let x = mod(u * v3 * pow); // (uv)(uv)^(p-5)/8\n    const vx2 = mod(v * x * x); // vx\n    const root1 = x; // First root candidate\n    const root2 = mod(x * RM1); // Second root candidate; RM1 is -1\n    const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root\n    const useRoot2 = vx2 === mod(-u); // If vx = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === mod(-u * RM1); // There is no valid root, vx = -u-1\n    if (useRoot1) x = root1;\n    if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n    if ((mod(x) & 1n) === 1n) x = mod(-x); // edIsNegative\n    if (!useRoot1 && !useRoot2) {\n        return null;\n    }\n    return x;\n}\n// https://datatracker.ietf.org/doc/html/rfc8032#section-5.1.3\nexport function pointIsOnCurve(y: bigint, lastByte: number): boolean {\n    const y2 = mod(y * y); // y\n    const u = mod(y2 - 1n); // u=y-1\n    const v = mod(D * y2 + 1n);\n    const x = uvRatio(u, v); // (uv)(uv)^(p-5)/8; square root\n    if (x === null) {\n        return false;\n    }\n    const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n    if (x === 0n && isLastByteOdd) {\n        return false;\n    }\n    return true;\n}\n","import { ReadonlyUint8Array } from '@solana/codecs-core';\n\nimport { pointIsOnCurve } from './vendor/noble/ed25519';\n\nfunction byteToHex(byte: number): string {\n    const hexString = byte.toString(16);\n    if (hexString.length === 1) {\n        return `0${hexString}`;\n    } else {\n        return hexString;\n    }\n}\n\nfunction decompressPointBytes(bytes: ReadonlyUint8Array): bigint {\n    const hexString = bytes.reduce((acc, byte, ii) => `${byteToHex(ii === 31 ? byte & ~0x80 : byte)}${acc}`, '');\n    const integerLiteralString = `0x${hexString}`;\n    return BigInt(integerLiteralString);\n}\n\nexport function compressedPointBytesAreOnCurve(bytes: ReadonlyUint8Array): boolean {\n    if (bytes.byteLength !== 32) {\n        return false;\n    }\n    const y = decompressPointBytes(bytes);\n    return pointIsOnCurve(y, bytes[31]);\n}\n","import { SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS, SolanaError } from '@solana/errors';\nimport type { AffinePoint } from '@solana/nominal-types';\n\nimport { type Address, getAddressCodec } from './address';\nimport { compressedPointBytesAreOnCurve } from './curve-internal';\n\n/**\n * Represents an {@link Address} that validates as being off-curve. Functions that require off-curve\n * addresses should specify their inputs in terms of this type.\n *\n * Whenever you need to validate an address as being off-curve, use the {@link offCurveAddress},\n * {@link assertIsOffCurveAddress}, or {@link isOffCurveAddress} functions in this package.\n */\nexport type OffCurveAddress<TAddress extends string = string> = AffinePoint<Address<TAddress>, 'invalid'>;\n\n/**\n * A type guard that returns `true` if the input address conforms to the {@link OffCurveAddress}\n * type, and refines its type for use in your application.\n *\n * @example\n * ```ts\n * import { isOffCurveAddress } from '@solana/addresses';\n *\n * if (isOffCurveAddress(accountAddress)) {\n *     // At this point, `accountAddress` has been refined to a\n *     // `OffCurveAddress` that can be used within your business logic.\n *     const { value: account } = await rpc.getAccountInfo(accountAddress).send();\n * } else {\n *     setError(`${accountAddress} is not off-curve`);\n * }\n * ```\n */\nexport function isOffCurveAddress<TAddress extends Address>(\n    putativeOffCurveAddress: TAddress,\n): putativeOffCurveAddress is OffCurveAddress<TAddress> {\n    const addressBytes = getAddressCodec().encode(putativeOffCurveAddress);\n    return compressedPointBytesAreOnCurve(addressBytes) === false;\n}\n\n/**\n * From time to time you might acquire an {@link Address}, that you expect to validate as an\n * off-curve address, from an untrusted source. Use this function to assert that such an address is\n * off-curve.\n *\n * @example\n * ```ts\n * import { assertIsOffCurveAddress } from '@solana/addresses';\n *\n * // Imagine a function that fetches an account's balance when a user submits a form.\n * function handleSubmit() {\n *     // We know only that the input conforms to the `string` type.\n *     const address: string = accountAddressInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `address` to `Address`.\n *         assertIsAddress(address);\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `address` to `OffCurveAddress`.\n *         assertIsOffCurveAddress(address);\n *         // At this point, `address` is an `OffCurveAddress` that can be used with the RPC.\n *         const balanceInLamports = await rpc.getBalance(address).send();\n *     } catch (e) {\n *         // `address` turned out to NOT be a base58-encoded off-curve address\n *     }\n * }\n * ```\n */\nexport function assertIsOffCurveAddress<TAddress extends Address>(\n    putativeOffCurveAddress: TAddress,\n): asserts putativeOffCurveAddress is OffCurveAddress<TAddress> {\n    if (!isOffCurveAddress(putativeOffCurveAddress)) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS);\n    }\n}\n\n/**\n * Combines _asserting_ that an {@link Address} is off-curve with _coercing_ it to the\n * {@link OffCurveAddress} type. It's most useful with untrusted input.\n */\nexport function offCurveAddress<TAddress extends Address>(\n    putativeOffCurveAddress: TAddress,\n): OffCurveAddress<TAddress> {\n    assertIsOffCurveAddress(putativeOffCurveAddress);\n    return putativeOffCurveAddress;\n}\n","import { assertDigestCapabilityIsAvailable } from '@solana/assertions';\nimport type { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED,\n    SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE,\n    SOLANA_ERROR__ADDRESSES__MALFORMED_PDA,\n    SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED,\n    SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE,\n    SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\nimport { Address, assertIsAddress, getAddressCodec, isAddress } from './address';\nimport { compressedPointBytesAreOnCurve } from './curve-internal';\n\n/**\n * A tuple representing a program derived address (derived from the address of some program and a\n * set of seeds) and the associated bump seed used to ensure that the address, as derived, does not\n * fall on the Ed25519 curve.\n *\n * Whenever you need to validate an arbitrary tuple as one that represents a program derived\n * address, use the {@link assertIsProgramDerivedAddress} or {@link isProgramDerivedAddress}\n * functions in this package.\n */\nexport type ProgramDerivedAddress<TAddress extends string = string> = Readonly<\n    [Address<TAddress>, ProgramDerivedAddressBump]\n>;\n\n/**\n * Represents an integer in the range [0,255] used in the derivation of a program derived address to\n * ensure that it does not fall on the Ed25519 curve.\n */\nexport type ProgramDerivedAddressBump = Brand<number, 'ProgramDerivedAddressBump'>;\n\n/**\n * A type guard that returns `true` if the input tuple conforms to the {@link ProgramDerivedAddress}\n * type, and refines its type for use in your program.\n *\n * @see The {@link isAddress} function for an example of how to use a type guard.\n */\nexport function isProgramDerivedAddress<TAddress extends string = string>(\n    value: unknown,\n): value is ProgramDerivedAddress<TAddress> {\n    return (\n        Array.isArray(value) &&\n        value.length === 2 &&\n        typeof value[0] === 'string' &&\n        typeof value[1] === 'number' &&\n        value[1] >= 0 &&\n        value[1] <= 255 &&\n        isAddress(value[0])\n    );\n}\n\n/**\n * In the event that you receive an address/bump-seed tuple from some untrusted source, use this\n * function to assert that it conforms to the {@link ProgramDerivedAddress} interface.\n *\n * @see The {@link assertIsAddress} function for an example of how to use an assertion function.\n */\nexport function assertIsProgramDerivedAddress<TAddress extends string = string>(\n    value: unknown,\n): asserts value is ProgramDerivedAddress<TAddress> {\n    const validFormat =\n        Array.isArray(value) && value.length === 2 && typeof value[0] === 'string' && typeof value[1] === 'number';\n    if (!validFormat) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MALFORMED_PDA);\n    }\n    if (value[1] < 0 || value[1] > 255) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE, {\n            bump: value[1],\n        });\n    }\n    assertIsAddress(value[0]);\n}\n\ntype ProgramDerivedAddressInput = Readonly<{\n    programAddress: Address;\n    seeds: Seed[];\n}>;\n\ntype SeedInput = Readonly<{\n    baseAddress: Address;\n    programAddress: Address;\n    seed: Seed;\n}>;\n\ntype Seed = ReadonlyUint8Array | string;\n\nconst MAX_SEED_LENGTH = 32;\nconst MAX_SEEDS = 16;\nconst PDA_MARKER_BYTES = [\n    // The string 'ProgramDerivedAddress'\n    80, 114, 111, 103, 114, 97, 109, 68, 101, 114, 105, 118, 101, 100, 65, 100, 100, 114, 101, 115, 115,\n] as const;\n\nasync function createProgramDerivedAddress({ programAddress, seeds }: ProgramDerivedAddressInput): Promise<Address> {\n    assertDigestCapabilityIsAvailable();\n    if (seeds.length > MAX_SEEDS) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED, {\n            actual: seeds.length,\n            maxSeeds: MAX_SEEDS,\n        });\n    }\n    let textEncoder: TextEncoder;\n    const seedBytes = seeds.reduce((acc, seed, ii) => {\n        const bytes = typeof seed === 'string' ? (textEncoder ||= new TextEncoder()).encode(seed) : seed;\n        if (bytes.byteLength > MAX_SEED_LENGTH) {\n            throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n                actual: bytes.byteLength,\n                index: ii,\n                maxSeedLength: MAX_SEED_LENGTH,\n            });\n        }\n        acc.push(...bytes);\n        return acc;\n    }, [] as number[]);\n    const base58EncodedAddressCodec = getAddressCodec();\n    const programAddressBytes = base58EncodedAddressCodec.encode(programAddress);\n    const addressBytesBuffer = await crypto.subtle.digest(\n        'SHA-256',\n        new Uint8Array([...seedBytes, ...programAddressBytes, ...PDA_MARKER_BYTES]),\n    );\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n    if (compressedPointBytesAreOnCurve(addressBytes)) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE);\n    }\n    return base58EncodedAddressCodec.decode(addressBytes);\n}\n\n/**\n * Given a program's {@link Address} and up to 16 {@link Seed | Seeds}, this method will return the\n * program derived address (PDA) associated with each.\n *\n * @example\n * ```ts\n * import { getAddressEncoder, getProgramDerivedAddress } from '@solana/addresses';\n *\n * const addressEncoder = getAddressEncoder();\n * const [pda, bumpSeed] = await getProgramDerivedAddress({\n *     programAddress: 'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address,\n *     seeds: [\n *         // Owner\n *         addressEncoder.encode('9fYLFVoVqwH37C3dyPi6cpeobfbQ2jtLpN5HgAYDDdkm' as Address),\n *         // Token program\n *         addressEncoder.encode('TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address),\n *         // Mint\n *         addressEncoder.encode('EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v' as Address),\n *     ],\n * });\n * ```\n */\nexport async function getProgramDerivedAddress({\n    programAddress,\n    seeds,\n}: ProgramDerivedAddressInput): Promise<ProgramDerivedAddress> {\n    let bumpSeed = 255;\n    while (bumpSeed > 0) {\n        try {\n            const address = await createProgramDerivedAddress({\n                programAddress,\n                seeds: [...seeds, new Uint8Array([bumpSeed])],\n            });\n            return [address, bumpSeed as ProgramDerivedAddressBump];\n        } catch (e) {\n            if (isSolanaError(e, SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE)) {\n                bumpSeed--;\n            } else {\n                throw e;\n            }\n        }\n    }\n    throw new SolanaError(SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED);\n}\n\n/**\n * Returns a base58-encoded address derived from some base address, some program address, and a seed\n * string or byte array.\n *\n * @example\n * ```ts\n * import { createAddressWithSeed } from '@solana/addresses';\n *\n * const derivedAddress = await createAddressWithSeed({\n *     // The private key associated with this address will be able to sign for `derivedAddress`.\n *     baseAddress: 'B9Lf9z5BfNPT4d5KMeaBFx8x1G4CULZYR1jA2kmxRDka' as Address,\n *     // Only this program will be able to write data to this account.\n *     programAddress: '445erYq578p2aERrGW9mn9KiYe3fuG6uHdcJ2LPPShGw' as Address,\n *     seed: 'data-account',\n * });\n * ```\n */\nexport async function createAddressWithSeed({ baseAddress, programAddress, seed }: SeedInput): Promise<Address> {\n    const { encode, decode } = getAddressCodec();\n\n    const seedBytes = typeof seed === 'string' ? new TextEncoder().encode(seed) : seed;\n    if (seedBytes.byteLength > MAX_SEED_LENGTH) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED, {\n            actual: seedBytes.byteLength,\n            index: 0,\n            maxSeedLength: MAX_SEED_LENGTH,\n        });\n    }\n\n    const programAddressBytes = encode(programAddress);\n    if (\n        programAddressBytes.length >= PDA_MARKER_BYTES.length &&\n        programAddressBytes.slice(-PDA_MARKER_BYTES.length).every((byte, index) => byte === PDA_MARKER_BYTES[index])\n    ) {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER);\n    }\n\n    const addressBytesBuffer = await crypto.subtle.digest(\n        'SHA-256',\n        new Uint8Array([...encode(baseAddress), ...seedBytes, ...programAddressBytes]),\n    );\n    const addressBytes = new Uint8Array(addressBytesBuffer);\n\n    return decode(addressBytes);\n}\n","import { assertKeyExporterIsAvailable } from '@solana/assertions';\nimport { SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY, SolanaError } from '@solana/errors';\n\nimport { Address, getAddressDecoder, getAddressEncoder } from './address';\n\n/**\n * Given a public {@link CryptoKey}, this method will return its associated {@link Address}.\n *\n * @example\n * ```ts\n * import { getAddressFromPublicKey } from '@solana/addresses';\n *\n * const address = await getAddressFromPublicKey(publicKey);\n * ```\n */\nexport async function getAddressFromPublicKey(publicKey: CryptoKey): Promise<Address> {\n    assertKeyExporterIsAvailable();\n    if (publicKey.type !== 'public' || publicKey.algorithm.name !== 'Ed25519') {\n        throw new SolanaError(SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY);\n    }\n    const publicKeyBytes = await crypto.subtle.exportKey('raw', publicKey);\n    return getAddressDecoder().decode(new Uint8Array(publicKeyBytes));\n}\n\n/**\n * Given an {@link Address}, return a {@link CryptoKey} that can be used to verify signatures.\n *\n * @example\n * ```ts\n * import { getAddressFromPublicKey } from '@solana/addresses';\n *\n * const publicKey = await getPublicKeyFromAddress(address);\n * ```\n */\nexport async function getPublicKeyFromAddress(address: Address) {\n    const addressBytes = getAddressEncoder().encode(address);\n    return await crypto.subtle.importKey('raw', addressBytes, { name: 'Ed25519' }, true /* extractable */, ['verify']);\n}\n","import { SolanaError, SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE } from '@solana/errors';\nimport { combineCodec, createDecoder, createEncoder } from '@solana/codecs-core';\n\n// src/assertions.ts\nfunction assertValidBaseString(alphabet4, testValue, givenValue = testValue) {\n  if (!testValue.match(new RegExp(`^[${alphabet4}]*$`))) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n      alphabet: alphabet4,\n      base: alphabet4.length,\n      value: givenValue\n    });\n  }\n}\nvar getBaseXEncoder = (alphabet4) => {\n  return createEncoder({\n    getSizeFromValue: (value) => {\n      const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);\n      if (!tailChars) return value.length;\n      const base10Number = getBigIntFromBaseX(tailChars, alphabet4);\n      return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n    },\n    write(value, bytes, offset) {\n      assertValidBaseString(alphabet4, value);\n      if (value === \"\") return offset;\n      const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);\n      if (!tailChars) {\n        bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n        return offset + leadingZeroes.length;\n      }\n      let base10Number = getBigIntFromBaseX(tailChars, alphabet4);\n      const tailBytes = [];\n      while (base10Number > 0n) {\n        tailBytes.unshift(Number(base10Number % 256n));\n        base10Number /= 256n;\n      }\n      const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n      bytes.set(bytesToAdd, offset);\n      return offset + bytesToAdd.length;\n    }\n  });\n};\nvar getBaseXDecoder = (alphabet4) => {\n  return createDecoder({\n    read(rawBytes, offset) {\n      const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n      if (bytes.length === 0) return [\"\", 0];\n      let trailIndex = bytes.findIndex((n) => n !== 0);\n      trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n      const leadingZeroes = alphabet4[0].repeat(trailIndex);\n      if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n      const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n      const tailChars = getBaseXFromBigInt(base10Number, alphabet4);\n      return [leadingZeroes + tailChars, rawBytes.length];\n    }\n  });\n};\nvar getBaseXCodec = (alphabet4) => combineCodec(getBaseXEncoder(alphabet4), getBaseXDecoder(alphabet4));\nfunction partitionLeadingZeroes(value, zeroCharacter) {\n  const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n  return [leadingZeros, tailChars];\n}\nfunction getBigIntFromBaseX(value, alphabet4) {\n  const base = BigInt(alphabet4.length);\n  let sum = 0n;\n  for (const char of value) {\n    sum *= base;\n    sum += BigInt(alphabet4.indexOf(char));\n  }\n  return sum;\n}\nfunction getBaseXFromBigInt(value, alphabet4) {\n  const base = BigInt(alphabet4.length);\n  const tailChars = [];\n  while (value > 0n) {\n    tailChars.unshift(alphabet4[Number(value % base)]);\n    value /= base;\n  }\n  return tailChars.join(\"\");\n}\n\n// src/base10.ts\nvar alphabet = \"0123456789\";\nvar getBase10Encoder = () => getBaseXEncoder(alphabet);\nvar getBase10Decoder = () => getBaseXDecoder(alphabet);\nvar getBase10Codec = () => getBaseXCodec(alphabet);\nvar INVALID_STRING_ERROR_BASE_CONFIG = {\n  alphabet: \"0123456789abcdef\",\n  base: 16\n};\nfunction charCodeToBase16(char) {\n  if (char >= 48 /* ZERO */ && char <= 57 /* NINE */) return char - 48 /* ZERO */;\n  if (char >= 65 /* A_UP */ && char <= 70 /* F_UP */) return char - (65 /* A_UP */ - 10);\n  if (char >= 97 /* A_LO */ && char <= 102 /* F_LO */) return char - (97 /* A_LO */ - 10);\n}\nvar getBase16Encoder = () => createEncoder({\n  getSizeFromValue: (value) => Math.ceil(value.length / 2),\n  write(value, bytes, offset) {\n    const len = value.length;\n    const al = len / 2;\n    if (len === 1) {\n      const c = value.charCodeAt(0);\n      const n = charCodeToBase16(c);\n      if (n === void 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n          ...INVALID_STRING_ERROR_BASE_CONFIG,\n          value\n        });\n      }\n      bytes.set([n], offset);\n      return 1 + offset;\n    }\n    const hexBytes = new Uint8Array(al);\n    for (let i = 0, j = 0; i < al; i++) {\n      const c1 = value.charCodeAt(j++);\n      const c2 = value.charCodeAt(j++);\n      const n1 = charCodeToBase16(c1);\n      const n2 = charCodeToBase16(c2);\n      if (n1 === void 0 || n2 === void 0 && !Number.isNaN(c2)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n          ...INVALID_STRING_ERROR_BASE_CONFIG,\n          value\n        });\n      }\n      hexBytes[i] = !Number.isNaN(c2) ? n1 << 4 | (n2 ?? 0) : n1;\n    }\n    bytes.set(hexBytes, offset);\n    return hexBytes.length + offset;\n  }\n});\nvar getBase16Decoder = () => createDecoder({\n  read(bytes, offset) {\n    const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n    return [value, bytes.length];\n  }\n});\nvar getBase16Codec = () => combineCodec(getBase16Encoder(), getBase16Decoder());\n\n// src/base58.ts\nvar alphabet2 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nvar getBase58Encoder = () => getBaseXEncoder(alphabet2);\nvar getBase58Decoder = () => getBaseXDecoder(alphabet2);\nvar getBase58Codec = () => getBaseXCodec(alphabet2);\nvar getBaseXResliceEncoder = (alphabet4, bits) => createEncoder({\n  getSizeFromValue: (value) => Math.floor(value.length * bits / 8),\n  write(value, bytes, offset) {\n    assertValidBaseString(alphabet4, value);\n    if (value === \"\") return offset;\n    const charIndices = [...value].map((c) => alphabet4.indexOf(c));\n    const reslicedBytes = reslice(charIndices, bits, 8, false);\n    bytes.set(reslicedBytes, offset);\n    return reslicedBytes.length + offset;\n  }\n});\nvar getBaseXResliceDecoder = (alphabet4, bits) => createDecoder({\n  read(rawBytes, offset = 0) {\n    const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n    if (bytes.length === 0) return [\"\", rawBytes.length];\n    const charIndices = reslice([...bytes], 8, bits, true);\n    return [charIndices.map((i) => alphabet4[i]).join(\"\"), rawBytes.length];\n  }\n});\nvar getBaseXResliceCodec = (alphabet4, bits) => combineCodec(getBaseXResliceEncoder(alphabet4, bits), getBaseXResliceDecoder(alphabet4, bits));\nfunction reslice(input, inputBits, outputBits, useRemainder) {\n  const output = [];\n  let accumulator = 0;\n  let bitsInAccumulator = 0;\n  const mask = (1 << outputBits) - 1;\n  for (const value of input) {\n    accumulator = accumulator << inputBits | value;\n    bitsInAccumulator += inputBits;\n    while (bitsInAccumulator >= outputBits) {\n      bitsInAccumulator -= outputBits;\n      output.push(accumulator >> bitsInAccumulator & mask);\n    }\n  }\n  if (useRemainder && bitsInAccumulator > 0) {\n    output.push(accumulator << outputBits - bitsInAccumulator & mask);\n  }\n  return output;\n}\n\n// src/base64.ts\nvar alphabet3 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar getBase64Encoder = () => {\n  {\n    return createEncoder({\n      getSizeFromValue: (value) => {\n        try {\n          return atob(value).length;\n        } catch {\n          throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet: alphabet3,\n            base: 64,\n            value\n          });\n        }\n      },\n      write(value, bytes, offset) {\n        try {\n          const bytesToAdd = atob(value).split(\"\").map((c) => c.charCodeAt(0));\n          bytes.set(bytesToAdd, offset);\n          return bytesToAdd.length + offset;\n        } catch {\n          throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet: alphabet3,\n            base: 64,\n            value\n          });\n        }\n      }\n    });\n  }\n};\nvar getBase64Decoder = () => {\n  {\n    return createDecoder({\n      read(bytes, offset = 0) {\n        const slice = bytes.slice(offset);\n        const value = btoa(String.fromCharCode(...slice));\n        return [value, bytes.length];\n      }\n    });\n  }\n};\nvar getBase64Codec = () => combineCodec(getBase64Encoder(), getBase64Decoder());\n\n// src/null-characters.ts\nvar removeNullCharacters = (value) => (\n  // eslint-disable-next-line no-control-regex\n  value.replace(/\\u0000/g, \"\")\n);\nvar padNullCharacters = (value, chars) => value.padEnd(chars, \"\\0\");\n\n// ../text-encoding-impl/dist/index.browser.mjs\nvar e = globalThis.TextDecoder;\nvar o = globalThis.TextEncoder;\n\n// src/utf8.ts\nvar getUtf8Encoder = () => {\n  let textEncoder;\n  return createEncoder({\n    getSizeFromValue: (value) => (textEncoder ||= new o()).encode(value).length,\n    write: (value, bytes, offset) => {\n      const bytesToAdd = (textEncoder ||= new o()).encode(value);\n      bytes.set(bytesToAdd, offset);\n      return offset + bytesToAdd.length;\n    }\n  });\n};\nvar getUtf8Decoder = () => {\n  let textDecoder;\n  return createDecoder({\n    read(bytes, offset) {\n      const value = (textDecoder ||= new e()).decode(bytes.slice(offset));\n      return [removeNullCharacters(value), bytes.length];\n    }\n  });\n};\nvar getUtf8Codec = () => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n\nexport { assertValidBaseString, getBase10Codec, getBase10Decoder, getBase10Encoder, getBase16Codec, getBase16Decoder, getBase16Encoder, getBase58Codec, getBase58Decoder, getBase58Encoder, getBase64Codec, getBase64Decoder, getBase64Encoder, getBaseXCodec, getBaseXDecoder, getBaseXEncoder, getBaseXResliceCodec, getBaseXResliceDecoder, getBaseXResliceEncoder, getUtf8Codec, getUtf8Decoder, getUtf8Encoder, padNullCharacters, removeNullCharacters };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '0123456789';\n\n/**\n * Returns an encoder for base-10 strings.\n *\n * This encoder serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-10 strings.\n *\n * @example\n * Encoding a base-10 string.\n * ```ts\n * const encoder = getBase10Encoder();\n * const bytes = encoder.encode('1024'); // 0x0400\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-10 strings.\n *\n * This decoder deserializes base-10 encoded strings from a byte array.\n *\n * For more details, see {@link getBase10Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-10 strings.\n *\n * @example\n * Decoding a base-10 string.\n * ```ts\n * const decoder = getBase10Decoder();\n * const value = decoder.decode(new Uint8Array([0x04, 0x00])); // \"1024\"\n * ```\n *\n * @see {@link getBase10Codec}\n */\nexport const getBase10Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-10 strings.\n *\n * This codec serializes strings using a base-10 encoding scheme.\n * The output consists of bytes representing the numerical values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-10 strings.\n *\n * @example\n * Encoding and decoding a base-10 string.\n * ```ts\n * const codec = getBase10Codec();\n * const bytes = codec.encode('1024'); // 0x0400\n * const value = codec.decode(bytes);  // \"1024\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-10 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase10Codec(), 5);\n * ```\n *\n * If you need a size-prefixed base-10 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase10Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase10Encoder} and {@link getBase10Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase10Encoder().encode('1024');\n * const value = getBase10Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase10Encoder}\n * @see {@link getBase10Decoder}\n */\nexport const getBase10Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nconst enum HexC {\n    ZERO = 48, // 0\n    NINE = 57, // 9\n    A_UP = 65, // A\n    F_UP = 70, // F\n    A_LO = 97, // a\n    F_LO = 102, // f\n}\n\nconst INVALID_STRING_ERROR_BASE_CONFIG = {\n    alphabet: '0123456789abcdef',\n    base: 16,\n} as const;\n\nfunction charCodeToBase16(char: number) {\n    if (char >= HexC.ZERO && char <= HexC.NINE) return char - HexC.ZERO;\n    if (char >= HexC.A_UP && char <= HexC.F_UP) return char - (HexC.A_UP - 10);\n    if (char >= HexC.A_LO && char <= HexC.F_LO) return char - (HexC.A_LO - 10);\n}\n\n/**\n * Returns an encoder for base-16 (hexadecimal) strings.\n *\n * This encoder serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-16 strings.\n *\n * @example\n * Encoding a base-16 string.\n * ```ts\n * const encoder = getBase16Encoder();\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Encoder = (): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.ceil(value.length / 2),\n        write(value: string, bytes, offset) {\n            const len = value.length;\n            const al = len / 2;\n            if (len === 1) {\n                const c = value.charCodeAt(0);\n                const n = charCodeToBase16(c);\n                if (n === undefined) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                bytes.set([n], offset);\n                return 1 + offset;\n            }\n            const hexBytes = new Uint8Array(al);\n            for (let i = 0, j = 0; i < al; i++) {\n                const c1 = value.charCodeAt(j++);\n                const c2 = value.charCodeAt(j++);\n\n                const n1 = charCodeToBase16(c1);\n                const n2 = charCodeToBase16(c2);\n                if (n1 === undefined || (n2 === undefined && !Number.isNaN(c2))) {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        ...INVALID_STRING_ERROR_BASE_CONFIG,\n                        value,\n                    });\n                }\n                hexBytes[i] = !Number.isNaN(c2) ? (n1 << 4) | (n2 ?? 0) : n1;\n            }\n\n            bytes.set(hexBytes, offset);\n            return hexBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-16 (hexadecimal) strings.\n *\n * This decoder deserializes base-16 encoded strings from a byte array.\n *\n * For more details, see {@link getBase16Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-16 strings.\n *\n * @example\n * Decoding a base-16 string.\n * ```ts\n * const decoder = getBase16Decoder();\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBase16Codec}\n */\nexport const getBase16Decoder = (): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(bytes, offset) {\n            const value = bytes.slice(offset).reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');\n            return [value, bytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-16 (hexadecimal) strings.\n *\n * This codec serializes strings using a base-16 encoding scheme.\n * The output consists of bytes representing the hexadecimal values of the input string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-16 strings.\n *\n * @example\n * Encoding and decoding a base-16 string.\n * ```ts\n * const codec = getBase16Codec();\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-16 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase16Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-16 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase16Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase16Encoder} and {@link getBase16Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase16Encoder().encode('deadface');\n * const value = getBase16Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase16Encoder}\n * @see {@link getBase16Decoder}\n */\nexport const getBase16Codec = (): VariableSizeCodec<string> => combineCodec(getBase16Encoder(), getBase16Decoder());\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings using bit re-slicing.\n *\n * This encoder serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to an alphabet, and encoding the result into a byte array.\n * This approach is commonly used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding a base-X string using bit re-slicing.\n * ```ts\n * const encoder = getBaseXResliceEncoder('elho', 2);\n * const bytes = encoder.encode('hellolol'); // 0x4aee\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceEncoder = (alphabet: string, bits: number): VariableSizeEncoder<string> =>\n    createEncoder({\n        getSizeFromValue: (value: string) => Math.floor((value.length * bits) / 8),\n        write(value: string, bytes, offset) {\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n            const charIndices = [...value].map(c => alphabet.indexOf(c));\n            const reslicedBytes = reslice(charIndices, bits, 8, false);\n            bytes.set(reslicedBytes, offset);\n            return reslicedBytes.length + offset;\n        },\n    });\n\n/**\n * Returns a decoder for base-X encoded strings using bit re-slicing.\n *\n * This decoder deserializes base-X encoded strings by re-slicing the bits of a byte array into\n * custom-sized chunks and mapping them to a specified alphabet.\n * This is typically used for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * For more details, see {@link getBaseXResliceCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings using bit re-slicing.\n *\n * @example\n * Decoding a base-X string using bit re-slicing.\n * ```ts\n * const decoder = getBaseXResliceDecoder('elho', 2);\n * const value = decoder.decode(new Uint8Array([0x4a, 0xee])); // \"hellolol\"\n * ```\n *\n * @see {@link getBaseXResliceCodec}\n */\nexport const getBaseXResliceDecoder = (alphabet: string, bits: number): VariableSizeDecoder<string> =>\n    createDecoder({\n        read(rawBytes, offset = 0): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', rawBytes.length];\n            const charIndices = reslice([...bytes], 8, bits, true);\n            return [charIndices.map(i => alphabet[i]).join(''), rawBytes.length];\n        },\n    });\n\n/**\n * Returns a codec for encoding and decoding base-X strings using bit re-slicing.\n *\n * This codec serializes strings by dividing the input into custom-sized bit chunks,\n * mapping them to a given alphabet, and encoding the result into bytes.\n * It is particularly suited for encoding schemes where the alphabet's length is a power of 2,\n * such as base-16 or base-64.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @param bits - The number of bits per encoded chunk, typically `log2(alphabet.length)`.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings using bit re-slicing.\n *\n * @example\n * Encoding and decoding a base-X string using bit re-slicing.\n * ```ts\n * const codec = getBaseXResliceCodec('elho', 2);\n * const bytes = codec.encode('hellolol'); // 0x4aee\n * const value = codec.decode(bytes);      // \"hellolol\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXResliceCodec('elho', 2), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXResliceCodec('elho', 2), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXResliceEncoder} and {@link getBaseXResliceDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXResliceEncoder('elho', 2).encode('hellolol');\n * const value = getBaseXResliceDecoder('elho', 2).decode(bytes);\n * ```\n *\n * @see {@link getBaseXResliceEncoder}\n * @see {@link getBaseXResliceDecoder}\n */\nexport const getBaseXResliceCodec = (alphabet: string, bits: number): VariableSizeCodec<string> =>\n    combineCodec(getBaseXResliceEncoder(alphabet, bits), getBaseXResliceDecoder(alphabet, bits));\n\n/** Helper function to reslice the bits inside bytes. */\nfunction reslice(input: number[], inputBits: number, outputBits: number, useRemainder: boolean): number[] {\n    const output = [];\n    let accumulator = 0;\n    let bitsInAccumulator = 0;\n    const mask = (1 << outputBits) - 1;\n    for (const value of input) {\n        accumulator = (accumulator << inputBits) | value;\n        bitsInAccumulator += inputBits;\n        while (bitsInAccumulator >= outputBits) {\n            bitsInAccumulator -= outputBits;\n            output.push((accumulator >> bitsInAccumulator) & mask);\n        }\n    }\n    if (useRemainder && bitsInAccumulator > 0) {\n        output.push((accumulator << (outputBits - bitsInAccumulator)) & mask);\n    }\n    return output;\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\nimport { assertValidBaseString } from './assertions';\nimport { getBaseXResliceDecoder, getBaseXResliceEncoder } from './baseX-reslice';\n\nconst alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n/**\n * Returns an encoder for base-64 strings.\n *\n * This encoder serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-64 strings.\n *\n * @example\n * Encoding a base-64 string.\n * ```ts\n * const encoder = getBase64Encoder();\n * const bytes = encoder.encode('hello+world'); // 0x85e965a3ec28ae57\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Encoder = (): VariableSizeEncoder<string> => {\n    if (__BROWSER__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => {\n                try {\n                    return (atob as Window['atob'])(value).length;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n            write(value: string, bytes, offset) {\n                try {\n                    const bytesToAdd = (atob as Window['atob'])(value)\n                        .split('')\n                        .map(c => c.charCodeAt(0));\n                    bytes.set(bytesToAdd, offset);\n                    return bytesToAdd.length + offset;\n                } catch {\n                    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n                        alphabet,\n                        base: 64,\n                        value,\n                    });\n                }\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createEncoder({\n            getSizeFromValue: (value: string) => Buffer.from(value, 'base64').length,\n            write(value: string, bytes, offset) {\n                assertValidBaseString(alphabet, value.replace(/=/g, ''));\n                const buffer = Buffer.from(value, 'base64');\n                bytes.set(buffer, offset);\n                return buffer.length + offset;\n            },\n        });\n    }\n\n    return transformEncoder(getBaseXResliceEncoder(alphabet, 6), (value: string): string => value.replace(/=/g, ''));\n};\n\n/**\n * Returns a decoder for base-64 strings.\n *\n * This decoder deserializes base-64 encoded strings from a byte array.\n *\n * For more details, see {@link getBase64Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-64 strings.\n *\n * @example\n * Decoding a base-64 string.\n * ```ts\n * const decoder = getBase64Decoder();\n * const value = decoder.decode(new Uint8Array([0x85, 0xe9, 0x65, 0xa3, 0xec, 0x28, 0xae, 0x57])); // \"hello+world\"\n * ```\n *\n * @see {@link getBase64Codec}\n */\nexport const getBase64Decoder = (): VariableSizeDecoder<string> => {\n    if (__BROWSER__) {\n        return createDecoder({\n            read(bytes, offset = 0) {\n                const slice = bytes.slice(offset);\n                const value = (btoa as Window['btoa'])(String.fromCharCode(...slice));\n                return [value, bytes.length];\n            },\n        });\n    }\n\n    if (__NODEJS__) {\n        return createDecoder({\n            read: (bytes, offset = 0) => [Buffer.from(bytes, offset).toString('base64'), bytes.length],\n        });\n    }\n\n    return transformDecoder(getBaseXResliceDecoder(alphabet, 6), (value: string): string =>\n        value.padEnd(Math.ceil(value.length / 4) * 4, '='),\n    );\n};\n\n/**\n * Returns a codec for encoding and decoding base-64 strings.\n *\n * This codec serializes strings using a base-64 encoding scheme,\n * commonly used for data encoding in URLs, cryptographic keys, and binary-to-text encoding.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-64 strings.\n *\n * @example\n * Encoding and decoding a base-64 string.\n * ```ts\n * const codec = getBase64Codec();\n * const bytes = codec.encode('hello+world'); // 0x85e965a3ec28ae57\n * const value = codec.decode(bytes);         // \"hello+world\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-64 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase64Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-64 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase64Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase64Encoder} and {@link getBase64Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase64Encoder().encode('hello+world');\n * const value = getBase64Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase64Encoder}\n * @see {@link getBase64Decoder}\n */\nexport const getBase64Codec = (): VariableSizeCodec<string> => combineCodec(getBase64Encoder(), getBase64Decoder());\n","/**\n * Removes all null characters (`\\u0000`) from a string.\n *\n * This function cleans a string by stripping out any null characters,\n * which are often used as padding in fixed-size string encodings.\n *\n * @param value - The string to process.\n * @returns The input string with all null characters removed.\n *\n * @example\n * Removing null characters from a string.\n * ```ts\n * removeNullCharacters('hello\\u0000\\u0000'); // \"hello\"\n * ```\n */\nexport const removeNullCharacters = (value: string) =>\n    // eslint-disable-next-line no-control-regex\n    value.replace(/\\u0000/g, '');\n\n/**\n * Pads a string with null characters (`\\u0000`) at the end to reach a fixed length.\n *\n * If the input string is shorter than the specified length, it is padded with null characters\n * until it reaches the desired size. If it is already long enough, it remains unchanged.\n *\n * @param value - The string to pad.\n * @param chars - The total length of the resulting string, including padding.\n * @returns The input string padded with null characters up to the specified length.\n *\n * @example\n * Padding a string with null characters.\n * ```ts\n * padNullCharacters('hello', 8); // \"hello\\u0000\\u0000\\u0000\"\n * ```\n */\nexport const padNullCharacters = (value: string, chars: number) => value.padEnd(chars, '\\u0000');\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { TextDecoder, TextEncoder } from '@solana/text-encoding-impl';\n\nimport { removeNullCharacters } from './null-characters';\n\n/**\n * Returns an encoder for UTF-8 strings.\n *\n * This encoder serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding UTF-8 strings.\n *\n * @example\n * Encoding a UTF-8 string.\n * ```ts\n * const encoder = getUtf8Encoder();\n * const bytes = encoder.encode('hello'); // 0x68656c6c6f\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Encoder = (): VariableSizeEncoder<string> => {\n    let textEncoder: TextEncoder;\n    return createEncoder({\n        getSizeFromValue: value => (textEncoder ||= new TextEncoder()).encode(value).length,\n        write: (value: string, bytes, offset) => {\n            const bytesToAdd = (textEncoder ||= new TextEncoder()).encode(value);\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for UTF-8 strings.\n *\n * This decoder deserializes UTF-8 encoded strings from a byte array.\n * It reads all available bytes starting from the given offset.\n *\n * For more details, see {@link getUtf8Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding UTF-8 strings.\n *\n * @example\n * Decoding a UTF-8 string.\n * ```ts\n * const decoder = getUtf8Decoder();\n * const value = decoder.decode(new Uint8Array([0x68, 0x65, 0x6c, 0x6c, 0x6f])); // \"hello\"\n * ```\n *\n * @see {@link getUtf8Codec}\n */\nexport const getUtf8Decoder = (): VariableSizeDecoder<string> => {\n    let textDecoder: TextDecoder;\n    return createDecoder({\n        read(bytes, offset) {\n            const value = (textDecoder ||= new TextDecoder()).decode(bytes.slice(offset));\n            return [removeNullCharacters(value), bytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding UTF-8 strings.\n *\n * This codec serializes strings using UTF-8 encoding.\n * The encoded output contains as many bytes as needed to represent the string.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding UTF-8 strings.\n *\n * @example\n * Encoding and decoding a UTF-8 string.\n * ```ts\n * const codec = getUtf8Codec();\n * const bytes = codec.encode('hello'); // 0x68656c6c6f\n * const value = codec.decode(bytes);   // \"hello\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size UTF-8 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getUtf8Codec(), 5);\n * ```\n *\n * If you need a size-prefixed UTF-8 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getUtf8Encoder} and {@link getUtf8Decoder} functions are available.\n *\n * ```ts\n * const bytes = getUtf8Encoder().encode('hello');\n * const value = getUtf8Decoder().decode(bytes);\n * ```\n *\n * @see {@link getUtf8Encoder}\n * @see {@link getUtf8Decoder}\n */\nexport const getUtf8Codec = (): VariableSizeCodec<string> => combineCodec(getUtf8Encoder(), getUtf8Decoder());\n","import { SolanaError, SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED, SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT } from '@solana/errors';\n\n// src/crypto.ts\nfunction assertPRNGIsAvailable() {\n  if (typeof globalThis.crypto === \"undefined\" || typeof globalThis.crypto.getRandomValues !== \"function\") {\n    throw new SolanaError(SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED);\n  }\n}\nfunction assertIsSecureContext() {\n  if (!globalThis.isSecureContext) {\n    throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT);\n  }\n}\nvar cachedEd25519Decision;\nasync function isEd25519CurveSupported(subtle) {\n  if (cachedEd25519Decision === void 0) {\n    cachedEd25519Decision = new Promise((resolve) => {\n      subtle.generateKey(\n        \"Ed25519\",\n        /* extractable */\n        false,\n        [\"sign\", \"verify\"]\n      ).then(() => {\n        resolve(cachedEd25519Decision = true);\n      }).catch(() => {\n        resolve(cachedEd25519Decision = false);\n      });\n    });\n  }\n  if (typeof cachedEd25519Decision === \"boolean\") {\n    return cachedEd25519Decision;\n  } else {\n    return await cachedEd25519Decision;\n  }\n}\nfunction assertDigestCapabilityIsAvailable() {\n  assertIsSecureContext();\n  if (typeof globalThis.crypto === \"undefined\" || typeof globalThis.crypto.subtle?.digest !== \"function\") {\n    throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED);\n  }\n}\nasync function assertKeyGenerationIsAvailable() {\n  assertIsSecureContext();\n  if (typeof globalThis.crypto === \"undefined\" || typeof globalThis.crypto.subtle?.generateKey !== \"function\") {\n    throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED);\n  }\n  if (!await isEd25519CurveSupported(globalThis.crypto.subtle)) {\n    throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED);\n  }\n}\nfunction assertKeyExporterIsAvailable() {\n  assertIsSecureContext();\n  if (typeof globalThis.crypto === \"undefined\" || typeof globalThis.crypto.subtle?.exportKey !== \"function\") {\n    throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED);\n  }\n}\nfunction assertSigningCapabilityIsAvailable() {\n  assertIsSecureContext();\n  if (typeof globalThis.crypto === \"undefined\" || typeof globalThis.crypto.subtle?.sign !== \"function\") {\n    throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED);\n  }\n}\nfunction assertVerificationCapabilityIsAvailable() {\n  assertIsSecureContext();\n  if (typeof globalThis.crypto === \"undefined\" || typeof globalThis.crypto.subtle?.verify !== \"function\") {\n    throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED);\n  }\n}\n\nexport { assertDigestCapabilityIsAvailable, assertKeyExporterIsAvailable, assertKeyGenerationIsAvailable, assertPRNGIsAvailable, assertSigningCapabilityIsAvailable, assertVerificationCapabilityIsAvailable };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","import { SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED, SolanaError } from '@solana/errors';\n\n/**\n * Throws an exception unless {@link Crypto#getRandomValues | `crypto.getRandomValues()`} is\n * available in the current JavaScript environment.\n */\nexport function assertPRNGIsAvailable() {\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.getRandomValues !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED);\n    }\n}\n","import {\n    SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT,\n    SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED,\n    SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED,\n    SolanaError,\n} from '@solana/errors';\n\nfunction assertIsSecureContext() {\n    if (__BROWSER__ && !globalThis.isSecureContext) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT);\n    }\n}\n\nlet cachedEd25519Decision: PromiseLike<boolean> | boolean | undefined;\nasync function isEd25519CurveSupported(subtle: SubtleCrypto): Promise<boolean> {\n    if (cachedEd25519Decision === undefined) {\n        cachedEd25519Decision = new Promise(resolve => {\n            subtle\n                .generateKey('Ed25519', /* extractable */ false, ['sign', 'verify'])\n                .then(() => {\n                    resolve((cachedEd25519Decision = true));\n                })\n                .catch(() => {\n                    resolve((cachedEd25519Decision = false));\n                });\n        });\n    }\n    if (typeof cachedEd25519Decision === 'boolean') {\n        return cachedEd25519Decision;\n    } else {\n        return await cachedEd25519Decision;\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#digest | `crypto.subtle.digest()`} is available in\n * the current JavaScript environment.\n */\nexport function assertDigestCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.digest !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED);\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#generateKey | `crypto.subtle.generateKey()`} is\n * available in the current JavaScript environment and has support for the Ed25519 curve.\n */\nexport async function assertKeyGenerationIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.generateKey !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED);\n    }\n    if (!(await isEd25519CurveSupported(globalThis.crypto.subtle))) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED);\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#exportKey | `crypto.subtle.exportKey()`} is\n * available in the current JavaScript environment.\n */\nexport function assertKeyExporterIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.exportKey !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED);\n    }\n}\n\n/**\n * Throws an exception unless {@link SubtleCrypto#sign | `crypto.subtle.sign()`} is available in the\n * current JavaScript environment.\n */\nexport function assertSigningCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.sign !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED);\n    }\n}\n/**\n * Throws an exception unless {@link SubtleCrypto#verify | `crypto.subtle.verify()`} is available in\n * the current JavaScript environment.\n */\nexport function assertVerificationCapabilityIsAvailable() {\n    assertIsSecureContext();\n    if (typeof globalThis.crypto === 'undefined' || typeof globalThis.crypto.subtle?.verify !== 'function') {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED);\n    }\n}\n","import { transformEncoder, assertIsFixedSize, fixEncoderSize, transformDecoder, fixDecoderSize, containsBytes, combineCodec } from '@solana/codecs-core';\nimport { getUnitEncoder, getBooleanEncoder, getConstantEncoder, getUnionEncoder, getTupleEncoder, getUnitDecoder, getBooleanDecoder, getConstantDecoder, getUnionDecoder, getTupleDecoder } from '@solana/codecs-data-structures';\nimport { getU8Encoder, getU8Decoder } from '@solana/codecs-numbers';\n\n// src/option.ts\nvar some = (value) => ({ __option: \"Some\", value });\nvar none = () => ({ __option: \"None\" });\nvar isOption = (input) => !!(input && typeof input === \"object\" && \"__option\" in input && (input.__option === \"Some\" && \"value\" in input || input.__option === \"None\"));\nvar isSome = (option) => option.__option === \"Some\";\nvar isNone = (option) => option.__option === \"None\";\n\n// src/unwrap-option.ts\nfunction unwrapOption(option, fallback) {\n  if (isSome(option)) return option.value;\n  return fallback ? fallback() : null;\n}\nvar wrapNullable = (nullable) => nullable !== null ? some(nullable) : none();\n\n// src/option-codec.ts\nfunction getOptionEncoder(item, config = {}) {\n  const prefix = (() => {\n    if (config.prefix === null) {\n      return transformEncoder(getUnitEncoder(), (_boolean) => void 0);\n    }\n    return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n  })();\n  const noneValue = (() => {\n    if (config.noneValue === \"zeroes\") {\n      assertIsFixedSize(item);\n      return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n    }\n    if (!config.noneValue) {\n      return getUnitEncoder();\n    }\n    return getConstantEncoder(config.noneValue);\n  })();\n  return getUnionEncoder(\n    [\n      transformEncoder(getTupleEncoder([prefix, noneValue]), (_value) => [\n        false,\n        void 0\n      ]),\n      transformEncoder(getTupleEncoder([prefix, item]), (value) => [\n        true,\n        isOption(value) && isSome(value) ? value.value : value\n      ])\n    ],\n    (variant) => {\n      const option = isOption(variant) ? variant : wrapNullable(variant);\n      return Number(isSome(option));\n    }\n  );\n}\nfunction getOptionDecoder(item, config = {}) {\n  const prefix = (() => {\n    if (config.prefix === null) {\n      return transformDecoder(getUnitDecoder(), () => false);\n    }\n    return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n  })();\n  const noneValue = (() => {\n    if (config.noneValue === \"zeroes\") {\n      assertIsFixedSize(item);\n      return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n    }\n    if (!config.noneValue) {\n      return getUnitDecoder();\n    }\n    return getConstantDecoder(config.noneValue);\n  })();\n  return getUnionDecoder(\n    [\n      transformDecoder(getTupleDecoder([prefix, noneValue]), () => none()),\n      transformDecoder(getTupleDecoder([prefix, item]), ([, value]) => some(value))\n    ],\n    (bytes, offset) => {\n      if (config.prefix === null && !config.noneValue) {\n        return Number(offset < bytes.length);\n      }\n      if (config.prefix === null && config.noneValue != null) {\n        const zeroValue = config.noneValue === \"zeroes\" ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n        return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n      }\n      return Number(prefix.read(bytes, offset)[0]);\n    }\n  );\n}\nfunction getOptionCodec(item, config = {}) {\n  return combineCodec(\n    getOptionEncoder(item, config),\n    getOptionDecoder(item, config)\n  );\n}\n\n// src/unwrap-option-recursively.ts\nfunction unwrapOptionRecursively(input, fallback) {\n  if (!input || ArrayBuffer.isView(input)) {\n    return input;\n  }\n  const next = (x) => fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x);\n  if (isOption(input)) {\n    if (isSome(input)) return next(input.value);\n    return fallback ? fallback() : null;\n  }\n  if (Array.isArray(input)) {\n    return input.map(next);\n  }\n  if (typeof input === \"object\") {\n    return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, next(v)]));\n  }\n  return input;\n}\n\nexport { getOptionCodec, getOptionDecoder, getOptionEncoder, isNone, isOption, isSome, none, some, unwrapOption, unwrapOptionRecursively, wrapNullable };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","/**\n * An implementation of the Rust `Option<T>` type in JavaScript.\n *\n * In Rust, optional values are represented using `Option<T>`, which can be either:\n * - `Some(T)`, indicating a present value.\n * - `None`, indicating the absence of a value.\n *\n * In JavaScript, this is typically represented as `T | null`. However, this approach fails with nested options.\n * For example, `Option<Option<T>>` in Rust would translate to `T | null | null` in JavaScript, which is equivalent to `T | null`.\n * This means there is no way to differentiate between `Some(None)` and `None`, making nested options impossible.\n *\n * This `Option` type helps solve this by mirroring Rusts `Option<T>` type.\n *\n * ```ts\n * type Option<T> = Some<T> | None;\n * type Some<T> = { __option: 'Some'; value: T };\n * type None = { __option: 'None' };\n * ```\n *\n * @typeParam T - The type of the contained value.\n *\n * @example\n * Here's how you can create `Option` values.\n *\n * To improve developer experience, helper functions are available.\n * TypeScript can infer the type of `T` or it can be explicitly provided.\n *\n * ```ts\n * // Create an option with a value.\n * some('Hello World');\n * some<number | string>(123);\n *\n * // Create an empty option.\n * none();\n * none<number | string>();\n * ```\n *\n * @see {@link Some}\n * @see {@link None}\n * @see {@link some}\n * @see {@link none}\n */\nexport type Option<T> = None | Some<T>;\n\n/**\n * A flexible type that allows working with {@link Option} values or nullable values.\n *\n * It defines a looser type that can be used when encoding {@link Option | Options}.\n * This allows us to pass `null` or the nested value directly whilst still\n * supporting the Option type for use-cases that need more type safety.\n *\n * @typeParam T - The type of the contained value.\n *\n * @example\n * Accepting both `Option<T>` and `T | null` as input.\n * ```ts\n * function double(value: OptionOrNullable<number>) {\n *   const option = isOption(value) ? value : wrapNullable(value);\n *   return isSome(option) ? option.value * 2 : 'No value';\n * }\n *\n * double(42);       // 84\n * double(some(21)); // 42\n * double(none());   // \"No value\"\n * double(null);     // \"No value\"\n * ```\n *\n * @see {@link Option}\n * @see {@link isOption}\n * @see {@link wrapNullable}\n */\nexport type OptionOrNullable<T> = Option<T> | T | null;\n\n/**\n * Represents an {@link Option} that contains a value.\n *\n * This type mirrors Rusts `Some(T)`, indicating that a value is present.\n *\n * For more details, see {@link Option}.\n *\n * @typeParam T - The type of the contained value.\n *\n * @example\n * Creating a `Some` value.\n * ```ts\n * const value = some(42);\n * isSome(value); // true\n * isNone(value); // false\n * ```\n *\n * @see {@link Option}\n * @see {@link some}\n * @see {@link isSome}\n */\nexport type Some<T> = Readonly<{ __option: 'Some'; value: T }>;\n\n/**\n * Represents an {@link Option} that contains no value.\n *\n * This type mirrors Rusts `None`, indicating the absence of a value.\n *\n * For more details, see {@link Option}.\n *\n * @example\n * Creating a `None` value.\n * ```ts\n * const empty = none();\n * isNone(empty); // true\n * isSome(empty); // false\n * ```\n *\n * @see {@link Option}\n * @see {@link none}\n * @see {@link isNone}\n */\nexport type None = Readonly<{ __option: 'None' }>;\n\n/**\n * Creates a new {@link Option} that contains a value.\n *\n * This function explicitly wraps a value in an {@link Option} type.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param value - The value to wrap in an {@link Option}.\n * @returns An {@link Option} containing the provided value.\n *\n * @example\n * Wrapping a value in an `Option`.\n * ```ts\n * const option = some('Hello');\n * option.value;     // \"Hello\"\n * isOption(option); // true\n * isSome(option);   // true\n * isNone(option);   // false\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n */\nexport const some = <T>(value: T): Option<T> => ({ __option: 'Some', value });\n\n/**\n * Creates a new {@link Option} that contains no value.\n *\n * This function explicitly represents an absent value.\n *\n * @typeParam T - The type of the expected absent value.\n *\n * @returns An {@link Option} containing no value.\n *\n * @example\n * Creating an empty `Option`.\n * ```ts\n * const empty = none<number>();\n * isOption(empty); // true\n * isSome(empty);   // false\n * isNone(empty);   // true\n * ```\n *\n * @see {@link Option}\n * @see {@link None}\n */\nexport const none = <T>(): Option<T> => ({ __option: 'None' });\n\n/**\n * Checks whether the given value is an {@link Option}.\n *\n * This function determines whether an input follows the `Option<T>` structure.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param input - The value to check.\n * @returns `true` if the value is an {@link Option}, `false` otherwise.\n *\n * @example\n * Checking for `Option` values.\n * ```ts\n * isOption(some(42));        // true\n * isOption(none());          // true\n * isOption(42);              // false\n * isOption(null);            // false\n * isOption(\"anything else\"); // false\n * ```\n *\n * @see {@link Option}\n */\nexport const isOption = <T = unknown>(input: unknown): input is Option<T> =>\n    !!(\n        input &&\n        typeof input === 'object' &&\n        '__option' in input &&\n        ((input.__option === 'Some' && 'value' in input) || input.__option === 'None')\n    );\n\n/**\n * Checks whether the given {@link Option} contains a value.\n *\n * This function acts as a type guard, ensuring the value is a {@link Some}.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param option - The {@link Option} to check.\n * @returns `true` if the option is a {@link Some}, `false` otherwise.\n *\n * @example\n * Checking for `Some` values.\n * ```ts\n * isSome(some(42)); // true\n * isSome(none());   // false\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n */\nexport const isSome = <T>(option: Option<T>): option is Some<T> => option.__option === 'Some';\n\n/**\n * Checks whether the given {@link Option} contains no value.\n *\n * This function acts as a type guard, ensuring the value is a {@link None}.\n *\n * @typeParam T - The type of the expected value.\n *\n * @param option - The {@link Option} to check.\n * @returns `true` if the option is a {@link None}, `false` otherwise.\n *\n * @example\n * Checking for `None` values.\n * ```ts\n * isNone(some(42)); // false\n * isNone(none());   // true\n * ```\n *\n * @see {@link Option}\n * @see {@link None}\n */\nexport const isNone = <T>(option: Option<T>): option is None => option.__option === 'None';\n","import { isSome, none, Option, some } from './option';\n\n/**\n * Unwraps the value of an {@link Option}, returning its contained value or a fallback.\n *\n * This function extracts the value `T` from an `Option<T>` type.\n * - If the option is {@link Some}, it returns the contained value `T`.\n * - If the option is {@link None}, it returns the fallback value `U`, which defaults to `null`.\n *\n * @typeParam T - The type of the contained value.\n * @typeParam U - The type of the fallback value (defaults to `null`).\n *\n * @param option - The {@link Option} to unwrap.\n * @param fallback - A function that provides a fallback value if the option is {@link None}.\n * @returns The contained value if {@link Some}, otherwise the fallback value.\n *\n * @example\n * Unwrapping an `Option` with no fallback.\n * ```ts\n * unwrapOption(some('Hello World')); // \"Hello World\"\n * unwrapOption(none());              // null\n * ```\n *\n * @example\n * Providing a custom fallback value.\n * ```ts\n * unwrapOption(some('Hello World'), () => 'Default'); // \"Hello World\"\n * unwrapOption(none(), () => 'Default');              // \"Default\"\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n * @see {@link None}\n */\nexport function unwrapOption<T>(option: Option<T>): T | null;\nexport function unwrapOption<T, U>(option: Option<T>, fallback: () => U): T | U;\nexport function unwrapOption<T, U = null>(option: Option<T>, fallback?: () => U): T | U {\n    if (isSome(option)) return option.value;\n    return fallback ? fallback() : (null as U);\n}\n\n/**\n * Wraps a nullable value into an {@link Option}.\n *\n * - If the input value is `null`, this function returns {@link None}.\n * - Otherwise, it wraps the value in {@link Some}.\n *\n * @typeParam T - The type of the contained value.\n *\n * @param nullable - The nullable value to wrap.\n * @returns An {@link Option} wrapping the value.\n *\n * @example\n * Wrapping nullable values.\n * ```ts\n * wrapNullable('Hello World'); // Option<string> (Some)\n * wrapNullable<string>(null);  // Option<string> (None)\n * ```\n *\n * @see {@link Option}\n * @see {@link Some}\n * @see {@link None}\n */\nexport const wrapNullable = <T>(nullable: T | null): Option<T> => (nullable !== null ? some(nullable) : none<T>());\n","import {\n    assertIsFixedSize,\n    Codec,\n    combineCodec,\n    containsBytes,\n    Decoder,\n    Encoder,\n    fixDecoderSize,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    fixEncoderSize,\n    ReadonlyUint8Array,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getBooleanDecoder,\n    getBooleanEncoder,\n    getConstantDecoder,\n    getConstantEncoder,\n    getTupleDecoder,\n    getTupleEncoder,\n    getUnionDecoder,\n    getUnionEncoder,\n    getUnitDecoder,\n    getUnitEncoder,\n} from '@solana/codecs-data-structures';\nimport {\n    FixedSizeNumberCodec,\n    FixedSizeNumberDecoder,\n    FixedSizeNumberEncoder,\n    getU8Decoder,\n    getU8Encoder,\n    NumberCodec,\n    NumberDecoder,\n    NumberEncoder,\n} from '@solana/codecs-numbers';\n\nimport { isOption, isSome, None, none, Option, OptionOrNullable, Some, some } from './option';\nimport { wrapNullable } from './unwrap-option';\n\n/**\n * Defines the configuration options for {@link Option} codecs.\n *\n * The `getOptionCodec` function behaves similarly to {@link getNullableCodec}\n * but encodes `Option<T>` types instead of `T | null` types.\n *\n * This configuration controls how {@link None} values are encoded and how presence\n * is determined when decoding.\n *\n * @typeParam TPrefix - A number codec, encoder, or decoder used as the presence prefix.\n *\n * @see {@link getOptionEncoder}\n * @see {@link getOptionDecoder}\n * @see {@link getOptionCodec}\n */\nexport type OptionCodecConfig<TPrefix extends NumberCodec | NumberDecoder | NumberEncoder> = {\n    /**\n     * Specifies how {@link None} values are represented in the encoded data.\n     *\n     * - By default, {@link None} values are omitted from encoding.\n     * - `'zeroes'`: The bytes allocated for the value are filled with zeroes. This requires a fixed-size codec for the item.\n     * - Custom byte array: {@link None} values are replaced with a predefined byte sequence. This results in a variable-size codec.\n     *\n     * @defaultValue No explicit `noneValue` is used; {@link None} values are omitted.\n     */\n    noneValue?: ReadonlyUint8Array | 'zeroes';\n\n    /**\n     * The presence prefix used to distinguish between {@link None} and present values.\n     *\n     * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`).\n     * - Custom number codec: Allows defining a different number size for the prefix.\n     * - `null`: No prefix is used; `noneValue` (if provided) determines {@link None}.\n     *   If no `noneValue` is set, {@link None} is identified by the absence of bytes.\n     *\n     * @defaultValue `u8` prefix.\n     */\n    prefix?: TPrefix | null;\n};\n\n/**\n * Returns an encoder for optional values using the {@link Option} type.\n *\n * This encoder serializes an {@link OptionOrNullable} value using a configurable approach:\n * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, {@link None} values are encoded as zeroes.\n * - If `noneValue` is a byte array, {@link None} values are replaced with the provided constant.\n *\n * Unlike {@link getNullableEncoder}, this encoder accepts both {@link Option} and {@link Nullable} values.\n *\n * For more details, see {@link getOptionCodec}.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n *\n * @param item - The encoder for the value that may be present.\n * @param config - Configuration options for encoding optional values.\n * @returns A `FixedSizeEncoder` or `VariableSizeEncoder` for encoding option values.\n *\n * @example\n * Encoding an optional string.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const encoder = getOptionEncoder(stringCodec);\n *\n * encoder.encode(some('Hi'));\n * encoder.encode('Hi');\n * // 0x01020000004869\n * //   | |       -- utf8 string content (\"Hi\").\n * //   | -- u32 string prefix (2 characters).\n * //   -- 1-byte prefix (Some).\n *\n * encoder.encode(none());\n * encoder.encode(null);\n * // 0x00\n * //   -- 1-byte prefix (None).\n * ```\n *\n * @see {@link getOptionCodec}\n */\nexport function getOptionEncoder<TFrom, TSize extends number>(\n    item: FixedSizeEncoder<TFrom, TSize>,\n    config: OptionCodecConfig<NumberEncoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeEncoder<OptionOrNullable<TFrom>, TSize>;\nexport function getOptionEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: OptionCodecConfig<FixedSizeNumberEncoder> & { noneValue: 'zeroes' },\n): FixedSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: FixedSizeEncoder<TFrom>,\n    config: OptionCodecConfig<NumberEncoder> & { noneValue: 'zeroes' },\n): VariableSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config?: OptionCodecConfig<NumberEncoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeEncoder<OptionOrNullable<TFrom>>;\nexport function getOptionEncoder<TFrom>(\n    item: Encoder<TFrom>,\n    config: OptionCodecConfig<NumberEncoder> = {},\n): Encoder<OptionOrNullable<TFrom>> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformEncoder(getUnitEncoder(), (_boolean: boolean) => undefined);\n        }\n        return getBooleanEncoder({ size: config.prefix ?? getU8Encoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixEncoderSize(getUnitEncoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitEncoder();\n        }\n        return getConstantEncoder(config.noneValue);\n    })();\n\n    return getUnionEncoder(\n        [\n            transformEncoder(getTupleEncoder([prefix, noneValue]), (_value: None | null): [boolean, void] => [\n                false,\n                undefined,\n            ]),\n            transformEncoder(getTupleEncoder([prefix, item]), (value: Some<TFrom> | TFrom): [boolean, TFrom] => [\n                true,\n                isOption(value) && isSome(value) ? value.value : value,\n            ]),\n        ],\n        variant => {\n            const option = isOption<TFrom>(variant) ? variant : wrapNullable(variant);\n            return Number(isSome(option));\n        },\n    );\n}\n\n/**\n * Returns a decoder for optional values using the {@link Option} type.\n *\n * This decoder deserializes an `Option<T>` value using a configurable approach:\n * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`). This can be customized or disabled.\n * - If `noneValue: 'zeroes'` is set, `None` values are identified by zeroes.\n * - If `noneValue` is a byte array, `None` values match the provided constant.\n *\n * Unlike {@link getNullableDecoder}, this decoder always outputs an {@link Option} type.\n *\n * For more details, see {@link getOptionCodec}.\n *\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The decoder for the value that may be present.\n * @param config - Configuration options for decoding optional values.\n * @returns A `FixedSizeDecoder` or `VariableSizeDecoder` for decoding option values.\n *\n * @example\n * Decoding an optional string with a size prefix.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const decoder = getOptionDecoder(stringCodec);\n *\n * decoder.decode(new Uint8Array([0x01, 0x02, 0x00, 0x00, 0x00, 0x48, 0x69]));\n * // some('Hi')\n *\n * decoder.decode(new Uint8Array([0x00]));\n * // none()\n * ```\n *\n * @see {@link getOptionCodec}\n */\nexport function getOptionDecoder<TTo, TSize extends number>(\n    item: FixedSizeDecoder<TTo, TSize>,\n    config: OptionCodecConfig<NumberDecoder> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeDecoder<Option<TTo>, TSize>;\nexport function getOptionDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: OptionCodecConfig<FixedSizeNumberDecoder> & { noneValue: 'zeroes' },\n): FixedSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: FixedSizeDecoder<TTo>,\n    config: OptionCodecConfig<NumberDecoder> & { noneValue: 'zeroes' },\n): VariableSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: Decoder<TTo>,\n    config?: OptionCodecConfig<NumberDecoder> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeDecoder<Option<TTo>>;\nexport function getOptionDecoder<TTo>(\n    item: Decoder<TTo>,\n    config: OptionCodecConfig<NumberDecoder> = {},\n): Decoder<Option<TTo>> {\n    const prefix = (() => {\n        if (config.prefix === null) {\n            return transformDecoder(getUnitDecoder(), () => false);\n        }\n        return getBooleanDecoder({ size: config.prefix ?? getU8Decoder() });\n    })();\n    const noneValue = (() => {\n        if (config.noneValue === 'zeroes') {\n            assertIsFixedSize(item);\n            return fixDecoderSize(getUnitDecoder(), item.fixedSize);\n        }\n        if (!config.noneValue) {\n            return getUnitDecoder();\n        }\n        return getConstantDecoder(config.noneValue);\n    })();\n\n    return getUnionDecoder(\n        [\n            transformDecoder(getTupleDecoder([prefix, noneValue]), () => none<TTo>()),\n            transformDecoder(getTupleDecoder([prefix, item]), ([, value]) => some(value)),\n        ],\n        (bytes, offset) => {\n            if (config.prefix === null && !config.noneValue) {\n                return Number(offset < bytes.length);\n            }\n            if (config.prefix === null && config.noneValue != null) {\n                const zeroValue =\n                    config.noneValue === 'zeroes' ? new Uint8Array(noneValue.fixedSize).fill(0) : config.noneValue;\n                return containsBytes(bytes, zeroValue, offset) ? 0 : 1;\n            }\n            return Number(prefix.read(bytes, offset)[0]);\n        },\n    );\n}\n\n/**\n * Returns a codec for encoding and decoding optional values using the {@link Option} type.\n *\n * This codec serializes and deserializes `Option<T>` values using a configurable approach:\n * - By default, a `u8` prefix is used (`0 = None`, `1 = Some`).\n * - If `noneValue: 'zeroes'` is set, `None` values are encoded/decoded as zeroes.\n * - If `noneValue` is a byte array, `None` values are represented by the provided constant.\n * - If `prefix: null` is set, the codec determines `None` values solely from `noneValue` or the presence of bytes.\n *\n * For more details on the configuration options, see {@link OptionCodecConfig}.\n *\n * Note that this behaves similarly to {@link getNullableCodec}, except it\n * encodes {@link OptionOrNullable} values and decodes {@link Option} values.\n *\n * @typeParam TFrom - The type of the main value being encoded.\n * @typeParam TTo - The type of the main value being decoded.\n *\n * @param item - The codec for the value that may be present.\n * @param config - Configuration options for encoding and decoding option values.\n * @returns A `FixedSizeCodec` or `VariableSizeCodec` for encoding and decoding option values.\n *\n * @example\n * Encoding and decoding an optional string with a size prefix.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const codec = getOptionCodec(stringCodec);\n *\n * const someBytes = codec.encode(some('Hi'));\n * // 0x01020000004869\n * //   | |       -- utf8 string content (\"Hi\").\n * //   | -- u32 string prefix (2 characters).\n * //   -- 1-byte prefix (Some).\n *\n * const noneBytes = codec.encode(none());\n * // 0x00\n * //   -- 1-byte prefix (None).\n *\n * codec.decode(someBytes); // some('Hi')\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Encoding nullable values.\n * ```ts\n * const stringCodec = addCodecSizePrefix(getUtf8Codec(), getU32Codec());\n * const codec = getOptionCodec(stringCodec);\n *\n * const someBytes = codec.encode('Hi'); // 0x01020000004869\n * const noneBytes = codec.encode(null); // 0x00\n *\n * codec.decode(someBytes); // some('Hi')\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Encoding and decoding an optional number with a fixed size.\n * ```ts\n * const codec = getOptionCodec(getU16Codec(), { noneValue: 'zeroes' });\n *\n * const someBytes = codec.encode(some(42)); // 0x012a00\n * const noneBytes = codec.encode(none());   // 0x000000\n *\n * codec.decode(someBytes); // some(42)\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Encoding and decoding {@link None} values with a custom byte sequence and no prefix.\n * ```ts\n * const codec = getOptionCodec(getU16Codec(), {\n *   noneValue: new Uint8Array([0xff, 0xff]),\n *   prefix: null,\n * });\n *\n * const someBytes = codec.encode(some(42)); // 0x2a00\n * const noneBytes = codec.encode(none());   // 0xffff\n *\n * codec.decode(someBytes); // some(42)\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @example\n * Identifying {@link None} values by the absence of bytes.\n * ```ts\n * const codec = getOptionCodec(getU16Codec(), { prefix: null });\n *\n * const someBytes = codec.encode(some(42)); // 0x2a00\n * const noneBytes = codec.encode(none());   // new Uint8Array(0)\n *\n * codec.decode(someBytes); // some(42)\n * codec.decode(noneBytes); // none()\n * ```\n *\n * @remarks\n * Separate {@link getOptionEncoder} and {@link getOptionDecoder} functions are available.\n *\n * ```ts\n * const bytes = getOptionEncoder(getU32Encoder()).encode(some(42));\n * const value = getOptionDecoder(getU32Decoder()).decode(bytes);\n * ```\n *\n * @see {@link getOptionEncoder}\n * @see {@link getOptionDecoder}\n */\nexport function getOptionCodec<TFrom, TTo extends TFrom, TSize extends number>(\n    item: FixedSizeCodec<TFrom, TTo, TSize>,\n    config: OptionCodecConfig<NumberCodec> & { noneValue: 'zeroes'; prefix: null },\n): FixedSizeCodec<OptionOrNullable<TFrom>, Option<TTo>, TSize>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: OptionCodecConfig<FixedSizeNumberCodec> & { noneValue: 'zeroes' },\n): FixedSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: FixedSizeCodec<TFrom, TTo>,\n    config: OptionCodecConfig<NumberCodec> & { noneValue: 'zeroes' },\n): VariableSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config?: OptionCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array },\n): VariableSizeCodec<OptionOrNullable<TFrom>, Option<TTo>>;\nexport function getOptionCodec<TFrom, TTo extends TFrom = TFrom>(\n    item: Codec<TFrom, TTo>,\n    config: OptionCodecConfig<NumberCodec> = {},\n): Codec<OptionOrNullable<TFrom>, Option<TTo>> {\n    type ConfigCast = OptionCodecConfig<NumberCodec> & { noneValue?: ReadonlyUint8Array };\n    return combineCodec(\n        getOptionEncoder<TFrom>(item, config as ConfigCast),\n        getOptionDecoder<TTo>(item, config as ConfigCast),\n    );\n}\n","import { isOption, isSome, None, Some } from './option';\n\n/**\n * Defines types that should not be recursively unwrapped.\n *\n * These types are preserved as-is when using {@link unwrapOptionRecursively}.\n *\n * @see {@link unwrapOptionRecursively}\n */\ntype UnUnwrappables =\n    | Date\n    | Int8Array\n    | Int16Array\n    | Int32Array\n    | Uint8Array\n    | Uint16Array\n    | Uint32Array\n    | bigint\n    | boolean\n    | number\n    | string\n    | symbol\n    | null\n    | undefined;\n\n/**\n * A type that recursively unwraps nested {@link Option} types.\n *\n * This type resolves all nested {@link Option} values, ensuring\n * that deeply wrapped values are properly extracted.\n *\n * - If `T` is an {@link Option}, it resolves to the contained value.\n * - If `T` is a known primitive or immutable type, it remains unchanged.\n * - If `T` is an object or array, it recursively unwraps any options found.\n *\n * The fallback type `U` (default: `null`) is used in place of `None` values.\n *\n * @typeParam T - The type to be unwrapped.\n * @typeParam U - The fallback type for `None` values (defaults to `null`).\n *\n * @example\n * Resolving nested `Option` types.\n * ```ts\n * UnwrappedOption<Some<Some<string>>>; // string\n * UnwrappedOption<None>;               // null\n * ```\n *\n * @example\n * Resolving options inside objects and arrays.\n * ```ts\n * UnwrappedOption<{ a: Some<number>; b: None }>; // { a: number; b: null }\n * UnwrappedOption<[Some<number>, None]>;         // [number, null]\n * ```\n *\n * @see {@link unwrapOptionRecursively}\n */\nexport type UnwrappedOption<T, U = null> =\n    T extends Some<infer TValue>\n        ? UnwrappedOption<TValue, U>\n        : T extends None\n          ? U\n          : T extends UnUnwrappables\n            ? T\n            : T extends object\n              ? { [key in keyof T]: UnwrappedOption<T[key], U> }\n              : T extends Array<infer TItem>\n                ? Array<UnwrappedOption<TItem, U>>\n                : T;\n\n/**\n * Recursively unwraps all nested {@link Option} types within a value.\n *\n * This function traverses a given value and removes all instances\n * of {@link Option}, replacing them with their contained values.\n *\n * - If an {@link Option} is encountered, its value is extracted.\n * - If an array or object is encountered, its elements are traversed recursively.\n * - If `None` is encountered, it is replaced with the fallback value (default: `null`).\n *\n * @typeParam T - The type of the input value.\n * @typeParam U - The fallback type for `None` values (defaults to `null`).\n *\n * @param input - The value to unwrap.\n * @param fallback - A function that provides a fallback value for `None` options.\n * @returns The recursively unwrapped value.\n *\n * @example\n * Recursively unwrapping nested options.\n * ```ts\n * unwrapOptionRecursively(some(some('Hello World'))); // \"Hello World\"\n * unwrapOptionRecursively(some(none<string>()));      // null\n * ```\n *\n * @example\n * Recursively unwrapping options inside objects and arrays.\n * ```ts\n * unwrapOptionRecursively({\n *   a: 'hello',\n *   b: none(),\n *   c: [{ c1: some(42) }, { c2: none() }],\n * });\n * // { a: \"hello\", b: null, c: [{ c1: 42 }, { c2: null }] }\n * ```\n *\n * @example\n * Using a fallback value for `None` options.\n * ```ts\n * unwrapOptionRecursively(\n *   {\n *     a: 'hello',\n *     b: none(),\n *     c: [{ c1: some(42) }, { c2: none() }],\n *   },\n *   () => 'Default',\n * );\n * // { a: \"hello\", b: \"Default\", c: [{ c1: 42 }, { c2: \"Default\" }] }\n * ```\n *\n * @remarks\n * This function does not mutate objects or arrays.\n *\n * @see {@link Option}\n * @see {@link UnwrappedOption}\n */\nexport function unwrapOptionRecursively<T>(input: T): UnwrappedOption<T>;\nexport function unwrapOptionRecursively<T, U>(input: T, fallback: () => U): UnwrappedOption<T, U>;\nexport function unwrapOptionRecursively<T, U = null>(input: T, fallback?: () => U): UnwrappedOption<T, U> {\n    // Types to bypass.\n    if (!input || ArrayBuffer.isView(input)) {\n        return input as UnwrappedOption<T, U>;\n    }\n\n    const next = <X>(x: X) =>\n        (fallback ? unwrapOptionRecursively(x, fallback) : unwrapOptionRecursively(x)) as UnwrappedOption<X, U>;\n\n    // Handle Option.\n    if (isOption(input)) {\n        if (isSome(input)) return next(input.value) as UnwrappedOption<T, U>;\n        return (fallback ? fallback() : null) as UnwrappedOption<T, U>;\n    }\n\n    // Walk.\n    if (Array.isArray(input)) {\n        return input.map(next) as UnwrappedOption<T, U>;\n    }\n    if (typeof input === 'object') {\n        return Object.fromEntries(Object.entries(input).map(([k, v]) => [k, next(v)])) as UnwrappedOption<T, U>;\n    }\n    return input as UnwrappedOption<T, U>;\n}\n","import { SolanaError, SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT, SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT, SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED, SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND, SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND } from '@solana/errors';\nimport { getBase64Encoder, getBase58Encoder } from '@solana/codecs-strings';\n\n// src/account.ts\nvar BASE_ACCOUNT_SIZE = 128;\nfunction decodeAccount(encodedAccount, decoder) {\n  try {\n    if (\"exists\" in encodedAccount && !encodedAccount.exists) {\n      return encodedAccount;\n    }\n    return Object.freeze({ ...encodedAccount, data: decoder.decode(encodedAccount.data) });\n  } catch {\n    throw new SolanaError(SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT, {\n      address: encodedAccount.address\n    });\n  }\n}\nfunction accountExists(account) {\n  return !(\"exists\" in account) || \"exists\" in account && account.exists;\n}\nfunction assertAccountDecoded(account) {\n  if (accountExists(account) && account.data instanceof Uint8Array) {\n    throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT, {\n      address: account.address\n    });\n  }\n}\nfunction assertAccountsDecoded(accounts) {\n  const encoded = accounts.filter((a) => accountExists(a) && a.data instanceof Uint8Array);\n  if (encoded.length > 0) {\n    const encodedAddresses = encoded.map((a) => a.address);\n    throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED, {\n      addresses: encodedAddresses\n    });\n  }\n}\nfunction parseBase64RpcAccount(address, rpcAccount) {\n  if (!rpcAccount) return Object.freeze({ address, exists: false });\n  const data = getBase64Encoder().encode(rpcAccount.data[0]);\n  return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\nfunction parseBase58RpcAccount(address, rpcAccount) {\n  if (!rpcAccount) return Object.freeze({ address, exists: false });\n  const data = getBase58Encoder().encode(typeof rpcAccount.data === \"string\" ? rpcAccount.data : rpcAccount.data[0]);\n  return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\nfunction parseJsonRpcAccount(address, rpcAccount) {\n  if (!rpcAccount) return Object.freeze({ address, exists: false });\n  const data = rpcAccount.data.parsed.info;\n  return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\nfunction parseBaseAccount(rpcAccount) {\n  return Object.freeze({\n    executable: rpcAccount.executable,\n    lamports: rpcAccount.lamports,\n    programAddress: rpcAccount.owner,\n    space: rpcAccount.space\n  });\n}\n\n// src/fetch-account.ts\nasync function fetchEncodedAccount(rpc, address, config = {}) {\n  const { abortSignal, ...rpcConfig } = config;\n  const response = await rpc.getAccountInfo(address, { ...rpcConfig, encoding: \"base64\" }).send({ abortSignal });\n  return parseBase64RpcAccount(address, response.value);\n}\nasync function fetchJsonParsedAccount(rpc, address, config = {}) {\n  const { abortSignal, ...rpcConfig } = config;\n  const { value: account } = await rpc.getAccountInfo(address, { ...rpcConfig, encoding: \"jsonParsed\" }).send({ abortSignal });\n  return !!account && typeof account === \"object\" && \"parsed\" in account.data ? parseJsonRpcAccount(address, account) : parseBase64RpcAccount(address, account);\n}\nasync function fetchEncodedAccounts(rpc, addresses, config = {}) {\n  const { abortSignal, ...rpcConfig } = config;\n  const response = await rpc.getMultipleAccounts(addresses, { ...rpcConfig, encoding: \"base64\" }).send({ abortSignal });\n  return response.value.map((account, index) => parseBase64RpcAccount(addresses[index], account));\n}\nasync function fetchJsonParsedAccounts(rpc, addresses, config = {}) {\n  const { abortSignal, ...rpcConfig } = config;\n  const response = await rpc.getMultipleAccounts(addresses, { ...rpcConfig, encoding: \"jsonParsed\" }).send({ abortSignal });\n  return response.value.map((account, index) => {\n    return !!account && typeof account === \"object\" && \"parsed\" in account.data ? parseJsonRpcAccount(addresses[index], account) : parseBase64RpcAccount(addresses[index], account);\n  });\n}\nfunction assertAccountExists(account) {\n  if (!account.exists) {\n    throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND, { address: account.address });\n  }\n}\nfunction assertAccountsExist(accounts) {\n  const missingAccounts = accounts.filter((a) => !a.exists);\n  if (missingAccounts.length > 0) {\n    const missingAddresses = missingAccounts.map((a) => a.address);\n    throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND, { addresses: missingAddresses });\n  }\n}\n\nexport { BASE_ACCOUNT_SIZE, assertAccountDecoded, assertAccountExists, assertAccountsDecoded, assertAccountsExist, decodeAccount, fetchEncodedAccount, fetchEncodedAccounts, fetchJsonParsedAccount, fetchJsonParsedAccounts, parseBase58RpcAccount, parseBase64RpcAccount, parseJsonRpcAccount };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","import type { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport type { Lamports } from '@solana/rpc-types';\n\n/**\n * The number of bytes required to store the {@link BaseAccount} information without its data.\n *\n * @example\n * ```ts\n * const myTotalAccountSize = myAccountDataSize + BASE_ACCOUNT_SIZE;\n * ```\n */\nexport const BASE_ACCOUNT_SIZE = 128;\n\n/**\n * Defines the attributes common to all Solana accounts. Namely, it contains everything stored\n * on-chain except the account data itself.\n *\n * @interface\n *\n * @example\n * ```ts\n * const BaseAccount: BaseAccount = {\n *     executable: false,\n *     lamports: lamports(1_000_000_000n),\n *     programAddress: address('1111..1111'),\n *     space: 42n,\n * };\n * ```\n */\nexport type BaseAccount = {\n    readonly executable: boolean;\n    readonly lamports: Lamports;\n    readonly programAddress: Address;\n    readonly space: bigint;\n};\n\n/**\n * Contains all the information relevant to a Solana account. It includes the account's address and\n * data, as well as the properties of {@link BaseAccount}.\n *\n * @interface\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * // Encoded\n * const myEncodedAccount: Account<Uint8Array, '1234..5678'> = {\n *     address: address('1234..5678'),\n *     data: new Uint8Array([1, 2, 3]),\n *     executable: false,\n *     lamports: lamports(1_000_000_000n),\n *     programAddress: address('1111..1111'),\n *     space: 42n,\n * };\n *\n * // Decoded\n * type MyAccountData = { name: string; age: number };\n * const myDecodedAccount: Account<MyAccountData, '1234..5678'> = {\n *     address: address('1234..5678'),\n *     data: { name: 'Alice', age: 30 },\n *     executable: false,\n *     lamports: lamports(1_000_000_000n),\n *     programAddress: address('1111..1111'),\n *     space: 42n,\n * };\n * ```\n */\nexport type Account<TData extends Uint8Array | object, TAddress extends string = string> = BaseAccount & {\n    readonly address: Address<TAddress>;\n    readonly data: TData;\n};\n\n/**\n * Represents an encoded account and is equivalent to an {@link Account} with `Uint8Array` account\n * data.\n *\n * @interface\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * {\n *     address: address('1234..5678'),\n *     data: new Uint8Array([1, 2, 3]),\n *     executable: false,\n *     lamports: lamports(1_000_000_000n),\n *     programAddress: address('1111..1111'),\n *     space: 42n,\n * } satisfies EncodedAccount<'1234..5678'>;\n * ```\n */\nexport type EncodedAccount<TAddress extends string = string> = Account<ReadonlyUint8Array, TAddress>;\n","import type { Decoder, ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED,\n    SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT,\n    SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT,\n    SolanaError,\n} from '@solana/errors';\n\nimport type { Account, EncodedAccount } from './account';\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\n\n/**\n * Transforms an {@link EncodedAccount} into an {@link Account} (or a {@link MaybeEncodedAccount}\n * into a {@link MaybeAccount}) by decoding the account data using the provided {@link Decoder}\n * instance.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The type of this account's data.\n *\n * @example\n * ```ts\n * type MyAccountData = { name: string; age: number };\n *\n * const myAccount: EncodedAccount<'1234..5678'>;\n * const myDecoder: Decoder<MyAccountData> = getStructDecoder([\n *     ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],\n *     ['age', getU32Decoder()],\n * ]);\n *\n * const myDecodedAccount = decodeAccount(myAccount, myDecoder);\n * myDecodedAccount satisfies Account<MyAccountData, '1234..5678'>;\n * ```\n */\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: EncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): Account<TData, TAddress>;\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: MaybeEncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): MaybeAccount<TData, TAddress>;\nexport function decodeAccount<TData extends object, TAddress extends string = string>(\n    encodedAccount: EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress>,\n    decoder: Decoder<TData>,\n): Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    try {\n        if ('exists' in encodedAccount && !encodedAccount.exists) {\n            return encodedAccount;\n        }\n        return Object.freeze({ ...encodedAccount, data: decoder.decode(encodedAccount.data) });\n    } catch {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT, {\n            address: encodedAccount.address,\n        });\n    }\n}\n\nfunction accountExists<TData extends object>(account: Account<TData> | MaybeAccount<TData>): account is Account<TData> {\n    return !('exists' in account) || ('exists' in account && account.exists);\n}\n\n/**\n * Asserts that an account stores decoded data, ie. not a `Uint8Array`.\n *\n * Note that it does not check the shape of the data matches the decoded type, only that it is not a\n * `Uint8Array`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The type of this account's data.\n *\n * @example\n * ```ts\n * type MyAccountData = { name: string; age: number };\n *\n * const myAccount: Account<MyAccountData | Uint8Array, '1234..5678'>;\n * assertAccountDecoded(myAccount);\n *\n * // now the account data can be used as MyAccountData\n * account.data satisfies MyAccountData;\n * ```\n *\n * This is particularly useful for narrowing the result of fetching a JSON parsed account.\n *\n * ```ts\n * const account: MaybeAccount<MockData | Uint8Array> = await fetchJsonParsedAccount<MockData>(\n *     rpc,\n *     '1234..5678' as Address,\n * );\n *\n * assertAccountDecoded(account);\n * // now we have a MaybeAccount<MockData>\n * account satisfies MaybeAccount<MockData>;\n * ```\n */\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: Account<TData | Uint8Array, TAddress>,\n): asserts account is Account<TData, TAddress>;\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: MaybeAccount<TData | Uint8Array, TAddress>,\n): asserts account is MaybeAccount<TData, TAddress>;\nexport function assertAccountDecoded<TData extends object, TAddress extends string = string>(\n    account: Account<TData | Uint8Array, TAddress> | MaybeAccount<TData | Uint8Array, TAddress>,\n): asserts account is Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    if (accountExists(account) && account.data instanceof Uint8Array) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT, {\n            address: account.address,\n        });\n    }\n}\n\n/**\n * Asserts that all input accounts store decoded data, ie. not a `Uint8Array`.\n *\n * As with {@link assertAccountDecoded} it does not check the shape of the data matches the decoded\n * type, only that it is not a `Uint8Array`.\n *\n * @example\n * ```ts\n * type MyAccountData = { name: string; age: number };\n *\n * const myAccounts: Account<MyAccountData | Uint8Array, Address>[];\n * assertAccountsDecoded(myAccounts);\n *\n * // now the account data can be used as MyAccountData\n * for (const a of account) {\n *     account.data satisfies MyAccountData;\n * }\n * ```\n */\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: Account<ReadonlyUint8Array | TData, TAddress>[],\n): asserts accounts is Account<TData, TAddress>[];\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: MaybeAccount<ReadonlyUint8Array | TData, TAddress>[],\n): asserts accounts is MaybeAccount<TData, TAddress>[];\nexport function assertAccountsDecoded<TData extends object, TAddress extends string = string>(\n    accounts: (Account<ReadonlyUint8Array | TData, TAddress> | MaybeAccount<ReadonlyUint8Array | TData, TAddress>)[],\n): asserts accounts is (Account<TData, TAddress> | MaybeAccount<TData, TAddress>)[] {\n    const encoded = accounts.filter(a => accountExists(a) && a.data instanceof Uint8Array);\n    if (encoded.length > 0) {\n        const encodedAddresses = encoded.map(a => a.address);\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED, {\n            addresses: encodedAddresses,\n        });\n    }\n}\n","import type { Address } from '@solana/addresses';\nimport { getBase58Encoder, getBase64Encoder } from '@solana/codecs-strings';\nimport type {\n    AccountInfoBase,\n    AccountInfoWithBase58Bytes,\n    AccountInfoWithBase58EncodedData,\n    AccountInfoWithBase64EncodedData,\n} from '@solana/rpc-types';\n\nimport type { Account, BaseAccount, EncodedAccount } from './account';\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\nimport type { JsonParsedDataResponse } from './rpc-api';\n\ntype Base64EncodedRpcAccount = AccountInfoBase & AccountInfoWithBase64EncodedData;\n\n/**\n * Parses a base64-encoded account provided by the RPC client into an {@link EncodedAccount} type or\n * a {@link MaybeEncodedAccount} type if the raw data can be set to `null`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * const myAddress = address('1234..5678');\n * const myRpcAccount = await rpc.getAccountInfo(myAddress, { encoding: 'base64' }).send();\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = parseBase64RpcAccount(myRpcAccount);\n * ```\n */\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount,\n): EncodedAccount<TAddress>;\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount | null,\n): MaybeEncodedAccount<TAddress>;\nexport function parseBase64RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base64EncodedRpcAccount | null,\n): EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = getBase64Encoder().encode(rpcAccount.data[0]);\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\ntype Base58EncodedRpcAccount = AccountInfoBase & (AccountInfoWithBase58Bytes | AccountInfoWithBase58EncodedData);\n\n/**\n * Parses a base58-encoded account provided by the RPC client into an {@link EncodedAccount} type or\n * a {@link MaybeEncodedAccount} type if the raw data can be set to `null`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * const myAddress = address('1234..5678');\n * const myRpcAccount = await rpc.getAccountInfo(myAddress, { encoding: 'base58' }).send();\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = parseBase58RpcAccount(myRpcAccount);\n * ```\n */\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount,\n): EncodedAccount<TAddress>;\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount | null,\n): MaybeEncodedAccount<TAddress>;\nexport function parseBase58RpcAccount<TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: Base58EncodedRpcAccount | null,\n): EncodedAccount<TAddress> | MaybeEncodedAccount<TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = getBase58Encoder().encode(typeof rpcAccount.data === 'string' ? rpcAccount.data : rpcAccount.data[0]);\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\ntype JsonParsedRpcAccount = AccountInfoBase & { readonly data: JsonParsedDataResponse<unknown> };\n\n/**\n * Parses an arbitrary `jsonParsed` account provided by the RPC client into an {@link Account} type\n * or a {@link MaybeAccount} type if the raw data can be set to `null`.\n *\n * The expected data type should be explicitly provided as the first type parameter.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The expected type of this account's data.\n *\n * @example\n * ```ts\n * const myAccount: Account<MyData> = parseJsonRpcAccount<MyData>(myJsonRpcAccount);\n * ```\n */\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount,\n): Account<TData, TAddress>;\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount | null,\n): MaybeAccount<TData, TAddress>;\nexport function parseJsonRpcAccount<TData extends object, TAddress extends string = string>(\n    address: Address<TAddress>,\n    rpcAccount: JsonParsedRpcAccount | null,\n): Account<TData, TAddress> | MaybeAccount<TData, TAddress> {\n    if (!rpcAccount) return Object.freeze({ address, exists: false });\n    const data = rpcAccount.data.parsed.info as TData;\n    return Object.freeze({ ...parseBaseAccount(rpcAccount), address, data, exists: true });\n}\n\nfunction parseBaseAccount(rpcAccount: AccountInfoBase): BaseAccount {\n    return Object.freeze({\n        executable: rpcAccount.executable,\n        lamports: rpcAccount.lamports,\n        programAddress: rpcAccount.owner,\n        space: rpcAccount.space,\n    });\n}\n","import type { Address } from '@solana/addresses';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Commitment, Slot } from '@solana/rpc-types';\n\nimport type { MaybeAccount, MaybeEncodedAccount } from './maybe-account';\nimport { parseBase64RpcAccount, parseJsonRpcAccount } from './parse-account';\nimport type { GetAccountInfoApi, GetMultipleAccountsApi } from './rpc-api';\n\n/**\n * Optional configuration for fetching a singular account.\n *\n * @interface\n */\nexport type FetchAccountConfig = {\n    abortSignal?: AbortSignal;\n    /**\n     * Fetch the details of the account as of the highest slot that has reached this level of\n     * commitment.\n     *\n     * @defaultValue Whichever default is applied by the underlying {@link RpcApi} in use. For\n     * example, when using an API created by a `createSolanaRpc*()` helper, the default commitment\n     * is `\"confirmed\"` unless configured otherwise. Unmitigated by an API layer on the client, the\n     * default commitment applied by the server is `\"finalized\"`.\n     */\n    commitment?: Commitment;\n    /**\n     * Prevents accessing stale data by enforcing that the RPC node has processed transactions up to\n     * this slot\n     */\n    minContextSlot?: Slot;\n};\n\n/**\n * Fetches a {@link MaybeEncodedAccount} from the provided RPC client and address.\n *\n * It uses the {@link GetAccountInfoApi.getAccountInfo | getAccountInfo} RPC method under the hood\n * with base64 encoding and an additional configuration object can be provided to customize the\n * behavior of the RPC call.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * const myAddress = address('1234..5678');\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = await fetchEncodedAccount(rpc, myAddress);\n *\n * // With custom configuration.\n * const myAccount: MaybeEncodedAccount<'1234..5678'> = await fetchEncodedAccount(rpc, myAddress, {\n *     abortSignal: myAbortController.signal,\n *     commitment: 'confirmed',\n * });\n * ```\n */\nexport async function fetchEncodedAccount<TAddress extends string = string>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: Address<TAddress>,\n    config: FetchAccountConfig = {},\n): Promise<MaybeEncodedAccount<TAddress>> {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc.getAccountInfo(address, { ...rpcConfig, encoding: 'base64' }).send({ abortSignal });\n    return parseBase64RpcAccount(address, response.value);\n}\n\n/**\n * Fetches a {@link MaybeAccount} from the provided RPC client and address by using\n * {@link GetAccountInfoApi.getAccountInfo | getAccountInfo} under the hood with the `jsonParsed`\n * encoding.\n *\n * It may also return a {@link MaybeEncodedAccount} if the RPC client does not know how to parse the\n * account at the requested address. In any case, the expected data type should be explicitly\n * provided as the first type parameter.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The expected type of this account's data.\n *\n * @example\n * ```ts\n * type TokenData = { mint: Address; owner: Address };\n * const myAccount = await fetchJsonParsedAccount<TokenData>(rpc, myAddress);\n * myAccount satisfies MaybeAccount<TokenData> | MaybeEncodedAccount;\n *\n * // With custom configuration.\n * const myAccount = await fetchJsonParsedAccount<TokenData>(rpc, myAddress, {\n *     abortSignal: myAbortController.signal,\n *     commitment: 'confirmed',\n * });\n * ```\n */\nexport async function fetchJsonParsedAccount<TData extends object, TAddress extends string = string>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: Address<TAddress>,\n    config: FetchAccountConfig = {},\n): Promise<MaybeAccount<TData, TAddress> | MaybeEncodedAccount<TAddress>> {\n    const { abortSignal, ...rpcConfig } = config;\n    const { value: account } = await rpc\n        .getAccountInfo(address, { ...rpcConfig, encoding: 'jsonParsed' })\n        .send({ abortSignal });\n    return !!account && typeof account === 'object' && 'parsed' in account.data\n        ? parseJsonRpcAccount<TData, TAddress>(address, account as Parameters<typeof parseJsonRpcAccount>[1])\n        : parseBase64RpcAccount<TAddress>(address, account as Parameters<typeof parseBase64RpcAccount>[1]);\n}\n\n/**\n * Optional configuration for fetching multiple accounts.\n *\n * @interface\n */\nexport type FetchAccountsConfig = {\n    abortSignal?: AbortSignal;\n    /**\n     * Fetch the details of the accounts as of the highest slot that has reached this level of\n     * commitment.\n     *\n     * @defaultValue Whichever default is applied by the underlying {@link RpcApi} in use. For\n     * example, when using an API created by a `createSolanaRpc*()` helper, the default commitment\n     * is `\"confirmed\"` unless configured otherwise. Unmitigated by an API layer on the client, the\n     * default commitment applied by the server is `\"finalized\"`.\n     */\n    commitment?: Commitment;\n    /**\n     * Prevents accessing stale data by enforcing that the RPC node has processed transactions up to\n     * this slot\n     */\n    minContextSlot?: Slot;\n};\n\n/**\n * Fetches an array of {@link MaybeEncodedAccount | MaybeEncodedAccounts} from the provided RPC\n * client and an array of addresses.\n *\n * It uses the {@link GetMultipleAccountsApi#getMultipleAccounts | getMultipleAccounts} RPC method\n * under the hood with base64 encodings and an additional configuration object can be provided to\n * customize the behavior of the RPC call.\n *\n * @typeParam TAddresses - Supply an array of string literals to define accounts having particular\n * addresses.\n *\n * @example\n * ```ts\n * const myAddressA = address('1234..5678');\n * const myAddressB = address('8765..4321');\n * const [myAccountA, myAccountB] = await fetchEncodedAccounts(rpc, [myAddressA, myAddressB]);\n * myAccountA satisfies MaybeEncodedAccount<'1234..5678'>;\n * myAccountB satisfies MaybeEncodedAccount<'8765..4321'>;\n *\n * // With custom configuration.\n * const [myAccountA, myAccountB] = await fetchEncodedAccounts(rpc, [myAddressA, myAddressB], {\n *     abortSignal: myAbortController.signal,\n *     commitment: 'confirmed',\n * });\n * ```\n */\nexport async function fetchEncodedAccounts<\n    TAddresses extends string[] = string[],\n    TWrappedAddresses extends { [P in keyof TAddresses]: Address<TAddresses[P]> } = {\n        [P in keyof TAddresses]: Address<TAddresses[P]>;\n    },\n>(rpc: Rpc<GetMultipleAccountsApi>, addresses: TWrappedAddresses, config: FetchAccountsConfig = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc\n        .getMultipleAccounts(addresses, { ...rpcConfig, encoding: 'base64' })\n        .send({ abortSignal });\n    return response.value.map((account, index) => parseBase64RpcAccount(addresses[index], account)) as {\n        [P in keyof TAddresses]: MaybeEncodedAccount<TAddresses[P]>;\n    };\n}\n\n/**\n * Fetches an array of {@link MaybeAccount | MaybeAccounts} from a provided RPC client and an array\n * of addresses.\n *\n * It uses the {@link GetMultipleAccountsApi#getMultipleAccounts | getMultipleAccounts} RPC method\n * under the hood with the `jsonParsed` encoding. It may also return a\n * {@link MaybeEncodedAccount} instead of the expected {@link MaybeAccount} if the RPC client does\n * not know how to parse some of the requested accounts. In any case, the array of expected data\n * types should be explicitly provided as the first type parameter.\n *\n * @typeParam TAddresses - Supply an array of string literals to define accounts having particular\n * addresses.\n * @typeParam TData - The expected types of these accounts' data.\n \n * @example\n * ```ts\n * type TokenData = { mint: Address; owner: Address };\n * type MintData = { supply: bigint };\n * const [myAccountA, myAccountB] = await fetchJsonParsedAccounts<[TokenData, MintData]>(rpc, [myAddressA, myAddressB]);\n * myAccountA satisfies MaybeAccount<TokenData> | MaybeEncodedAccount;\n * myAccountB satisfies MaybeAccount<MintData> | MaybeEncodedAccount;\n * ```\n */\nexport async function fetchJsonParsedAccounts<\n    TData extends object[],\n    TAddresses extends string[] = string[],\n    TWrappedAddresses extends { [P in keyof TAddresses]: Address<TAddresses[P]> } = {\n        [P in keyof TAddresses]: Address<TAddresses[P]>;\n    },\n>(rpc: Rpc<GetMultipleAccountsApi>, addresses: TWrappedAddresses, config: FetchAccountsConfig = {}) {\n    const { abortSignal, ...rpcConfig } = config;\n    const response = await rpc\n        .getMultipleAccounts(addresses, { ...rpcConfig, encoding: 'jsonParsed' })\n        .send({ abortSignal });\n    return response.value.map((account, index) => {\n        return !!account && typeof account === 'object' && 'parsed' in account.data\n            ? parseJsonRpcAccount(addresses[index], account as Parameters<typeof parseJsonRpcAccount>[1])\n            : parseBase64RpcAccount(addresses[index], account as Parameters<typeof parseBase64RpcAccount>[1]);\n    }) as {\n        [P in keyof TAddresses]:\n            | MaybeAccount<TData[P & keyof TData], TAddresses[P]>\n            | MaybeEncodedAccount<TAddresses[P]>;\n    } & {\n        [P in keyof TData]:\n            | MaybeAccount<TData[P], TAddresses[P & keyof TAddresses]>\n            | MaybeEncodedAccount<TAddresses[P & keyof TAddresses]>;\n    };\n}\n","import { Address } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND,\n    SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\n\nimport { Account } from './account';\n\n/**\n * Represents an account that may or may not exist on-chain.\n *\n * When the account exists, it is represented as an {@link Account} type with an additional `exists`\n * attribute set to `true`. When it does not exist, it is represented by an object containing only\n * the address of the account and an `exists` attribute set to `false`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * // Account exists\n * const myExistingAccount: MaybeAccount<MyAccountData, '1234..5678'> = {\n *     exists: true,\n *     address: address('1234..5678'),\n *     data: { name: 'Alice', age: 30 },\n *     // ...\n * };\n *\n * // Account does not exist\n * const myMissingAccount: MaybeAccount<MyAccountData, '8765..4321'> = {\n *     exists: false,\n *     address: address('8765..4321'),\n * };\n * ```\n */\nexport type MaybeAccount<TData extends Uint8Array | object, TAddress extends string = string> =\n    | { readonly address: Address<TAddress>; readonly exists: false }\n    | (Account<TData, TAddress> & { readonly exists: true });\n\n/**\n * Represents an encoded account that may or may not exist on-chain.\n *\n * When the account exists, it is represented as an {@link Account} type having its `TData` type\n * parameter set to `Uint8Array` with an additional `exists` attribute set to `true`. When it does\n * not exist, it is represented by an object containing only the address of the account and an\n * `exists` attribute set to `false`.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n *\n * @example\n * ```ts\n * // Encoded account exists\n * const myExistingAccount: MaybeEncodedAccount<'1234..5678'> = {\n *     exists: true,\n *     address: address('1234..5678'),\n *     data: new Uint8Array([1, 2, 3]),\n *     // ...\n * };\n *\n * // Encoded account does not exist\n * const myMissingAccount: MaybeEncodedAccount<'8765..4321'> = {\n *     exists: false,\n *     address: address('8765..4321'),\n * };\n * ```\n */\nexport type MaybeEncodedAccount<TAddress extends string = string> = MaybeAccount<Uint8Array, TAddress>;\n\n/**\n * Given a {@link MaybeAccount}, asserts that the account exists and allows it to be used as an\n * {@link Account} type going forward.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * const myAccount: MaybeEncodedAccount<'1234..5678'>;\n * assertAccountExists(myAccount);\n *\n * // Now we can use myAccount as an `EncodedAccount`\n * myAccount satisfies EncodedAccount<'1234..5678'>;\n * ```\n */\nexport function assertAccountExists<TData extends Uint8Array | object, TAddress extends string = string>(\n    account: MaybeAccount<TData, TAddress>,\n): asserts account is Account<TData, TAddress> & { exists: true } {\n    if (!account.exists) {\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND, { address: account.address });\n    }\n}\n\n/**\n * Given an array of {@link MaybeAccount | MaybeAccounts}, asserts that all the accounts exist and\n * allows them to be used as an array of {@link Account | Accounts} going forward.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TData - The nature of this account's data. It can be represented as either a\n * `Uint8Array` &ndash; meaning the account is encoded &ndash; or a custom data type &ndash; meaning\n * the account is decoded.\n *\n * @example\n * ```ts\n * const myAccounts: MaybeEncodedAccount<Address>[];\n * assertAccountsExist(myAccounts);\n *\n * // Now we can use them as an array of `EncodedAccounts`\n * for (const a of myAccounts) {\n *     a satisfies EncodedAccount<Address>;\n * }\n * ```\n */\nexport function assertAccountsExist<TData extends Uint8Array | object, TAddress extends string = string>(\n    accounts: MaybeAccount<TData, TAddress>[],\n): asserts accounts is (Account<TData, TAddress> & { exists: true })[] {\n    const missingAccounts = accounts.filter(a => !a.exists);\n    if (missingAccounts.length > 0) {\n        const missingAddresses = missingAccounts.map(a => a.address);\n        throw new SolanaError(SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND, { addresses: missingAddresses });\n    }\n}\n","import { isSolanaError, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM } from '@solana/errors';\n\n// src/program-error.ts\nfunction isProgramError(error, transactionMessage, programAddress, code) {\n  if (!isSolanaError(error, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM)) {\n    return false;\n  }\n  const instructionProgramAddress = transactionMessage.instructions[error.context.index]?.programAddress;\n  if (!instructionProgramAddress || instructionProgramAddress !== programAddress) {\n    return false;\n  }\n  return typeof code === \"undefined\" || error.context.code === code;\n}\n\nexport { isProgramError };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","import type { Address } from '@solana/addresses';\nimport { isSolanaError, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM, SolanaError } from '@solana/errors';\n\n/**\n * Identifies whether an error -- typically caused by a transaction failure -- is a custom program\n * error from the provided program address.\n *\n * @param transactionMessage The transaction message that failed to execute. Since the RPC response\n * only provides the index of the failed instruction, the transaction message is required to\n * determine its program address\n * @param programAddress The address of the program from which the error is expected to have\n * originated\n * @param code The expected error code of the custom program error. When provided, the function will\n * check that the custom program error code matches the given value.\n *\n * @example\n * ```ts\n * try {\n *     // Send and confirm your transaction.\n * } catch (error) {\n *     if (isProgramError(error, transactionMessage, myProgramAddress, 42)) {\n *         // Handle custom program error 42 from this program.\n *     } else if (isProgramError(error, transactionMessage, myProgramAddress)) {\n *         // Handle all other custom program errors from this program.\n *     } else {\n *         throw error;\n *     }\n * }\n * ```\n */\nexport function isProgramError<TProgramErrorCode extends number>(\n    error: unknown,\n    transactionMessage: { instructions: Record<number, { programAddress: Address }> },\n    programAddress: Address,\n    code?: TProgramErrorCode,\n): error is Readonly<{ context: Readonly<{ code: TProgramErrorCode }> }> &\n    SolanaError<typeof SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM> {\n    if (!isSolanaError(error, SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM)) {\n        return false;\n    }\n    const instructionProgramAddress = transactionMessage.instructions[error.context.index]?.programAddress;\n    if (!instructionProgramAddress || instructionProgramAddress !== programAddress) {\n        return false;\n    }\n    return typeof code === 'undefined' || error.context.code === code;\n}\n","import { SolanaError, SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH, SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS, SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA } from '@solana/errors';\n\n// src/instruction.ts\nfunction isInstructionForProgram(instruction, programAddress) {\n  return instruction.programAddress === programAddress;\n}\nfunction assertIsInstructionForProgram(instruction, programAddress) {\n  if (instruction.programAddress !== programAddress) {\n    throw new SolanaError(SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH, {\n      actualProgramAddress: instruction.programAddress,\n      expectedProgramAddress: programAddress\n    });\n  }\n}\nfunction isInstructionWithAccounts(instruction) {\n  return instruction.accounts !== void 0;\n}\nfunction assertIsInstructionWithAccounts(instruction) {\n  if (instruction.accounts === void 0) {\n    throw new SolanaError(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS, {\n      data: instruction.data,\n      programAddress: instruction.programAddress\n    });\n  }\n}\nfunction isInstructionWithData(instruction) {\n  return instruction.data !== void 0;\n}\nfunction assertIsInstructionWithData(instruction) {\n  if (instruction.data === void 0) {\n    throw new SolanaError(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA, {\n      accountAddresses: instruction.accounts?.map((a) => a.address),\n      programAddress: instruction.programAddress\n    });\n  }\n}\n\n// src/roles.ts\nvar AccountRole = /* @__PURE__ */ ((AccountRole2) => {\n  AccountRole2[AccountRole2[\"WRITABLE_SIGNER\"] = /* 3 */\n  3] = \"WRITABLE_SIGNER\";\n  AccountRole2[AccountRole2[\"READONLY_SIGNER\"] = /* 2 */\n  2] = \"READONLY_SIGNER\";\n  AccountRole2[AccountRole2[\"WRITABLE\"] = /* 1 */\n  1] = \"WRITABLE\";\n  AccountRole2[AccountRole2[\"READONLY\"] = /* 0 */\n  0] = \"READONLY\";\n  return AccountRole2;\n})(AccountRole || {});\nvar IS_SIGNER_BITMASK = 2;\nvar IS_WRITABLE_BITMASK = 1;\nfunction downgradeRoleToNonSigner(role) {\n  return role & -3;\n}\nfunction downgradeRoleToReadonly(role) {\n  return role & -2;\n}\nfunction isSignerRole(role) {\n  return role >= 2 /* READONLY_SIGNER */;\n}\nfunction isWritableRole(role) {\n  return (role & IS_WRITABLE_BITMASK) !== 0;\n}\nfunction mergeRoles(roleA, roleB) {\n  return roleA | roleB;\n}\nfunction upgradeRoleToSigner(role) {\n  return role | IS_SIGNER_BITMASK;\n}\nfunction upgradeRoleToWritable(role) {\n  return role | IS_WRITABLE_BITMASK;\n}\n\nexport { AccountRole, assertIsInstructionForProgram, assertIsInstructionWithAccounts, assertIsInstructionWithData, downgradeRoleToNonSigner, downgradeRoleToReadonly, isInstructionForProgram, isInstructionWithAccounts, isInstructionWithData, isSignerRole, isWritableRole, mergeRoles, upgradeRoleToSigner, upgradeRoleToWritable };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS,\n    SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA,\n    SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH,\n    SolanaError,\n} from '@solana/errors';\n\nimport { AccountLookupMeta, AccountMeta } from './accounts';\n\n/**\n * An instruction destined for a given program.\n *\n * @example\n * ```ts\n * type StakeProgramInstruction = Instruction<'StakeConfig11111111111111111111111111111111'>;\n * ```\n */\nexport interface Instruction<\n    TProgramAddress extends string = string,\n    TAccounts extends readonly (AccountLookupMeta | AccountMeta)[] = readonly (AccountLookupMeta | AccountMeta)[],\n> {\n    readonly accounts?: TAccounts;\n    readonly data?: ReadonlyUint8Array;\n    readonly programAddress: Address<TProgramAddress>;\n}\n\n/**\n * An instruction that loads certain accounts.\n *\n * @example\n * ```ts\n * type InstructionWithTwoAccounts = InstructionWithAccounts<\n *     [\n *         WritableAccount, // First account\n *         RentSysvar, // Second account\n *     ]\n * >;\n * ```\n */\nexport interface InstructionWithAccounts<TAccounts extends readonly (AccountLookupMeta | AccountMeta)[]>\n    extends Instruction {\n    readonly accounts: TAccounts;\n}\n\nexport function isInstructionForProgram<TProgramAddress extends string, TInstruction extends Instruction>(\n    instruction: TInstruction,\n    programAddress: Address<TProgramAddress>,\n): instruction is TInstruction & { programAddress: Address<TProgramAddress> } {\n    return instruction.programAddress === programAddress;\n}\n\nexport function assertIsInstructionForProgram<TProgramAddress extends string, TInstruction extends Instruction>(\n    instruction: TInstruction,\n    programAddress: Address<TProgramAddress>,\n): asserts instruction is TInstruction & { programAddress: Address<TProgramAddress> } {\n    if (instruction.programAddress !== programAddress) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH, {\n            actualProgramAddress: instruction.programAddress,\n            expectedProgramAddress: programAddress,\n        });\n    }\n}\n\nexport function isInstructionWithAccounts<\n    TAccounts extends readonly (AccountLookupMeta | AccountMeta)[] = readonly (AccountLookupMeta | AccountMeta)[],\n    TInstruction extends Instruction = Instruction,\n>(instruction: TInstruction): instruction is InstructionWithAccounts<TAccounts> & TInstruction {\n    return instruction.accounts !== undefined;\n}\n\nexport function assertIsInstructionWithAccounts<\n    TAccounts extends readonly (AccountLookupMeta | AccountMeta)[] = readonly (AccountLookupMeta | AccountMeta)[],\n    TInstruction extends Instruction = Instruction,\n>(instruction: TInstruction): asserts instruction is InstructionWithAccounts<TAccounts> & TInstruction {\n    if (instruction.accounts === undefined) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS, {\n            data: instruction.data,\n            programAddress: instruction.programAddress,\n        });\n    }\n}\n\n/**\n * An instruction whose data conforms to a certain type.\n *\n * This is most useful when you have a branded `Uint8Array` that represents a particular\n * instruction's data.\n *\n * @example A type for the \\`AdvanceNonce\\` instruction of the System program\n * ```ts\n * type AdvanceNonceAccountInstruction<\n *     TNonceAccountAddress extends string = string,\n *     TNonceAuthorityAddress extends string = string,\n * > = Instruction<'11111111111111111111111111111111'> &\n *     InstructionWithAccounts<\n *         [\n *             WritableAccount<TNonceAccountAddress>,\n *             ReadonlyAccount<'SysvarRecentB1ockHashes11111111111111111111'>,\n *             ReadonlySignerAccount<TNonceAuthorityAddress>,\n *         ]\n *     > &\n *     InstructionWithData<AdvanceNonceAccountInstructionData>;\n * ```\n */\nexport interface InstructionWithData<TData extends ReadonlyUint8Array> extends Instruction {\n    readonly data: TData;\n}\n\nexport function isInstructionWithData<\n    TData extends ReadonlyUint8Array = ReadonlyUint8Array,\n    TInstruction extends Instruction = Instruction,\n>(instruction: TInstruction): instruction is InstructionWithData<TData> & TInstruction {\n    return instruction.data !== undefined;\n}\n\nexport function assertIsInstructionWithData<\n    TData extends ReadonlyUint8Array = ReadonlyUint8Array,\n    TInstruction extends Instruction = Instruction,\n>(instruction: TInstruction): asserts instruction is InstructionWithData<TData> & TInstruction {\n    if (instruction.data === undefined) {\n        throw new SolanaError(SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA, {\n            accountAddresses: instruction.accounts?.map(a => a.address),\n            programAddress: instruction.programAddress,\n        });\n    }\n}\n","/**\n * Describes the purpose for which an account participates in a transaction.\n *\n * Every account that participates in a transaction can be read from, but only ones that you mark as\n * writable may be written to, and only ones that you indicate must sign the transaction will gain\n * the privileges associated with signers at runtime.\n *\n * |                               | `isSigner` | `isWritable` |\n * | ----------------------------- | ---------- | ------------ |\n * | `AccountRole.READONLY`        | &#x274c;   | &#x274c;     |\n * | `AccountRole.WRITABLE`        | &#x274c;   | &#x2705;     |\n * | `AccountRole.READONLY_SIGNER` | &#x2705;   | &#x274c;     |\n * | `AccountRole.WRITABLE_SIGNER` | &#x2705;   | &#x2705;     |\n */\nexport enum AccountRole {\n    // Bitflag guide: is signer  is writable\n    WRITABLE_SIGNER = /* 3 */ 0b11, // prettier-ignore\n    READONLY_SIGNER = /* 2 */ 0b10, // prettier-ignore\n    WRITABLE =        /* 1 */ 0b01, // prettier-ignore\n    READONLY =        /* 0 */ 0b00, // prettier-ignore\n}\n\n// Quick primer on bitwise operations: https://stackoverflow.com/a/1436448/802047\nconst IS_SIGNER_BITMASK = 0b10;\nconst IS_WRITABLE_BITMASK = 0b01;\n\n/**\n * @returns An {@link AccountRole} representing the non-signer variant of the supplied role.\n */\nexport function downgradeRoleToNonSigner(role: AccountRole.READONLY_SIGNER): AccountRole.READONLY;\nexport function downgradeRoleToNonSigner(role: AccountRole.WRITABLE_SIGNER): AccountRole.WRITABLE;\nexport function downgradeRoleToNonSigner(role: AccountRole): AccountRole;\nexport function downgradeRoleToNonSigner(role: AccountRole): AccountRole {\n    return role & ~IS_SIGNER_BITMASK;\n}\n\n/**\n * @returns An {@link AccountRole} representing the read-only variant of the supplied role.\n */\nexport function downgradeRoleToReadonly(role: AccountRole.WRITABLE): AccountRole.READONLY;\nexport function downgradeRoleToReadonly(role: AccountRole.WRITABLE_SIGNER): AccountRole.READONLY_SIGNER;\nexport function downgradeRoleToReadonly(role: AccountRole): AccountRole;\nexport function downgradeRoleToReadonly(role: AccountRole): AccountRole {\n    return role & ~IS_WRITABLE_BITMASK;\n}\n\n/**\n * Returns `true` if the {@link AccountRole} given represents that of a signer. Also refines the\n * TypeScript type of the supplied role.\n */\nexport function isSignerRole(role: AccountRole): role is AccountRole.READONLY_SIGNER | AccountRole.WRITABLE_SIGNER {\n    return role >= AccountRole.READONLY_SIGNER;\n}\n\n/**\n * Returns `true` if the {@link AccountRole} given represents that of a writable account. Also\n * refines the TypeScript type of the supplied role.\n */\nexport function isWritableRole(role: AccountRole): role is AccountRole.WRITABLE | AccountRole.WRITABLE_SIGNER {\n    return (role & IS_WRITABLE_BITMASK) !== 0;\n}\n\n/**\n * Given two {@link AccountRole | AccountRoles}, will return the {@link AccountRole} that grants the\n * highest privileges of both.\n *\n * @example\n * ```ts\n * // Returns `AccountRole.WRITABLE_SIGNER`\n * mergeRoles(AccountRole.READONLY_SIGNER, AccountRole.WRITABLE);\n * ```\n */\nexport function mergeRoles(roleA: AccountRole.WRITABLE, roleB: AccountRole.READONLY_SIGNER): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY_SIGNER, roleB: AccountRole.WRITABLE): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.WRITABLE_SIGNER): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.WRITABLE_SIGNER, roleB: AccountRole): AccountRole.WRITABLE_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.READONLY_SIGNER): AccountRole.READONLY_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY_SIGNER, roleB: AccountRole): AccountRole.READONLY_SIGNER; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole.WRITABLE): AccountRole.WRITABLE; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.WRITABLE, roleB: AccountRole): AccountRole.WRITABLE; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole.READONLY, roleB: AccountRole.READONLY): AccountRole.READONLY; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole): AccountRole; // prettier-ignore\nexport function mergeRoles(roleA: AccountRole, roleB: AccountRole): AccountRole {\n    return roleA | roleB;\n}\n\n/**\n * @returns An {@link AccountRole} representing the signer variant of the supplied role.\n */\nexport function upgradeRoleToSigner(role: AccountRole.READONLY): AccountRole.READONLY_SIGNER;\nexport function upgradeRoleToSigner(role: AccountRole.WRITABLE): AccountRole.WRITABLE_SIGNER;\nexport function upgradeRoleToSigner(role: AccountRole): AccountRole;\nexport function upgradeRoleToSigner(role: AccountRole): AccountRole {\n    return role | IS_SIGNER_BITMASK;\n}\n\n/**\n * @returns An {@link AccountRole} representing the writable variant of the supplied role.\n */\nexport function upgradeRoleToWritable(role: AccountRole.READONLY): AccountRole.WRITABLE;\nexport function upgradeRoleToWritable(role: AccountRole.READONLY_SIGNER): AccountRole.WRITABLE_SIGNER;\nexport function upgradeRoleToWritable(role: AccountRole): AccountRole;\nexport function upgradeRoleToWritable(role: AccountRole): AccountRole {\n    return role | IS_WRITABLE_BITMASK;\n}\n","import { SolanaError, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING, SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS, SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS } from '@solana/errors';\nimport { isSignerRole } from '@solana/instructions';\nimport { getAddressFromPublicKey, isAddress } from '@solana/addresses';\nimport { generateKeyPair, createKeyPairFromBytes, createKeyPairFromPrivateKeyBytes, signBytes } from '@solana/keys';\nimport { assertIsFullySignedTransaction, compileTransaction, partiallySignTransaction } from '@solana/transactions';\n\n// src/deduplicate-signers.ts\nfunction deduplicateSigners(signers) {\n  const deduplicated = {};\n  signers.forEach((signer) => {\n    if (!deduplicated[signer.address]) {\n      deduplicated[signer.address] = signer;\n    } else if (deduplicated[signer.address] !== signer) {\n      throw new SolanaError(SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, {\n        address: signer.address\n      });\n    }\n  });\n  return Object.values(deduplicated);\n}\nfunction isTransactionModifyingSigner(value) {\n  return \"modifyAndSignTransactions\" in value && typeof value.modifyAndSignTransactions === \"function\";\n}\nfunction assertIsTransactionModifyingSigner(value) {\n  if (!isTransactionModifyingSigner(value)) {\n    throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, {\n      address: value.address\n    });\n  }\n}\nfunction isTransactionPartialSigner(value) {\n  return \"signTransactions\" in value && typeof value.signTransactions === \"function\";\n}\nfunction assertIsTransactionPartialSigner(value) {\n  if (!isTransactionPartialSigner(value)) {\n    throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, {\n      address: value.address\n    });\n  }\n}\nfunction isTransactionSendingSigner(value) {\n  return \"signAndSendTransactions\" in value && typeof value.signAndSendTransactions === \"function\";\n}\nfunction assertIsTransactionSendingSigner(value) {\n  if (!isTransactionSendingSigner(value)) {\n    throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, {\n      address: value.address\n    });\n  }\n}\n\n// src/transaction-signer.ts\nfunction isTransactionSigner(value) {\n  return isTransactionPartialSigner(value) || isTransactionModifyingSigner(value) || isTransactionSendingSigner(value);\n}\nfunction assertIsTransactionSigner(value) {\n  if (!isTransactionSigner(value)) {\n    throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, {\n      address: value.address\n    });\n  }\n}\n\n// src/account-signer-meta.ts\nfunction getSignersFromInstruction(instruction) {\n  return deduplicateSigners(\n    (instruction.accounts ?? []).flatMap((account) => \"signer\" in account ? account.signer : [])\n  );\n}\nfunction getSignersFromTransactionMessage(transaction) {\n  return deduplicateSigners([\n    ...transaction.feePayer && isTransactionSigner(transaction.feePayer) ? [transaction.feePayer] : [],\n    ...transaction.instructions.flatMap(getSignersFromInstruction)\n  ]);\n}\nfunction addSignersToInstruction(signers, instruction) {\n  if (!instruction.accounts || instruction.accounts.length === 0) {\n    return instruction;\n  }\n  const signerByAddress = new Map(deduplicateSigners(signers).map((signer) => [signer.address, signer]));\n  return Object.freeze({\n    ...instruction,\n    accounts: instruction.accounts.map((account) => {\n      const signer = signerByAddress.get(account.address);\n      if (!isSignerRole(account.role) || \"signer\" in account || !signer) {\n        return account;\n      }\n      return Object.freeze({ ...account, signer });\n    })\n  });\n}\nfunction addSignersToTransactionMessage(signers, transactionMessage) {\n  const feePayerSigner = hasAddressOnlyFeePayer(transactionMessage) ? signers.find((signer) => signer.address === transactionMessage.feePayer.address) : void 0;\n  if (!feePayerSigner && transactionMessage.instructions.length === 0) {\n    return transactionMessage;\n  }\n  return Object.freeze({\n    ...transactionMessage,\n    ...feePayerSigner ? { feePayer: feePayerSigner } : null,\n    instructions: transactionMessage.instructions.map((instruction) => addSignersToInstruction(signers, instruction))\n  });\n}\nfunction hasAddressOnlyFeePayer(message) {\n  return !!message && \"feePayer\" in message && !!message.feePayer && typeof message.feePayer.address === \"string\" && !isTransactionSigner(message.feePayer);\n}\n\n// src/fee-payer-signer.ts\nfunction setTransactionMessageFeePayerSigner(feePayer, transactionMessage) {\n  Object.freeze(feePayer);\n  const out = { ...transactionMessage, feePayer };\n  Object.freeze(out);\n  return out;\n}\nfunction isMessagePartialSigner(value) {\n  return \"signMessages\" in value && typeof value.signMessages === \"function\";\n}\nfunction assertIsMessagePartialSigner(value) {\n  if (!isMessagePartialSigner(value)) {\n    throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, {\n      address: value.address\n    });\n  }\n}\n\n// src/keypair-signer.ts\nfunction isKeyPairSigner(value) {\n  return \"keyPair\" in value && typeof value.keyPair === \"object\" && isMessagePartialSigner(value) && isTransactionPartialSigner(value);\n}\nfunction assertIsKeyPairSigner(value) {\n  if (!isKeyPairSigner(value)) {\n    throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, {\n      address: value.address\n    });\n  }\n}\nasync function createSignerFromKeyPair(keyPair) {\n  const address = await getAddressFromPublicKey(keyPair.publicKey);\n  const out = {\n    address,\n    keyPair,\n    signMessages: (messages) => Promise.all(\n      messages.map(\n        async (message) => Object.freeze({ [address]: await signBytes(keyPair.privateKey, message.content) })\n      )\n    ),\n    signTransactions: (transactions) => Promise.all(\n      transactions.map(async (transaction) => {\n        const signedTransaction = await partiallySignTransaction([keyPair], transaction);\n        return Object.freeze({ [address]: signedTransaction.signatures[address] });\n      })\n    )\n  };\n  return Object.freeze(out);\n}\nasync function generateKeyPairSigner() {\n  return await createSignerFromKeyPair(await generateKeyPair());\n}\nasync function createKeyPairSignerFromBytes(bytes, extractable) {\n  return await createSignerFromKeyPair(await createKeyPairFromBytes(bytes, extractable));\n}\nasync function createKeyPairSignerFromPrivateKeyBytes(bytes, extractable) {\n  return await createSignerFromKeyPair(await createKeyPairFromPrivateKeyBytes(bytes, extractable));\n}\nfunction isMessageModifyingSigner(value) {\n  return isAddress(value.address) && \"modifyAndSignMessages\" in value && typeof value.modifyAndSignMessages === \"function\";\n}\nfunction assertIsMessageModifyingSigner(value) {\n  if (!isMessageModifyingSigner(value)) {\n    throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, {\n      address: value.address\n    });\n  }\n}\nfunction isMessageSigner(value) {\n  return isMessagePartialSigner(value) || isMessageModifyingSigner(value);\n}\nfunction assertIsMessageSigner(value) {\n  if (!isMessageSigner(value)) {\n    throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, {\n      address: value.address\n    });\n  }\n}\n\n// src/noop-signer.ts\nfunction createNoopSigner(address) {\n  const out = {\n    address,\n    signMessages: (messages) => Promise.resolve(messages.map(() => Object.freeze({}))),\n    signTransactions: (transactions) => Promise.resolve(transactions.map(() => Object.freeze({})))\n  };\n  return Object.freeze(out);\n}\nfunction isTransactionMessageWithSingleSendingSigner(transaction) {\n  try {\n    assertIsTransactionMessageWithSingleSendingSigner(transaction);\n    return true;\n  } catch {\n    return false;\n  }\n}\nfunction assertIsTransactionMessageWithSingleSendingSigner(transaction) {\n  const signers = getSignersFromTransactionMessage(transaction);\n  const sendingSigners = signers.filter(isTransactionSendingSigner);\n  if (sendingSigners.length === 0) {\n    throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n  }\n  const sendingOnlySigners = sendingSigners.filter(\n    (signer) => !isTransactionPartialSigner(signer) && !isTransactionModifyingSigner(signer)\n  );\n  if (sendingOnlySigners.length > 1) {\n    throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS);\n  }\n}\n\n// src/sign-transaction.ts\nasync function partiallySignTransactionMessageWithSigners(transactionMessage, config) {\n  const { partialSigners, modifyingSigners } = categorizeTransactionSigners(\n    deduplicateSigners(getSignersFromTransactionMessage(transactionMessage).filter(isTransactionSigner)),\n    { identifySendingSigner: false }\n  );\n  return await signModifyingAndPartialTransactionSigners(\n    transactionMessage,\n    modifyingSigners,\n    partialSigners,\n    config\n  );\n}\nasync function signTransactionMessageWithSigners(transactionMessage, config) {\n  const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage, config);\n  assertIsFullySignedTransaction(signedTransaction);\n  return signedTransaction;\n}\nasync function signAndSendTransactionMessageWithSigners(transaction, config) {\n  assertIsTransactionMessageWithSingleSendingSigner(transaction);\n  const abortSignal = config?.abortSignal;\n  const { partialSigners, modifyingSigners, sendingSigner } = categorizeTransactionSigners(\n    deduplicateSigners(getSignersFromTransactionMessage(transaction).filter(isTransactionSigner))\n  );\n  abortSignal?.throwIfAborted();\n  const signedTransaction = await signModifyingAndPartialTransactionSigners(\n    transaction,\n    modifyingSigners,\n    partialSigners,\n    config\n  );\n  if (!sendingSigner) {\n    throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n  }\n  abortSignal?.throwIfAborted();\n  const [signature] = await sendingSigner.signAndSendTransactions([signedTransaction], config);\n  abortSignal?.throwIfAborted();\n  return signature;\n}\nfunction categorizeTransactionSigners(signers, config = {}) {\n  const identifySendingSigner = config.identifySendingSigner ?? true;\n  const sendingSigner = identifySendingSigner ? identifyTransactionSendingSigner(signers) : null;\n  const otherSigners = signers.filter(\n    (signer) => signer !== sendingSigner && (isTransactionModifyingSigner(signer) || isTransactionPartialSigner(signer))\n  );\n  const modifyingSigners = identifyTransactionModifyingSigners(otherSigners);\n  const partialSigners = otherSigners.filter(isTransactionPartialSigner).filter((signer) => !modifyingSigners.includes(signer));\n  return Object.freeze({ modifyingSigners, partialSigners, sendingSigner });\n}\nfunction identifyTransactionSendingSigner(signers) {\n  const sendingSigners = signers.filter(isTransactionSendingSigner);\n  if (sendingSigners.length === 0) return null;\n  const sendingOnlySigners = sendingSigners.filter(\n    (signer) => !isTransactionModifyingSigner(signer) && !isTransactionPartialSigner(signer)\n  );\n  if (sendingOnlySigners.length > 0) {\n    return sendingOnlySigners[0];\n  }\n  return sendingSigners[0];\n}\nfunction identifyTransactionModifyingSigners(signers) {\n  const modifyingSigners = signers.filter(isTransactionModifyingSigner);\n  if (modifyingSigners.length === 0) return [];\n  const nonPartialSigners = modifyingSigners.filter((signer) => !isTransactionPartialSigner(signer));\n  if (nonPartialSigners.length > 0) return nonPartialSigners;\n  return [modifyingSigners[0]];\n}\nasync function signModifyingAndPartialTransactionSigners(transactionMessage, modifyingSigners = [], partialSigners = [], config) {\n  const transaction = compileTransaction(transactionMessage);\n  const modifiedTransaction = await modifyingSigners.reduce(\n    async (transaction2, modifyingSigner) => {\n      config?.abortSignal?.throwIfAborted();\n      const [tx] = await modifyingSigner.modifyAndSignTransactions([await transaction2], config);\n      return Object.freeze(tx);\n    },\n    Promise.resolve(transaction)\n  );\n  config?.abortSignal?.throwIfAborted();\n  const signatureDictionaries = await Promise.all(\n    partialSigners.map(async (partialSigner) => {\n      const [signatures] = await partialSigner.signTransactions([modifiedTransaction], config);\n      return signatures;\n    })\n  );\n  return Object.freeze({\n    ...modifiedTransaction,\n    signatures: Object.freeze(\n      signatureDictionaries.reduce((signatures, signatureDictionary) => {\n        return { ...signatures, ...signatureDictionary };\n      }, modifiedTransaction.signatures ?? {})\n    )\n  });\n}\nvar o = globalThis.TextEncoder;\n\n// src/signable-message.ts\nfunction createSignableMessage(content, signatures = {}) {\n  return Object.freeze({\n    content: typeof content === \"string\" ? new o().encode(content) : content,\n    signatures: Object.freeze({ ...signatures })\n  });\n}\n\nexport { addSignersToInstruction, addSignersToTransactionMessage, assertIsKeyPairSigner, assertIsMessageModifyingSigner, assertIsMessagePartialSigner, assertIsMessageSigner, assertIsTransactionMessageWithSingleSendingSigner, assertIsTransactionModifyingSigner, assertIsTransactionPartialSigner, assertIsTransactionSendingSigner, assertIsTransactionSigner, createKeyPairSignerFromBytes, createKeyPairSignerFromPrivateKeyBytes, createNoopSigner, createSignableMessage, createSignerFromKeyPair, generateKeyPairSigner, getSignersFromInstruction, getSignersFromTransactionMessage, isKeyPairSigner, isMessageModifyingSigner, isMessagePartialSigner, isMessageSigner, isTransactionMessageWithSingleSendingSigner, isTransactionModifyingSigner, isTransactionPartialSigner, isTransactionSendingSigner, isTransactionSigner, partiallySignTransactionMessageWithSigners, setTransactionMessageFeePayerSigner, signAndSendTransactionMessageWithSigners, signTransactionMessageWithSigners };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, SolanaError } from '@solana/errors';\n\nimport { MessageSigner } from './message-signer';\nimport { TransactionSigner } from './transaction-signer';\n\n/**\n * Removes all duplicated {@link MessageSigner | MessageSigners} and\n * {@link TransactionSigner | TransactionSigners} from a provided array\n * by comparing their {@link Address | addresses}.\n *\n * @internal\n */\nexport function deduplicateSigners<TSigner extends MessageSigner | TransactionSigner>(\n    signers: readonly TSigner[],\n): readonly TSigner[] {\n    const deduplicated: Record<Address, TSigner> = {};\n    signers.forEach(signer => {\n        if (!deduplicated[signer.address]) {\n            deduplicated[signer.address] = signer;\n        } else if (deduplicated[signer.address] !== signer) {\n            throw new SolanaError(SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS, {\n                address: signer.address,\n            });\n        }\n    });\n    return Object.values(deduplicated);\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, SolanaError } from '@solana/errors';\nimport { Transaction, TransactionWithinSizeLimit, TransactionWithLifetime } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link TransactionModifyingSigner#modifyAndSignTransactions | modifyAndSignTransactions} method.\n *\n * @see {@link BaseTransactionSignerConfig}\n */\nexport type TransactionModifyingSignerConfig = BaseTransactionSignerConfig;\n\n/**\n * A signer interface that potentially modifies the provided {@link Transaction | Transactions}\n * before signing them.\n *\n * For instance, this enables wallets to inject additional instructions into the\n * transaction before signing them. For each transaction, instead of returning a\n * {@link SignatureDictionary}, its\n * {@link TransactionModifyingSigner#modifyAndSignTransactions | modifyAndSignTransactions} function\n * returns an updated {@link Transaction} with a potentially modified set of instructions and\n * signature dictionary. The returned transaction must be within the transaction size limit,\n * and include a `lifetimeConstraint`.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: TransactionModifyingSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     modifyAndSignTransactions: async (\n *         transactions: Transaction[]\n *     ): Promise<(Transaction & TransactionWithinSizeLimit & TransactionWithLifetime)[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Sequential**. Contrary to partial signers, these cannot be executed in\n *   parallel as each call can modify the provided transactions.\n * - **First signers**. For a given transaction, a modifying signer must always\n *   be used before a partial signer as the former will likely modify the\n *   transaction and thus impact the outcome of the latter.\n * - **Potential conflicts**. If more than one modifying signer is provided,\n *   the second signer may invalidate the signature of the first one. However,\n *   modifying signers may decide not to modify a transaction based on the\n *   existence of signatures for that transaction.\n *\n * @see {@link isTransactionModifyingSigner}\n * @see {@link assertIsTransactionModifyingSigner}\n */\nexport type TransactionModifyingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    modifyAndSignTransactions(\n        transactions: readonly (Transaction | (Transaction & TransactionWithLifetime))[],\n        config?: TransactionModifyingSignerConfig,\n    ): Promise<readonly (Transaction & TransactionWithinSizeLimit & TransactionWithLifetime)[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionModifyingSigner({ address, modifyAndSignTransactions: async () => {} }); // true\n * isTransactionModifyingSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionModifyingSigner}\n */\nexport function isTransactionModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionModifyingSigner<TAddress> {\n    return 'modifyAndSignTransactions' in value && typeof value.modifyAndSignTransactions === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionModifyingSigner({ address, modifyAndSignTransactions: async () => {} }); // void\n * assertIsTransactionModifyingSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionModifyingSigner}\n */\nexport function assertIsTransactionModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionModifyingSigner<TAddress> {\n    if (!isTransactionModifyingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, SolanaError } from '@solana/errors';\nimport { Transaction, TransactionWithinSizeLimit, TransactionWithLifetime } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig, SignatureDictionary } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link TransactionPartialSigner#signTransactions | signTransactions} method.\n *\n * @see {@link BaseTransactionSignerConfig}\n */\nexport type TransactionPartialSignerConfig = BaseTransactionSignerConfig;\n\n/**\n * A signer interface that signs an array of {@link Transaction | Transactions}\n *  without modifying their content. It defines a\n * {@link TransactionPartialSigner#signTransactions | signTransactions}\n * function that returns a {@link SignatureDictionary} for each provided transaction.\n *\n * Such signature dictionaries are expected to be merged with the existing ones if any.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: TransactionPartialSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     signTransactions: async (\n *         transactions: Transaction[]\n *     ): Promise<SignatureDictionary[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Parallel**. It returns a signature dictionary for each provided\n *   transaction without modifying them, making it possible for multiple\n *   partial signers to sign the same transaction in parallel.\n * - **Flexible order**. The order in which we use these signers for\n *   a given transaction doesnt matter.\n *\n * @see {@link isTransactionPartialSigner}\n * @see {@link assertIsTransactionPartialSigner}\n */\nexport type TransactionPartialSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signTransactions(\n        transactions: readonly (Transaction & TransactionWithinSizeLimit & TransactionWithLifetime)[],\n        config?: TransactionPartialSignerConfig,\n    ): Promise<readonly SignatureDictionary[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionPartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionPartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionPartialSigner({ address, signTransactions: async () => {} }); // true\n * isTransactionPartialSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionPartialSigner}\n */\nexport function isTransactionPartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionPartialSigner<TAddress> {\n    return 'signTransactions' in value && typeof value.signTransactions === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionPartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionPartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionPartialSigner({ address, signTransactions: async () => {} }); // void\n * assertIsTransactionPartialSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionPartialSigner}\n */\nexport function assertIsTransactionPartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionPartialSigner<TAddress> {\n    if (!isTransactionPartialSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { Transaction, TransactionWithLifetime } from '@solana/transactions';\n\nimport { BaseTransactionSignerConfig } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link TransactionSendingSignerConfig#signAndSendTransactions | signAndSendTransactions} method.\n *\n * @see {@link BaseTransactionSignerConfig}\n */\nexport type TransactionSendingSignerConfig = BaseTransactionSignerConfig;\n\n/**\n * A signer interface that signs one or multiple transactions\n * before sending them immediately to the blockchain.\n *\n * It defines a {@link TransactionSendingSignerConfig#signAndSendTransactions | signAndSendTransactions}\n * function that returns the transaction signature (i.e. its identifier) for each provided\n * {@link Transaction}.\n *\n * This interface is required for PDA wallets and other types of wallets that don't provide an\n * interface for signing transactions without sending them.\n *\n * Note that it is also possible for such signers to modify the provided transactions\n * before signing and sending them. This enables use cases where the modified transactions\n * cannot be shared with the app and thus must be sent directly.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const myTransactionSendingSigner: TransactionSendingSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     signAndSendTransactions: async (transactions: Transaction[]): Promise<SignatureBytes[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Single signer**. Since this signer also sends the provided transactions,\n *   we can only use a single {@link TransactionSendingSigner} for a given set of transactions.\n * - **Last signer**. Trivially, that signer must also be the last one used.\n * - **Potential conflicts**. Since signers may decide to modify the given\n *   transactions before sending them, they may invalidate previous signatures.\n *   However, signers may decide not to modify a transaction based\n *   on the existence of signatures for that transaction.\n * - **Potential confirmation**. Whilst this is not required by this interface,\n *   it is also worth noting that most wallets will also wait for the transaction\n *   to be confirmed (typically with a `confirmed` commitment)\n *   before notifying the app that they are done.\n *\n * @see {@link isTransactionSendingSigner}\n * @see {@link assertIsTransactionSendingSigner}\n */\nexport type TransactionSendingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signAndSendTransactions(\n        transactions: readonly (Transaction | (Transaction & TransactionWithLifetime))[],\n        config?: TransactionSendingSignerConfig,\n    ): Promise<readonly SignatureBytes[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionSendingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionSendingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionSendingSigner({ address, signAndSendTransactions: async () => {} }); // true\n * isTransactionSendingSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionSendingSigner}\n */\nexport function isTransactionSendingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionSendingSigner<TAddress> {\n    return 'signAndSendTransactions' in value && typeof value.signAndSendTransactions === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionSendingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionSendingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionSendingSigner({ address, signAndSendTransactions: async () => {} }); // void\n * assertIsTransactionSendingSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionSendingSigner}\n */\nexport function assertIsTransactionSendingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionSendingSigner<TAddress> {\n    if (!isTransactionSendingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, SolanaError } from '@solana/errors';\n\nimport { isTransactionModifyingSigner, TransactionModifyingSigner } from './transaction-modifying-signer';\nimport { isTransactionPartialSigner, TransactionPartialSigner } from './transaction-partial-signer';\nimport { isTransactionSendingSigner, TransactionSendingSigner } from './transaction-sending-signer';\n\n/**\n * Defines a signer capable of signing transactions.\n *\n * @see {@link TransactionModifyingSigner} For signers that can modify transactions before signing them.\n * @see {@link TransactionPartialSigner} For signers that can be used in parallel.\n * @see {@link TransactionSendingSigner} For signers that send transactions after signing them.\n * @see {@link isTransactionSigner}\n * @see {@link assertIsTransactionSigner}\n */\nexport type TransactionSigner<TAddress extends string = string> =\n    | TransactionModifyingSigner<TAddress>\n    | TransactionPartialSigner<TAddress>\n    | TransactionSendingSigner<TAddress>;\n\n/**\n * Checks whether the provided value implements the {@link TransactionSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isTransactionSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isTransactionSigner({ address, signTransactions: async () => {} }); // true\n * isTransactionSigner({ address, modifyAndSignTransactions: async () => {} }); // true\n * isTransactionSigner({ address, signAndSendTransactions: async () => {} }); // true\n * isTransactionSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsTransactionSigner}\n */\nexport function isTransactionSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is TransactionSigner<TAddress> {\n    return (\n        isTransactionPartialSigner(value) || isTransactionModifyingSigner(value) || isTransactionSendingSigner(value)\n    );\n}\n\n/**\n * Asserts that the provided value implements the {@link TransactionSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsTransactionSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsTransactionSigner({ address, signTransactions: async () => {} }); // void\n * assertIsTransactionSigner({ address, modifyAndSignTransactions: async () => {} }); // void\n * assertIsTransactionSigner({ address, signAndSendTransactions: async () => {} }); // void\n * assertIsTransactionSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isTransactionSigner}\n */\nexport function assertIsTransactionSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is TransactionSigner<TAddress> {\n    if (!isTransactionSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { AccountLookupMeta, AccountMeta, AccountRole, Instruction } from '@solana/instructions';\nimport {\n    BaseTransactionMessage,\n    TransactionMessageWithFeePayer,\n    TransactionVersion,\n} from '@solana/transaction-messages';\n\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { TransactionMessageWithFeePayerSigner } from './fee-payer-signer';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\n\n/**\n * An extension of the {@link AccountMeta} type that allows us to store {@link TransactionSigner | TransactionSigners} inside it.\n *\n * Note that, because this type represents a signer, it must use one the following two roles:\n * - {@link AccountRole.READONLY_SIGNER}\n * - {@link AccountRole.WRITABLE_SIGNER}\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for the {@link TransactionSigner} to use within the account meta.\n *\n * @interface\n *\n * @example\n * ```ts\n * import { AccountRole } from '@solana/instructions';\n * import { generateKeyPairSigner, AccountSignerMeta } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * const account: AccountSignerMeta = {\n *     address: signer.address,\n *     role: AccountRole.READONLY_SIGNER,\n *     signer,\n * };\n * ```\n */\nexport interface AccountSignerMeta<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n> extends AccountMeta<TAddress> {\n    readonly role: AccountRole.READONLY_SIGNER | AccountRole.WRITABLE_SIGNER;\n    readonly signer: TSigner;\n}\n\n/**\n * A union type that supports base account metas as well as {@link AccountSignerMeta | signer account metas}.\n */\ntype AccountMetaWithSigner<TSigner extends TransactionSigner = TransactionSigner> =\n    | AccountLookupMeta\n    | AccountMeta\n    | AccountSignerMeta<string, TSigner>;\n\n/**\n * Composable type that allows {@link AccountSignerMeta | AccountSignerMetas} to be used inside the instruction's `accounts` array\n *\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n * @typeParam TAccounts - Optionally provide a narrower type for the account metas.\n *\n * @interface\n *\n * @example\n * ```ts\n * import { AccountRole, Instruction } from '@solana/instructions';\n * import { generateKeyPairSigner, InstructionWithSigners } from '@solana/signers';\n *\n * const [authority, buffer] = await Promise.all([\n *     generateKeyPairSigner(),\n *     generateKeyPairSigner(),\n * ]);\n * const instruction: Instruction & InstructionWithSigners = {\n *     programAddress: address('1234..5678'),\n *     accounts: [\n *         // The authority is a signer account.\n *         {\n *             address: authority.address,\n *             role: AccountRole.READONLY_SIGNER,\n *             signer: authority,\n *         },\n *         // The buffer is a writable account.\n *         { address: buffer.address, role: AccountRole.WRITABLE },\n *     ],\n * };\n * ```\n */\nexport type InstructionWithSigners<\n    TSigner extends TransactionSigner = TransactionSigner,\n    TAccounts extends readonly AccountMetaWithSigner<TSigner>[] = readonly AccountMetaWithSigner<TSigner>[],\n> = Pick<Instruction<string, TAccounts>, 'accounts'>;\n\n/**\n * A {@link BaseTransactionMessage} type extension that accept {@link TransactionSigner | TransactionSigners}.\n *\n * Namely, it allows:\n * - a {@link TransactionSigner} to be used as the fee payer and\n * - {@link InstructionWithSigners} to be used in its instructions.\n *\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n * @typeParam TAccounts - Optionally provide a narrower type for the account metas.\n *\n * @example\n * ```ts\n * import { Instruction } from '@solana/instructions';\n * import { BaseTransactionMessage } from '@solana/transaction-messages';\n * import { generateKeyPairSigner, InstructionWithSigners, TransactionMessageWithSigners } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * const firstInstruction: Instruction = { ... };\n * const secondInstruction: InstructionWithSigners = { ... };\n * const transactionMessage: BaseTransactionMessage & TransactionMessageWithSigners = {\n *     feePayer: signer,\n *     instructions: [firstInstruction, secondInstruction],\n * }\n * ```\n */\nexport type TransactionMessageWithSigners<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n    TAccounts extends readonly AccountMetaWithSigner<TSigner>[] = readonly AccountMetaWithSigner<TSigner>[],\n> = Partial<TransactionMessageWithFeePayer<TAddress> | TransactionMessageWithFeePayerSigner<TAddress, TSigner>> &\n    Pick<\n        BaseTransactionMessage<TransactionVersion, Instruction & InstructionWithSigners<TSigner, TAccounts>>,\n        'instructions'\n    >;\n\n/**\n * Extracts and deduplicates all {@link TransactionSigner | TransactionSigners} stored\n * inside the account metas of an {@link InstructionWithSigners | instruction}.\n *\n * Any extracted signers that share the same {@link Address} will be de-duplicated.\n *\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n *\n * @example\n * ```ts\n * import { InstructionWithSigners, getSignersFromInstruction } from '@solana/signers';\n *\n * const signerA = { address: address('1111..1111'), signTransactions: async () => {} };\n * const signerB = { address: address('2222..2222'), signTransactions: async () => {} };\n * const instructionWithSigners: InstructionWithSigners = {\n *     accounts: [\n *         { address: signerA.address, signer: signerA, ... },\n *         { address: signerB.address, signer: signerB, ... },\n *         { address: signerA.address, signer: signerA, ... },\n *     ],\n * };\n *\n * const instructionSigners = getSignersFromInstruction(instructionWithSigners);\n * // ^ [signerA, signerB]\n * ```\n */\nexport function getSignersFromInstruction<TSigner extends TransactionSigner = TransactionSigner>(\n    instruction: InstructionWithSigners<TSigner>,\n): readonly TSigner[] {\n    return deduplicateSigners(\n        (instruction.accounts ?? []).flatMap(account => ('signer' in account ? account.signer : [])),\n    );\n}\n\n/**\n * Extracts and deduplicates all {@link TransactionSigner | TransactionSigners} stored\n * inside a given {@link TransactionMessageWithSigners | transaction message}.\n *\n * This includes any {@link TransactionSigner | TransactionSigners} stored\n * as the fee payer or in the instructions of the transaction message.\n *\n * Any extracted signers that share the same {@link Address} will be de-duplicated.\n *\n * @typeParam TAddress - Supply a string literal to define an account having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for {@link TransactionSigner | TransactionSigners}.\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import { Instruction } from '@solana/instructions';\n * import { InstructionWithSigners, TransactionMessageWithSigners, getSignersFromTransactionMessage } from '@solana/signers';\n *\n * const signerA = { address: address('1111..1111'), signTransactions: async () => {} };\n * const signerB = { address: address('2222..2222'), signTransactions: async () => {} };\n * const firstInstruction: Instruction & InstructionWithSigners = {\n *     programAddress: address('1234..5678'),\n *     accounts: [{ address: signerA.address, signer: signerA, ... }],\n * };\n * const secondInstruction: Instruction & InstructionWithSigners = {\n *     programAddress: address('1234..5678'),\n *     accounts: [{ address: signerB.address, signer: signerB, ... }],\n * };\n * const transactionMessage: TransactionMessageWithSigners = {\n *     feePayer: signerA,\n *     instructions: [firstInstruction, secondInstruction],\n * }\n *\n * const transactionSigners = getSignersFromTransactionMessage(transactionMessage);\n * // ^ [signerA, signerB]\n * ```\n */\nexport function getSignersFromTransactionMessage<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n    TTransactionMessage extends TransactionMessageWithSigners<TAddress, TSigner> = TransactionMessageWithSigners<\n        TAddress,\n        TSigner\n    >,\n>(transaction: TTransactionMessage): readonly TSigner[] {\n    return deduplicateSigners([\n        ...(transaction.feePayer && isTransactionSigner(transaction.feePayer) ? [transaction.feePayer as TSigner] : []),\n        ...transaction.instructions.flatMap(getSignersFromInstruction),\n    ]);\n}\n","import { Address } from '@solana/addresses';\nimport { Instruction, isSignerRole } from '@solana/instructions';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\nimport { AccountSignerMeta, InstructionWithSigners, TransactionMessageWithSigners } from './account-signer-meta';\nimport { deduplicateSigners } from './deduplicate-signers';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\n\n/**\n * Attaches the provided {@link TransactionSigner | TransactionSigners} to the\n * account metas of an instruction when applicable.\n *\n * For an account meta to match a provided signer it:\n * - Must have a signer role ({@link AccountRole.READONLY_SIGNER} or {@link AccountRole.WRITABLE_SIGNER}).\n * - Must have the same address as the provided signer.\n * - Must not have an attached signer already.\n *\n * @typeParam TInstruction - The inferred type of the instruction provided.\n *\n * @example\n * ```ts\n * import { AccountRole, Instruction } from '@solana/instructions';\n * import { addSignersToInstruction, TransactionSigner } from '@solana/signers';\n *\n * const instruction: Instruction = {\n *     accounts: [\n *         { address: '1111' as Address, role: AccountRole.READONLY_SIGNER },\n *         { address: '2222' as Address, role: AccountRole.WRITABLE_SIGNER },\n *     ],\n *     // ...\n * };\n *\n * const signerA: TransactionSigner<'1111'>;\n * const signerB: TransactionSigner<'2222'>;\n * const instructionWithSigners = addSignersToInstruction(\n *     [signerA, signerB],\n *     instruction\n * );\n *\n * // instructionWithSigners.accounts[0].signer === signerA\n * // instructionWithSigners.accounts[1].signer === signerB\n * ```\n */\nexport function addSignersToInstruction<TInstruction extends Instruction>(\n    signers: TransactionSigner[],\n    instruction: TInstruction | (InstructionWithSigners & TInstruction),\n): InstructionWithSigners & TInstruction {\n    if (!instruction.accounts || instruction.accounts.length === 0) {\n        return instruction as InstructionWithSigners & TInstruction;\n    }\n\n    const signerByAddress = new Map(deduplicateSigners(signers).map(signer => [signer.address, signer]));\n    return Object.freeze({\n        ...instruction,\n        accounts: instruction.accounts.map(account => {\n            const signer = signerByAddress.get(account.address);\n            if (!isSignerRole(account.role) || 'signer' in account || !signer) {\n                return account;\n            }\n            return Object.freeze({ ...account, signer } as AccountSignerMeta);\n        }),\n    });\n}\n\n/**\n * Attaches the provided {@link TransactionSigner | TransactionSigners} to the\n * account metas of all instructions inside a transaction message and/or\n * the transaction message fee payer, when applicable.\n *\n * For an account meta to match a provided signer it:\n * - Must have a signer role ({@link AccountRole.READONLY_SIGNER} or {@link AccountRole.WRITABLE_SIGNER}).\n * - Must have the same address as the provided signer.\n * - Must not have an attached signer already.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import { AccountRole, Instruction } from '@solana/instructions';\n * import { BaseTransactionMessage } from '@solana/transaction-messages';\n * import { addSignersToTransactionMessage, TransactionSigner } from '@solana/signers';\n *\n * const instructionA: Instruction = {\n *     accounts: [{ address: '1111' as Address, role: AccountRole.READONLY_SIGNER }],\n *     // ...\n * };\n * const instructionB: Instruction = {\n *     accounts: [{ address: '2222' as Address, role: AccountRole.WRITABLE_SIGNER }],\n *     // ...\n * };\n * const transactionMessage: BaseTransactionMessage = {\n *     instructions: [instructionA, instructionB],\n *     // ...\n * }\n *\n * const signerA: TransactionSigner<'1111'>;\n * const signerB: TransactionSigner<'2222'>;\n * const transactionMessageWithSigners = addSignersToTransactionMessage(\n *     [signerA, signerB],\n *     transactionMessage\n * );\n *\n * // transactionMessageWithSigners.instructions[0].accounts[0].signer === signerA\n * // transactionMessageWithSigners.instructions[1].accounts[0].signer === signerB\n * ```\n */\nexport function addSignersToTransactionMessage<TTransactionMessage extends BaseTransactionMessage>(\n    signers: TransactionSigner[],\n    transactionMessage: TTransactionMessage | (TransactionMessageWithSigners & TTransactionMessage),\n): TransactionMessageWithSigners & TTransactionMessage {\n    const feePayerSigner = hasAddressOnlyFeePayer(transactionMessage)\n        ? signers.find(signer => signer.address === transactionMessage.feePayer.address)\n        : undefined;\n\n    if (!feePayerSigner && transactionMessage.instructions.length === 0) {\n        return transactionMessage as TransactionMessageWithSigners & TTransactionMessage;\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        ...(feePayerSigner ? { feePayer: feePayerSigner } : null),\n        instructions: transactionMessage.instructions.map(instruction => addSignersToInstruction(signers, instruction)),\n    });\n}\n\nfunction hasAddressOnlyFeePayer(\n    message: BaseTransactionMessage & Partial<TransactionMessageWithFeePayer>,\n): message is BaseTransactionMessage & { feePayer: { address: Address } } {\n    return (\n        !!message &&\n        'feePayer' in message &&\n        !!message.feePayer &&\n        typeof message.feePayer.address === 'string' &&\n        !isTransactionSigner(message.feePayer)\n    );\n}\n","import { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\nimport { TransactionSigner } from './transaction-signer';\n\n/**\n * Alternative to {@link TransactionMessageWithFeePayer} that uses a {@link TransactionSigner} for the fee payer.\n *\n * @typeParam TAddress - Supply a string literal to define a fee payer having a particular address.\n * @typeParam TSigner - Optionally provide a narrower type for the {@link TransactionSigner}.\n *\n * @example\n * ```ts\n * import { BaseTransactionMessage } from '@solana/transaction-messages';\n * import { generateKeyPairSigner, TransactionMessageWithFeePayerSigner } from '@solana/signers';\n *\n * const transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayerSigner = {\n *     feePayer: await generateKeyPairSigner(),\n *     instructions: [],\n *     version: 0,\n * };\n * ```\n */\nexport interface TransactionMessageWithFeePayerSigner<\n    TAddress extends string = string,\n    TSigner extends TransactionSigner<TAddress> = TransactionSigner<TAddress>,\n> {\n    readonly feePayer: TSigner;\n}\n\n/**\n * Sets the fee payer of a {@link BaseTransactionMessage | transaction message}\n * using a {@link TransactionSigner}.\n *\n * @typeParam TFeePayerAddress - Supply a string literal to define a fee payer having a particular address.\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import { pipe } from '@solana/functional';\n * import { generateKeyPairSigner, setTransactionMessageFeePayerSigner } from '@solana/signers';\n * import { createTransactionMessage } from '@solana/transaction-messages';\n *\n * const feePayer = await generateKeyPairSigner();\n * const transactionMessage = pipe(\n *     createTransactionMessage({ version: 0 }),\n *     message => setTransactionMessageFeePayerSigner(signer, message),\n * );\n * ```\n */\nexport function setTransactionMessageFeePayerSigner<\n    TFeePayerAddress extends string,\n    TTransactionMessage extends BaseTransactionMessage &\n        Partial<TransactionMessageWithFeePayer | TransactionMessageWithFeePayerSigner>,\n>(\n    feePayer: TransactionSigner<TFeePayerAddress>,\n    transactionMessage: TTransactionMessage,\n): Omit<TTransactionMessage, 'feePayer'> & TransactionMessageWithFeePayerSigner<TFeePayerAddress> {\n    Object.freeze(feePayer);\n    const out = { ...transactionMessage, feePayer };\n    Object.freeze(out);\n    return out;\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, SolanaError } from '@solana/errors';\n\nimport { SignableMessage } from './signable-message';\nimport { BaseSignerConfig, SignatureDictionary } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link MessagePartialSigner#signMessages | signMessages} method.\n *\n * @see {@link BaseSignerConfig}\n */\nexport type MessagePartialSignerConfig = BaseSignerConfig;\n\n/**\n * A signer interface that signs an array of {@link SignableMessage | SignableMessages}\n * without modifying their content.\n *\n * It defines a {@link MessagePartialSigner#signMessages | signMessages} function\n * that returns a {@link SignatureDictionary} for each provided message.\n * Such signature dictionaries are expected to be merged with the existing ones if any.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: MessagePartialSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     signMessages: async (\n *         messages: SignableMessage[]\n *     ): Promise<SignatureDictionary[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Parallel**. When multiple signers sign the same message, we can\n *   perform this operation in parallel to obtain all their signatures.\n * - **Flexible order**. The order in which we use these signers\n *   for a given message doesnt matter.\n *\n * @see {@link SignableMessage}\n * @see {@link createSignableMessage}\n * @see {@link isMessagePartialSigner}\n * @see {@link assertIsMessagePartialSigner}\n */\nexport type MessagePartialSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    signMessages(\n        messages: readonly SignableMessage[],\n        config?: MessagePartialSignerConfig,\n    ): Promise<readonly SignatureDictionary[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link MessagePartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isMessagePartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isMessagePartialSigner({ address, signMessages: async () => {} }); // true\n * isMessagePartialSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsMessagePartialSigner}\n */\nexport function isMessagePartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessagePartialSigner<TAddress> {\n    return 'signMessages' in value && typeof value.signMessages === 'function';\n}\n\n/**\n * Asserts that the provided value implements the {@link MessagePartialSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsMessagePartialSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsMessagePartialSigner({ address, signMessages: async () => {} }); // void\n * assertIsMessagePartialSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isMessagePartialSigner}\n */\nexport function assertIsMessagePartialSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessagePartialSigner<TAddress> {\n    if (!isMessagePartialSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address, getAddressFromPublicKey } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, SolanaError } from '@solana/errors';\nimport { createKeyPairFromBytes, createKeyPairFromPrivateKeyBytes, generateKeyPair, signBytes } from '@solana/keys';\nimport { partiallySignTransaction } from '@solana/transactions';\n\nimport { isMessagePartialSigner, MessagePartialSigner } from './message-partial-signer';\nimport { isTransactionPartialSigner, TransactionPartialSigner } from './transaction-partial-signer';\n\n/**\n * Defines a signer that uses a {@link CryptoKeyPair} to sign messages and transactions.\n *\n * It implements both the {@link MessagePartialSigner} and {@link TransactionPartialSigner}\n * interfaces and keeps track of the {@link CryptoKeyPair} instance used\n * to sign messages and transactions.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner } from '@solana/signers';\n *\n * const signer = generateKeyPairSigner();\n * signer.address; // Address;\n * signer.keyPair; // CryptoKeyPair;\n * const [messageSignatures] = await signer.signMessages([message]);\n * const [transactionSignatures] = await signer.signTransactions([transaction]);\n * ```\n *\n * @see {@link generateKeyPairSigner}\n * @see {@link createSignerFromKeyPair}\n * @see {@link createKeyPairSignerFromBytes}\n * @see {@link createKeyPairSignerFromPrivateKeyBytes}\n * @see {@link isKeyPairSigner}\n * @see {@link assertIsKeyPairSigner}\n */\nexport type KeyPairSigner<TAddress extends string = string> = MessagePartialSigner<TAddress> &\n    TransactionPartialSigner<TAddress> & { keyPair: CryptoKeyPair };\n\n/**\n * Checks whether the provided value implements the {@link KeyPairSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner, isKeyPairSigner } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * isKeyPairSigner(signer); // true\n * isKeyPairSigner({ address: address('1234..5678') }); // false\n * ```\n */\nexport function isKeyPairSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is KeyPairSigner<TAddress> {\n    return (\n        'keyPair' in value &&\n        typeof value.keyPair === 'object' &&\n        isMessagePartialSigner(value) &&\n        isTransactionPartialSigner(value)\n    );\n}\n\n/**\n * Asserts that the provided value implements the {@link KeyPairSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner, assertIsKeyPairSigner } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * assertIsKeyPairSigner(signer); // void\n * assertIsKeyPairSigner({ address: address('1234..5678') }); // Throws an error.\n * ```\n */\nexport function assertIsKeyPairSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is KeyPairSigner<TAddress> {\n    if (!isKeyPairSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n\n/**\n * Creates a {@link KeyPairSigner} from a provided {@link CryptoKeyPair}.\n *\n * The {@link MessagePartialSigner#signMessages | signMessages} and\n * {@link TransactionPartialSigner#signTransactions | signTransactions}\n * functions of the returned signer will use the private key of the provided\n * key pair to sign messages and transactions.\n *\n * Note that both the {@link MessagePartialSigner#signMessages | signMessages} and\n * {@link TransactionPartialSigner#signTransactions | signTransactions} implementations\n * are parallelized, meaning that they will sign all provided messages and transactions in parallel.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { createSignerFromKeyPair, KeyPairSigner } from '@solana/signers';\n *\n * const keyPair: CryptoKeyPair = await generateKeyPair();\n * const signer: KeyPairSigner = await createSignerFromKeyPair(keyPair);\n * ```\n */\nexport async function createSignerFromKeyPair(keyPair: CryptoKeyPair): Promise<KeyPairSigner> {\n    const address = await getAddressFromPublicKey(keyPair.publicKey);\n    const out: KeyPairSigner = {\n        address,\n        keyPair,\n        signMessages: messages =>\n            Promise.all(\n                messages.map(async message =>\n                    Object.freeze({ [address]: await signBytes(keyPair.privateKey, message.content) }),\n                ),\n            ),\n        signTransactions: transactions =>\n            Promise.all(\n                transactions.map(async transaction => {\n                    const signedTransaction = await partiallySignTransaction([keyPair], transaction);\n                    // we know that the address has signed `signedTransaction` because it comes from the keypair\n                    return Object.freeze({ [address]: signedTransaction.signatures[address]! });\n                }),\n            ),\n    };\n\n    return Object.freeze(out);\n}\n\n/**\n * Generates a signer capable of signing messages and transactions by generating\n * a {@link CryptoKeyPair} and creating a {@link KeyPairSigner} from it.\n *\n * @example\n * ```ts\n * import { generateKeyPairSigner } from '@solana/signers';\n *\n * const signer = await generateKeyPairSigner();\n * ```\n *\n * @see {@link createSignerFromKeyPair}\n */\nexport async function generateKeyPairSigner(): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await generateKeyPair());\n}\n\n/**\n * Creates a new {@link KeyPairSigner} from a 64-bytes `Uint8Array` secret key (private key and public key).\n *\n * @example\n * ```ts\n * import fs from 'fs';\n * import { createKeyPairSignerFromBytes } from '@solana/signers';\n *\n * // Get bytes from local keypair file.\n * const keypairFile = fs.readFileSync('~/.config/solana/id.json');\n * const keypairBytes = new Uint8Array(JSON.parse(keypairFile.toString()));\n *\n * // Create a KeyPairSigner from the bytes.\n * const signer = await createKeyPairSignerFromBytes(keypairBytes);\n * ```\n *\n * @see {@link createKeyPairSignerFromPrivateKeyBytes} if you only have the 32-bytes private key instead.\n */\nexport async function createKeyPairSignerFromBytes(\n    bytes: ReadonlyUint8Array,\n    extractable?: boolean,\n): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await createKeyPairFromBytes(bytes, extractable));\n}\n\n/**\n * Creates a new {@link KeyPairSigner} from a 32-bytes `Uint8Array` private key.\n *\n * @example\n * ```ts\n * import { getUtf8Encoder } from '@solana/codecs-strings';\n * import { createKeyPairSignerFromPrivateKeyBytes } from '@solana/signers';\n *\n * const message = getUtf8Encoder().encode('Hello, World!');\n * const seed = new Uint8Array(await crypto.subtle.digest('SHA-256', message));\n *\n * const derivedSigner = await createKeyPairSignerFromPrivateKeyBytes(seed);\n * ```\n *\n * @see {@link createKeyPairSignerFromBytes} if you have the 64-bytes secret key instead (private key and public key).\n */\nexport async function createKeyPairSignerFromPrivateKeyBytes(\n    bytes: ReadonlyUint8Array,\n    extractable?: boolean,\n): Promise<KeyPairSigner> {\n    return await createSignerFromKeyPair(await createKeyPairFromPrivateKeyBytes(bytes, extractable));\n}\n","import { Address, isAddress } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, SolanaError } from '@solana/errors';\n\nimport { SignableMessage } from './signable-message';\nimport { BaseSignerConfig } from './types';\n\n/**\n * The configuration to optionally provide when calling the\n * {@link MessageModifyingSigner#modifyAndSignMessages | modifyAndSignMessages} method.\n *\n * @see {@link BaseSignerConfig}\n */\nexport type MessageModifyingSignerConfig = BaseSignerConfig;\n\n/**\n * A signer interface that _potentially_ modifies the content\n * of the provided {@link SignableMessage | SignableMessages} before signing them.\n *\n * For instance, this enables wallets to prefix or suffix nonces to the messages they sign.\n * For each message, instead of returning a {@link SignatureDictionary}, the\n * {@link MessageModifyingSigner#modifyAndSignMessages | modifyAndSignMessages} function\n * returns an updated {@link SignableMessage} with a potentially modified content and signature dictionary.\n *\n * @typeParam TAddress - Supply a string literal to define a signer having a particular address.\n *\n * @example\n * ```ts\n * const signer: MessageModifyingSigner<'1234..5678'> = {\n *     address: address('1234..5678'),\n *     modifyAndSignMessages: async (\n *         messages: SignableMessage[]\n *     ): Promise<SignableMessage[]> => {\n *         // My custom signing logic.\n *     },\n * };\n * ```\n *\n * @remarks\n * Here are the main characteristics of this signer interface:\n *\n * - **Sequential**. Contrary to partial signers, these cannot be executed in\n *   parallel as each call can modify the content of the message.\n * - **First signers**. For a given message, a modifying signer must always be used\n *   before a partial signer as the former will likely modify the message and\n *   thus impact the outcome of the latter.\n * - **Potential conflicts**. If more than one modifying signer is provided, the second\n *   signer may invalidate the signature of the first one. However, modifying signers\n *   may decide not to modify a message based on the existence of signatures for that message.\n *\n * @see {@link SignableMessage}\n * @see {@link createSignableMessage}\n * @see {@link isMessageModifyingSigner}\n * @see {@link assertIsMessageModifyingSigner}\n */\nexport type MessageModifyingSigner<TAddress extends string = string> = Readonly<{\n    address: Address<TAddress>;\n    modifyAndSignMessages(\n        messages: readonly SignableMessage[],\n        config?: MessageModifyingSignerConfig,\n    ): Promise<readonly SignableMessage[]>;\n}>;\n\n/**\n * Checks whether the provided value implements the {@link MessageModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isMessageModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isMessageModifyingSigner({ address, modifyAndSignMessages: async () => {} }); // true\n * isMessageModifyingSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsMessageModifyingSigner}\n */\nexport function isMessageModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessageModifyingSigner<TAddress> {\n    return (\n        isAddress(value.address) &&\n        'modifyAndSignMessages' in value &&\n        typeof value.modifyAndSignMessages === 'function'\n    );\n}\n\n/**\n * Asserts that the provided value implements the {@link MessageModifyingSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsMessageModifyingSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsMessageModifyingSigner({ address, modifyAndSignMessages: async () => {} }); // void\n * assertIsMessageModifyingSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isMessageModifyingSigner}\n */\nexport function assertIsMessageModifyingSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessageModifyingSigner<TAddress> {\n    if (!isMessageModifyingSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, SolanaError } from '@solana/errors';\n\nimport { isMessageModifyingSigner, MessageModifyingSigner } from './message-modifying-signer';\nimport { isMessagePartialSigner, MessagePartialSigner } from './message-partial-signer';\n\n/**\n * Defines a signer capable of signing messages.\n *\n * @see {@link MessageModifyingSigner} For signers that can modify messages before signing them.\n * @see {@link MessagePartialSigner} For signers that can be used in parallel.\n * @see {@link isMessageSigner}\n * @see {@link assertIsMessageSigner}\n */\nexport type MessageSigner<TAddress extends string = string> =\n    | MessageModifyingSigner<TAddress>\n    | MessagePartialSigner<TAddress>;\n\n/**\n * Checks whether the provided value implements the {@link MessageSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { isMessageSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * isMessageSigner({ address, signMessages: async () => {} }); // true\n * isMessageSigner({ address, modifyAndSignMessages: async () => {} }); // true\n * isMessageSigner({ address }); // false\n * ```\n *\n * @see {@link assertIsMessageSigner}\n */\nexport function isMessageSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): value is MessageSigner<TAddress> {\n    return isMessagePartialSigner(value) || isMessageModifyingSigner(value);\n}\n\n/**\n * Asserts that the provided value implements the {@link MessageSigner} interface.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { Address } from '@solana/addresses';\n * import { assertIsMessageSigner } from '@solana/signers';\n *\n * const address = '1234..5678' as Address<'1234..5678'>;\n * assertIsMessageSigner({ address, signMessages: async () => {} }); // void\n * assertIsMessageSigner({ address, modifyAndSignMessages: async () => {} }); // void\n * assertIsMessageSigner({ address }); // Throws an error.\n * ```\n *\n * @see {@link isMessageSigner}\n */\nexport function assertIsMessageSigner<TAddress extends string>(value: {\n    [key: string]: unknown;\n    address: Address<TAddress>;\n}): asserts value is MessageSigner<TAddress> {\n    if (!isMessageSigner(value)) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER, {\n            address: value.address,\n        });\n    }\n}\n","import { Address } from '@solana/addresses';\n\nimport { MessagePartialSigner } from './message-partial-signer';\nimport { TransactionPartialSigner } from './transaction-partial-signer';\n\n/**\n * Defines a Noop (No-Operation) signer that pretends to partially sign messages and transactions.\n *\n * For a given {@link Address}, a Noop Signer can be created to offer an implementation of both\n * the {@link MessagePartialSigner} and {@link TransactionPartialSigner} interfaces such that\n * they do not sign anything. Namely, signing a transaction or a message with a `NoopSigner`\n * will return an empty `SignatureDictionary`.\n *\n * @typeParam TAddress - Supply a string literal to define a Noop signer having a particular address.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { createNoopSigner } from '@solana/signers';\n *\n * const signer = createNoopSigner(address('1234..5678'));\n * const [messageSignatures] = await signer.signMessages([message]);\n * const [transactionSignatures] = await signer.signTransactions([transaction]);\n * // ^ Both messageSignatures and transactionSignatures are empty.\n * ```\n *\n * @remarks\n * This signer may be useful:\n *\n * - For testing purposes.\n * - For indicating that a given account is a signer and taking the responsibility to provide\n *   the signature for that account ourselves. For instance, if we need to send the transaction\n *   to a server that will sign it and send it for us.\n *\n * @see {@link createNoopSigner}\n */\nexport type NoopSigner<TAddress extends string = string> = MessagePartialSigner<TAddress> &\n    TransactionPartialSigner<TAddress>;\n\n/**\n * Creates a {@link NoopSigner} from the provided {@link Address}.\n *\n * @typeParam TAddress - The inferred type of the address provided.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { createNoopSigner } from '@solana/signers';\n *\n * const signer = createNoopSigner(address('1234..5678'));\n * ```\n */\nexport function createNoopSigner<TAddress extends string = string>(address: Address<TAddress>): NoopSigner<TAddress> {\n    const out: NoopSigner<TAddress> = {\n        address,\n        signMessages: messages => Promise.resolve(messages.map(() => Object.freeze({}))),\n        signTransactions: transactions => Promise.resolve(transactions.map(() => Object.freeze({}))),\n    };\n\n    return Object.freeze(out);\n}\n","import {\n    SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS,\n    SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\n\nimport { getSignersFromTransactionMessage, TransactionMessageWithSigners } from './account-signer-meta';\nimport { isTransactionModifyingSigner } from './transaction-modifying-signer';\nimport { isTransactionPartialSigner } from './transaction-partial-signer';\nimport { isTransactionSendingSigner } from './transaction-sending-signer';\n\n/**\n * Defines a transaction message with exactly one {@link TransactionSendingSigner}.\n *\n * This type is used to narrow the type of transaction messages that have been\n * checked to have exactly one sending signer.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithSingleSendingSigner } from '@solana/signers';\n *\n * assertIsTransactionMessageWithSingleSendingSigner(transactionMessage);\n * transactionMessage satisfies TransactionMessageWithSingleSendingSigner;\n * ```\n *\n * @see {@link isTransactionMessageWithSingleSendingSigner}\n * @see {@link assertIsTransactionMessageWithSingleSendingSigner}\n */\nexport type TransactionMessageWithSingleSendingSigner = Brand<\n    TransactionMessageWithSigners,\n    'TransactionMessageWithSingleSendingSigner'\n>;\n\n/**\n * Checks whether the provided transaction has exactly one {@link TransactionSendingSigner}.\n *\n * This can be useful when using {@link signAndSendTransactionMessageWithSigners} to provide\n * a fallback strategy in case the transaction message cannot be send using this function.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import {\n *     isTransactionMessageWithSingleSendingSigner,\n *     signAndSendTransactionMessageWithSigners,\n *     signTransactionMessageWithSigners,\n * } from '@solana/signers';\n * import { getBase64EncodedWireTransaction } from '@solana/transactions';\n *\n * let transactionSignature: SignatureBytes;\n * if (isTransactionMessageWithSingleSendingSigner(transactionMessage)) {\n *     transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage);\n * } else {\n *     const signedTransaction = await signTransactionMessageWithSigners(transactionMessage);\n *     const encodedTransaction = getBase64EncodedWireTransaction(signedTransaction);\n *     transactionSignature = await rpc.sendTransaction(encodedTransaction).send();\n * }\n * ```\n *\n * @see {@link signAndSendTransactionMessageWithSigners}\n * @see {@link assertIsTransactionMessageWithSingleSendingSigner}\n */\nexport function isTransactionMessageWithSingleSendingSigner<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(transaction: TTransactionMessage): transaction is TransactionMessageWithSingleSendingSigner & TTransactionMessage {\n    try {\n        assertIsTransactionMessageWithSingleSendingSigner(transaction);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * Asserts that the provided transaction message has exactly one {@link TransactionSendingSigner}.\n *\n * This can be useful when using the {@link signAndSendTransactionMessageWithSigners} function\n * to ensure it will be able to select the correct signer to send the transaction.\n *\n * @typeParam TTransactionMessage - The inferred type of the transaction message provided.\n *\n * @example\n * ```ts\n * import {\n *     assertIsTransactionMessageWithSingleSendingSigner,\n *     signAndSendTransactionMessageWithSigners\n * } from '@solana/signers';\n *\n * assertIsTransactionMessageWithSingleSendingSigner(transactionMessage);\n * const transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage);\n * ```\n *\n * @see {@link signAndSendTransactionMessageWithSigners}\n * @see {@link isTransactionMessageWithSingleSendingSigner}\n */\nexport function assertIsTransactionMessageWithSingleSendingSigner<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(\n    transaction: TTransactionMessage,\n): asserts transaction is TransactionMessageWithSingleSendingSigner & TTransactionMessage {\n    const signers = getSignersFromTransactionMessage(transaction);\n    const sendingSigners = signers.filter(isTransactionSendingSigner);\n\n    if (sendingSigners.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n    }\n\n    // When identifying if there are multiple sending signers, we only need to check for\n    // sending signers that do not implement other transaction signer interfaces as\n    // they will be used as these other signer interfaces in case of a conflict.\n    const sendingOnlySigners = sendingSigners.filter(\n        signer => !isTransactionPartialSigner(signer) && !isTransactionModifyingSigner(signer),\n    );\n\n    if (sendingOnlySigners.length > 1) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS);\n    }\n}\n","import { SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { BaseTransactionMessage, TransactionMessageWithFeePayer } from '@solana/transaction-messages';\nimport {\n    assertIsFullySignedTransaction,\n    compileTransaction,\n    SendableTransaction,\n    Transaction,\n    TransactionWithinSizeLimit,\n    TransactionWithLifetime,\n} from '@solana/transactions';\n\nimport { getSignersFromTransactionMessage, TransactionMessageWithSigners } from './account-signer-meta';\nimport { deduplicateSigners } from './deduplicate-signers';\nimport {\n    isTransactionModifyingSigner,\n    TransactionModifyingSigner,\n    TransactionModifyingSignerConfig,\n} from './transaction-modifying-signer';\nimport {\n    isTransactionPartialSigner,\n    TransactionPartialSigner,\n    TransactionPartialSignerConfig,\n} from './transaction-partial-signer';\nimport {\n    isTransactionSendingSigner,\n    TransactionSendingSigner,\n    TransactionSendingSignerConfig,\n} from './transaction-sending-signer';\nimport { isTransactionSigner, TransactionSigner } from './transaction-signer';\nimport { assertIsTransactionMessageWithSingleSendingSigner } from './transaction-with-single-sending-signer';\n\n/**\n * Extracts all {@link TransactionSigner | TransactionSigners} inside the provided\n * transaction message and uses them to return a signed transaction.\n *\n * It first uses all {@link TransactionModifyingSigner | TransactionModifyingSigners} sequentially before\n * using all {@link TransactionPartialSigner | TransactionPartialSigners} in parallel.\n *\n * If a composite signer implements both interfaces, it will be used as a\n * {@link TransactionModifyingSigner} if no other signer implements that interface.\n * Otherwise, it will be used as a {@link TransactionPartialSigner}.\n *\n * @example\n * ```ts\n * const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage);\n * ```\n *\n * It also accepts an optional {@link AbortSignal} that will be propagated to all signers.\n *\n * ```ts\n * const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n * ```\n *\n * @remarks\n * Finally, note that this function ignores {@link TransactionSendingSigner | TransactionSendingSigners}\n * as it does not send the transaction. Check out the {@link signAndSendTransactionMessageWithSigners}\n * function for more details on how to use sending signers.\n *\n * @see {@link signTransactionMessageWithSigners}\n * @see {@link signAndSendTransactionMessageWithSigners}\n */\nexport async function partiallySignTransactionMessageWithSigners(\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithSigners,\n    config?: TransactionPartialSignerConfig,\n): Promise<Transaction & TransactionWithinSizeLimit & TransactionWithLifetime> {\n    const { partialSigners, modifyingSigners } = categorizeTransactionSigners(\n        deduplicateSigners(getSignersFromTransactionMessage(transactionMessage).filter(isTransactionSigner)),\n        { identifySendingSigner: false },\n    );\n\n    return await signModifyingAndPartialTransactionSigners(\n        transactionMessage,\n        modifyingSigners,\n        partialSigners,\n        config,\n    );\n}\n\n/**\n * Extracts all {@link TransactionSigner | TransactionSigners} inside the provided\n * transaction message and uses them to return a signed transaction before asserting\n * that all signatures required by the transaction are present.\n *\n * This function delegates to the {@link partiallySignTransactionMessageWithSigners} function\n * in order to extract signers from the transaction message and sign the transaction.\n *\n * @example\n * ```ts\n * const mySignedTransaction = await signTransactionMessageWithSigners(myTransactionMessage);\n *\n * // With additional config.\n * const mySignedTransaction = await signTransactionMessageWithSigners(myTransactionMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n *\n * // We now know the transaction is fully signed.\n * mySignedTransaction satisfies FullySignedTransaction;\n * ```\n *\n * @see {@link partiallySignTransactionMessageWithSigners}\n * @see {@link signAndSendTransactionMessageWithSigners}\n */\nexport async function signTransactionMessageWithSigners(\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithSigners,\n    config?: TransactionPartialSignerConfig,\n): Promise<SendableTransaction & Transaction & TransactionWithLifetime> {\n    const signedTransaction = await partiallySignTransactionMessageWithSigners(transactionMessage, config);\n    assertIsFullySignedTransaction(signedTransaction);\n    return signedTransaction;\n}\n\n/**\n * Extracts all {@link TransactionSigner | TransactionSigners} inside the provided\n * transaction message and uses them to sign it before sending it immediately to the blockchain.\n *\n * It returns the signature of the sent transaction (i.e. its identifier) as bytes.\n *\n * @example\n * ```ts\n * import { signAndSendTransactionMessageWithSigners } from '@solana/signers';\n *\n * const transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage);\n *\n * // With additional config.\n * const transactionSignature = await signAndSendTransactionMessageWithSigners(transactionMessage, {\n *     abortSignal: myAbortController.signal,\n * });\n * ```\n *\n * @remarks\n * Similarly to the {@link partiallySignTransactionMessageWithSigners} function, it first uses all\n * {@link TransactionModifyingSigner | TransactionModifyingSigners} sequentially before using all\n * {@link TransactionPartialSigner | TransactionPartialSigners} in parallel.\n * It then sends the transaction using the {@link TransactionSendingSigner} it identified.\n *\n * Composite transaction signers are treated such that at least one sending signer is used if any.\n * When a {@link TransactionSigner} implements more than one interface, we use it as a:\n *\n * - {@link TransactionSendingSigner}, if no other {@link TransactionSendingSigner} exists.\n * - {@link TransactionModifyingSigner}, if no other {@link TransactionModifyingSigner} exists.\n * - {@link TransactionPartialSigner}, otherwise.\n *\n * The provided transaction must contain exactly one {@link TransactionSendingSigner} inside its account metas.\n * If more than one composite signers implement the {@link TransactionSendingSigner} interface,\n * one of them will be selected as the sending signer. Otherwise, if multiple\n * {@link TransactionSendingSigner | TransactionSendingSigners} must be selected, the function will throw an error.\n *\n * If you'd like to assert that a transaction makes use of exactly one {@link TransactionSendingSigner}\n * _before_ calling this function, you may use the {@link assertIsTransactionMessageWithSingleSendingSigner} function.\n *\n * Alternatively, you may use the {@link isTransactionMessageWithSingleSendingSigner} function to provide a\n * fallback in case the transaction does not contain any sending signer.\n *\n * @see {@link assertIsTransactionMessageWithSingleSendingSigner}\n * @see {@link isTransactionMessageWithSingleSendingSigner}\n * @see {@link partiallySignTransactionMessageWithSigners}\n * @see {@link signTransactionMessageWithSigners}\n *\n */\nexport async function signAndSendTransactionMessageWithSigners(\n    transaction: BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithSigners,\n    config?: TransactionSendingSignerConfig,\n): Promise<SignatureBytes> {\n    assertIsTransactionMessageWithSingleSendingSigner(transaction);\n\n    const abortSignal = config?.abortSignal;\n    const { partialSigners, modifyingSigners, sendingSigner } = categorizeTransactionSigners(\n        deduplicateSigners(getSignersFromTransactionMessage(transaction).filter(isTransactionSigner)),\n    );\n\n    abortSignal?.throwIfAborted();\n    const signedTransaction = await signModifyingAndPartialTransactionSigners(\n        transaction,\n        modifyingSigners,\n        partialSigners,\n        config,\n    );\n\n    if (!sendingSigner) {\n        throw new SolanaError(SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING);\n    }\n\n    abortSignal?.throwIfAborted();\n    const [signature] = await sendingSigner.signAndSendTransactions([signedTransaction], config);\n    abortSignal?.throwIfAborted();\n\n    return signature;\n}\n\n/**\n * Identifies each provided TransactionSigner and categorizes them into their respective types.\n * When a signer implements multiple interface, it will try to used to most powerful interface\n * but fallback to the least powerful interface when necessary.\n * For instance, if a signer implements TransactionSendingSigner and TransactionModifyingSigner,\n * it will be categorized as a TransactionSendingSigner if and only if no other signers implement\n * the TransactionSendingSigner interface.\n */\nfunction categorizeTransactionSigners(\n    signers: readonly TransactionSigner[],\n    config: { identifySendingSigner?: boolean } = {},\n): Readonly<{\n    modifyingSigners: readonly TransactionModifyingSigner[];\n    partialSigners: readonly TransactionPartialSigner[];\n    sendingSigner: TransactionSendingSigner | null;\n}> {\n    // Identify the unique sending signer that should be used.\n    const identifySendingSigner = config.identifySendingSigner ?? true;\n    const sendingSigner = identifySendingSigner ? identifyTransactionSendingSigner(signers) : null;\n\n    // Now, focus on the other signers.\n    // I.e. the modifying or partial signers that are not the identified sending signer.\n    // Note that any other sending only signers will be discarded.\n    const otherSigners = signers.filter(\n        (signer): signer is TransactionModifyingSigner | TransactionPartialSigner =>\n            signer !== sendingSigner && (isTransactionModifyingSigner(signer) || isTransactionPartialSigner(signer)),\n    );\n\n    // Identify the modifying signers from the other signers.\n    const modifyingSigners = identifyTransactionModifyingSigners(otherSigners);\n\n    // Use any remaining signers as partial signers.\n    const partialSigners = otherSigners\n        .filter(isTransactionPartialSigner)\n        .filter(signer => !(modifyingSigners as typeof otherSigners).includes(signer));\n\n    return Object.freeze({ modifyingSigners, partialSigners, sendingSigner });\n}\n\n/** Identifies the best signer to use as a TransactionSendingSigner, if any */\nfunction identifyTransactionSendingSigner(signers: readonly TransactionSigner[]): TransactionSendingSigner | null {\n    // Ensure there are any TransactionSendingSigners in the first place.\n    const sendingSigners = signers.filter(isTransactionSendingSigner);\n    if (sendingSigners.length === 0) return null;\n\n    // Prefer sending signers that do not offer other interfaces.\n    const sendingOnlySigners = sendingSigners.filter(\n        signer => !isTransactionModifyingSigner(signer) && !isTransactionPartialSigner(signer),\n    );\n    if (sendingOnlySigners.length > 0) {\n        return sendingOnlySigners[0];\n    }\n\n    // Otherwise, choose any sending signer.\n    return sendingSigners[0];\n}\n\n/** Identifies the best signers to use as TransactionModifyingSigners, if any */\nfunction identifyTransactionModifyingSigners(\n    signers: readonly (TransactionModifyingSigner | TransactionPartialSigner)[],\n): readonly TransactionModifyingSigner[] {\n    // Ensure there are any TransactionModifyingSigner in the first place.\n    const modifyingSigners = signers.filter(isTransactionModifyingSigner);\n    if (modifyingSigners.length === 0) return [];\n\n    // Prefer modifying signers that do not offer partial signing.\n    const nonPartialSigners = modifyingSigners.filter(signer => !isTransactionPartialSigner(signer));\n    if (nonPartialSigners.length > 0) return nonPartialSigners;\n\n    // Otherwise, choose only one modifying signer (whichever).\n    return [modifyingSigners[0]];\n}\n\n/**\n * Signs a transaction using the provided TransactionModifyingSigners\n * sequentially followed by the TransactionPartialSigners in parallel.\n */\nasync function signModifyingAndPartialTransactionSigners(\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithSigners,\n    modifyingSigners: readonly TransactionModifyingSigner[] = [],\n    partialSigners: readonly TransactionPartialSigner[] = [],\n    config?: TransactionModifyingSignerConfig,\n): Promise<Transaction & TransactionWithinSizeLimit & TransactionWithLifetime> {\n    // serialize the transaction\n    const transaction = compileTransaction(transactionMessage);\n\n    // Handle modifying signers sequentially.\n    const modifiedTransaction = (await modifyingSigners.reduce(\n        async (transaction, modifyingSigner) => {\n            config?.abortSignal?.throwIfAborted();\n            const [tx] = await modifyingSigner.modifyAndSignTransactions([await transaction], config);\n            return Object.freeze(tx);\n        },\n        Promise.resolve(transaction) as Promise<Readonly<Transaction & TransactionWithLifetime>>,\n    )) as Transaction & TransactionWithinSizeLimit & TransactionWithLifetime;\n\n    // Handle partial signers in parallel.\n    config?.abortSignal?.throwIfAborted();\n    const signatureDictionaries = await Promise.all(\n        partialSigners.map(async partialSigner => {\n            const [signatures] = await partialSigner.signTransactions([modifiedTransaction], config);\n            return signatures;\n        }),\n    );\n\n    return Object.freeze({\n        ...modifiedTransaction,\n        signatures: Object.freeze(\n            signatureDictionaries.reduce((signatures, signatureDictionary) => {\n                return { ...signatures, ...signatureDictionary };\n            }, modifiedTransaction.signatures ?? {}),\n        ),\n    });\n}\n","export const TextDecoder = globalThis.TextDecoder;\nexport const TextEncoder = globalThis.TextEncoder;\n","import { TextEncoder } from '@solana/text-encoding-impl';\n\nimport { SignatureDictionary } from './types';\n\n/**\n * Defines a message that needs signing and its current set of signatures if any.\n *\n * This interface allows {@link MessageModifyingSigner | MessageModifyingSigners}\n * to decide on whether or not they should modify the provided message depending\n * on whether or not signatures already exist for such message.\n *\n * It also helps create a more consistent API by providing a structure analogous\n * to transactions which also keep track of their {@link SignatureDictionary}.\n *\n * @example\n * ```ts\n * import { createSignableMessage } from '@solana/signers';\n *\n * const message = createSignableMessage(new Uint8Array([1, 2, 3]));\n * message.content; // The content of the message as bytes.\n * message.signatures; // The current set of signatures for this message.\n * ```\n *\n * @see {@link createSignableMessage}\n */\nexport type SignableMessage = Readonly<{\n    content: Uint8Array;\n    signatures: SignatureDictionary;\n}>;\n\n/**\n * Creates a {@link SignableMessage} from a `Uint8Array` or a UTF-8 string.\n *\n * It optionally accepts a signature dictionary if the message already contains signatures.\n *\n * @example\n * ```ts\n * const message = createSignableMessage(new Uint8Array([1, 2, 3]));\n * const messageFromText = createSignableMessage('Hello world!');\n * const messageWithSignatures = createSignableMessage('Hello world!', {\n *     [address('1234..5678')]: new Uint8Array([1, 2, 3]) as SignatureBytes,\n * });\n * ```\n */\nexport function createSignableMessage(\n    content: Uint8Array | string,\n    signatures: SignatureDictionary = {},\n): SignableMessage {\n    return Object.freeze({\n        content: typeof content === 'string' ? new TextEncoder().encode(content) : content,\n        signatures: Object.freeze({ ...signatures }),\n    });\n}\n","import { assertKeyExporterIsAvailable, assertSigningCapabilityIsAvailable, assertVerificationCapabilityIsAvailable, assertKeyGenerationIsAvailable, assertPRNGIsAvailable } from '@solana/assertions';\nimport { SolanaError, SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY, SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE, SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH, SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH, SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY } from '@solana/errors';\nimport { getBase58Encoder } from '@solana/codecs-strings';\n\n// src/key-pair.ts\n\n// src/algorithm.ts\nvar ED25519_ALGORITHM_IDENTIFIER = (\n  // Resist the temptation to convert this to a simple string; As of version 133.0.3, Firefox\n  // requires the object form of `AlgorithmIdentifier` and will throw a `DOMException` otherwise.\n  Object.freeze({ name: \"Ed25519\" })\n);\nfunction addPkcs8Header(bytes) {\n  return new Uint8Array([\n    /**\n     * PKCS#8 header\n     */\n    48,\n    // ASN.1 sequence tag\n    46,\n    // Length of sequence (46 more bytes)\n    2,\n    // ASN.1 integer tag\n    1,\n    // Length of integer\n    0,\n    // Version number\n    48,\n    // ASN.1 sequence tag\n    5,\n    // Length of sequence\n    6,\n    // ASN.1 object identifier tag\n    3,\n    // Length of object identifier\n    // Edwards curve algorithms identifier https://oid-rep.orange-labs.fr/get/1.3.101.112\n    43,\n    // iso(1) / identified-organization(3) (The first node is multiplied by the decimal 40 and the result is added to the value of the second node)\n    101,\n    // thawte(101)\n    // Ed25519 identifier\n    112,\n    // id-Ed25519(112)\n    /**\n     * Private key payload\n     */\n    4,\n    // ASN.1 octet string tag\n    34,\n    // String length (34 more bytes)\n    // Private key bytes as octet string\n    4,\n    // ASN.1 octet string tag\n    32,\n    // String length (32 bytes)\n    ...bytes\n  ]);\n}\nasync function createPrivateKeyFromBytes(bytes, extractable = false) {\n  const actualLength = bytes.byteLength;\n  if (actualLength !== 32) {\n    throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, {\n      actualLength\n    });\n  }\n  const privateKeyBytesPkcs8 = addPkcs8Header(bytes);\n  return await crypto.subtle.importKey(\"pkcs8\", privateKeyBytesPkcs8, ED25519_ALGORITHM_IDENTIFIER, extractable, [\n    \"sign\"\n  ]);\n}\nasync function getPublicKeyFromPrivateKey(privateKey, extractable = false) {\n  assertKeyExporterIsAvailable();\n  if (privateKey.extractable === false) {\n    throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY, { key: privateKey });\n  }\n  const jwk = await crypto.subtle.exportKey(\"jwk\", privateKey);\n  return await crypto.subtle.importKey(\n    \"jwk\",\n    {\n      crv: \"Ed25519\",\n      ext: extractable,\n      key_ops: [\"verify\"],\n      kty: \"OKP\",\n      x: jwk.x\n    },\n    \"Ed25519\",\n    extractable,\n    [\"verify\"]\n  );\n}\nvar base58Encoder;\nfunction assertIsSignature(putativeSignature) {\n  if (!base58Encoder) base58Encoder = getBase58Encoder();\n  if (\n    // Lowest value (64 bytes of zeroes)\n    putativeSignature.length < 64 || // Highest value (64 bytes of 255)\n    putativeSignature.length > 88\n  ) {\n    throw new SolanaError(SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE, {\n      actualLength: putativeSignature.length\n    });\n  }\n  const bytes = base58Encoder.encode(putativeSignature);\n  assertIsSignatureBytes(bytes);\n}\nfunction assertIsSignatureBytes(putativeSignatureBytes) {\n  const numBytes = putativeSignatureBytes.byteLength;\n  if (numBytes !== 64) {\n    throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH, {\n      actualLength: numBytes\n    });\n  }\n}\nfunction isSignature(putativeSignature) {\n  if (!base58Encoder) base58Encoder = getBase58Encoder();\n  if (\n    // Lowest value (64 bytes of zeroes)\n    putativeSignature.length < 64 || // Highest value (64 bytes of 255)\n    putativeSignature.length > 88\n  ) {\n    return false;\n  }\n  const bytes = base58Encoder.encode(putativeSignature);\n  return isSignatureBytes(bytes);\n}\nfunction isSignatureBytes(putativeSignatureBytes) {\n  return putativeSignatureBytes.byteLength === 64;\n}\nasync function signBytes(key, data) {\n  assertSigningCapabilityIsAvailable();\n  const signedData = await crypto.subtle.sign(ED25519_ALGORITHM_IDENTIFIER, key, data);\n  return new Uint8Array(signedData);\n}\nfunction signature(putativeSignature) {\n  assertIsSignature(putativeSignature);\n  return putativeSignature;\n}\nfunction signatureBytes(putativeSignatureBytes) {\n  assertIsSignatureBytes(putativeSignatureBytes);\n  return putativeSignatureBytes;\n}\nasync function verifySignature(key, signature2, data) {\n  assertVerificationCapabilityIsAvailable();\n  return await crypto.subtle.verify(ED25519_ALGORITHM_IDENTIFIER, key, signature2, data);\n}\n\n// src/key-pair.ts\nasync function generateKeyPair() {\n  await assertKeyGenerationIsAvailable();\n  const keyPair = await crypto.subtle.generateKey(\n    /* algorithm */\n    ED25519_ALGORITHM_IDENTIFIER,\n    // Native implementation status: https://github.com/WICG/webcrypto-secure-curves/issues/20\n    /* extractable */\n    false,\n    // Prevents the bytes of the private key from being visible to JS.\n    /* allowed uses */\n    [\"sign\", \"verify\"]\n  );\n  return keyPair;\n}\nasync function createKeyPairFromBytes(bytes, extractable = false) {\n  assertPRNGIsAvailable();\n  if (bytes.byteLength !== 64) {\n    throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH, { byteLength: bytes.byteLength });\n  }\n  const [publicKey, privateKey] = await Promise.all([\n    crypto.subtle.importKey(\n      \"raw\",\n      bytes.slice(32),\n      ED25519_ALGORITHM_IDENTIFIER,\n      /* extractable */\n      true,\n      [\n        \"verify\"\n      ]\n    ),\n    createPrivateKeyFromBytes(bytes.slice(0, 32), extractable)\n  ]);\n  const randomBytes = new Uint8Array(32);\n  crypto.getRandomValues(randomBytes);\n  const signedData = await signBytes(privateKey, randomBytes);\n  const isValid = await verifySignature(publicKey, signedData, randomBytes);\n  if (!isValid) {\n    throw new SolanaError(SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY);\n  }\n  return { privateKey, publicKey };\n}\nasync function createKeyPairFromPrivateKeyBytes(bytes, extractable = false) {\n  const privateKeyPromise = createPrivateKeyFromBytes(bytes, extractable);\n  const [publicKey, privateKey] = await Promise.all([\n    // This nested promise makes things efficient by\n    // creating the public key in parallel with the\n    // second private key creation, if it is needed.\n    (extractable ? privateKeyPromise : createPrivateKeyFromBytes(\n      bytes,\n      true\n      /* extractable */\n    )).then(\n      async (privateKey2) => await getPublicKeyFromPrivateKey(\n        privateKey2,\n        true\n        /* extractable */\n      )\n    ),\n    privateKeyPromise\n  ]);\n  return { privateKey, publicKey };\n}\n\nexport { assertIsSignature, assertIsSignatureBytes, createKeyPairFromBytes, createKeyPairFromPrivateKeyBytes, createPrivateKeyFromBytes, generateKeyPair, getPublicKeyFromPrivateKey, isSignature, isSignatureBytes, signBytes, signature, signatureBytes, verifySignature };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","export const ED25519_ALGORITHM_IDENTIFIER =\n    // Resist the temptation to convert this to a simple string; As of version 133.0.3, Firefox\n    // requires the object form of `AlgorithmIdentifier` and will throw a `DOMException` otherwise.\n    Object.freeze({ name: 'Ed25519' });\n","import { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, SolanaError } from '@solana/errors';\n\nimport { ED25519_ALGORITHM_IDENTIFIER } from './algorithm';\n\nfunction addPkcs8Header(bytes: ReadonlyUint8Array): ReadonlyUint8Array {\n    // prettier-ignore\n    return new Uint8Array([\n        /**\n         * PKCS#8 header\n         */\n        0x30, // ASN.1 sequence tag\n        0x2e, // Length of sequence (46 more bytes)\n\n            0x02, // ASN.1 integer tag\n            0x01, // Length of integer\n                0x00, // Version number\n\n            0x30, // ASN.1 sequence tag\n            0x05, // Length of sequence\n                0x06, // ASN.1 object identifier tag\n                0x03, // Length of object identifier\n                    // Edwards curve algorithms identifier https://oid-rep.orange-labs.fr/get/1.3.101.112\n                        0x2b, // iso(1) / identified-organization(3) (The first node is multiplied by the decimal 40 and the result is added to the value of the second node)\n                        0x65, // thawte(101)\n                    // Ed25519 identifier\n                        0x70, // id-Ed25519(112)\n\n        /**\n         * Private key payload\n         */\n        0x04, // ASN.1 octet string tag\n        0x22, // String length (34 more bytes)\n\n            // Private key bytes as octet string\n            0x04, // ASN.1 octet string tag\n            0x20, // String length (32 bytes)\n\n        ...bytes\n    ]);\n}\n\n/**\n * Given a private key represented as a 32-byte `Uint8Array`, creates an Ed25519 private key for use\n * with other methods in this package that accept\n * [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) objects.\n *\n * @param bytes 32 bytes that represent the private key\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the private\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import { createPrivateKeyFromBytes } from '@solana/keys';\n *\n * const privateKey = await createPrivateKeyFromBytes(new Uint8Array([...]));\n * const extractablePrivateKey = await createPrivateKeyFromBytes(new Uint8Array([...]), true);\n * ```\n */\nexport async function createPrivateKeyFromBytes(\n    bytes: ReadonlyUint8Array,\n    extractable: boolean = false,\n): Promise<CryptoKey> {\n    const actualLength = bytes.byteLength;\n    if (actualLength !== 32) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH, {\n            actualLength,\n        });\n    }\n    const privateKeyBytesPkcs8 = addPkcs8Header(bytes);\n    return await crypto.subtle.importKey('pkcs8', privateKeyBytesPkcs8, ED25519_ALGORITHM_IDENTIFIER, extractable, [\n        'sign',\n    ]);\n}\n","import { assertKeyExporterIsAvailable } from '@solana/assertions';\nimport { SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY, SolanaError } from '@solana/errors';\n\n/**\n * Given an extractable [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * private key, gets the corresponding public key as a\n * [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey).\n *\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the public\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import { createPrivateKeyFromBytes, getPublicKeyFromPrivateKey } from '@solana/keys';\n *\n * const privateKey = await createPrivateKeyFromBytes(new Uint8Array([...]), true);\n *\n * const publicKey = await getPublicKeyFromPrivateKey(privateKey);\n * const extractablePublicKey = await getPublicKeyFromPrivateKey(privateKey, true);\n * ```\n */\nexport async function getPublicKeyFromPrivateKey(\n    privateKey: CryptoKey,\n    extractable: boolean = false,\n): Promise<CryptoKey> {\n    assertKeyExporterIsAvailable();\n\n    if (privateKey.extractable === false) {\n        throw new SolanaError(SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY, { key: privateKey });\n    }\n\n    // Export private key.\n    const jwk = await crypto.subtle.exportKey('jwk', privateKey);\n\n    // Import public key.\n    return await crypto.subtle.importKey(\n        'jwk',\n        {\n            crv /* curve */: 'Ed25519',\n            ext /* extractable */: extractable,\n            key_ops /* key operations */: ['verify'],\n            kty /* key type */: 'OKP' /* octet key pair */,\n            x /* public key x-coordinate */: jwk.x,\n        },\n        'Ed25519',\n        extractable,\n        ['verify'],\n    );\n}\n","import { assertSigningCapabilityIsAvailable, assertVerificationCapabilityIsAvailable } from '@solana/assertions';\nimport { Encoder, ReadonlyUint8Array } from '@solana/codecs-core';\nimport { getBase58Encoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\nimport { ED25519_ALGORITHM_IDENTIFIER } from './algorithm';\n\n/**\n * A 64-byte Ed25519 signature as a base58-encoded string.\n */\nexport type Signature = Brand<EncodedString<string, 'base58'>, 'Signature'>;\n/**\n * A 64-byte Ed25519 signature.\n *\n * Whenever you need to verify that a particular signature is, in fact, the one that would have been\n * produced by signing some known bytes using the private key associated with some known public key,\n * use the {@link verifySignature} function in this package.\n */\nexport type SignatureBytes = Brand<Uint8Array, 'SignatureBytes'>;\n\nlet base58Encoder: Encoder<string> | undefined;\n\n/**\n * Asserts that an arbitrary string is a base58-encoded Ed25519 signature.\n *\n * Useful when you receive a string from user input or an untrusted network API that you expect to\n * represent an Ed25519 signature (eg. of a transaction).\n *\n * @example\n * ```ts\n * import { assertIsSignature } from '@solana/keys';\n *\n * // Imagine a function that asserts whether a user-supplied signature is valid or not.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const signature: string = signatureInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `signature` to `Signature`.\n *         assertIsSignature(signature);\n *         // At this point, `signature` is a `Signature` that can be used with the RPC.\n *         const {\n *             value: [status],\n *         } = await rpc.getSignatureStatuses([signature]).send();\n *     } catch (e) {\n *         // `signature` turned out not to be a base58-encoded signature\n *     }\n * }\n * ```\n */\nexport function assertIsSignature(putativeSignature: string): asserts putativeSignature is Signature {\n    if (!base58Encoder) base58Encoder = getBase58Encoder();\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (64 bytes of zeroes)\n        putativeSignature.length < 64 ||\n        // Highest value (64 bytes of 255)\n        putativeSignature.length > 88\n    ) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE, {\n            actualLength: putativeSignature.length,\n        });\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const bytes = base58Encoder.encode(putativeSignature);\n    assertIsSignatureBytes(bytes);\n}\n\n/**\n * Asserts that an arbitrary `ReadonlyUint8Array` is an Ed25519 signature.\n *\n * Useful when you receive a `ReadonlyUint8Array` from an external interface (like the browser wallets' `signMessage` API) that you expect to\n * represent an Ed25519 signature.\n *\n * @example\n * ```ts\n * import { assertIsSignatureBytes } from '@solana/keys';\n *\n * // Imagine a function that verifies a signature.\n * function verifySignature() {\n *     // We know only that the input conforms to the `ReadonlyUint8Array` type.\n *     const signatureBytes: ReadonlyUint8Array = signatureBytesInput;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `signatureBytes` to `SignatureBytes`.\n *         assertIsSignatureBytes(signatureBytes);\n *         // At this point, `signatureBytes` is a `SignatureBytes` that can be used with `verifySignature`.\n *         if (!(await verifySignature(publicKey, signatureBytes, data))) {\n *             throw new Error('The data were *not* signed by the private key associated with `publicKey`');\n *         }\n *     } catch (e) {\n *         // `signatureBytes` turned out not to be a 64-byte Ed25519 signature\n *     }\n * }\n * ```\n */\nexport function assertIsSignatureBytes(\n    putativeSignatureBytes: ReadonlyUint8Array,\n): asserts putativeSignatureBytes is SignatureBytes {\n    const numBytes = putativeSignatureBytes.byteLength;\n    if (numBytes !== 64) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH, {\n            actualLength: numBytes,\n        });\n    }\n}\n\n/**\n * A type guard that accepts a string as input. It will both return `true` if the string conforms to\n * the {@link Signature} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isSignature } from '@solana/keys';\n *\n * if (isSignature(signature)) {\n *     // At this point, `signature` has been refined to a\n *     // `Signature` that can be used with the RPC.\n *     const {\n *         value: [status],\n *     } = await rpc.getSignatureStatuses([signature]).send();\n *     setSignatureStatus(status);\n * } else {\n *     setError(`${signature} is not a transaction signature`);\n * }\n * ```\n */\nexport function isSignature(putativeSignature: string): putativeSignature is Signature {\n    if (!base58Encoder) base58Encoder = getBase58Encoder();\n\n    // Fast-path; see if the input string is of an acceptable length.\n    if (\n        // Lowest value (64 bytes of zeroes)\n        putativeSignature.length < 64 ||\n        // Highest value (64 bytes of 255)\n        putativeSignature.length > 88\n    ) {\n        return false;\n    }\n    // Slow-path; actually attempt to decode the input string.\n    const bytes = base58Encoder.encode(putativeSignature);\n    return isSignatureBytes(bytes);\n}\n\n/**\n * A type guard that accepts a `ReadonlyUint8Array` as input. It will both return `true` if the `ReadonlyUint8Array` conforms to\n * the {@link SignatureBytes} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isSignatureBytes } from '@solana/keys';\n *\n * if (isSignatureBytes(signatureBytes)) {\n *     // At this point, `signatureBytes` has been refined to a\n *     // `SignatureBytes` that can be used with `verifySignature`.\n *     if (!(await verifySignature(publicKey, signatureBytes, data))) {\n *         throw new Error('The data were *not* signed by the private key associated with `publicKey`');\n *     }\n * } else {\n *     setError(`${signatureBytes} is not a 64-byte Ed25519 signature`);\n * }\n * ```\n */\nexport function isSignatureBytes(putativeSignatureBytes: ReadonlyUint8Array): putativeSignatureBytes is SignatureBytes {\n    return putativeSignatureBytes.byteLength === 64;\n}\n\n/**\n * Given a private [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) and a\n * `Uint8Array` of bytes, this method will return the 64-byte Ed25519 signature of that data as a\n * `Uint8Array`.\n *\n * @example\n * ```ts\n * import { signBytes } from '@solana/keys';\n *\n * const data = new Uint8Array([1, 2, 3]);\n * const signature = await signBytes(privateKey, data);\n * ```\n */\nexport async function signBytes(key: CryptoKey, data: ReadonlyUint8Array): Promise<SignatureBytes> {\n    assertSigningCapabilityIsAvailable();\n    const signedData = await crypto.subtle.sign(ED25519_ALGORITHM_IDENTIFIER, key, data);\n    return new Uint8Array(signedData) as SignatureBytes;\n}\n\n/**\n * This helper combines _asserting_ that a string is an Ed25519 signature with _coercing_ it to the\n * {@link Signature} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { signature } from '@solana/keys';\n *\n * const signature = signature(userSuppliedSignature);\n * const {\n *     value: [status],\n * } = await rpc.getSignatureStatuses([signature]).send();\n * ```\n */\nexport function signature(putativeSignature: string): Signature {\n    assertIsSignature(putativeSignature);\n    return putativeSignature;\n}\n\n/**\n * This helper combines _asserting_ that a `ReadonlyUint8Array` is an Ed25519 signature with _coercing_ it to the\n * {@link SignatureBytes} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { signatureBytes } from '@solana/keys';\n *\n * const signature = signatureBytes(userSuppliedSignatureBytes);\n * if (!(await verifySignature(publicKey, signature, data))) {\n *     throw new Error('The data were *not* signed by the private key associated with `publicKey`');\n * }\n * ```\n */\nexport function signatureBytes(putativeSignatureBytes: ReadonlyUint8Array): SignatureBytes {\n    assertIsSignatureBytes(putativeSignatureBytes);\n    return putativeSignatureBytes;\n}\n\n/**\n * Given a public [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey), some\n * {@link SignatureBytes}, and a `Uint8Array` of data, this method will return `true` if the\n * signature was produced by signing the data using the private key associated with the public key,\n * and `false` otherwise.\n *\n * @example\n * ```ts\n * import { verifySignature } from '@solana/keys';\n *\n * const data = new Uint8Array([1, 2, 3]);\n * if (!(await verifySignature(publicKey, signature, data))) {\n *     throw new Error('The data were *not* signed by the private key associated with `publicKey`');\n * }\n * ```\n */\nexport async function verifySignature(\n    key: CryptoKey,\n    signature: SignatureBytes,\n    data: ReadonlyUint8Array,\n): Promise<boolean> {\n    assertVerificationCapabilityIsAvailable();\n    return await crypto.subtle.verify(ED25519_ALGORITHM_IDENTIFIER, key, signature, data);\n}\n","import { assertKeyGenerationIsAvailable, assertPRNGIsAvailable } from '@solana/assertions';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH,\n    SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY,\n    SolanaError,\n} from '@solana/errors';\n\nimport { ED25519_ALGORITHM_IDENTIFIER } from './algorithm';\nimport { createPrivateKeyFromBytes } from './private-key';\nimport { getPublicKeyFromPrivateKey } from './public-key';\nimport { signBytes, verifySignature } from './signatures';\n\n/**\n * Generates an Ed25519 public/private key pair for use with other methods in this package that\n * accept [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey) objects.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n *\n * const { privateKey, publicKey } = await generateKeyPair();\n * ```\n */\nexport async function generateKeyPair(): Promise<CryptoKeyPair> {\n    await assertKeyGenerationIsAvailable();\n    const keyPair = await crypto.subtle.generateKey(\n        /* algorithm */ ED25519_ALGORITHM_IDENTIFIER, // Native implementation status: https://github.com/WICG/webcrypto-secure-curves/issues/20\n        /* extractable */ false, // Prevents the bytes of the private key from being visible to JS.\n        /* allowed uses */ ['sign', 'verify'],\n    );\n    return keyPair;\n}\n\n/**\n * Given a 64-byte `Uint8Array` secret key, creates an Ed25519 public/private key pair for use with\n * other methods in this package that accept [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * objects.\n *\n * @param bytes 64 bytes, the first 32 of which represent the private key and the last 32 of which\n * represent its associated public key\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the private\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import fs from 'fs';\n * import { createKeyPairFromBytes } from '@solana/keys';\n *\n * // Get bytes from local keypair file.\n * const keypairFile = fs.readFileSync('~/.config/solana/id.json');\n * const keypairBytes = new Uint8Array(JSON.parse(keypairFile.toString()));\n *\n * // Create a CryptoKeyPair from the bytes.\n * const { privateKey, publicKey } = await createKeyPairFromBytes(keypairBytes);\n * ```\n */\nexport async function createKeyPairFromBytes(\n    bytes: ReadonlyUint8Array,\n    extractable: boolean = false,\n): Promise<CryptoKeyPair> {\n    assertPRNGIsAvailable();\n\n    if (bytes.byteLength !== 64) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH, { byteLength: bytes.byteLength });\n    }\n    const [publicKey, privateKey] = await Promise.all([\n        crypto.subtle.importKey('raw', bytes.slice(32), ED25519_ALGORITHM_IDENTIFIER, /* extractable */ true, [\n            'verify',\n        ]),\n        createPrivateKeyFromBytes(bytes.slice(0, 32), extractable),\n    ]);\n\n    // Verify the key pair\n    const randomBytes = new Uint8Array(32);\n    crypto.getRandomValues(randomBytes);\n    const signedData = await signBytes(privateKey, randomBytes);\n    const isValid = await verifySignature(publicKey, signedData, randomBytes);\n    if (!isValid) {\n        throw new SolanaError(SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY);\n    }\n\n    return { privateKey, publicKey } as CryptoKeyPair;\n}\n\n/**\n * Given a private key represented as a 32-byte `Uint8Array`, creates an Ed25519 public/private key\n * pair for use with other methods in this package that accept [`CryptoKey`](https://developer.mozilla.org/en-US/docs/Web/API/CryptoKey)\n * objects.\n *\n * @param bytes 32 bytes that represent the private key\n * @param extractable Setting this to `true` makes it possible to extract the bytes of the private\n * key using the [`crypto.subtle.exportKey()`](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/exportKey)\n * API. Defaults to `false`.\n *\n * @example\n * ```ts\n * import { createKeyPairFromPrivateKeyBytes } from '@solana/keys';\n *\n * const { privateKey, publicKey } = await createKeyPairFromPrivateKeyBytes(new Uint8Array([...]));\n * ```\n *\n * This can be useful when you have a private key but not the corresponding public key or when you\n * need to derive key pairs from seeds. For instance, the following code snippet derives a key pair\n * from the hash of a message.\n *\n * ```ts\n * import { getUtf8Encoder } from '@solana/codecs-strings';\n * import { createKeyPairFromPrivateKeyBytes } from '@solana/keys';\n *\n * const message = getUtf8Encoder().encode('Hello, World!');\n * const seed = new Uint8Array(await crypto.subtle.digest('SHA-256', message));\n *\n * const derivedKeypair = await createKeyPairFromPrivateKeyBytes(seed);\n * ```\n */\nexport async function createKeyPairFromPrivateKeyBytes(\n    bytes: ReadonlyUint8Array,\n    extractable: boolean = false,\n): Promise<CryptoKeyPair> {\n    const privateKeyPromise = createPrivateKeyFromBytes(bytes, extractable);\n\n    // Here we need the private key to be extractable in order to export\n    // it as a public key. Therefore, if the `extractable` parameter\n    // is `false`, we need to create two private keys such that:\n    //   - The extractable one is used to create the public key and\n    //   - The non-extractable one is the one we will return.\n    const [publicKey, privateKey] = await Promise.all([\n        // This nested promise makes things efficient by\n        // creating the public key in parallel with the\n        // second private key creation, if it is needed.\n        (extractable ? privateKeyPromise : createPrivateKeyFromBytes(bytes, true /* extractable */)).then(\n            async privateKey => await getPublicKeyFromPrivateKey(privateKey, true /* extractable */),\n        ),\n        privateKeyPromise,\n    ]);\n\n    return { privateKey, publicKey };\n}\n","import { getAddressDecoder, isAddress, getAddressFromPublicKey } from '@solana/addresses';\nimport { transformDecoder, fixDecoderSize, combineCodec, padRightDecoder, transformEncoder, fixEncoderSize } from '@solana/codecs-core';\nimport { getStructEncoder, getBytesEncoder, getStructDecoder, getArrayDecoder, getBytesDecoder, getTupleDecoder, getArrayEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getU8Decoder, getShortU16Encoder } from '@solana/codecs-numbers';\nimport { SolanaError, SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE, SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME, SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME, SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING, SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING, SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES } from '@solana/errors';\nimport { getTransactionVersionDecoder, compileTransactionMessage, getCompiledTransactionMessageEncoder, isTransactionMessageWithBlockhashLifetime, isTransactionMessageWithDurableNonceLifetime } from '@solana/transaction-messages';\nimport { isBlockhash } from '@solana/rpc-types';\nimport { getBase58Decoder, getBase64Decoder } from '@solana/codecs-strings';\nimport { signBytes } from '@solana/keys';\n\n// src/codecs/transaction-codec.ts\nfunction getSignaturesToEncode(signaturesMap) {\n  const signatures = Object.values(signaturesMap);\n  if (signatures.length === 0) {\n    throw new SolanaError(SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES);\n  }\n  return signatures.map((signature) => {\n    if (!signature) {\n      return new Uint8Array(64).fill(0);\n    }\n    return signature;\n  });\n}\nfunction getSignaturesEncoder() {\n  return transformEncoder(\n    getArrayEncoder(fixEncoderSize(getBytesEncoder(), 64), { size: getShortU16Encoder() }),\n    getSignaturesToEncode\n  );\n}\n\n// src/codecs/transaction-codec.ts\nfunction getTransactionEncoder() {\n  return getStructEncoder([\n    [\"signatures\", getSignaturesEncoder()],\n    [\"messageBytes\", getBytesEncoder()]\n  ]);\n}\nfunction getTransactionDecoder() {\n  return transformDecoder(\n    getStructDecoder([\n      [\"signatures\", getArrayDecoder(fixDecoderSize(getBytesDecoder(), 64), { size: getShortU16Decoder() })],\n      [\"messageBytes\", getBytesDecoder()]\n    ]),\n    decodePartiallyDecodedTransaction\n  );\n}\nfunction getTransactionCodec() {\n  return combineCodec(getTransactionEncoder(), getTransactionDecoder());\n}\nfunction decodePartiallyDecodedTransaction(transaction) {\n  const { messageBytes, signatures } = transaction;\n  const signerAddressesDecoder = getTupleDecoder([\n    // read transaction version\n    getTransactionVersionDecoder(),\n    // read first byte of header, `numSignerAccounts`\n    // padRight to skip the next 2 bytes, `numReadOnlySignedAccounts` and `numReadOnlyUnsignedAccounts` which we don't need\n    padRightDecoder(getU8Decoder(), 2),\n    // read static addresses\n    getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() })\n  ]);\n  const [_txVersion, numRequiredSignatures, staticAddresses] = signerAddressesDecoder.decode(messageBytes);\n  const signerAddresses = staticAddresses.slice(0, numRequiredSignatures);\n  if (signerAddresses.length !== signatures.length) {\n    throw new SolanaError(SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, {\n      numRequiredSignatures,\n      signaturesLength: signatures.length,\n      signerAddresses\n    });\n  }\n  const signaturesMap = {};\n  signerAddresses.forEach((address, index) => {\n    const signatureForAddress = signatures[index];\n    if (signatureForAddress.every((b) => b === 0)) {\n      signaturesMap[address] = null;\n    } else {\n      signaturesMap[address] = signatureForAddress;\n    }\n  });\n  return {\n    messageBytes,\n    signatures: Object.freeze(signaturesMap)\n  };\n}\nvar SYSTEM_PROGRAM_ADDRESS = \"11111111111111111111111111111111\";\nfunction compiledInstructionIsAdvanceNonceInstruction(instruction, staticAddresses) {\n  return staticAddresses[instruction.programAddressIndex] === SYSTEM_PROGRAM_ADDRESS && // Test for `AdvanceNonceAccount` instruction data\n  instruction.data != null && isAdvanceNonceAccountInstructionData(instruction.data) && // Test for exactly 3 accounts\n  instruction.accountIndices?.length === 3;\n}\nfunction isAdvanceNonceAccountInstructionData(data) {\n  return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\nasync function getTransactionLifetimeConstraintFromCompiledTransactionMessage(compiledTransactionMessage) {\n  const firstInstruction = compiledTransactionMessage.instructions[0];\n  const { staticAccounts } = compiledTransactionMessage;\n  if (firstInstruction && compiledInstructionIsAdvanceNonceInstruction(firstInstruction, staticAccounts)) {\n    const nonceAccountAddress = staticAccounts[firstInstruction.accountIndices[0]];\n    if (!nonceAccountAddress) {\n      throw new SolanaError(SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE, {\n        nonce: compiledTransactionMessage.lifetimeToken\n      });\n    }\n    return {\n      nonce: compiledTransactionMessage.lifetimeToken,\n      nonceAccountAddress\n    };\n  } else {\n    return {\n      blockhash: compiledTransactionMessage.lifetimeToken,\n      // This is not known from the compiled message, so we set it to the maximum possible value\n      lastValidBlockHeight: 0xffffffffffffffffn\n    };\n  }\n}\nfunction isTransactionWithBlockhashLifetime(transaction) {\n  return \"lifetimeConstraint\" in transaction && \"blockhash\" in transaction.lifetimeConstraint && typeof transaction.lifetimeConstraint.blockhash === \"string\" && typeof transaction.lifetimeConstraint.lastValidBlockHeight === \"bigint\" && isBlockhash(transaction.lifetimeConstraint.blockhash);\n}\nfunction assertIsTransactionWithBlockhashLifetime(transaction) {\n  if (!isTransactionWithBlockhashLifetime(transaction)) {\n    throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);\n  }\n}\nfunction isTransactionWithDurableNonceLifetime(transaction) {\n  return \"lifetimeConstraint\" in transaction && \"nonce\" in transaction.lifetimeConstraint && typeof transaction.lifetimeConstraint.nonce === \"string\" && typeof transaction.lifetimeConstraint.nonceAccountAddress === \"string\" && isAddress(transaction.lifetimeConstraint.nonceAccountAddress);\n}\nfunction assertIsTransactionWithDurableNonceLifetime(transaction) {\n  if (!isTransactionWithDurableNonceLifetime(transaction)) {\n    throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);\n  }\n}\nfunction compileTransaction(transactionMessage) {\n  const compiledMessage = compileTransactionMessage(transactionMessage);\n  const messageBytes = getCompiledTransactionMessageEncoder().encode(compiledMessage);\n  const transactionSigners = compiledMessage.staticAccounts.slice(0, compiledMessage.header.numSignerAccounts);\n  const signatures = {};\n  for (const signerAddress of transactionSigners) {\n    signatures[signerAddress] = null;\n  }\n  let lifetimeConstraint;\n  if (isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n    lifetimeConstraint = {\n      blockhash: transactionMessage.lifetimeConstraint.blockhash,\n      lastValidBlockHeight: transactionMessage.lifetimeConstraint.lastValidBlockHeight\n    };\n  } else if (isTransactionMessageWithDurableNonceLifetime(transactionMessage)) {\n    lifetimeConstraint = {\n      nonce: transactionMessage.lifetimeConstraint.nonce,\n      nonceAccountAddress: transactionMessage.instructions[0].accounts[0].address\n    };\n  }\n  return Object.freeze({\n    ...lifetimeConstraint ? { lifetimeConstraint } : void 0,\n    messageBytes,\n    signatures: Object.freeze(signatures)\n  });\n}\nvar base58Decoder;\nfunction getSignatureFromTransaction(transaction) {\n  if (!base58Decoder) base58Decoder = getBase58Decoder();\n  const signatureBytes = Object.values(transaction.signatures)[0];\n  if (!signatureBytes) {\n    throw new SolanaError(SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING);\n  }\n  const transactionSignature = base58Decoder.decode(signatureBytes);\n  return transactionSignature;\n}\nfunction uint8ArraysEqual(arr1, arr2) {\n  return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);\n}\nasync function partiallySignTransaction(keyPairs, transaction) {\n  let newSignatures;\n  let unexpectedSigners;\n  await Promise.all(\n    keyPairs.map(async (keyPair) => {\n      const address = await getAddressFromPublicKey(keyPair.publicKey);\n      const existingSignature = transaction.signatures[address];\n      if (existingSignature === void 0) {\n        unexpectedSigners ||= /* @__PURE__ */ new Set();\n        unexpectedSigners.add(address);\n        return;\n      }\n      if (unexpectedSigners) {\n        return;\n      }\n      const newSignature = await signBytes(keyPair.privateKey, transaction.messageBytes);\n      if (existingSignature !== null && uint8ArraysEqual(newSignature, existingSignature)) {\n        return;\n      }\n      newSignatures ||= {};\n      newSignatures[address] = newSignature;\n    })\n  );\n  if (unexpectedSigners && unexpectedSigners.size > 0) {\n    const expectedSigners = Object.keys(transaction.signatures);\n    throw new SolanaError(SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION, {\n      expectedAddresses: expectedSigners,\n      unexpectedAddresses: [...unexpectedSigners]\n    });\n  }\n  if (!newSignatures) {\n    return transaction;\n  }\n  return Object.freeze({\n    ...transaction,\n    signatures: Object.freeze({\n      ...transaction.signatures,\n      ...newSignatures\n    })\n  });\n}\nasync function signTransaction(keyPairs, transaction) {\n  const out = await partiallySignTransaction(keyPairs, transaction);\n  assertIsFullySignedTransaction(out);\n  Object.freeze(out);\n  return out;\n}\nfunction isFullySignedTransaction(transaction) {\n  return Object.entries(transaction.signatures).every(([_, signatureBytes]) => !!signatureBytes);\n}\nfunction assertIsFullySignedTransaction(transaction) {\n  const missingSigs = [];\n  Object.entries(transaction.signatures).forEach(([address, signatureBytes]) => {\n    if (!signatureBytes) {\n      missingSigs.push(address);\n    }\n  });\n  if (missingSigs.length > 0) {\n    throw new SolanaError(SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING, {\n      addresses: missingSigs\n    });\n  }\n}\nfunction getBase64EncodedWireTransaction(transaction) {\n  const wireTransactionBytes = getTransactionEncoder().encode(transaction);\n  return getBase64Decoder().decode(wireTransactionBytes);\n}\nvar TRANSACTION_PACKET_SIZE = 1280;\nvar TRANSACTION_PACKET_HEADER = 40 + 8;\nvar TRANSACTION_SIZE_LIMIT = TRANSACTION_PACKET_SIZE - TRANSACTION_PACKET_HEADER;\nfunction getTransactionSize(transaction) {\n  return getTransactionEncoder().getSizeFromValue(transaction);\n}\nfunction isTransactionWithinSizeLimit(transaction) {\n  return getTransactionSize(transaction) <= TRANSACTION_SIZE_LIMIT;\n}\nfunction assertIsTransactionWithinSizeLimit(transaction) {\n  const transactionSize = getTransactionSize(transaction);\n  if (transactionSize > TRANSACTION_SIZE_LIMIT) {\n    throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, {\n      transactionSize,\n      transactionSizeLimit: TRANSACTION_SIZE_LIMIT\n    });\n  }\n}\n\n// src/sendable-transaction.ts\nfunction isSendableTransaction(transaction) {\n  return isFullySignedTransaction(transaction) && isTransactionWithinSizeLimit(transaction);\n}\nfunction assertIsSendableTransaction(transaction) {\n  assertIsFullySignedTransaction(transaction);\n  assertIsTransactionWithinSizeLimit(transaction);\n}\nfunction getTransactionMessageSize(transactionMessage) {\n  return getTransactionSize(compileTransaction(transactionMessage));\n}\nfunction isTransactionMessageWithinSizeLimit(transactionMessage) {\n  return getTransactionMessageSize(transactionMessage) <= TRANSACTION_SIZE_LIMIT;\n}\nfunction assertIsTransactionMessageWithinSizeLimit(transactionMessage) {\n  const transactionSize = getTransactionMessageSize(transactionMessage);\n  if (transactionSize > TRANSACTION_SIZE_LIMIT) {\n    throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, {\n      transactionSize,\n      transactionSizeLimit: TRANSACTION_SIZE_LIMIT\n    });\n  }\n}\n\nexport { TRANSACTION_PACKET_HEADER, TRANSACTION_PACKET_SIZE, TRANSACTION_SIZE_LIMIT, assertIsFullySignedTransaction, assertIsSendableTransaction, assertIsTransactionMessageWithinSizeLimit, assertIsTransactionWithBlockhashLifetime, assertIsTransactionWithDurableNonceLifetime, assertIsTransactionWithinSizeLimit, compileTransaction, getBase64EncodedWireTransaction, getSignatureFromTransaction, getTransactionCodec, getTransactionDecoder, getTransactionEncoder, getTransactionLifetimeConstraintFromCompiledTransactionMessage, getTransactionMessageSize, getTransactionSize, isFullySignedTransaction, isSendableTransaction, isTransactionMessageWithinSizeLimit, isTransactionWithBlockhashLifetime, isTransactionWithDurableNonceLifetime, isTransactionWithinSizeLimit, partiallySignTransaction, signTransaction };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","import { fixEncoderSize, transformEncoder, VariableSizeEncoder } from '@solana/codecs-core';\nimport { getArrayEncoder, getBytesEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Encoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\n\nimport { SignaturesMap } from '../transaction';\n\nfunction getSignaturesToEncode(signaturesMap: SignaturesMap): SignatureBytes[] {\n    const signatures = Object.values(signaturesMap);\n    if (signatures.length === 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES);\n    }\n\n    return signatures.map(signature => {\n        if (!signature) {\n            return new Uint8Array(64).fill(0) as SignatureBytes;\n        }\n        return signature;\n    });\n}\n\nexport function getSignaturesEncoder(): VariableSizeEncoder<SignaturesMap> {\n    return transformEncoder(\n        getArrayEncoder(fixEncoderSize(getBytesEncoder(), 64), { size: getShortU16Encoder() }),\n        getSignaturesToEncode,\n    );\n}\n","import { getAddressDecoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    fixDecoderSize,\n    padRightDecoder,\n    ReadonlyUint8Array,\n    transformDecoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getTupleDecoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getU8Decoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, SolanaError } from '@solana/errors';\nimport { SignatureBytes } from '@solana/keys';\nimport { getTransactionVersionDecoder } from '@solana/transaction-messages';\n\nimport { SignaturesMap, Transaction, TransactionMessageBytes } from '../transaction';\nimport { getSignaturesEncoder } from './signatures-encoder';\n\n/**\n * Returns an encoder that you can use to encode a {@link Transaction} to a byte array in a wire\n * format appropriate for sending to the Solana network for execution.\n */\nexport function getTransactionEncoder(): VariableSizeEncoder<Transaction> {\n    return getStructEncoder([\n        ['signatures', getSignaturesEncoder()],\n        ['messageBytes', getBytesEncoder()],\n    ]);\n}\n\n/**\n * Returns a decoder that you can use to convert a byte array in the Solana transaction wire format\n * to a {@link Transaction} object.\n *\n * @example\n * ```ts\n * import { getTransactionDecoder } from '@solana/transactions';\n *\n * const transactionDecoder = getTransactionDecoder();\n * const transaction = transactionDecoder.decode(wireTransactionBytes);\n * for (const [address, signature] in Object.entries(transaction.signatures)) {\n *     console.log(`Signature by ${address}`, signature);\n * }\n * ```\n */\n\nexport function getTransactionDecoder(): VariableSizeDecoder<Transaction> {\n    return transformDecoder(\n        getStructDecoder([\n            ['signatures', getArrayDecoder(fixDecoderSize(getBytesDecoder(), 64), { size: getShortU16Decoder() })],\n            ['messageBytes', getBytesDecoder()],\n        ]),\n        decodePartiallyDecodedTransaction,\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a {@link Transaction}\n *\n * @see {@link getTransactionDecoder}\n * @see {@link getTransactionEncoder}\n */\nexport function getTransactionCodec(): VariableSizeCodec<Transaction> {\n    return combineCodec(getTransactionEncoder(), getTransactionDecoder());\n}\n\ntype PartiallyDecodedTransaction = {\n    messageBytes: ReadonlyUint8Array;\n    signatures: ReadonlyUint8Array[];\n};\n\nfunction decodePartiallyDecodedTransaction(transaction: PartiallyDecodedTransaction): Transaction {\n    const { messageBytes, signatures } = transaction;\n\n    /*\n    Relevant message structure is at the start:\n    - transaction version (0 bytes for legacy transactions, 1 byte for versioned transactions)\n    - `numRequiredSignatures` (1 byte, we verify this matches the length of signatures)\n    - `numReadOnlySignedAccounts` (1 byte, not used here)\n    - `numReadOnlyUnsignedAccounts` (1 byte, not used here)\n    - static addresses, with signers first. This is an array of addresses, prefixed with a short-u16 length\n    */\n\n    const signerAddressesDecoder = getTupleDecoder([\n        // read transaction version\n        getTransactionVersionDecoder(),\n        // read first byte of header, `numSignerAccounts`\n        // padRight to skip the next 2 bytes, `numReadOnlySignedAccounts` and `numReadOnlyUnsignedAccounts` which we don't need\n        padRightDecoder(getU8Decoder(), 2),\n        // read static addresses\n        getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() }),\n    ]);\n    const [_txVersion, numRequiredSignatures, staticAddresses] = signerAddressesDecoder.decode(messageBytes);\n\n    const signerAddresses = staticAddresses.slice(0, numRequiredSignatures);\n\n    // signer addresses and signatures must be the same length\n    // we encode an all-zero signature when the signature is missing\n    if (signerAddresses.length !== signatures.length) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH, {\n            numRequiredSignatures,\n            signaturesLength: signatures.length,\n            signerAddresses,\n        });\n    }\n\n    // combine the signer addresses + signatures into the signatures map\n    const signaturesMap: SignaturesMap = {};\n    signerAddresses.forEach((address, index) => {\n        const signatureForAddress = signatures[index];\n        if (signatureForAddress.every(b => b === 0)) {\n            signaturesMap[address] = null;\n        } else {\n            signaturesMap[address] = signatureForAddress as SignatureBytes;\n        }\n    });\n\n    return {\n        messageBytes: messageBytes as TransactionMessageBytes,\n        signatures: Object.freeze(signaturesMap),\n    };\n}\n","import { type Address, isAddress } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME,\n    SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE,\n    SolanaError,\n} from '@solana/errors';\nimport { type Blockhash, isBlockhash, type Slot } from '@solana/rpc-types';\nimport type {\n    CompiledTransactionMessage,\n    CompiledTransactionMessageWithLifetime,\n    Nonce,\n    TransactionMessage,\n    TransactionMessageWithBlockhashLifetime,\n    TransactionMessageWithDurableNonceLifetime,\n} from '@solana/transaction-messages';\n\nimport type { Transaction } from './transaction';\n\n/**\n * A constraint which, when applied to a transaction, makes that transaction eligible to land on the\n * network. The transaction will continue to be eligible to land until the network considers the\n * `blockhash` to be expired.\n *\n * This can happen when the network proceeds past the `lastValidBlockHeight` for which the blockhash\n * is considered valid, or when the network switches to a fork where that blockhash is not present.\n */\nexport type TransactionBlockhashLifetime = {\n    /**\n     * A recent blockhash observed by the transaction proposer.\n     *\n     * The transaction will be considered eligible to land until the network determines this\n     * blockhash to be too old, or has switched to a fork where it is not present.\n     */\n    blockhash: Blockhash;\n    /**\n     * This is the block height beyond which the network will consider the blockhash to be too old\n     * to make a transaction eligible to land.\n     */\n    lastValidBlockHeight: Slot;\n};\n\n/**\n * A constraint which, when applied to a transaction, makes that transaction eligible to land on the\n * network.\n *\n * The transaction will continue to be eligible to land until the network considers the `nonce` to\n * have advanced. This can happen when the nonce account in which this nonce is found is destroyed,\n * or the nonce value within changes.\n */\nexport type TransactionDurableNonceLifetime = {\n    /**\n     * A value contained in the account with address `nonceAccountAddress` at the time the\n     * transaction was prepared.\n     *\n     * The transaction will be considered eligible to land until the nonce account ceases to exist\n     * or contain this value.\n     */\n    nonce: Nonce;\n    /** The account that contains the `nonce` value */\n    nonceAccountAddress: Address;\n};\n\n/**\n * A transaction whose ability to land on the network is determined by some evanescent criteria.\n *\n * This describes a window of time after which a transaction is constructed and before which it will\n * no longer be accepted by the network.\n *\n * No transaction can land on Solana without having a `lifetimeConstraint` set.\n */\nexport type TransactionWithLifetime = {\n    readonly lifetimeConstraint: TransactionBlockhashLifetime | TransactionDurableNonceLifetime;\n};\n\n/**\n * A transaction whose lifetime is determined by the age of a blockhash observed on the network.\n *\n * The transaction will continue to be eligible to land until the network considers the `blockhash`\n * to be expired.\n */\nexport type TransactionWithBlockhashLifetime = {\n    readonly lifetimeConstraint: TransactionBlockhashLifetime;\n};\n\n/**\n * A transaction whose lifetime is determined by a nonce.\n *\n * The transaction will continue to be eligible to land until the network considers the `nonce` to\n * have advanced. This can happen when the nonce account in which this nonce is found is destroyed,\n * or the nonce value within changes.\n */\nexport type TransactionWithDurableNonceLifetime = {\n    readonly lifetimeConstraint: TransactionDurableNonceLifetime;\n};\n\n/**\n * Helper type that sets the lifetime constraint of a transaction to be the same as the\n * lifetime constraint of the provided transaction message.\n *\n * If the transaction message has no explicit lifetime constraint, neither will the transaction.\n */\nexport type SetTransactionLifetimeFromTransactionMessage<\n    TTransaction extends Transaction,\n    TTransactionMessage extends TransactionMessage,\n> = TTransactionMessage extends { lifetimeConstraint: unknown }\n    ? TTransactionMessage['lifetimeConstraint'] extends TransactionMessageWithBlockhashLifetime['lifetimeConstraint']\n        ? TransactionWithBlockhashLifetime & TTransaction\n        : TTransactionMessage['lifetimeConstraint'] extends TransactionMessageWithDurableNonceLifetime['lifetimeConstraint']\n          ? TransactionWithDurableNonceLifetime & TTransaction\n          : TransactionWithLifetime & TTransaction\n    : TTransaction;\n\nconst SYSTEM_PROGRAM_ADDRESS = '11111111111111111111111111111111' as Address;\n\nfunction compiledInstructionIsAdvanceNonceInstruction(\n    instruction: CompiledTransactionMessage['instructions'][number],\n    staticAddresses: Address[],\n): instruction is typeof instruction & { accountIndices: [number, number, number] } {\n    return (\n        staticAddresses[instruction.programAddressIndex] === SYSTEM_PROGRAM_ADDRESS &&\n        // Test for `AdvanceNonceAccount` instruction data\n        instruction.data != null &&\n        isAdvanceNonceAccountInstructionData(instruction.data) &&\n        // Test for exactly 3 accounts\n        instruction.accountIndices?.length === 3\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionData(data: ReadonlyUint8Array): boolean {\n    // AdvanceNonceAccount is the fifth instruction in the System Program (index 4)\n    return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\n\n/**\n * Get the lifetime constraint for a transaction from a compiled transaction message that includes a lifetime token.\n * @param compiledTransactionMessage A compiled transaction message that includes a lifetime token\n * @returns A lifetime constraint for the transaction\n * Note that this is less precise than checking a decompiled instruction, as we can't inspect\n * the address or role of input accounts (which may be in lookup tables). However, this is\n * sufficient for all valid advance durable nonce instructions.\n * Note that the program address must not be in a lookup table, see [this answer on StackExchange](https://solana.stackexchange.com/a/16224/289)\n * @see {@link isAdvanceNonceAccountInstruction}\n * Note that this function is async to allow for future implementations that may fetch `lastValidBlockHeight` using an RPC\n */\n// eslint-disable-next-line @typescript-eslint/require-await\nexport async function getTransactionLifetimeConstraintFromCompiledTransactionMessage(\n    compiledTransactionMessage: CompiledTransactionMessage & CompiledTransactionMessageWithLifetime,\n): Promise<TransactionBlockhashLifetime | TransactionDurableNonceLifetime> {\n    const firstInstruction = compiledTransactionMessage.instructions[0];\n    const { staticAccounts } = compiledTransactionMessage;\n\n    // We need to check if the first instruction is an AdvanceNonceAccount instruction\n    if (firstInstruction && compiledInstructionIsAdvanceNonceInstruction(firstInstruction, staticAccounts)) {\n        const nonceAccountAddress = staticAccounts[firstInstruction.accountIndices[0]];\n        if (!nonceAccountAddress) {\n            throw new SolanaError(SOLANA_ERROR__TRANSACTION__NONCE_ACCOUNT_CANNOT_BE_IN_LOOKUP_TABLE, {\n                nonce: compiledTransactionMessage.lifetimeToken,\n            });\n        }\n        return {\n            nonce: compiledTransactionMessage.lifetimeToken as Nonce,\n            nonceAccountAddress,\n        };\n    } else {\n        return {\n            blockhash: compiledTransactionMessage.lifetimeToken as Blockhash,\n            // This is not known from the compiled message, so we set it to the maximum possible value\n            lastValidBlockHeight: 0xffffffffffffffffn,\n        };\n    }\n}\n\n/**\n * A type guard that returns `true` if the transaction conforms to the\n * {@link TransactionWithBlockhashLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionWithBlockhashLifetime } from '@solana/transactions';\n *\n * if (isTransactionWithBlockhashLifetime(transaction)) {\n *     // At this point, `transaction` has been refined to a `TransactionWithBlockhashLifetime`.\n *     const { blockhash } = transaction.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n *     setBlockhashIsValid(blockhashIsValid);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a blockhash-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionWithBlockhashLifetime(\n    transaction: Transaction | (Transaction & TransactionWithLifetime),\n): transaction is Transaction & TransactionWithBlockhashLifetime {\n    return (\n        'lifetimeConstraint' in transaction &&\n        'blockhash' in transaction.lifetimeConstraint &&\n        typeof transaction.lifetimeConstraint.blockhash === 'string' &&\n        typeof transaction.lifetimeConstraint.lastValidBlockHeight === 'bigint' &&\n        isBlockhash(transaction.lifetimeConstraint.blockhash)\n    );\n}\n\n/**\n * From time to time you might acquire a transaction, that you expect to have a\n * blockhash-based lifetime, from for example a wallet. Use this function to\n * assert that such a transaction actually has a blockhash-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionWithBlockhashLifetime } from '@solana/transactions';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `transaction` to `TransactionWithBlockhashLifetime`.\n *     assertIsTransactionWithBlockhashLifetime(transaction);\n *     // At this point, `transaction` is a `TransactionWithBlockhashLifetime` that can be used\n *     // with the RPC.\n *     const { blockhash } = transaction.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n * } catch (e) {\n *     // `transaction` turned out not to have a blockhash-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionWithBlockhashLifetime(\n    transaction: Transaction | (Transaction & TransactionWithLifetime),\n): asserts transaction is Transaction & TransactionWithBlockhashLifetime {\n    if (!isTransactionWithBlockhashLifetime(transaction)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);\n    }\n}\n\n/**\n * A type guard that returns `true` if the transaction conforms to the\n * {@link TransactionWithDurableNonceLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionWithDurableNonceLifetime } from '@solana/transactions';\n * import { fetchNonce } from \"@solana-program/system\";\n *\n * if (isTransactionWithDurableNonceLifetime(transaction)) {\n *     // At this point, `transaction` has been refined to a\n *     // `TransactionWithDurableNonceLifetime`.\n *     const { nonce, nonceAccountAddress } = transaction.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n *     setNonceIsValid(nonce === actualNonce);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a nonce-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionWithDurableNonceLifetime(\n    transaction: Transaction | (Transaction & TransactionWithLifetime),\n): transaction is Transaction & TransactionWithDurableNonceLifetime {\n    return (\n        'lifetimeConstraint' in transaction &&\n        'nonce' in transaction.lifetimeConstraint &&\n        typeof transaction.lifetimeConstraint.nonce === 'string' &&\n        typeof transaction.lifetimeConstraint.nonceAccountAddress === 'string' &&\n        isAddress(transaction.lifetimeConstraint.nonceAccountAddress)\n    );\n}\n\n/**\n * From time to time you might acquire a transaction, that you expect to have a\n * nonce-based lifetime, from for example a wallet. Use this function to assert\n * that such a transaction actually has a nonce-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionWithDurableNonceLifetime } from '@solana/transactions';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `transaction` to `TransactionWithDurableNonceLifetime`.\n *     assertIsTransactionWithDurableNonceLifetime(transaction);\n *     // At this point, `transaction` is a `TransactionWithDurableNonceLifetime` that can be used\n *     // with the RPC.\n *     const { nonce, nonceAccountAddress } = transaction.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n * } catch (e) {\n *     // `transaction` turned out not to have a nonce-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionWithDurableNonceLifetime(\n    transaction: Transaction | (Transaction & TransactionWithLifetime),\n): asserts transaction is Transaction & TransactionWithDurableNonceLifetime {\n    if (!isTransactionWithDurableNonceLifetime(transaction)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);\n    }\n}\n","import {\n    BaseTransactionMessage,\n    compileTransactionMessage,\n    getCompiledTransactionMessageEncoder,\n    isTransactionMessageWithBlockhashLifetime,\n    isTransactionMessageWithDurableNonceLifetime,\n    TransactionMessageWithFeePayer,\n} from '@solana/transaction-messages';\n\nimport type { TransactionWithLifetime } from './lifetime';\nimport type { SignaturesMap, TransactionFromTransactionMessage, TransactionMessageBytes } from './transaction';\n\n/**\n * Returns a {@link Transaction} object for a given {@link TransactionMessage}.\n *\n * This includes the compiled bytes of the transaction message, and a map of signatures. This map\n * will have a key for each address that is required to sign the transaction. The transaction will\n * not yet have signatures for any of these addresses.\n *\n * Whether a transaction message is ready to be compiled or not is enforced for you at the type\n * level. In order to be signable, a transaction message must:\n *\n * - have a version and a list of zero or more instructions (ie. conform to\n *   {@link BaseTransactionMessage})\n * - have a fee payer set (ie. conform to {@link TransactionMessageWithFeePayer})\n * - have a lifetime specified (ie. conform to {@link TransactionMessageWithBlockhashLifetime} or\n *   {@link TransactionMessageWithDurableNonceLifetime})\n */\nexport function compileTransaction<TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer>(\n    transactionMessage: TTransactionMessage,\n): Readonly<TransactionFromTransactionMessage<TTransactionMessage>> {\n    type ReturnType = Readonly<TransactionFromTransactionMessage<TTransactionMessage>>;\n\n    const compiledMessage = compileTransactionMessage(transactionMessage);\n    const messageBytes = getCompiledTransactionMessageEncoder().encode(compiledMessage) as TransactionMessageBytes;\n\n    const transactionSigners = compiledMessage.staticAccounts.slice(0, compiledMessage.header.numSignerAccounts);\n    const signatures: SignaturesMap = {};\n    for (const signerAddress of transactionSigners) {\n        signatures[signerAddress] = null;\n    }\n\n    let lifetimeConstraint: TransactionWithLifetime['lifetimeConstraint'] | undefined;\n    if (isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n        lifetimeConstraint = {\n            blockhash: transactionMessage.lifetimeConstraint.blockhash,\n            lastValidBlockHeight: transactionMessage.lifetimeConstraint.lastValidBlockHeight,\n        };\n    } else if (isTransactionMessageWithDurableNonceLifetime(transactionMessage)) {\n        lifetimeConstraint = {\n            nonce: transactionMessage.lifetimeConstraint.nonce,\n            nonceAccountAddress: transactionMessage.instructions[0].accounts[0].address,\n        };\n    }\n\n    return Object.freeze({\n        ...(lifetimeConstraint ? { lifetimeConstraint } : undefined),\n        messageBytes: messageBytes,\n        signatures: Object.freeze(signatures),\n    }) as ReturnType;\n}\n","import { Address, getAddressFromPublicKey } from '@solana/addresses';\nimport { Decoder } from '@solana/codecs-core';\nimport { getBase58Decoder } from '@solana/codecs-strings';\nimport {\n    SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION,\n    SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING,\n    SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING,\n    SolanaError,\n} from '@solana/errors';\nimport { Signature, SignatureBytes, signBytes } from '@solana/keys';\nimport { NominalType } from '@solana/nominal-types';\n\nimport { TransactionWithLifetime } from './lifetime';\nimport { Transaction } from './transaction';\n\n/**\n * Represents a transaction that is signed by all of its required signers. Being fully signed is a\n * prerequisite of functions designed to land transactions on the network.\n */\nexport type FullySignedTransaction = NominalType<'transactionSignedness', 'fullySigned'>;\n\nlet base58Decoder: Decoder<string> | undefined;\n\n/**\n * Given a transaction signed by its fee payer, this method will return the {@link Signature} that\n * uniquely identifies it. This string can be used to look up transactions at a later date, for\n * example on a Solana block explorer.\n *\n * @example\n * ```ts\n * import { getSignatureFromTransaction } from '@solana/transactions';\n *\n * const signature = getSignatureFromTransaction(tx);\n * console.debug(`Inspect this transaction at https://explorer.solana.com/tx/${signature}`);\n * ```\n */\nexport function getSignatureFromTransaction(transaction: Transaction): Signature {\n    if (!base58Decoder) base58Decoder = getBase58Decoder();\n\n    // We have ordered signatures from the compiled message accounts\n    // first signature is the fee payer\n    const signatureBytes = Object.values(transaction.signatures)[0];\n    if (!signatureBytes) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING);\n    }\n    const transactionSignature = base58Decoder.decode(signatureBytes);\n    return transactionSignature as Signature;\n}\n\nfunction uint8ArraysEqual(arr1: Uint8Array, arr2: Uint8Array) {\n    return arr1.length === arr2.length && arr1.every((value, index) => value === arr2[index]);\n}\n\n/**\n * Given an array of `CryptoKey` objects which are private keys pertaining to addresses that are\n * required to sign a transaction, this method will return a new signed transaction of type\n * {@link Transaction}.\n *\n * Though the resulting transaction might have every signature it needs to land on the network, this\n * function will not assert that it does. A partially signed transaction cannot be landed on the\n * network, but can be serialized and deserialized.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { partiallySignTransaction } from '@solana/transactions';\n *\n * const partiallySignedTransaction = await partiallySignTransaction([myPrivateKey], tx);\n * ```\n *\n * @see {@link signTransaction} if you want to assert that the transaction has all of its required\n * signatures after signing.\n */\nexport async function partiallySignTransaction<TTransaction extends Transaction & TransactionWithLifetime>(\n    keyPairs: CryptoKeyPair[],\n    transaction: TTransaction,\n): Promise<TTransaction> {\n    let newSignatures: Record<Address, SignatureBytes> | undefined;\n    let unexpectedSigners: Set<Address> | undefined;\n\n    await Promise.all(\n        keyPairs.map(async keyPair => {\n            const address = await getAddressFromPublicKey(keyPair.publicKey);\n            const existingSignature = transaction.signatures[address];\n\n            // Check if the address is expected to sign the transaction\n            if (existingSignature === undefined) {\n                // address is not an expected signer for this transaction\n                unexpectedSigners ||= new Set();\n                unexpectedSigners.add(address);\n                return;\n            }\n\n            // Return if there are any unexpected signers already since we won't be using signatures\n            if (unexpectedSigners) {\n                return;\n            }\n\n            const newSignature = await signBytes(keyPair.privateKey, transaction.messageBytes);\n\n            if (existingSignature !== null && uint8ArraysEqual(newSignature, existingSignature)) {\n                // already have the same signature set\n                return;\n            }\n\n            newSignatures ||= {};\n            newSignatures[address] = newSignature;\n        }),\n    );\n\n    if (unexpectedSigners && unexpectedSigners.size > 0) {\n        const expectedSigners = Object.keys(transaction.signatures);\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION, {\n            expectedAddresses: expectedSigners,\n            unexpectedAddresses: [...unexpectedSigners],\n        });\n    }\n\n    if (!newSignatures) {\n        return transaction;\n    }\n\n    return Object.freeze({\n        ...transaction,\n        signatures: Object.freeze({\n            ...transaction.signatures,\n            ...newSignatures,\n        }),\n    });\n}\n\n/**\n * Given an array of `CryptoKey` objects which are private keys pertaining to addresses that are\n * required to sign a transaction, this method will return a new signed transaction of type\n * {@link FullySignedTransaction}.\n *\n * This function will throw unless the resulting transaction is fully signed.\n *\n * @example\n * ```ts\n * import { generateKeyPair } from '@solana/keys';\n * import { signTransaction } from '@solana/transactions';\n *\n * const signedTransaction = await signTransaction([myPrivateKey], tx);\n * ```\n *\n * @see {@link partiallySignTransaction} if you want to sign the transaction without asserting that\n * the resulting transaction is fully signed.\n */\nexport async function signTransaction<TTransaction extends Transaction & TransactionWithLifetime>(\n    keyPairs: CryptoKeyPair[],\n    transaction: TTransaction,\n): Promise<FullySignedTransaction & TTransaction> {\n    const out = await partiallySignTransaction(keyPairs, transaction);\n    assertIsFullySignedTransaction(out);\n    Object.freeze(out);\n    return out;\n}\n\n/**\n * Checks whether a given {@link Transaction} is fully signed.\n *\n * @example\n * ```ts\n * import { isFullySignedTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * if (isFullySignedTransaction(transaction)) {\n *   // At this point we know that the transaction is signed and can be sent to the network.\n * }\n * ```\n */\nexport function isFullySignedTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): transaction is FullySignedTransaction & TTransaction {\n    return Object.entries(transaction.signatures).every(([_, signatureBytes]) => !!signatureBytes);\n}\n\n/**\n * From time to time you might acquire a {@link Transaction}, that you expect to be fully signed,\n * from an untrusted network API or user input. Use this function to assert that such a transaction\n * is fully signed.\n *\n * @example\n * ```ts\n * import { assertIsFullySignedTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * try {\n *     // If this type assertion function doesn't throw, then Typescript will upcast `transaction`\n *     // to `FullySignedTransaction`.\n *     assertIsFullySignedTransaction(transaction);\n *     // At this point we know that the transaction is signed and can be sent to the network.\n *     await sendAndConfirmTransaction(transaction, { commitment: 'confirmed' });\n * } catch(e) {\n *     if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING)) {\n *         setError(`Missing signatures for ${e.context.addresses.join(', ')}`);\n *     }\n *     throw;\n * }\n * ```\n */\nexport function assertIsFullySignedTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): asserts transaction is FullySignedTransaction & TTransaction {\n    const missingSigs: Address[] = [];\n    Object.entries(transaction.signatures).forEach(([address, signatureBytes]) => {\n        if (!signatureBytes) {\n            missingSigs.push(address as Address);\n        }\n    });\n\n    if (missingSigs.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING, {\n            addresses: missingSigs,\n        });\n    }\n}\n","import { getBase64Decoder } from '@solana/codecs-strings';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\nimport { getTransactionEncoder } from './codecs';\nimport { Transaction } from './transaction';\n\n/** Represents the wire format of a transaction as a base64-encoded string. */\nexport type Base64EncodedWireTransaction = Brand<EncodedString<string, 'base64'>, 'Base64EncodedWireTransaction'>;\n\n/**\n * Given a signed transaction, this method returns the transaction as a string that conforms to the\n * {@link Base64EncodedWireTransaction} type.\n *\n * @example\n * ```ts\n * import { getBase64EncodedWireTransaction, signTransaction } from '@solana/transactions';\n *\n * const serializedTransaction = getBase64EncodedWireTransaction(signedTransaction);\n * const signature = await rpc.sendTransaction(serializedTransaction, { encoding: 'base64' }).send();\n * ```\n */\nexport function getBase64EncodedWireTransaction(transaction: Transaction): Base64EncodedWireTransaction {\n    const wireTransactionBytes = getTransactionEncoder().encode(transaction);\n    return getBase64Decoder().decode(wireTransactionBytes) as Base64EncodedWireTransaction;\n}\n","import { SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, SolanaError } from '@solana/errors';\nimport type { NominalType } from '@solana/nominal-types';\nimport type { BaseTransactionMessage, TransactionMessageWithinSizeLimit } from '@solana/transaction-messages';\n\nimport { getTransactionEncoder } from './codecs';\nimport { Transaction } from './transaction';\n\n/**\n * The maximum size of a transaction packet in bytes.\n */\nexport const TRANSACTION_PACKET_SIZE = 1280;\n\n/**\n * The size of the transaction packet header in bytes.\n * This includes the IPv6 header and the fragment header.\n */\nexport const TRANSACTION_PACKET_HEADER =\n    40 /* 40 bytes is the size of the IPv6 header. */ + 8; /* 8 bytes is the size of the fragment header. */\n\n/**\n * The maximum size of a transaction in bytes.\n *\n * Note that this excludes the transaction packet header.\n * In other words, this is how much content we can fit in a transaction packet.\n */\nexport const TRANSACTION_SIZE_LIMIT = TRANSACTION_PACKET_SIZE - TRANSACTION_PACKET_HEADER;\n\n/**\n * Gets the size of a given transaction in bytes.\n *\n * @example\n * ```ts\n * const transactionSize = getTransactionSize(transaction);\n * ```\n */\nexport function getTransactionSize(transaction: Transaction): number {\n    return getTransactionEncoder().getSizeFromValue(transaction);\n}\n\n/**\n * A type guard that checks if a transaction is within the size limit.\n */\nexport type TransactionWithinSizeLimit = NominalType<'transactionSize', 'withinLimit'>;\n\n/**\n * Helper type that adds the `TransactionWithinSizeLimit` flag to\n * a transaction if and only if the provided transaction message\n * is also within the size limit.\n */\nexport type SetTransactionWithinSizeLimitFromTransactionMessage<\n    TTransaction extends Transaction,\n    TTransactionMessage extends BaseTransactionMessage,\n> = TTransactionMessage extends TransactionMessageWithinSizeLimit\n    ? TransactionWithinSizeLimit & TTransaction\n    : TTransaction;\n\n/**\n * Checks if a transaction is within the size limit.\n *\n * @typeParam TTransaction - The type of the given transaction.\n *\n * @example\n * ```ts\n * if (isTransactionWithinSizeLimit(transaction)) {\n *    transaction satisfies TransactionWithinSizeLimit;\n * }\n * ```\n */\nexport function isTransactionWithinSizeLimit<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): transaction is TransactionWithinSizeLimit & TTransaction {\n    return getTransactionSize(transaction) <= TRANSACTION_SIZE_LIMIT;\n}\n\n/**\n * Asserts that a given transaction is within the size limit.\n *\n * Throws a {@link SolanaError} of code {@link SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT}\n * if the transaction exceeds the size limit.\n *\n * @typeParam TTransaction - The type of the given transaction.\n *\n * @example\n * ```ts\n * assertIsTransactionWithinSizeLimit(transaction);\n * transaction satisfies TransactionWithinSizeLimit;\n * ```\n */\nexport function assertIsTransactionWithinSizeLimit<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): asserts transaction is TransactionWithinSizeLimit & TTransaction {\n    const transactionSize = getTransactionSize(transaction);\n    if (transactionSize > TRANSACTION_SIZE_LIMIT) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, {\n            transactionSize,\n            transactionSizeLimit: TRANSACTION_SIZE_LIMIT,\n        });\n    }\n}\n","import { assertIsFullySignedTransaction, FullySignedTransaction, isFullySignedTransaction } from './signatures';\nimport { Transaction } from './transaction';\nimport {\n    assertIsTransactionWithinSizeLimit,\n    isTransactionWithinSizeLimit,\n    TransactionWithinSizeLimit,\n} from './transaction-size';\n\n/**\n * Helper type that includes all transaction types required\n * for the transaction to be sent to the network.\n *\n * @see {@link isSendableTransaction}\n * @see {@link assertIsSendableTransaction}\n */\nexport type SendableTransaction = FullySignedTransaction & TransactionWithinSizeLimit;\n\n/**\n * Checks if a transaction has all the required\n * conditions to be sent to the network.\n *\n * @example\n * ```ts\n * import { isSendableTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * if (isSendableTransaction(transaction)) {\n *   // At this point we know that the transaction can be sent to the network.\n * }\n * ```\n *\n * @see {@link assertIsSendableTransaction}\n */\nexport function isSendableTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): transaction is SendableTransaction & TTransaction {\n    return isFullySignedTransaction(transaction) && isTransactionWithinSizeLimit(transaction);\n}\n\n/**\n * Asserts that a given transaction has all the\n * required conditions to be sent to the network.\n *\n * From time to time you might acquire a {@link Transaction}\n * from an untrusted network API or user input and you are not sure\n * that it has all the required conditions to be sent to the network\n *  such as being fully signed and within the size limit.\n * This function can be used to assert that such a transaction\n * is in fact sendable.\n *\n * @example\n * ```ts\n * import { assertIsSendableTransaction } from '@solana/transactions';\n *\n * const transaction = getTransactionDecoder().decode(transactionBytes);\n * try {\n *     // If this type assertion function doesn't throw, then Typescript will upcast `transaction`\n *     // to `SendableTransaction`.\n *     assertIsSendableTransaction(transaction);\n *     // At this point we know that the transaction can be sent to the network.\n *     await sendAndConfirmTransaction(transaction, { commitment: 'confirmed' });\n * } catch(e) {\n *     if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING)) {\n *         setError(`Missing signatures for ${e.context.addresses.join(', ')}`);\n *     } else if (isSolanaError(e, SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT)) {\n *         setError(`Transaction exceeds size limit of ${e.context.transactionSizeLimit} bytes`);\n *     }\n *     throw;\n * }\n * ```\n */\nexport function assertIsSendableTransaction<TTransaction extends Transaction>(\n    transaction: TTransaction,\n): asserts transaction is SendableTransaction & TTransaction {\n    assertIsFullySignedTransaction(transaction);\n    assertIsTransactionWithinSizeLimit(transaction);\n}\n","import { SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, SolanaError } from '@solana/errors';\nimport type {\n    BaseTransactionMessage,\n    TransactionMessageWithFeePayer,\n    TransactionMessageWithinSizeLimit,\n} from '@solana/transaction-messages';\n\nimport { compileTransaction } from './compile-transaction';\nimport { getTransactionSize, TRANSACTION_SIZE_LIMIT } from './transaction-size';\n\n/**\n * Gets the compiled transaction size of a given transaction message in bytes.\n *\n * @example\n * ```ts\n * const transactionSize = getTransactionMessageSize(transactionMessage);\n * ```\n */\nexport function getTransactionMessageSize(\n    transactionMessage: BaseTransactionMessage & TransactionMessageWithFeePayer,\n): number {\n    return getTransactionSize(compileTransaction(transactionMessage));\n}\n\n/**\n * Checks if a transaction message is within the size limit\n * when compiled into a transaction.\n *\n * @typeParam TTransactionMessage - The type of the given transaction message.\n *\n * @example\n * ```ts\n * if (isTransactionMessageWithinSizeLimit(transactionMessage)) {\n *    transactionMessage satisfies TransactionMessageWithinSizeLimit;\n * }\n * ```\n */\nexport function isTransactionMessageWithinSizeLimit<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(\n    transactionMessage: TTransactionMessage,\n): transactionMessage is TransactionMessageWithinSizeLimit & TTransactionMessage {\n    return getTransactionMessageSize(transactionMessage) <= TRANSACTION_SIZE_LIMIT;\n}\n\n/**\n * Asserts that a given transaction message is within the size limit\n * when compiled into a transaction.\n *\n * Throws a {@link SolanaError} of code {@link SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT}\n * if the transaction message exceeds the size limit.\n *\n * @typeParam TTransactionMessage - The type of the given transaction message.\n *\n * @example\n * ```ts\n * assertIsTransactionMessageWithinSizeLimit(transactionMessage);\n * transactionMessage satisfies TransactionMessageWithinSizeLimit;\n * ```\n */\nexport function assertIsTransactionMessageWithinSizeLimit<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(\n    transactionMessage: TTransactionMessage,\n): asserts transactionMessage is TransactionMessageWithinSizeLimit & TTransactionMessage {\n    const transactionSize = getTransactionMessageSize(transactionMessage);\n    if (transactionSize > TRANSACTION_SIZE_LIMIT) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT, {\n            transactionSize,\n            transactionSizeLimit: TRANSACTION_SIZE_LIMIT,\n        });\n    }\n}\n","import { SolanaError, SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME, SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED, SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE, SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND, SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES } from '@solana/errors';\nimport { isBlockhash } from '@solana/rpc-types';\nimport { getAddressDecoder, getAddressComparator, assertIsAddress, getAddressEncoder } from '@solana/addresses';\nimport { createEncoder, createDecoder, combineCodec, transformDecoder, transformEncoder, fixDecoderSize, fixEncoderSize, addDecoderSizePrefix, addEncoderSizePrefix } from '@solana/codecs-core';\nimport { getStructDecoder, getStructEncoder, getArrayDecoder, getUnionEncoder, getConstantEncoder, getArrayEncoder, getBytesDecoder, getBytesEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\nimport { isSignerRole, AccountRole, isWritableRole, mergeRoles } from '@solana/instructions';\nimport { pipe } from '@solana/functional';\n\n// src/blockhash.ts\nfunction isTransactionMessageWithBlockhashLifetime(transactionMessage) {\n  return \"lifetimeConstraint\" in transactionMessage && typeof transactionMessage.lifetimeConstraint.blockhash === \"string\" && typeof transactionMessage.lifetimeConstraint.lastValidBlockHeight === \"bigint\" && isBlockhash(transactionMessage.lifetimeConstraint.blockhash);\n}\nfunction assertIsTransactionMessageWithBlockhashLifetime(transactionMessage) {\n  if (!isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n    throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);\n  }\n}\nfunction setTransactionMessageLifetimeUsingBlockhash(blockhashLifetimeConstraint, transactionMessage) {\n  if (\"lifetimeConstraint\" in transactionMessage && transactionMessage.lifetimeConstraint && \"blockhash\" in transactionMessage.lifetimeConstraint && transactionMessage.lifetimeConstraint.blockhash === blockhashLifetimeConstraint.blockhash && transactionMessage.lifetimeConstraint.lastValidBlockHeight === blockhashLifetimeConstraint.lastValidBlockHeight) {\n    return transactionMessage;\n  }\n  return Object.freeze({\n    ...transactionMessage,\n    lifetimeConstraint: Object.freeze(blockhashLifetimeConstraint)\n  });\n}\nfunction assertValidBaseString(alphabet4, testValue, givenValue = testValue) {\n  if (!testValue.match(new RegExp(`^[${alphabet4}]*$`))) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n      alphabet: alphabet4,\n      base: alphabet4.length,\n      value: givenValue\n    });\n  }\n}\nvar getBaseXEncoder = (alphabet4) => {\n  return createEncoder({\n    getSizeFromValue: (value) => {\n      const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);\n      if (!tailChars) return value.length;\n      const base10Number = getBigIntFromBaseX(tailChars, alphabet4);\n      return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n    },\n    write(value, bytes, offset) {\n      assertValidBaseString(alphabet4, value);\n      if (value === \"\") return offset;\n      const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet4[0]);\n      if (!tailChars) {\n        bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n        return offset + leadingZeroes.length;\n      }\n      let base10Number = getBigIntFromBaseX(tailChars, alphabet4);\n      const tailBytes = [];\n      while (base10Number > 0n) {\n        tailBytes.unshift(Number(base10Number % 256n));\n        base10Number /= 256n;\n      }\n      const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n      bytes.set(bytesToAdd, offset);\n      return offset + bytesToAdd.length;\n    }\n  });\n};\nvar getBaseXDecoder = (alphabet4) => {\n  return createDecoder({\n    read(rawBytes, offset) {\n      const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n      if (bytes.length === 0) return [\"\", 0];\n      let trailIndex = bytes.findIndex((n) => n !== 0);\n      trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n      const leadingZeroes = alphabet4[0].repeat(trailIndex);\n      if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n      const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n      const tailChars = getBaseXFromBigInt(base10Number, alphabet4);\n      return [leadingZeroes + tailChars, rawBytes.length];\n    }\n  });\n};\nfunction partitionLeadingZeroes(value, zeroCharacter) {\n  const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n  return [leadingZeros, tailChars];\n}\nfunction getBigIntFromBaseX(value, alphabet4) {\n  const base = BigInt(alphabet4.length);\n  let sum = 0n;\n  for (const char of value) {\n    sum *= base;\n    sum += BigInt(alphabet4.indexOf(char));\n  }\n  return sum;\n}\nfunction getBaseXFromBigInt(value, alphabet4) {\n  const base = BigInt(alphabet4.length);\n  const tailChars = [];\n  while (value > 0n) {\n    tailChars.unshift(alphabet4[Number(value % base)]);\n    value /= base;\n  }\n  return tailChars.join(\"\");\n}\nvar alphabet2 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nvar getBase58Encoder = () => getBaseXEncoder(alphabet2);\nvar getBase58Decoder = () => getBaseXDecoder(alphabet2);\nvar memoizedAddressTableLookupEncoder;\nfunction getAddressTableLookupEncoder() {\n  if (!memoizedAddressTableLookupEncoder) {\n    const indexEncoder = getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() });\n    memoizedAddressTableLookupEncoder = getStructEncoder([\n      [\"lookupTableAddress\", getAddressEncoder()],\n      [\"writableIndexes\", indexEncoder],\n      [\"readonlyIndexes\", indexEncoder]\n    ]);\n  }\n  return memoizedAddressTableLookupEncoder;\n}\nvar memoizedAddressTableLookupDecoder;\nfunction getAddressTableLookupDecoder() {\n  if (!memoizedAddressTableLookupDecoder) {\n    const indexEncoder = getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() });\n    memoizedAddressTableLookupDecoder = getStructDecoder([\n      [\"lookupTableAddress\", getAddressDecoder()],\n      [\"writableIndexes\", indexEncoder],\n      [\"readonlyIndexes\", indexEncoder]\n    ]);\n  }\n  return memoizedAddressTableLookupDecoder;\n}\nvar memoizedU8Encoder;\nfunction getMemoizedU8Encoder() {\n  if (!memoizedU8Encoder) memoizedU8Encoder = getU8Encoder();\n  return memoizedU8Encoder;\n}\nvar memoizedU8Decoder;\nfunction getMemoizedU8Decoder() {\n  if (!memoizedU8Decoder) memoizedU8Decoder = getU8Decoder();\n  return memoizedU8Decoder;\n}\nfunction getMessageHeaderEncoder() {\n  return getStructEncoder([\n    [\"numSignerAccounts\", getMemoizedU8Encoder()],\n    [\"numReadonlySignerAccounts\", getMemoizedU8Encoder()],\n    [\"numReadonlyNonSignerAccounts\", getMemoizedU8Encoder()]\n  ]);\n}\nfunction getMessageHeaderDecoder() {\n  return getStructDecoder([\n    [\"numSignerAccounts\", getMemoizedU8Decoder()],\n    [\"numReadonlySignerAccounts\", getMemoizedU8Decoder()],\n    [\"numReadonlyNonSignerAccounts\", getMemoizedU8Decoder()]\n  ]);\n}\nvar memoizedGetInstructionEncoder;\nfunction getInstructionEncoder() {\n  if (!memoizedGetInstructionEncoder) {\n    memoizedGetInstructionEncoder = transformEncoder(\n      getStructEncoder([\n        [\"programAddressIndex\", getU8Encoder()],\n        [\"accountIndices\", getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() })],\n        [\"data\", addEncoderSizePrefix(getBytesEncoder(), getShortU16Encoder())]\n      ]),\n      // Convert an instruction to have all fields defined\n      (instruction) => {\n        if (instruction.accountIndices !== void 0 && instruction.data !== void 0) {\n          return instruction;\n        }\n        return {\n          ...instruction,\n          accountIndices: instruction.accountIndices ?? [],\n          data: instruction.data ?? new Uint8Array(0)\n        };\n      }\n    );\n  }\n  return memoizedGetInstructionEncoder;\n}\nvar memoizedGetInstructionDecoder;\nfunction getInstructionDecoder() {\n  if (!memoizedGetInstructionDecoder) {\n    memoizedGetInstructionDecoder = transformDecoder(\n      getStructDecoder([\n        [\"programAddressIndex\", getU8Decoder()],\n        [\"accountIndices\", getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],\n        [\n          \"data\",\n          addDecoderSizePrefix(getBytesDecoder(), getShortU16Decoder())\n        ]\n      ]),\n      // Convert an instruction to exclude optional fields if they are empty\n      (instruction) => {\n        if (instruction.accountIndices.length && instruction.data.byteLength) {\n          return instruction;\n        }\n        const { accountIndices, data, ...rest } = instruction;\n        return {\n          ...rest,\n          ...accountIndices.length ? { accountIndices } : null,\n          ...data.byteLength ? { data } : null\n        };\n      }\n    );\n  }\n  return memoizedGetInstructionDecoder;\n}\n\n// src/transaction-message.ts\nvar MAX_SUPPORTED_TRANSACTION_VERSION = 0;\n\n// src/codecs/transaction-version.ts\nvar VERSION_FLAG_MASK = 128;\nfunction getTransactionVersionEncoder() {\n  return createEncoder({\n    getSizeFromValue: (value) => value === \"legacy\" ? 0 : 1,\n    maxSize: 1,\n    write: (value, bytes, offset) => {\n      if (value === \"legacy\") {\n        return offset;\n      }\n      if (value < 0 || value > 127) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, {\n          actualVersion: value\n        });\n      }\n      if (value > MAX_SUPPORTED_TRANSACTION_VERSION) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED, {\n          unsupportedVersion: value\n        });\n      }\n      bytes.set([value | VERSION_FLAG_MASK], offset);\n      return offset + 1;\n    }\n  });\n}\nfunction getTransactionVersionDecoder() {\n  return createDecoder({\n    maxSize: 1,\n    read: (bytes, offset) => {\n      const firstByte = bytes[offset];\n      if ((firstByte & VERSION_FLAG_MASK) === 0) {\n        return [\"legacy\", offset];\n      } else {\n        const version = firstByte ^ VERSION_FLAG_MASK;\n        if (version > MAX_SUPPORTED_TRANSACTION_VERSION) {\n          throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED, {\n            unsupportedVersion: version\n          });\n        }\n        return [version, offset + 1];\n      }\n    }\n  });\n}\nfunction getTransactionVersionCodec() {\n  return combineCodec(getTransactionVersionEncoder(), getTransactionVersionDecoder());\n}\n\n// src/codecs/message.ts\nfunction getCompiledMessageLegacyEncoder() {\n  return getStructEncoder(getPreludeStructEncoderTuple());\n}\nfunction getCompiledMessageVersionedEncoder() {\n  return transformEncoder(\n    getStructEncoder([\n      ...getPreludeStructEncoderTuple(),\n      [\"addressTableLookups\", getAddressTableLookupArrayEncoder()]\n    ]),\n    (value) => {\n      if (value.version === \"legacy\") {\n        return value;\n      }\n      return {\n        ...value,\n        addressTableLookups: value.addressTableLookups ?? []\n      };\n    }\n  );\n}\nfunction getPreludeStructEncoderTuple() {\n  const lifetimeTokenEncoder = getUnionEncoder(\n    [\n      // Use a 32-byte constant encoder for a missing lifetime token (index 0).\n      getConstantEncoder(new Uint8Array(32)),\n      // Use a 32-byte base58 encoder for a valid lifetime token (index 1).\n      fixEncoderSize(getBase58Encoder(), 32)\n    ],\n    (value) => value === void 0 ? 0 : 1\n  );\n  return [\n    [\"version\", getTransactionVersionEncoder()],\n    [\"header\", getMessageHeaderEncoder()],\n    [\"staticAccounts\", getArrayEncoder(getAddressEncoder(), { size: getShortU16Encoder() })],\n    [\"lifetimeToken\", lifetimeTokenEncoder],\n    [\"instructions\", getArrayEncoder(getInstructionEncoder(), { size: getShortU16Encoder() })]\n  ];\n}\nfunction getPreludeStructDecoderTuple() {\n  return [\n    [\"version\", getTransactionVersionDecoder()],\n    [\"header\", getMessageHeaderDecoder()],\n    [\"staticAccounts\", getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() })],\n    [\"lifetimeToken\", fixDecoderSize(getBase58Decoder(), 32)],\n    [\"instructions\", getArrayDecoder(getInstructionDecoder(), { size: getShortU16Decoder() })],\n    [\"addressTableLookups\", getAddressTableLookupArrayDecoder()]\n  ];\n}\nfunction getAddressTableLookupArrayEncoder() {\n  return getArrayEncoder(getAddressTableLookupEncoder(), { size: getShortU16Encoder() });\n}\nfunction getAddressTableLookupArrayDecoder() {\n  return getArrayDecoder(getAddressTableLookupDecoder(), { size: getShortU16Decoder() });\n}\nfunction getCompiledTransactionMessageEncoder() {\n  return createEncoder({\n    getSizeFromValue: (compiledMessage) => {\n      if (compiledMessage.version === \"legacy\") {\n        return getCompiledMessageLegacyEncoder().getSizeFromValue(compiledMessage);\n      } else {\n        return getCompiledMessageVersionedEncoder().getSizeFromValue(compiledMessage);\n      }\n    },\n    write: (compiledMessage, bytes, offset) => {\n      if (compiledMessage.version === \"legacy\") {\n        return getCompiledMessageLegacyEncoder().write(compiledMessage, bytes, offset);\n      } else {\n        return getCompiledMessageVersionedEncoder().write(compiledMessage, bytes, offset);\n      }\n    }\n  });\n}\nfunction getCompiledTransactionMessageDecoder() {\n  return transformDecoder(\n    getStructDecoder(getPreludeStructDecoderTuple()),\n    ({ addressTableLookups, ...restOfMessage }) => {\n      if (restOfMessage.version === \"legacy\" || !addressTableLookups?.length) {\n        return restOfMessage;\n      }\n      return { ...restOfMessage, addressTableLookups };\n    }\n  );\n}\nfunction getCompiledTransactionMessageCodec() {\n  return combineCodec(getCompiledTransactionMessageEncoder(), getCompiledTransactionMessageDecoder());\n}\nfunction upsert(addressMap, address, update) {\n  addressMap[address] = update(addressMap[address] ?? { role: AccountRole.READONLY });\n}\nvar TYPE = Symbol(\"AddressMapTypeProperty\");\nfunction getAddressMapFromInstructions(feePayer, instructions) {\n  const addressMap = {\n    [feePayer]: { [TYPE]: 0 /* FEE_PAYER */, role: AccountRole.WRITABLE_SIGNER }\n  };\n  const addressesOfInvokedPrograms = /* @__PURE__ */ new Set();\n  for (const instruction of instructions) {\n    upsert(addressMap, instruction.programAddress, (entry) => {\n      addressesOfInvokedPrograms.add(instruction.programAddress);\n      if (TYPE in entry) {\n        if (isWritableRole(entry.role)) {\n          switch (entry[TYPE]) {\n            case 0 /* FEE_PAYER */:\n              throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES, {\n                programAddress: instruction.programAddress\n              });\n            default:\n              throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, {\n                programAddress: instruction.programAddress\n              });\n          }\n        }\n        if (entry[TYPE] === 2 /* STATIC */) {\n          return entry;\n        }\n      }\n      return { [TYPE]: 2 /* STATIC */, role: AccountRole.READONLY };\n    });\n    let addressComparator;\n    if (!instruction.accounts) {\n      continue;\n    }\n    for (const account of instruction.accounts) {\n      upsert(addressMap, account.address, (entry) => {\n        const {\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          address: _,\n          ...accountMeta\n        } = account;\n        if (TYPE in entry) {\n          switch (entry[TYPE]) {\n            case 0 /* FEE_PAYER */:\n              return entry;\n            case 1 /* LOOKUP_TABLE */: {\n              const nextRole = mergeRoles(entry.role, accountMeta.role);\n              if (\"lookupTableAddress\" in accountMeta) {\n                const shouldReplaceEntry = (\n                  // Consider using the new LOOKUP_TABLE if its address is different...\n                  entry.lookupTableAddress !== accountMeta.lookupTableAddress && // ...and sorts before the existing one.\n                  (addressComparator ||= getAddressComparator())(\n                    accountMeta.lookupTableAddress,\n                    entry.lookupTableAddress\n                  ) < 0\n                );\n                if (shouldReplaceEntry) {\n                  return {\n                    [TYPE]: 1 /* LOOKUP_TABLE */,\n                    ...accountMeta,\n                    role: nextRole\n                  };\n                }\n              } else if (isSignerRole(accountMeta.role)) {\n                return {\n                  [TYPE]: 2 /* STATIC */,\n                  role: nextRole\n                };\n              }\n              if (entry.role !== nextRole) {\n                return {\n                  ...entry,\n                  role: nextRole\n                };\n              } else {\n                return entry;\n              }\n            }\n            case 2 /* STATIC */: {\n              const nextRole = mergeRoles(entry.role, accountMeta.role);\n              if (\n                // Check to see if this address represents a program that is invoked\n                // in this transaction.\n                addressesOfInvokedPrograms.has(account.address)\n              ) {\n                if (isWritableRole(accountMeta.role)) {\n                  throw new SolanaError(\n                    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n                    {\n                      programAddress: account.address\n                    }\n                  );\n                }\n                if (entry.role !== nextRole) {\n                  return {\n                    ...entry,\n                    role: nextRole\n                  };\n                } else {\n                  return entry;\n                }\n              } else if (\"lookupTableAddress\" in accountMeta && // Static accounts can be 'upgraded' to lookup table accounts as\n              // long as they are not require to sign the transaction.\n              !isSignerRole(entry.role)) {\n                return {\n                  ...accountMeta,\n                  [TYPE]: 1 /* LOOKUP_TABLE */,\n                  role: nextRole\n                };\n              } else {\n                if (entry.role !== nextRole) {\n                  return {\n                    ...entry,\n                    role: nextRole\n                  };\n                } else {\n                  return entry;\n                }\n              }\n            }\n          }\n        }\n        if (\"lookupTableAddress\" in accountMeta) {\n          return {\n            ...accountMeta,\n            [TYPE]: 1 /* LOOKUP_TABLE */\n          };\n        } else {\n          return {\n            ...accountMeta,\n            [TYPE]: 2 /* STATIC */\n          };\n        }\n      });\n    }\n  }\n  return addressMap;\n}\nfunction getOrderedAccountsFromAddressMap(addressMap) {\n  let addressComparator;\n  const orderedAccounts = Object.entries(addressMap).sort(([leftAddress, leftEntry], [rightAddress, rightEntry]) => {\n    if (leftEntry[TYPE] !== rightEntry[TYPE]) {\n      if (leftEntry[TYPE] === 0 /* FEE_PAYER */) {\n        return -1;\n      } else if (rightEntry[TYPE] === 0 /* FEE_PAYER */) {\n        return 1;\n      } else if (leftEntry[TYPE] === 2 /* STATIC */) {\n        return -1;\n      } else if (rightEntry[TYPE] === 2 /* STATIC */) {\n        return 1;\n      }\n    }\n    const leftIsSigner = isSignerRole(leftEntry.role);\n    if (leftIsSigner !== isSignerRole(rightEntry.role)) {\n      return leftIsSigner ? -1 : 1;\n    }\n    const leftIsWritable = isWritableRole(leftEntry.role);\n    if (leftIsWritable !== isWritableRole(rightEntry.role)) {\n      return leftIsWritable ? -1 : 1;\n    }\n    addressComparator ||= getAddressComparator();\n    if (leftEntry[TYPE] === 1 /* LOOKUP_TABLE */ && rightEntry[TYPE] === 1 /* LOOKUP_TABLE */ && leftEntry.lookupTableAddress !== rightEntry.lookupTableAddress) {\n      return addressComparator(leftEntry.lookupTableAddress, rightEntry.lookupTableAddress);\n    } else {\n      return addressComparator(leftAddress, rightAddress);\n    }\n  }).map(([address, addressMeta]) => ({\n    address,\n    ...addressMeta\n  }));\n  return orderedAccounts;\n}\nfunction getCompiledAddressTableLookups(orderedAccounts) {\n  const index = {};\n  for (const account of orderedAccounts) {\n    if (!(\"lookupTableAddress\" in account)) {\n      continue;\n    }\n    const entry = index[account.lookupTableAddress] ||= {\n      readonlyIndexes: [],\n      writableIndexes: []\n    };\n    if (account.role === AccountRole.WRITABLE) {\n      entry.writableIndexes.push(account.addressIndex);\n    } else {\n      entry.readonlyIndexes.push(account.addressIndex);\n    }\n  }\n  return Object.keys(index).sort(getAddressComparator()).map((lookupTableAddress) => ({\n    lookupTableAddress,\n    ...index[lookupTableAddress]\n  }));\n}\nfunction getCompiledMessageHeader(orderedAccounts) {\n  let numReadonlyNonSignerAccounts = 0;\n  let numReadonlySignerAccounts = 0;\n  let numSignerAccounts = 0;\n  for (const account of orderedAccounts) {\n    if (\"lookupTableAddress\" in account) {\n      break;\n    }\n    const accountIsWritable = isWritableRole(account.role);\n    if (isSignerRole(account.role)) {\n      numSignerAccounts++;\n      if (!accountIsWritable) {\n        numReadonlySignerAccounts++;\n      }\n    } else if (!accountIsWritable) {\n      numReadonlyNonSignerAccounts++;\n    }\n  }\n  return {\n    numReadonlyNonSignerAccounts,\n    numReadonlySignerAccounts,\n    numSignerAccounts\n  };\n}\n\n// src/compile/instructions.ts\nfunction getAccountIndex(orderedAccounts) {\n  const out = {};\n  for (const [index, account] of orderedAccounts.entries()) {\n    out[account.address] = index;\n  }\n  return out;\n}\nfunction getCompiledInstructions(instructions, orderedAccounts) {\n  const accountIndex = getAccountIndex(orderedAccounts);\n  return instructions.map(({ accounts, data, programAddress }) => {\n    return {\n      programAddressIndex: accountIndex[programAddress],\n      ...accounts ? { accountIndices: accounts.map(({ address }) => accountIndex[address]) } : null,\n      ...data ? { data } : null\n    };\n  });\n}\n\n// src/compile/lifetime-token.ts\nfunction getCompiledLifetimeToken(lifetimeConstraint) {\n  if (\"nonce\" in lifetimeConstraint) {\n    return lifetimeConstraint.nonce;\n  }\n  return lifetimeConstraint.blockhash;\n}\n\n// src/compile/static-accounts.ts\nfunction getCompiledStaticAccounts(orderedAccounts) {\n  const firstLookupTableAccountIndex = orderedAccounts.findIndex((account) => \"lookupTableAddress\" in account);\n  const orderedStaticAccounts = firstLookupTableAccountIndex === -1 ? orderedAccounts : orderedAccounts.slice(0, firstLookupTableAccountIndex);\n  return orderedStaticAccounts.map(({ address }) => address);\n}\n\n// src/compile/message.ts\nfunction compileTransactionMessage(transactionMessage) {\n  const addressMap = getAddressMapFromInstructions(\n    transactionMessage.feePayer.address,\n    transactionMessage.instructions\n  );\n  const orderedAccounts = getOrderedAccountsFromAddressMap(addressMap);\n  const lifetimeConstraint = transactionMessage.lifetimeConstraint;\n  return {\n    ...transactionMessage.version !== \"legacy\" ? { addressTableLookups: getCompiledAddressTableLookups(orderedAccounts) } : null,\n    ...lifetimeConstraint ? { lifetimeToken: getCompiledLifetimeToken(lifetimeConstraint) } : null,\n    header: getCompiledMessageHeader(orderedAccounts),\n    instructions: getCompiledInstructions(transactionMessage.instructions, orderedAccounts),\n    staticAccounts: getCompiledStaticAccounts(orderedAccounts),\n    version: transactionMessage.version\n  };\n}\nfunction findAddressInLookupTables(address, role, addressesByLookupTableAddress) {\n  for (const [lookupTableAddress, addresses] of Object.entries(addressesByLookupTableAddress)) {\n    for (let i = 0; i < addresses.length; i++) {\n      if (address === addresses[i]) {\n        return {\n          address,\n          addressIndex: i,\n          lookupTableAddress,\n          role\n        };\n      }\n    }\n  }\n}\nfunction compressTransactionMessageUsingAddressLookupTables(transactionMessage, addressesByLookupTableAddress) {\n  const programAddresses = new Set(transactionMessage.instructions.map((ix) => ix.programAddress));\n  const eligibleLookupAddresses = new Set(\n    Object.values(addressesByLookupTableAddress).flatMap((a) => a).filter((address) => !programAddresses.has(address))\n  );\n  const newInstructions = [];\n  let updatedAnyInstructions = false;\n  for (const instruction of transactionMessage.instructions) {\n    if (!instruction.accounts) {\n      newInstructions.push(instruction);\n      continue;\n    }\n    const newAccounts = [];\n    let updatedAnyAccounts = false;\n    for (const account of instruction.accounts) {\n      if (\"lookupTableAddress\" in account || !eligibleLookupAddresses.has(account.address) || isSignerRole(account.role)) {\n        newAccounts.push(account);\n        continue;\n      }\n      const lookupMetaAccount = findAddressInLookupTables(\n        account.address,\n        account.role,\n        addressesByLookupTableAddress\n      );\n      newAccounts.push(Object.freeze(lookupMetaAccount));\n      updatedAnyAccounts = true;\n      updatedAnyInstructions = true;\n    }\n    newInstructions.push(\n      Object.freeze(updatedAnyAccounts ? { ...instruction, accounts: newAccounts } : instruction)\n    );\n  }\n  return Object.freeze(\n    updatedAnyInstructions ? { ...transactionMessage, instructions: newInstructions } : transactionMessage\n  );\n}\n\n// src/create-transaction-message.ts\nfunction createTransactionMessage(config) {\n  return Object.freeze({\n    instructions: Object.freeze([]),\n    version: config.version\n  });\n}\nvar RECENT_BLOCKHASHES_SYSVAR_ADDRESS = \"SysvarRecentB1ockHashes11111111111111111111\";\nvar SYSTEM_PROGRAM_ADDRESS = \"11111111111111111111111111111111\";\nfunction createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress) {\n  return {\n    accounts: [\n      { address: nonceAccountAddress, role: AccountRole.WRITABLE },\n      {\n        address: RECENT_BLOCKHASHES_SYSVAR_ADDRESS,\n        role: AccountRole.READONLY\n      },\n      { address: nonceAuthorityAddress, role: AccountRole.READONLY_SIGNER }\n    ],\n    data: new Uint8Array([4, 0, 0, 0]),\n    programAddress: SYSTEM_PROGRAM_ADDRESS\n  };\n}\nfunction isAdvanceNonceAccountInstruction(instruction) {\n  return instruction.programAddress === SYSTEM_PROGRAM_ADDRESS && // Test for `AdvanceNonceAccount` instruction data\n  instruction.data != null && isAdvanceNonceAccountInstructionData(instruction.data) && // Test for exactly 3 accounts\n  instruction.accounts?.length === 3 && // First account is nonce account address\n  instruction.accounts[0].address != null && instruction.accounts[0].role === AccountRole.WRITABLE && // Second account is recent blockhashes sysvar\n  instruction.accounts[1].address === RECENT_BLOCKHASHES_SYSVAR_ADDRESS && instruction.accounts[1].role === AccountRole.READONLY && // Third account is nonce authority account\n  instruction.accounts[2].address != null && isSignerRole(instruction.accounts[2].role);\n}\nfunction isAdvanceNonceAccountInstructionData(data) {\n  return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\n\n// src/durable-nonce.ts\nfunction isTransactionMessageWithDurableNonceLifetime(transactionMessage) {\n  return \"lifetimeConstraint\" in transactionMessage && typeof transactionMessage.lifetimeConstraint.nonce === \"string\" && transactionMessage.instructions[0] != null && isAdvanceNonceAccountInstruction(transactionMessage.instructions[0]);\n}\nfunction assertIsTransactionMessageWithDurableNonceLifetime(transactionMessage) {\n  if (!isTransactionMessageWithDurableNonceLifetime(transactionMessage)) {\n    throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);\n  }\n}\nfunction isAdvanceNonceAccountInstructionForNonce(instruction, nonceAccountAddress, nonceAuthorityAddress) {\n  return instruction.accounts[0].address === nonceAccountAddress && instruction.accounts[2].address === nonceAuthorityAddress;\n}\nfunction setTransactionMessageLifetimeUsingDurableNonce({\n  nonce,\n  nonceAccountAddress,\n  nonceAuthorityAddress\n}, transactionMessage) {\n  let newInstructions;\n  const firstInstruction = transactionMessage.instructions[0];\n  if (firstInstruction && isAdvanceNonceAccountInstruction(firstInstruction)) {\n    if (isAdvanceNonceAccountInstructionForNonce(firstInstruction, nonceAccountAddress, nonceAuthorityAddress)) {\n      if (isTransactionMessageWithDurableNonceLifetime(transactionMessage) && transactionMessage.lifetimeConstraint.nonce === nonce) {\n        return transactionMessage;\n      } else {\n        newInstructions = [firstInstruction, ...transactionMessage.instructions.slice(1)];\n      }\n    } else {\n      newInstructions = [\n        Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n        ...transactionMessage.instructions.slice(1)\n      ];\n    }\n  } else {\n    newInstructions = [\n      Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n      ...transactionMessage.instructions\n    ];\n  }\n  return Object.freeze({\n    ...transactionMessage,\n    instructions: Object.freeze(newInstructions),\n    lifetimeConstraint: Object.freeze({ nonce })\n  });\n}\n\n// src/fee-payer.ts\nfunction setTransactionMessageFeePayer(feePayer, transactionMessage) {\n  if (\"feePayer\" in transactionMessage && feePayer === transactionMessage.feePayer?.address && isAddressOnlyFeePayer(transactionMessage.feePayer)) {\n    return transactionMessage;\n  }\n  const out = {\n    ...transactionMessage,\n    feePayer: Object.freeze({ address: feePayer })\n  };\n  Object.freeze(out);\n  return out;\n}\nfunction isAddressOnlyFeePayer(feePayer) {\n  return !!feePayer && \"address\" in feePayer && typeof feePayer.address === \"string\" && Object.keys(feePayer).length === 1;\n}\n\n// src/instructions.ts\nfunction appendTransactionMessageInstruction(instruction, transactionMessage) {\n  return appendTransactionMessageInstructions([instruction], transactionMessage);\n}\nfunction appendTransactionMessageInstructions(instructions, transactionMessage) {\n  return Object.freeze({\n    ...transactionMessage,\n    instructions: Object.freeze([\n      ...transactionMessage.instructions,\n      ...instructions\n    ])\n  });\n}\nfunction prependTransactionMessageInstruction(instruction, transactionMessage) {\n  return prependTransactionMessageInstructions([instruction], transactionMessage);\n}\nfunction prependTransactionMessageInstructions(instructions, transactionMessage) {\n  return Object.freeze({\n    ...transactionMessage,\n    instructions: Object.freeze([\n      ...instructions,\n      ...transactionMessage.instructions\n    ])\n  });\n}\n\n// src/decompile-message.ts\nfunction getAccountMetas(message) {\n  const { header } = message;\n  const numWritableSignerAccounts = header.numSignerAccounts - header.numReadonlySignerAccounts;\n  const numWritableNonSignerAccounts = message.staticAccounts.length - header.numSignerAccounts - header.numReadonlyNonSignerAccounts;\n  const accountMetas = [];\n  let accountIndex = 0;\n  for (let i = 0; i < numWritableSignerAccounts; i++) {\n    accountMetas.push({\n      address: message.staticAccounts[accountIndex],\n      role: AccountRole.WRITABLE_SIGNER\n    });\n    accountIndex++;\n  }\n  for (let i = 0; i < header.numReadonlySignerAccounts; i++) {\n    accountMetas.push({\n      address: message.staticAccounts[accountIndex],\n      role: AccountRole.READONLY_SIGNER\n    });\n    accountIndex++;\n  }\n  for (let i = 0; i < numWritableNonSignerAccounts; i++) {\n    accountMetas.push({\n      address: message.staticAccounts[accountIndex],\n      role: AccountRole.WRITABLE\n    });\n    accountIndex++;\n  }\n  for (let i = 0; i < header.numReadonlyNonSignerAccounts; i++) {\n    accountMetas.push({\n      address: message.staticAccounts[accountIndex],\n      role: AccountRole.READONLY\n    });\n    accountIndex++;\n  }\n  return accountMetas;\n}\nfunction getAddressLookupMetas(compiledAddressTableLookups, addressesByLookupTableAddress) {\n  const compiledAddressTableLookupAddresses = compiledAddressTableLookups.map((l) => l.lookupTableAddress);\n  const missing = compiledAddressTableLookupAddresses.filter((a) => addressesByLookupTableAddress[a] === void 0);\n  if (missing.length > 0) {\n    throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING, {\n      lookupTableAddresses: missing\n    });\n  }\n  const readOnlyMetas = [];\n  const writableMetas = [];\n  for (const lookup of compiledAddressTableLookups) {\n    const addresses = addressesByLookupTableAddress[lookup.lookupTableAddress];\n    const readonlyIndexes = lookup.readonlyIndexes;\n    const writableIndexes = lookup.writableIndexes;\n    const highestIndex = Math.max(...readonlyIndexes, ...writableIndexes);\n    if (highestIndex >= addresses.length) {\n      throw new SolanaError(\n        SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n        {\n          highestKnownIndex: addresses.length - 1,\n          highestRequestedIndex: highestIndex,\n          lookupTableAddress: lookup.lookupTableAddress\n        }\n      );\n    }\n    const readOnlyForLookup = readonlyIndexes.map((r) => ({\n      address: addresses[r],\n      addressIndex: r,\n      lookupTableAddress: lookup.lookupTableAddress,\n      role: AccountRole.READONLY\n    }));\n    readOnlyMetas.push(...readOnlyForLookup);\n    const writableForLookup = writableIndexes.map((w) => ({\n      address: addresses[w],\n      addressIndex: w,\n      lookupTableAddress: lookup.lookupTableAddress,\n      role: AccountRole.WRITABLE\n    }));\n    writableMetas.push(...writableForLookup);\n  }\n  return [...writableMetas, ...readOnlyMetas];\n}\nfunction convertInstruction(instruction, accountMetas) {\n  const programAddress = accountMetas[instruction.programAddressIndex]?.address;\n  if (!programAddress) {\n    throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND, {\n      index: instruction.programAddressIndex\n    });\n  }\n  const accounts = instruction.accountIndices?.map((accountIndex) => accountMetas[accountIndex]);\n  const { data } = instruction;\n  return Object.freeze({\n    programAddress,\n    ...accounts && accounts.length ? { accounts: Object.freeze(accounts) } : {},\n    ...data && data.length ? { data } : {}\n  });\n}\nfunction getLifetimeConstraint(messageLifetimeToken, firstInstruction, lastValidBlockHeight) {\n  if (!firstInstruction || !isAdvanceNonceAccountInstruction(firstInstruction)) {\n    return {\n      blockhash: messageLifetimeToken,\n      lastValidBlockHeight: lastValidBlockHeight ?? 2n ** 64n - 1n\n      // U64 MAX\n    };\n  } else {\n    const nonceAccountAddress = firstInstruction.accounts[0].address;\n    assertIsAddress(nonceAccountAddress);\n    const nonceAuthorityAddress = firstInstruction.accounts[2].address;\n    assertIsAddress(nonceAuthorityAddress);\n    return {\n      nonce: messageLifetimeToken,\n      nonceAccountAddress,\n      nonceAuthorityAddress\n    };\n  }\n}\nfunction decompileTransactionMessage(compiledTransactionMessage, config) {\n  const feePayer = compiledTransactionMessage.staticAccounts[0];\n  if (!feePayer) {\n    throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING);\n  }\n  const accountMetas = getAccountMetas(compiledTransactionMessage);\n  const accountLookupMetas = \"addressTableLookups\" in compiledTransactionMessage && compiledTransactionMessage.addressTableLookups !== void 0 && compiledTransactionMessage.addressTableLookups.length > 0 ? getAddressLookupMetas(\n    compiledTransactionMessage.addressTableLookups,\n    config?.addressesByLookupTableAddress ?? {}\n  ) : [];\n  const transactionMetas = [...accountMetas, ...accountLookupMetas];\n  const instructions = compiledTransactionMessage.instructions.map(\n    (compiledInstruction) => convertInstruction(compiledInstruction, transactionMetas)\n  );\n  const firstInstruction = instructions[0];\n  const lifetimeConstraint = getLifetimeConstraint(\n    compiledTransactionMessage.lifetimeToken,\n    firstInstruction,\n    config?.lastValidBlockHeight\n  );\n  return pipe(\n    createTransactionMessage({ version: compiledTransactionMessage.version }),\n    (m) => setTransactionMessageFeePayer(feePayer, m),\n    (m) => instructions.reduce(\n      (acc, instruction) => appendTransactionMessageInstruction(instruction, acc),\n      m\n    ),\n    (m) => \"blockhash\" in lifetimeConstraint ? setTransactionMessageLifetimeUsingBlockhash(lifetimeConstraint, m) : setTransactionMessageLifetimeUsingDurableNonce(lifetimeConstraint, m)\n  );\n}\n\nexport { MAX_SUPPORTED_TRANSACTION_VERSION, appendTransactionMessageInstruction, appendTransactionMessageInstructions, assertIsTransactionMessageWithBlockhashLifetime, assertIsTransactionMessageWithDurableNonceLifetime, compileTransactionMessage, compressTransactionMessageUsingAddressLookupTables, createTransactionMessage, decompileTransactionMessage, getCompiledTransactionMessageCodec, getCompiledTransactionMessageDecoder, getCompiledTransactionMessageEncoder, getTransactionVersionCodec, getTransactionVersionDecoder, getTransactionVersionEncoder, isAdvanceNonceAccountInstruction, isTransactionMessageWithBlockhashLifetime, isTransactionMessageWithDurableNonceLifetime, prependTransactionMessageInstruction, prependTransactionMessageInstructions, setTransactionMessageFeePayer, setTransactionMessageLifetimeUsingBlockhash, setTransactionMessageLifetimeUsingDurableNonce };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","import { SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME, SolanaError } from '@solana/errors';\nimport { type Blockhash, isBlockhash } from '@solana/rpc-types';\n\nimport { ExcludeTransactionMessageLifetime, TransactionMessageWithLifetime } from './lifetime';\nimport { BaseTransactionMessage } from './transaction-message';\n\n/**\n * A constraint which, when applied to a transaction message, makes that transaction message\n * eligible to land on the network. The transaction message will continue to be eligible to land\n * until the network considers the `blockhash` to be expired.\n *\n * This can happen when the network proceeds past the `lastValidBlockHeight` for which the blockhash\n * is considered valid, or when the network switches to a fork where that blockhash is not present.\n */\ntype BlockhashLifetimeConstraint = Readonly<{\n    /**\n     * A recent blockhash observed by the transaction proposer.\n     *\n     * The transaction message will be considered eligible to land until the network determines this\n     * blockhash to be too old, or has switched to a fork where it is not present.\n     */\n    blockhash: Blockhash;\n    /**\n     * This is the block height beyond which the network will consider the blockhash to be too old\n     * to make a transaction message eligible to land.\n     */\n    lastValidBlockHeight: bigint;\n}>;\n\n/**\n * Represents a transaction message whose lifetime is defined by the age of the blockhash it\n * includes.\n *\n * Such a transaction can only be landed on the network if the current block height of the network\n * is less than or equal to the value of\n * `TransactionMessageWithBlockhashLifetime['lifetimeConstraint']['lastValidBlockHeight']`.\n */\nexport interface TransactionMessageWithBlockhashLifetime {\n    readonly lifetimeConstraint: BlockhashLifetimeConstraint;\n}\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithBlockhashLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionMessageWithBlockhashLifetime } from '@solana/transaction-messages';\n *\n * if (isTransactionMessageWithBlockhashLifetime(message)) {\n *     // At this point, `message` has been refined to a `TransactionMessageWithBlockhashLifetime`.\n *     const { blockhash } = message.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n *     setBlockhashIsValid(blockhashIsValid);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a blockhash-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionMessageWithBlockhashLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n): transactionMessage is BaseTransactionMessage & TransactionMessageWithBlockhashLifetime {\n    return (\n        'lifetimeConstraint' in transactionMessage &&\n        typeof transactionMessage.lifetimeConstraint.blockhash === 'string' &&\n        typeof transactionMessage.lifetimeConstraint.lastValidBlockHeight === 'bigint' &&\n        isBlockhash(transactionMessage.lifetimeConstraint.blockhash)\n    );\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * blockhash-based lifetime, from an untrusted network API or user input. Use this function to\n * assert that such a transaction message actually has a blockhash-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithBlockhashLifetime } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithBlockhashLifetime`.\n *     assertIsTransactionMessageWithBlockhashLifetime(message);\n *     // At this point, `message` is a `TransactionMessageWithBlockhashLifetime` that can be used\n *     // with the RPC.\n *     const { blockhash } = message.lifetimeConstraint;\n *     const { value: blockhashIsValid } = await rpc.isBlockhashValid(blockhash).send();\n * } catch (e) {\n *     // `message` turned out not to have a blockhash-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionMessageWithBlockhashLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithBlockhashLifetime),\n): asserts transactionMessage is BaseTransactionMessage & TransactionMessageWithBlockhashLifetime {\n    if (!isTransactionMessageWithBlockhashLifetime(transactionMessage)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME);\n    }\n}\n\n/**\n * Given a blockhash and the last block height at which that blockhash is considered usable to land\n * transactions, this method will return a new transaction message having the same type as the one\n * supplied plus the `TransactionMessageWithBlockhashLifetime` type.\n *\n * @example\n * ```ts\n * import { setTransactionMessageLifetimeUsingBlockhash } from '@solana/transaction-messages';\n *\n * const { value: latestBlockhash } = await rpc.getLatestBlockhash().send();\n * const txMessageWithBlockhashLifetime = setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, txMessage);\n * ```\n */\nexport function setTransactionMessageLifetimeUsingBlockhash<\n    TTransactionMessage extends BaseTransactionMessage & Partial<TransactionMessageWithLifetime>,\n>(\n    blockhashLifetimeConstraint: BlockhashLifetimeConstraint,\n    transactionMessage: TTransactionMessage,\n): ExcludeTransactionMessageLifetime<TTransactionMessage> & TransactionMessageWithBlockhashLifetime {\n    type ReturnType = ExcludeTransactionMessageLifetime<TTransactionMessage> & TransactionMessageWithBlockhashLifetime;\n\n    if (\n        'lifetimeConstraint' in transactionMessage &&\n        transactionMessage.lifetimeConstraint &&\n        'blockhash' in transactionMessage.lifetimeConstraint &&\n        transactionMessage.lifetimeConstraint.blockhash === blockhashLifetimeConstraint.blockhash &&\n        transactionMessage.lifetimeConstraint.lastValidBlockHeight === blockhashLifetimeConstraint.lastValidBlockHeight\n    ) {\n        return transactionMessage as ReturnType;\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        lifetimeConstraint: Object.freeze(blockhashLifetimeConstraint),\n    }) as ReturnType;\n}\n","import { SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, SolanaError } from '@solana/errors';\n\n/**\n * Asserts that a given string contains only characters from the specified alphabet.\n *\n * This function validates whether a string consists exclusively of characters\n * from the provided `alphabet`. If the validation fails, it throws an error\n * indicating the invalid base string.\n *\n * @param alphabet - The allowed set of characters for the base encoding.\n * @param testValue - The string to validate against the given alphabet.\n * @param givenValue - The original string provided by the user (defaults to `testValue`).\n *\n * @throws {SolanaError} If `testValue` contains characters not present in `alphabet`.\n *\n * @example\n * Validating a base-8 encoded string.\n * ```ts\n * assertValidBaseString('01234567', '123047'); // Passes\n * assertValidBaseString('01234567', '128');    // Throws error\n * ```\n */\nexport function assertValidBaseString(alphabet: string, testValue: string, givenValue = testValue) {\n    if (!testValue.match(new RegExp(`^[${alphabet}]*$`))) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE, {\n            alphabet,\n            base: alphabet.length,\n            value: givenValue,\n        });\n    }\n}\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\n\nimport { assertValidBaseString } from './assertions';\n\n/**\n * Returns an encoder for base-X encoded strings.\n *\n * This encoder serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process involves converting the input string to a numeric value in base-X, then\n * encoding that value into bytes while preserving leading zeroes.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeEncoder<string>` for encoding base-X strings.\n *\n * @example\n * Encoding a base-X string using a custom alphabet.\n * ```ts\n * const encoder = getBaseXEncoder('0123456789abcdef');\n * const bytes = encoder.encode('deadface'); // 0xdeadface\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXEncoder = (alphabet: string): VariableSizeEncoder<string> => {\n    return createEncoder({\n        getSizeFromValue: (value: string): number => {\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) return value.length;\n\n            const base10Number = getBigIntFromBaseX(tailChars, alphabet);\n            return leadingZeroes.length + Math.ceil(base10Number.toString(16).length / 2);\n        },\n        write(value: string, bytes, offset) {\n            // Check if the value is valid.\n            assertValidBaseString(alphabet, value);\n            if (value === '') return offset;\n\n            // Handle leading zeroes.\n            const [leadingZeroes, tailChars] = partitionLeadingZeroes(value, alphabet[0]);\n            if (!tailChars) {\n                bytes.set(new Uint8Array(leadingZeroes.length).fill(0), offset);\n                return offset + leadingZeroes.length;\n            }\n\n            // From baseX to base10.\n            let base10Number = getBigIntFromBaseX(tailChars, alphabet);\n\n            // From base10 to bytes.\n            const tailBytes: number[] = [];\n            while (base10Number > 0n) {\n                tailBytes.unshift(Number(base10Number % 256n));\n                base10Number /= 256n;\n            }\n\n            const bytesToAdd = [...Array(leadingZeroes.length).fill(0), ...tailBytes];\n            bytes.set(bytesToAdd, offset);\n            return offset + bytesToAdd.length;\n        },\n    });\n};\n\n/**\n * Returns a decoder for base-X encoded strings.\n *\n * This decoder deserializes base-X encoded strings from a byte array using a custom alphabet.\n * The decoding process converts the byte array into a numeric value in base-10, then\n * maps that value back to characters in the specified base-X alphabet.\n *\n * For more details, see {@link getBaseXCodec}.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeDecoder<string>` for decoding base-X strings.\n *\n * @example\n * Decoding a base-X string using a custom alphabet.\n * ```ts\n * const decoder = getBaseXDecoder('0123456789abcdef');\n * const value = decoder.decode(new Uint8Array([0xde, 0xad, 0xfa, 0xce])); // \"deadface\"\n * ```\n *\n * @see {@link getBaseXCodec}\n */\nexport const getBaseXDecoder = (alphabet: string): VariableSizeDecoder<string> => {\n    return createDecoder({\n        read(rawBytes, offset): [string, number] {\n            const bytes = offset === 0 ? rawBytes : rawBytes.slice(offset);\n            if (bytes.length === 0) return ['', 0];\n\n            // Handle leading zeroes.\n            let trailIndex = bytes.findIndex(n => n !== 0);\n            trailIndex = trailIndex === -1 ? bytes.length : trailIndex;\n            const leadingZeroes = alphabet[0].repeat(trailIndex);\n            if (trailIndex === bytes.length) return [leadingZeroes, rawBytes.length];\n\n            // From bytes to base10.\n            const base10Number = bytes.slice(trailIndex).reduce((sum, byte) => sum * 256n + BigInt(byte), 0n);\n\n            // From base10 to baseX.\n            const tailChars = getBaseXFromBigInt(base10Number, alphabet);\n\n            return [leadingZeroes + tailChars, rawBytes.length];\n        },\n    });\n};\n\n/**\n * Returns a codec for encoding and decoding base-X strings.\n *\n * This codec serializes strings using a custom alphabet, treating the length of the alphabet as the base.\n * The encoding process converts the input string into a numeric value in base-X, which is then encoded as bytes.\n * The decoding process reverses this transformation to reconstruct the original string.\n *\n * This codec supports leading zeroes by treating the first character of the alphabet as the zero character.\n *\n * @param alphabet - The set of characters defining the base-X encoding.\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-X strings.\n *\n * @example\n * Encoding and decoding a base-X string using a custom alphabet.\n * ```ts\n * const codec = getBaseXCodec('0123456789abcdef');\n * const bytes = codec.encode('deadface'); // 0xdeadface\n * const value = codec.decode(bytes);      // \"deadface\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-X codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBaseXCodec('0123456789abcdef'), 8);\n * ```\n *\n * If you need a size-prefixed base-X codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBaseXCodec('0123456789abcdef'), getU32Codec());\n * ```\n *\n * Separate {@link getBaseXEncoder} and {@link getBaseXDecoder} functions are available.\n *\n * ```ts\n * const bytes = getBaseXEncoder('0123456789abcdef').encode('deadface');\n * const value = getBaseXDecoder('0123456789abcdef').decode(bytes);\n * ```\n *\n * @see {@link getBaseXEncoder}\n * @see {@link getBaseXDecoder}\n */\nexport const getBaseXCodec = (alphabet: string): VariableSizeCodec<string> =>\n    combineCodec(getBaseXEncoder(alphabet), getBaseXDecoder(alphabet));\n\nfunction partitionLeadingZeroes(\n    value: string,\n    zeroCharacter: string,\n): [leadingZeros: string, tailChars: string | undefined] {\n    const [leadingZeros, tailChars] = value.split(new RegExp(`((?!${zeroCharacter}).*)`));\n    return [leadingZeros, tailChars];\n}\n\nfunction getBigIntFromBaseX(value: string, alphabet: string): bigint {\n    const base = BigInt(alphabet.length);\n    let sum = 0n;\n    for (const char of value) {\n        sum *= base;\n        sum += BigInt(alphabet.indexOf(char));\n    }\n    return sum;\n}\n\nfunction getBaseXFromBigInt(value: bigint, alphabet: string): string {\n    const base = BigInt(alphabet.length);\n    const tailChars = [];\n    while (value > 0n) {\n        tailChars.unshift(alphabet[Number(value % base)]);\n        value /= base;\n    }\n    return tailChars.join('');\n}\n","import { getBaseXCodec, getBaseXDecoder, getBaseXEncoder } from './baseX';\n\nconst alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';\n\n/**\n * Returns an encoder for base-58 strings.\n *\n * This encoder serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeEncoder<string>` for encoding base-58 strings.\n *\n * @example\n * Encoding a base-58 string.\n * ```ts\n * const encoder = getBase58Encoder();\n * const bytes = encoder.encode('heLLo'); // 0x1b6a3070\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Encoder = () => getBaseXEncoder(alphabet);\n\n/**\n * Returns a decoder for base-58 strings.\n *\n * This decoder deserializes base-58 encoded strings from a byte array.\n *\n * For more details, see {@link getBase58Codec}.\n *\n * @returns A `VariableSizeDecoder<string>` for decoding base-58 strings.\n *\n * @example\n * Decoding a base-58 string.\n * ```ts\n * const decoder = getBase58Decoder();\n * const value = decoder.decode(new Uint8Array([0x1b, 0x6a, 0x30, 0x70])); // \"heLLo\"\n * ```\n *\n * @see {@link getBase58Codec}\n */\nexport const getBase58Decoder = () => getBaseXDecoder(alphabet);\n\n/**\n * Returns a codec for encoding and decoding base-58 strings.\n *\n * This codec serializes strings using a base-58 encoding scheme,\n * commonly used in cryptocurrency addresses and other compact representations.\n *\n * @returns A `VariableSizeCodec<string>` for encoding and decoding base-58 strings.\n *\n * @example\n * Encoding and decoding a base-58 string.\n * ```ts\n * const codec = getBase58Codec();\n * const bytes = codec.encode('heLLo'); // 0x1b6a3070\n * const value = codec.decode(bytes);   // \"heLLo\"\n * ```\n *\n * @remarks\n * This codec does not enforce a size boundary. It will encode and decode all bytes necessary to represent the string.\n *\n * If you need a fixed-size base-58 codec, consider using {@link fixCodecSize}.\n *\n * ```ts\n * const codec = fixCodecSize(getBase58Codec(), 8);\n * ```\n *\n * If you need a size-prefixed base-58 codec, consider using {@link addCodecSizePrefix}.\n *\n * ```ts\n * const codec = addCodecSizePrefix(getBase58Codec(), getU32Codec());\n * ```\n *\n * Separate {@link getBase58Encoder} and {@link getBase58Decoder} functions are available.\n *\n * ```ts\n * const bytes = getBase58Encoder().encode('heLLo');\n * const value = getBase58Decoder().decode(bytes);\n * ```\n *\n * @see {@link getBase58Encoder}\n * @see {@link getBase58Decoder}\n */\nexport const getBase58Codec = () => getBaseXCodec(alphabet);\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    type Encoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport { getArrayDecoder, getArrayEncoder, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport type { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\n\ntype AddressTableLookup = ReturnType<typeof getCompiledAddressTableLookups>[number];\n\nlet memoizedAddressTableLookupEncoder: VariableSizeEncoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupEncoder(): VariableSizeEncoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupEncoder) {\n        const indexEncoder = getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() }) as Encoder<\n            readonly number[]\n        >;\n        memoizedAddressTableLookupEncoder = getStructEncoder([\n            ['lookupTableAddress', getAddressEncoder()],\n            ['writableIndexes', indexEncoder],\n            ['readonlyIndexes', indexEncoder],\n        ]);\n    }\n\n    return memoizedAddressTableLookupEncoder;\n}\n\nlet memoizedAddressTableLookupDecoder: VariableSizeDecoder<AddressTableLookup> | undefined;\nexport function getAddressTableLookupDecoder(): VariableSizeDecoder<AddressTableLookup> {\n    if (!memoizedAddressTableLookupDecoder) {\n        const indexEncoder = getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() });\n        memoizedAddressTableLookupDecoder = getStructDecoder([\n            ['lookupTableAddress', getAddressDecoder()],\n            ['writableIndexes', indexEncoder],\n            ['readonlyIndexes', indexEncoder],\n        ]);\n    }\n\n    return memoizedAddressTableLookupDecoder;\n}\n\nexport function getAddressTableLookupCodec(): VariableSizeCodec<AddressTableLookup> {\n    return combineCodec(getAddressTableLookupEncoder(), getAddressTableLookupDecoder());\n}\n","import { FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport { getStructCodec, getStructDecoder, getStructEncoder } from '@solana/codecs-data-structures';\nimport { getU8Codec, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledMessageHeader } from '../compile/header';\n\ntype MessageHeader = ReturnType<typeof getCompiledMessageHeader>;\n\nlet memoizedU8Encoder: FixedSizeEncoder<number, 1> | undefined;\nfunction getMemoizedU8Encoder(): FixedSizeEncoder<number, 1> {\n    if (!memoizedU8Encoder) memoizedU8Encoder = getU8Encoder();\n    return memoizedU8Encoder;\n}\n\nlet memoizedU8Decoder: FixedSizeDecoder<number, 1> | undefined;\nfunction getMemoizedU8Decoder(): FixedSizeDecoder<number, 1> {\n    if (!memoizedU8Decoder) memoizedU8Decoder = getU8Decoder();\n    return memoizedU8Decoder;\n}\n\nlet memoizedU8Codec: FixedSizeCodec<number, number, 1> | undefined;\nfunction getMemoizedU8Codec(): FixedSizeCodec<number, number, 1> {\n    if (!memoizedU8Codec) memoizedU8Codec = getU8Codec();\n    return memoizedU8Codec;\n}\n\nexport function getMessageHeaderEncoder(): FixedSizeEncoder<MessageHeader, 3> {\n    return getStructEncoder([\n        ['numSignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Encoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Encoder()],\n    ]) as FixedSizeEncoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderDecoder(): FixedSizeDecoder<MessageHeader, 3> {\n    return getStructDecoder([\n        ['numSignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlySignerAccounts', getMemoizedU8Decoder()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Decoder()],\n    ]) as FixedSizeDecoder<MessageHeader, 3>;\n}\n\nexport function getMessageHeaderCodec(): FixedSizeCodec<MessageHeader, MessageHeader, 3> {\n    return getStructCodec([\n        ['numSignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlySignerAccounts', getMemoizedU8Codec()],\n        ['numReadonlyNonSignerAccounts', getMemoizedU8Codec()],\n    ]) as FixedSizeCodec<MessageHeader, MessageHeader, 3>;\n}\n","import {\n    addDecoderSizePrefix,\n    addEncoderSizePrefix,\n    combineCodec,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getArrayEncoder,\n    getBytesDecoder,\n    getBytesEncoder,\n    getStructDecoder,\n    getStructEncoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder, getU8Decoder, getU8Encoder } from '@solana/codecs-numbers';\n\nimport { getCompiledInstructions } from '../compile/instructions';\n\ntype Instruction = ReturnType<typeof getCompiledInstructions>[number];\n\nlet memoizedGetInstructionEncoder: VariableSizeEncoder<Instruction> | undefined;\nexport function getInstructionEncoder(): VariableSizeEncoder<Instruction> {\n    if (!memoizedGetInstructionEncoder) {\n        memoizedGetInstructionEncoder = transformEncoder<Required<Instruction>, Instruction>(\n            getStructEncoder([\n                ['programAddressIndex', getU8Encoder()],\n                ['accountIndices', getArrayEncoder(getU8Encoder(), { size: getShortU16Encoder() })],\n                ['data', addEncoderSizePrefix(getBytesEncoder(), getShortU16Encoder())],\n            ]),\n            // Convert an instruction to have all fields defined\n            (instruction: Instruction): Required<Instruction> => {\n                if (instruction.accountIndices !== undefined && instruction.data !== undefined) {\n                    return instruction as Required<Instruction>;\n                }\n                return {\n                    ...instruction,\n                    accountIndices: instruction.accountIndices ?? [],\n                    data: instruction.data ?? new Uint8Array(0),\n                } as Required<Instruction>;\n            },\n        );\n    }\n\n    return memoizedGetInstructionEncoder;\n}\n\nlet memoizedGetInstructionDecoder: VariableSizeDecoder<Instruction> | undefined;\nexport function getInstructionDecoder(): VariableSizeDecoder<Instruction> {\n    if (!memoizedGetInstructionDecoder) {\n        memoizedGetInstructionDecoder = transformDecoder<Required<Instruction>, Instruction>(\n            getStructDecoder([\n                ['programAddressIndex', getU8Decoder()],\n                ['accountIndices', getArrayDecoder(getU8Decoder(), { size: getShortU16Decoder() })],\n                [\n                    'data',\n                    addDecoderSizePrefix(getBytesDecoder(), getShortU16Decoder()) as VariableSizeDecoder<Uint8Array>,\n                ],\n            ]),\n            // Convert an instruction to exclude optional fields if they are empty\n            (instruction: Required<Instruction>): Instruction => {\n                if (instruction.accountIndices.length && instruction.data.byteLength) {\n                    return instruction;\n                }\n                const { accountIndices, data, ...rest } = instruction;\n                return {\n                    ...rest,\n                    ...(accountIndices.length ? { accountIndices } : null),\n                    ...(data.byteLength ? { data } : null),\n                };\n            },\n        );\n    }\n    return memoizedGetInstructionDecoder;\n}\n\nexport function getInstructionCodec(): VariableSizeCodec<Instruction> {\n    return combineCodec(getInstructionEncoder(), getInstructionDecoder());\n}\n","import { AccountMeta, Instruction } from '@solana/instructions';\n\nexport type BaseTransactionMessage<\n    TVersion extends TransactionVersion = TransactionVersion,\n    TInstruction extends Instruction = Instruction,\n> = Readonly<{\n    instructions: readonly TInstruction[];\n    version: TVersion;\n}>;\n\nexport const MAX_SUPPORTED_TRANSACTION_VERSION = 0;\n\ntype LegacyInstruction<TProgramAddress extends string = string> = Instruction<TProgramAddress, readonly AccountMeta[]>;\ntype LegacyTransactionMessage = BaseTransactionMessage<'legacy', LegacyInstruction>;\ntype V0TransactionMessage = BaseTransactionMessage<0, Instruction>;\n\nexport type TransactionMessage = LegacyTransactionMessage | V0TransactionMessage;\nexport type TransactionVersion = 'legacy' | 0;\n","import {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED,\n    SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE,\n    SolanaError,\n} from '@solana/errors';\n\nimport { MAX_SUPPORTED_TRANSACTION_VERSION, TransactionVersion } from '../transaction-message';\n\nconst VERSION_FLAG_MASK = 0x80;\n\n/**\n * Returns an encoder that you can use to encode a {@link TransactionVersion} to a byte array.\n *\n * Legacy messages will produce an empty array and will not advance the offset. Versioned messages\n * will produce an array with a single byte.\n */\nexport function getTransactionVersionEncoder(): VariableSizeEncoder<TransactionVersion> {\n    return createEncoder({\n        getSizeFromValue: value => (value === 'legacy' ? 0 : 1),\n        maxSize: 1,\n        write: (value, bytes, offset) => {\n            if (value === 'legacy') {\n                return offset;\n            }\n            if (value < 0 || value > 127) {\n                throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE, {\n                    actualVersion: value,\n                });\n            }\n\n            if (value > MAX_SUPPORTED_TRANSACTION_VERSION) {\n                throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED, {\n                    unsupportedVersion: value,\n                });\n            }\n            bytes.set([value | VERSION_FLAG_MASK], offset);\n            return offset + 1;\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a\n * {@link TransactionVersion}.\n *\n * When the byte at the current offset is determined to represent a legacy transaction, this decoder\n * will return `'legacy'` and will not advance the offset.\n */\nexport function getTransactionVersionDecoder(): VariableSizeDecoder<TransactionVersion> {\n    return createDecoder({\n        maxSize: 1,\n        read: (bytes, offset) => {\n            const firstByte = bytes[offset];\n            if ((firstByte & VERSION_FLAG_MASK) === 0) {\n                // No version flag set; it's a legacy (unversioned) transaction.\n                return ['legacy', offset];\n            } else {\n                const version = firstByte ^ VERSION_FLAG_MASK;\n                if (version > MAX_SUPPORTED_TRANSACTION_VERSION) {\n                    throw new SolanaError(SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_NOT_SUPPORTED, {\n                        unsupportedVersion: version,\n                    });\n                }\n                return [version as TransactionVersion, offset + 1];\n            }\n        },\n    });\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link TransactionVersion}\n *\n * @see {@link getTransactionVersionDecoder}\n * @see {@link getTransactionVersionEncoder}\n */\nexport function getTransactionVersionCodec(): VariableSizeCodec<TransactionVersion> {\n    return combineCodec(getTransactionVersionEncoder(), getTransactionVersionDecoder());\n}\n","import { getAddressDecoder, getAddressEncoder } from '@solana/addresses';\nimport {\n    combineCodec,\n    createEncoder,\n    Decoder,\n    fixDecoderSize,\n    fixEncoderSize,\n    transformDecoder,\n    transformEncoder,\n    VariableSizeCodec,\n    VariableSizeDecoder,\n    VariableSizeEncoder,\n} from '@solana/codecs-core';\nimport {\n    getArrayDecoder,\n    getArrayEncoder,\n    getConstantEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getUnionEncoder,\n} from '@solana/codecs-data-structures';\nimport { getShortU16Decoder, getShortU16Encoder } from '@solana/codecs-numbers';\nimport { getBase58Decoder, getBase58Encoder } from '@solana/codecs-strings';\n\nimport { getCompiledAddressTableLookups } from '../compile/address-table-lookups';\nimport { CompiledTransactionMessage, CompiledTransactionMessageWithLifetime } from '../compile/message';\nimport { getAddressTableLookupDecoder, getAddressTableLookupEncoder } from './address-table-lookup';\nimport { getMessageHeaderDecoder, getMessageHeaderEncoder } from './header';\nimport { getInstructionDecoder, getInstructionEncoder } from './instruction';\nimport { getTransactionVersionDecoder, getTransactionVersionEncoder } from './transaction-version';\n\nfunction getCompiledMessageLegacyEncoder(): VariableSizeEncoder<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n> {\n    return getStructEncoder(getPreludeStructEncoderTuple()) as VariableSizeEncoder<\n        CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n    >;\n}\n\nfunction getCompiledMessageVersionedEncoder(): VariableSizeEncoder<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n> {\n    return transformEncoder(\n        getStructEncoder([\n            ...getPreludeStructEncoderTuple(),\n            ['addressTableLookups', getAddressTableLookupArrayEncoder()],\n        ]) as VariableSizeEncoder<\n            CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n        >,\n        value => {\n            if (value.version === 'legacy') {\n                return value;\n            }\n            return {\n                ...value,\n                addressTableLookups: value.addressTableLookups ?? [],\n            };\n        },\n    );\n}\n\nfunction getPreludeStructEncoderTuple() {\n    const lifetimeTokenEncoder = getUnionEncoder(\n        [\n            // Use a 32-byte constant encoder for a missing lifetime token (index 0).\n            getConstantEncoder(new Uint8Array(32)),\n            // Use a 32-byte base58 encoder for a valid lifetime token (index 1).\n            fixEncoderSize(getBase58Encoder(), 32),\n        ],\n        value => (value === undefined ? 0 : 1),\n    );\n\n    return [\n        ['version', getTransactionVersionEncoder()],\n        ['header', getMessageHeaderEncoder()],\n        ['staticAccounts', getArrayEncoder(getAddressEncoder(), { size: getShortU16Encoder() })],\n        ['lifetimeToken', lifetimeTokenEncoder],\n        ['instructions', getArrayEncoder(getInstructionEncoder(), { size: getShortU16Encoder() })],\n    ] as const;\n}\n\nfunction getPreludeStructDecoderTuple() {\n    return [\n        ['version', getTransactionVersionDecoder() as Decoder<number>],\n        ['header', getMessageHeaderDecoder()],\n        ['staticAccounts', getArrayDecoder(getAddressDecoder(), { size: getShortU16Decoder() })],\n        ['lifetimeToken', fixDecoderSize(getBase58Decoder(), 32)],\n        ['instructions', getArrayDecoder(getInstructionDecoder(), { size: getShortU16Decoder() })],\n        ['addressTableLookups', getAddressTableLookupArrayDecoder()],\n    ] as const;\n}\n\nfunction getAddressTableLookupArrayEncoder() {\n    return getArrayEncoder(getAddressTableLookupEncoder(), { size: getShortU16Encoder() });\n}\n\nfunction getAddressTableLookupArrayDecoder() {\n    return getArrayDecoder(getAddressTableLookupDecoder(), { size: getShortU16Decoder() });\n}\n\n/**\n * Returns an encoder that you can use to encode a {@link CompiledTransactionMessage} to a byte\n * array.\n *\n * The wire format of a Solana transaction consists of signatures followed by a compiled transaction\n * message. The byte array produced by this encoder is the message part.\n */\nexport function getCompiledTransactionMessageEncoder(): VariableSizeEncoder<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime)\n> {\n    return createEncoder({\n        getSizeFromValue: compiledMessage => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().getSizeFromValue(compiledMessage);\n            } else {\n                return getCompiledMessageVersionedEncoder().getSizeFromValue(compiledMessage);\n            }\n        },\n        write: (compiledMessage, bytes, offset) => {\n            if (compiledMessage.version === 'legacy') {\n                return getCompiledMessageLegacyEncoder().write(compiledMessage, bytes, offset);\n            } else {\n                return getCompiledMessageVersionedEncoder().write(compiledMessage, bytes, offset);\n            }\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a\n * {@link CompiledTransactionMessage}.\n *\n * The wire format of a Solana transaction consists of signatures followed by a compiled transaction\n * message. You can use this decoder to decode the message part.\n */\nexport function getCompiledTransactionMessageDecoder(): VariableSizeDecoder<\n    CompiledTransactionMessage & CompiledTransactionMessageWithLifetime\n> {\n    return transformDecoder(\n        getStructDecoder(getPreludeStructDecoderTuple()) as VariableSizeDecoder<\n            CompiledTransactionMessage &\n                CompiledTransactionMessageWithLifetime & {\n                    addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups>;\n                }\n        >,\n        ({ addressTableLookups, ...restOfMessage }) => {\n            if (restOfMessage.version === 'legacy' || !addressTableLookups?.length) {\n                return restOfMessage;\n            }\n            return { ...restOfMessage, addressTableLookups };\n        },\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link CompiledTransactionMessage}\n *\n * @see {@link getCompiledTransactionMessageDecoder}\n * @see {@link getCompiledTransactionMessageEncoder}\n */\nexport function getCompiledTransactionMessageCodec(): VariableSizeCodec<\n    CompiledTransactionMessage | (CompiledTransactionMessage & CompiledTransactionMessageWithLifetime),\n    CompiledTransactionMessage & CompiledTransactionMessageWithLifetime\n> {\n    return combineCodec(getCompiledTransactionMessageEncoder(), getCompiledTransactionMessageDecoder());\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES,\n    SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n    SolanaError,\n} from '@solana/errors';\nimport {\n    AccountLookupMeta,\n    AccountMeta,\n    AccountRole,\n    Instruction,\n    isSignerRole,\n    isWritableRole,\n    mergeRoles,\n    ReadonlyAccount,\n    ReadonlyAccountLookup,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableAccountLookup,\n    WritableSignerAccount,\n} from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nexport const enum AddressMapEntryType {\n    FEE_PAYER,\n    LOOKUP_TABLE,\n    STATIC,\n}\n\ntype AddressMap = {\n    [address: string]: FeePayerAccountEntry | LookupTableAccountEntry | StaticAccountEntry;\n};\ntype FeePayerAccountEntry = Omit<WritableSignerAccount, 'address'> & {\n    [TYPE]: AddressMapEntryType.FEE_PAYER;\n};\ntype LookupTableAccountEntry = Omit<ReadonlyAccountLookup | WritableAccountLookup, 'address'> & {\n    [TYPE]: AddressMapEntryType.LOOKUP_TABLE;\n};\nexport type OrderedAccounts = Brand<(AccountLookupMeta | AccountMeta)[], 'OrderedAccounts'>;\ntype StaticAccountEntry = Omit<\n    ReadonlyAccount | ReadonlySignerAccount | WritableAccount | WritableSignerAccount,\n    'address'\n> & { [TYPE]: AddressMapEntryType.STATIC };\n\nfunction upsert(\n    addressMap: AddressMap,\n    address: Address,\n    update: (\n        entry: FeePayerAccountEntry | LookupTableAccountEntry | Record<never, never> | StaticAccountEntry,\n    ) => AddressMap[Address],\n) {\n    addressMap[address] = update(addressMap[address] ?? { role: AccountRole.READONLY });\n}\n\nconst TYPE = Symbol('AddressMapTypeProperty');\nexport const ADDRESS_MAP_TYPE_PROPERTY: typeof TYPE = TYPE;\n\nexport function getAddressMapFromInstructions(feePayer: Address, instructions: readonly Instruction[]): AddressMap {\n    const addressMap: AddressMap = {\n        [feePayer]: { [TYPE]: AddressMapEntryType.FEE_PAYER, role: AccountRole.WRITABLE_SIGNER },\n    };\n    const addressesOfInvokedPrograms = new Set<Address>();\n    for (const instruction of instructions) {\n        upsert(addressMap, instruction.programAddress, entry => {\n            addressesOfInvokedPrograms.add(instruction.programAddress);\n            if (TYPE in entry) {\n                if (isWritableRole(entry.role)) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES, {\n                                programAddress: instruction.programAddress,\n                            });\n                        default:\n                            throw new SolanaError(SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE, {\n                                programAddress: instruction.programAddress,\n                            });\n                    }\n                }\n                if (entry[TYPE] === AddressMapEntryType.STATIC) {\n                    return entry;\n                }\n            }\n            return { [TYPE]: AddressMapEntryType.STATIC, role: AccountRole.READONLY };\n        });\n        let addressComparator: ReturnType<typeof getAddressComparator>;\n        if (!instruction.accounts) {\n            continue;\n        }\n        for (const account of instruction.accounts) {\n            upsert(addressMap, account.address, entry => {\n                const {\n                    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                    address: _,\n                    ...accountMeta\n                } = account;\n                if (TYPE in entry) {\n                    switch (entry[TYPE]) {\n                        case AddressMapEntryType.FEE_PAYER:\n                            // The fee payer already has the highest rank -- it is by definition\n                            // writable-signer. Return it, no matter how `account` is configured\n                            return entry;\n                        case AddressMapEntryType.LOOKUP_TABLE: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if ('lookupTableAddress' in accountMeta) {\n                                const shouldReplaceEntry =\n                                    // Consider using the new LOOKUP_TABLE if its address is different...\n                                    entry.lookupTableAddress !== accountMeta.lookupTableAddress &&\n                                    // ...and sorts before the existing one.\n                                    (addressComparator ||= getAddressComparator())(\n                                        accountMeta.lookupTableAddress,\n                                        entry.lookupTableAddress,\n                                    ) < 0;\n                                if (shouldReplaceEntry) {\n                                    return {\n                                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                        ...accountMeta,\n                                        role: nextRole,\n                                    } as LookupTableAccountEntry;\n                                }\n                            } else if (isSignerRole(accountMeta.role)) {\n                                // Upgrade this LOOKUP_TABLE entry to a static entry if it must sign.\n                                return {\n                                    [TYPE]: AddressMapEntryType.STATIC,\n                                    role: nextRole,\n                                } as StaticAccountEntry;\n                            }\n                            if (entry.role !== nextRole) {\n                                return {\n                                    ...entry,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                return entry;\n                            }\n                        }\n                        case AddressMapEntryType.STATIC: {\n                            const nextRole = mergeRoles(entry.role, accountMeta.role);\n                            if (\n                                // Check to see if this address represents a program that is invoked\n                                // in this transaction.\n                                addressesOfInvokedPrograms.has(account.address)\n                            ) {\n                                if (isWritableRole(accountMeta.role)) {\n                                    throw new SolanaError(\n                                        SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE,\n                                        {\n                                            programAddress: account.address,\n                                        },\n                                    );\n                                }\n                                if (entry.role !== nextRole) {\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            } else if (\n                                'lookupTableAddress' in accountMeta &&\n                                // Static accounts can be 'upgraded' to lookup table accounts as\n                                // long as they are not require to sign the transaction.\n                                !isSignerRole(entry.role)\n                            ) {\n                                return {\n                                    ...accountMeta,\n                                    [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                                    role: nextRole,\n                                } as LookupTableAccountEntry;\n                            } else {\n                                if (entry.role !== nextRole) {\n                                    // The account's role ranks higher than the current entry's.\n                                    return {\n                                        ...entry,\n                                        role: nextRole,\n                                    } as StaticAccountEntry;\n                                } else {\n                                    return entry;\n                                }\n                            }\n                        }\n                    }\n                }\n                if ('lookupTableAddress' in accountMeta) {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.LOOKUP_TABLE,\n                    };\n                } else {\n                    return {\n                        ...accountMeta,\n                        [TYPE]: AddressMapEntryType.STATIC,\n                    };\n                }\n            });\n        }\n    }\n    return addressMap;\n}\n\nexport function getOrderedAccountsFromAddressMap(addressMap: AddressMap): OrderedAccounts {\n    let addressComparator: ReturnType<typeof getAddressComparator>;\n    const orderedAccounts: (AccountLookupMeta | AccountMeta)[] = Object.entries(addressMap)\n        .sort(([leftAddress, leftEntry], [rightAddress, rightEntry]) => {\n            // STEP 1: Rapid precedence check. Fee payer, then static addresses, then lookups.\n            if (leftEntry[TYPE] !== rightEntry[TYPE]) {\n                if (leftEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.FEE_PAYER) {\n                    return 1;\n                } else if (leftEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return -1;\n                } else if (rightEntry[TYPE] === AddressMapEntryType.STATIC) {\n                    return 1;\n                }\n            }\n            // STEP 2: Sort by signer-writability.\n            const leftIsSigner = isSignerRole(leftEntry.role);\n            if (leftIsSigner !== isSignerRole(rightEntry.role)) {\n                return leftIsSigner ? -1 : 1;\n            }\n            const leftIsWritable = isWritableRole(leftEntry.role);\n            if (leftIsWritable !== isWritableRole(rightEntry.role)) {\n                return leftIsWritable ? -1 : 1;\n            }\n            // STEP 3: Sort by address.\n            addressComparator ||= getAddressComparator();\n            if (\n                leftEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                rightEntry[TYPE] === AddressMapEntryType.LOOKUP_TABLE &&\n                leftEntry.lookupTableAddress !== rightEntry.lookupTableAddress\n            ) {\n                return addressComparator(leftEntry.lookupTableAddress, rightEntry.lookupTableAddress);\n            } else {\n                return addressComparator(leftAddress, rightAddress);\n            }\n        })\n        .map(([address, addressMeta]) => ({\n            address: address as Address<typeof address>,\n            ...addressMeta,\n        }));\n    return orderedAccounts as unknown as OrderedAccounts;\n}\n","import { Address, getAddressComparator } from '@solana/addresses';\nimport { AccountRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype AddressTableLookup = Readonly<{\n    /** The address of the address lookup table account. */\n    lookupTableAddress: Address;\n    /** Indexes of accounts in a lookup table to load as read-only. */\n    readonlyIndexes: readonly number[];\n    /** Indexes of accounts in a lookup table to load as writable. */\n    writableIndexes: readonly number[];\n}>;\n\nexport function getCompiledAddressTableLookups(orderedAccounts: OrderedAccounts): AddressTableLookup[] {\n    const index: Record<\n        Address,\n        Readonly<{\n            [K in keyof Omit<AddressTableLookup, 'lookupTableAddress'>]: number[];\n        }>\n    > = {};\n    for (const account of orderedAccounts) {\n        if (!('lookupTableAddress' in account)) {\n            continue;\n        }\n        const entry = (index[account.lookupTableAddress] ||= {\n            readonlyIndexes: [],\n            writableIndexes: [],\n        });\n        if (account.role === AccountRole.WRITABLE) {\n            entry.writableIndexes.push(account.addressIndex);\n        } else {\n            entry.readonlyIndexes.push(account.addressIndex);\n        }\n    }\n    return Object.keys(index)\n        .sort(getAddressComparator())\n        .map(lookupTableAddress => ({\n            lookupTableAddress: lookupTableAddress as Address,\n            ...index[lookupTableAddress as unknown as Address],\n        }));\n}\n","import { isSignerRole, isWritableRole } from '@solana/instructions';\n\nimport { OrderedAccounts } from '../compile/accounts';\n\ntype MessageHeader = Readonly<{\n    /**\n     * The number of accounts in the static accounts list that are neither writable nor\n     * signers.\n     *\n     * Adding this number to `numSignerAccounts` yields the index of the first read-only non-signer\n     * account in the static accounts list.\n     */\n    numReadonlyNonSignerAccounts: number;\n    /**\n     * The number of read-only accounts in the static accounts list that must sign this\n     * transaction.\n     *\n     * Subtracting this number from `numSignerAccounts` yields the index of the first read-only\n     * signer account in the static accounts list.\n     */\n    numReadonlySignerAccounts: number;\n    /**\n     * The number of accounts in the static accounts list that must sign this transaction.\n     *\n     * Subtracting `numReadonlySignerAccounts` from this number yields the number of\n     * writable signer accounts in the static accounts list. Writable signer accounts always\n     * begin at index zero in the static accounts list.\n     *\n     * This number itself is the index of the first non-signer account in the static\n     * accounts list.\n     */\n    numSignerAccounts: number;\n}>;\n\nexport function getCompiledMessageHeader(orderedAccounts: OrderedAccounts): MessageHeader {\n    let numReadonlyNonSignerAccounts = 0;\n    let numReadonlySignerAccounts = 0;\n    let numSignerAccounts = 0;\n    for (const account of orderedAccounts) {\n        if ('lookupTableAddress' in account) {\n            break;\n        }\n        const accountIsWritable = isWritableRole(account.role);\n        if (isSignerRole(account.role)) {\n            numSignerAccounts++;\n            if (!accountIsWritable) {\n                numReadonlySignerAccounts++;\n            }\n        } else if (!accountIsWritable) {\n            numReadonlyNonSignerAccounts++;\n        }\n    }\n    return {\n        numReadonlyNonSignerAccounts,\n        numReadonlySignerAccounts,\n        numSignerAccounts,\n    };\n}\n","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport { Instruction } from '@solana/instructions';\n\nimport { OrderedAccounts } from './accounts';\n\ntype CompiledInstruction = Readonly<{\n    /**\n     * An ordered list of indices that indicate which accounts in the transaction message's\n     * accounts list are loaded by this instruction.\n     */\n    accountIndices?: number[];\n    /** The input to the invoked program */\n    data?: ReadonlyUint8Array;\n    /**\n     * The index of the address in the transaction message's accounts list associated with the\n     * program to invoke.\n     */\n    programAddressIndex: number;\n}>;\n\nfunction getAccountIndex(orderedAccounts: OrderedAccounts) {\n    const out: Record<Address, number> = {};\n    for (const [index, account] of orderedAccounts.entries()) {\n        out[account.address] = index;\n    }\n    return out;\n}\n\nexport function getCompiledInstructions(\n    instructions: readonly Instruction[],\n    orderedAccounts: OrderedAccounts,\n): CompiledInstruction[] {\n    const accountIndex = getAccountIndex(orderedAccounts);\n    return instructions.map(({ accounts, data, programAddress }) => {\n        return {\n            programAddressIndex: accountIndex[programAddress],\n            ...(accounts ? { accountIndices: accounts.map(({ address }) => accountIndex[address]) } : null),\n            ...(data ? { data } : null),\n        };\n    });\n}\n","import { TransactionMessageWithBlockhashLifetime, TransactionMessageWithDurableNonceLifetime } from '../index';\n\nexport function getCompiledLifetimeToken(\n    lifetimeConstraint: (\n        | TransactionMessageWithBlockhashLifetime\n        | TransactionMessageWithDurableNonceLifetime\n    )['lifetimeConstraint'],\n): string {\n    if ('nonce' in lifetimeConstraint) {\n        return lifetimeConstraint.nonce;\n    }\n    return lifetimeConstraint.blockhash;\n}\n","import { Address } from '@solana/addresses';\n\nimport { OrderedAccounts } from './accounts';\n\nexport function getCompiledStaticAccounts(orderedAccounts: OrderedAccounts): Address[] {\n    const firstLookupTableAccountIndex = orderedAccounts.findIndex(account => 'lookupTableAddress' in account);\n    const orderedStaticAccounts =\n        firstLookupTableAccountIndex === -1 ? orderedAccounts : orderedAccounts.slice(0, firstLookupTableAccountIndex);\n    return orderedStaticAccounts.map(({ address }) => address);\n}\n","import { TransactionMessageWithFeePayer } from '../fee-payer';\nimport { TransactionMessageWithLifetime } from '../lifetime';\nimport { BaseTransactionMessage } from '../transaction-message';\nimport { getAddressMapFromInstructions, getOrderedAccountsFromAddressMap } from './accounts';\nimport { getCompiledAddressTableLookups } from './address-table-lookups';\nimport { getCompiledMessageHeader } from './header';\nimport { getCompiledInstructions } from './instructions';\nimport { getCompiledLifetimeToken } from './lifetime-token';\nimport { getCompiledStaticAccounts } from './static-accounts';\n\ntype BaseCompiledTransactionMessage = Readonly<{\n    /**\n     * Information about the version of the transaction message and the role of the accounts it\n     * loads.\n     */\n    header: ReturnType<typeof getCompiledMessageHeader>;\n    instructions: ReturnType<typeof getCompiledInstructions>;\n    /** A list of addresses indicating which accounts to load */\n    staticAccounts: ReturnType<typeof getCompiledStaticAccounts>;\n}>;\n\n/**\n * A transaction message in a form suitable for encoding for execution on the network.\n *\n * You can not fully reconstruct a source message from a compiled message without extra information.\n * In particular, supporting details about the lifetime constraint and the concrete addresses of\n * accounts sourced from account lookup tables are lost to compilation.\n */\nexport type CompiledTransactionMessage = LegacyCompiledTransactionMessage | VersionedCompiledTransactionMessage;\n\nexport type CompiledTransactionMessageWithLifetime = Readonly<{\n    /**\n     * 32 bytes of data observed by the transaction proposed that makes a transaction eligible to\n     * land on the network.\n     *\n     * In the case of a transaction message with a nonce lifetime constraint, this will be the value\n     * of the nonce itself. In all other cases this will be a recent blockhash.\n     */\n    lifetimeToken: ReturnType<typeof getCompiledLifetimeToken>;\n}>;\n\ntype LegacyCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        version: 'legacy';\n    }>;\n\ntype VersionedCompiledTransactionMessage = BaseCompiledTransactionMessage &\n    Readonly<{\n        /** A list of address tables and the accounts that this transaction loads from them */\n        addressTableLookups?: ReturnType<typeof getCompiledAddressTableLookups>;\n        version: 0;\n    }>;\n\n/**\n * Converts the type of transaction message data structure that you create in your application to\n * the type of transaction message data structure that can be encoded for execution on the network.\n *\n * This is a lossy process; you can not fully reconstruct a source message from a compiled message\n * without extra information. In particular, supporting details about the lifetime constraint and\n * the concrete addresses of accounts sourced from account lookup tables will be lost to\n * compilation.\n *\n * @see {@link decompileTransactionMessage}\n */\nexport function compileTransactionMessage<\n    TTransactionMessage extends BaseTransactionMessage & TransactionMessageWithFeePayer,\n>(transactionMessage: TTransactionMessage): CompiledTransactionMessageFromTransactionMessage<TTransactionMessage> {\n    type ReturnType = CompiledTransactionMessageFromTransactionMessage<TTransactionMessage>;\n\n    const addressMap = getAddressMapFromInstructions(\n        transactionMessage.feePayer.address,\n        transactionMessage.instructions,\n    );\n    const orderedAccounts = getOrderedAccountsFromAddressMap(addressMap);\n    const lifetimeConstraint = (transactionMessage as Partial<TransactionMessageWithLifetime>).lifetimeConstraint;\n\n    return {\n        ...(transactionMessage.version !== 'legacy'\n            ? { addressTableLookups: getCompiledAddressTableLookups(orderedAccounts) }\n            : null),\n        ...(lifetimeConstraint ? { lifetimeToken: getCompiledLifetimeToken(lifetimeConstraint) } : null),\n        header: getCompiledMessageHeader(orderedAccounts),\n        instructions: getCompiledInstructions(transactionMessage.instructions, orderedAccounts),\n        staticAccounts: getCompiledStaticAccounts(orderedAccounts),\n        version: transactionMessage.version,\n    } as ReturnType;\n}\n\ntype CompiledTransactionMessageFromTransactionMessage<TTransactionMessage extends BaseTransactionMessage> =\n    ForwardTransactionMessageLifetime<ForwardTransactionMessageVersion<TTransactionMessage>, TTransactionMessage>;\n\ntype ForwardTransactionMessageVersion<TTransactionMessage extends BaseTransactionMessage> =\n    TTransactionMessage extends Readonly<{ version: 'legacy' }>\n        ? LegacyCompiledTransactionMessage\n        : VersionedCompiledTransactionMessage;\n\ntype ForwardTransactionMessageLifetime<\n    TCompiledTransactionMessage extends CompiledTransactionMessage,\n    TTransactionMessage extends BaseTransactionMessage,\n> = TTransactionMessage extends TransactionMessageWithLifetime\n    ? CompiledTransactionMessageWithLifetime & TCompiledTransactionMessage\n    : TCompiledTransactionMessage;\n","import { Address } from '@solana/addresses';\nimport { AccountLookupMeta, AccountMeta, AccountRole, Instruction, isSignerRole } from '@solana/instructions';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { BaseTransactionMessage, TransactionMessage } from './transaction-message';\n\ntype Mutable<T> = {\n    -readonly [P in keyof T]: T[P];\n};\n\n// Look up the address in lookup tables, return a lookup meta if it is found in any of them\nfunction findAddressInLookupTables(\n    address: Address,\n    role: AccountRole.READONLY | AccountRole.WRITABLE,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): AccountLookupMeta | undefined {\n    for (const [lookupTableAddress, addresses] of Object.entries(addressesByLookupTableAddress)) {\n        for (let i = 0; i < addresses.length; i++) {\n            if (address === addresses[i]) {\n                return {\n                    address,\n                    addressIndex: i,\n                    lookupTableAddress: lookupTableAddress as Address,\n                    role,\n                };\n            }\n        }\n    }\n}\n\ntype TransactionMessageNotLegacy = Exclude<TransactionMessage, { version: 'legacy' }>;\n\n// Each account can be AccountLookupMeta | AccountMeta\ntype WidenInstructionAccounts<TInstruction extends Instruction> =\n    TInstruction extends Instruction<infer TProgramAddress, infer TAccounts>\n        ? Instruction<\n              TProgramAddress,\n              {\n                  [K in keyof TAccounts]: TAccounts[K] extends AccountMeta<infer TAddress>\n                      ? AccountLookupMeta<TAddress> | AccountMeta<TAddress>\n                      : TAccounts[K];\n              }\n          >\n        : TInstruction;\n\ntype ExtractAdditionalProps<T, U> = Omit<T, keyof U>;\n\ntype WidenTransactionMessageInstructions<TTransactionMessage extends TransactionMessage> =\n    TTransactionMessage extends BaseTransactionMessage<infer TVersion, infer TInstruction>\n        ? BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>> &\n              ExtractAdditionalProps<\n                  TTransactionMessage,\n                  BaseTransactionMessage<TVersion, WidenInstructionAccounts<TInstruction>>\n              >\n        : TTransactionMessage;\n\n/**\n * Given a transaction message and a mapping of lookup tables to the addresses stored in them, this\n * function will return a new transaction message with the same instructions but with all non-signer\n * accounts that are found in the given lookup tables represented by an {@link AccountLookupMeta}\n * instead of an {@link AccountMeta}.\n *\n * This means that these accounts will take up less space in the compiled transaction message. This\n * size reduction is most significant when the transaction includes many accounts from the same\n * lookup table.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import {\n *     AddressesByLookupTableAddress,\n *     compressTransactionMessageUsingAddressLookupTables,\n * } from '@solana/transaction-messages';\n * import { fetchAddressLookupTable } from '@solana-program/address-lookup-table';\n *\n * const lookupTableAddress = address('4QwSwNriKPrz8DLW4ju5uxC2TN5cksJx6tPUPj7DGLAW');\n * const {\n *     data: { addresses },\n * } = await fetchAddressLookupTable(rpc, lookupTableAddress);\n * const addressesByAddressLookupTable: AddressesByLookupTableAddress = {\n *     [lookupTableAddress]: addresses,\n * };\n *\n * const compressedTransactionMessage = compressTransactionMessageUsingAddressLookupTables(\n *     transactionMessage,\n *     addressesByAddressLookupTable,\n * );\n * ```\n */\nexport function compressTransactionMessageUsingAddressLookupTables<\n    TTransactionMessage extends TransactionMessageNotLegacy = TransactionMessageNotLegacy,\n>(\n    transactionMessage: TTransactionMessage,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): TTransactionMessage | WidenTransactionMessageInstructions<TTransactionMessage> {\n    const programAddresses = new Set(transactionMessage.instructions.map(ix => ix.programAddress));\n    const eligibleLookupAddresses = new Set(\n        Object.values(addressesByLookupTableAddress)\n            .flatMap(a => a)\n            .filter(address => !programAddresses.has(address)),\n    );\n    const newInstructions: Instruction[] = [];\n    let updatedAnyInstructions = false;\n    for (const instruction of transactionMessage.instructions) {\n        if (!instruction.accounts) {\n            newInstructions.push(instruction);\n            continue;\n        }\n\n        const newAccounts: Mutable<NonNullable<Instruction['accounts']>> = [];\n        let updatedAnyAccounts = false;\n        for (const account of instruction.accounts) {\n            // If the address is already a lookup, is not in any lookup tables, or is a signer role, return as-is\n            if (\n                'lookupTableAddress' in account ||\n                !eligibleLookupAddresses.has(account.address) ||\n                isSignerRole(account.role)\n            ) {\n                newAccounts.push(account);\n                continue;\n            }\n\n            // We already checked it's in one of the lookup tables\n            const lookupMetaAccount = findAddressInLookupTables(\n                account.address,\n                account.role,\n                addressesByLookupTableAddress,\n            )!;\n            newAccounts.push(Object.freeze(lookupMetaAccount));\n            updatedAnyAccounts = true;\n            updatedAnyInstructions = true;\n        }\n\n        newInstructions.push(\n            Object.freeze(updatedAnyAccounts ? { ...instruction, accounts: newAccounts } : instruction),\n        );\n    }\n\n    return Object.freeze(\n        updatedAnyInstructions ? { ...transactionMessage, instructions: newInstructions } : transactionMessage,\n    );\n}\n","import { TransactionMessage, TransactionVersion } from './transaction-message';\nimport { TransactionMessageWithinSizeLimit } from './transaction-message-size';\n\ntype TransactionConfig<TVersion extends TransactionVersion> = Readonly<{\n    version: TVersion;\n}>;\n\ntype EmptyTransactionMessage<TVersion extends TransactionVersion> = Omit<\n    Extract<TransactionMessage, { version: TVersion }>,\n    'instructions'\n> &\n    TransactionMessageWithinSizeLimit & { instructions: readonly [] };\n\n/**\n * Given a {@link TransactionVersion} this method will return an empty transaction having the\n * capabilities of that version.\n *\n * @example\n * ```ts\n * import { createTransactionMessage } from '@solana/transaction-messages';\n *\n * const message = createTransactionMessage({ version: 0 });\n * ```\n */\nexport function createTransactionMessage<TVersion extends TransactionVersion>(\n    config: TransactionConfig<TVersion>,\n): EmptyTransactionMessage<TVersion> {\n    return Object.freeze({\n        instructions: Object.freeze([]),\n        version: config.version,\n    }) as EmptyTransactionMessage<TVersion>;\n}\n","import { Address } from '@solana/addresses';\nimport { ReadonlyUint8Array } from '@solana/codecs-core';\nimport {\n    AccountRole,\n    Instruction,\n    InstructionWithAccounts,\n    InstructionWithData,\n    isSignerRole,\n    ReadonlyAccount,\n    ReadonlySignerAccount,\n    WritableAccount,\n    WritableSignerAccount,\n} from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nexport type AdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n> = Instruction<'11111111111111111111111111111111'> &\n    InstructionWithAccounts<\n        readonly [\n            WritableAccount<TNonceAccountAddress>,\n            ReadonlyAccount<'SysvarRecentB1ockHashes11111111111111111111'>,\n            ReadonlySignerAccount<TNonceAuthorityAddress> | WritableSignerAccount<TNonceAuthorityAddress>,\n        ]\n    > &\n    InstructionWithData<AdvanceNonceAccountInstructionData>;\n\ntype AdvanceNonceAccountInstructionData = Brand<Uint8Array, 'AdvanceNonceAccountInstructionData'>;\n\nconst RECENT_BLOCKHASHES_SYSVAR_ADDRESS =\n    'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\nconst SYSTEM_PROGRAM_ADDRESS = '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;\n\n/**\n * Creates an instruction for the System program to advance a nonce.\n *\n * This instruction is a prerequisite for a transaction with a nonce-based lifetime to be landed on\n * the network. In order to be considered valid, the transaction must meet all of these criteria.\n *\n * 1. Its lifetime constraint must be a {@link NonceLifetimeConstraint}.\n * 2. The value contained in the on-chain account at the address `nonceAccountAddress` must be equal\n *    to {@link NonceLifetimeConstraint.nonce} at the time the transaction is landed.\n * 3. The first instruction in that transaction message must be the one returned by this function.\n *\n * You could also use the `getAdvanceNonceAccountInstruction` method of `@solana-program/system`.\n */\nexport function createAdvanceNonceAccountInstruction<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n>(\n    nonceAccountAddress: Address<TNonceAccountAddress>,\n    nonceAuthorityAddress: Address<TNonceAuthorityAddress>,\n): AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return {\n        accounts: [\n            { address: nonceAccountAddress, role: AccountRole.WRITABLE },\n            {\n                address: RECENT_BLOCKHASHES_SYSVAR_ADDRESS,\n                role: AccountRole.READONLY,\n            },\n            { address: nonceAuthorityAddress, role: AccountRole.READONLY_SIGNER },\n        ],\n        data: new Uint8Array([4, 0, 0, 0]) as AdvanceNonceAccountInstructionData,\n        programAddress: SYSTEM_PROGRAM_ADDRESS,\n    };\n}\n\n/**\n * A type guard that returns `true` if the instruction conforms to the\n * {@link AdvanceNonceAccountInstruction} type, and refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isAdvanceNonceAccountInstruction } from '@solana/transaction-messages';\n *\n * if (isAdvanceNonceAccountInstruction(message.instructions[0])) {\n *     // At this point, the first instruction in the message has been refined to a\n *     // `AdvanceNonceAccountInstruction`.\n *     setNonceAccountAddress(message.instructions[0].accounts[0].address);\n * } else {\n *     setError('The first instruction is not an `AdvanceNonce` instruction');\n * }\n * ```\n */\nexport function isAdvanceNonceAccountInstruction(\n    instruction: Instruction,\n): instruction is AdvanceNonceAccountInstruction {\n    return (\n        instruction.programAddress === SYSTEM_PROGRAM_ADDRESS &&\n        // Test for `AdvanceNonceAccount` instruction data\n        instruction.data != null &&\n        isAdvanceNonceAccountInstructionData(instruction.data) &&\n        // Test for exactly 3 accounts\n        instruction.accounts?.length === 3 &&\n        // First account is nonce account address\n        instruction.accounts[0].address != null &&\n        instruction.accounts[0].role === AccountRole.WRITABLE &&\n        // Second account is recent blockhashes sysvar\n        instruction.accounts[1].address === RECENT_BLOCKHASHES_SYSVAR_ADDRESS &&\n        instruction.accounts[1].role === AccountRole.READONLY &&\n        // Third account is nonce authority account\n        instruction.accounts[2].address != null &&\n        isSignerRole(instruction.accounts[2].role)\n    );\n}\n\nfunction isAdvanceNonceAccountInstructionData(data: ReadonlyUint8Array): data is AdvanceNonceAccountInstructionData {\n    // AdvanceNonceAccount is the fifth instruction in the System Program (index 4)\n    return data.byteLength === 4 && data[0] === 4 && data[1] === 0 && data[2] === 0 && data[3] === 0;\n}\n","import { Address } from '@solana/addresses';\nimport { SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME, SolanaError } from '@solana/errors';\nimport { Instruction } from '@solana/instructions';\nimport { Brand } from '@solana/nominal-types';\n\nimport {\n    AdvanceNonceAccountInstruction,\n    createAdvanceNonceAccountInstruction,\n    isAdvanceNonceAccountInstruction,\n} from './durable-nonce-instruction';\nimport { ExcludeTransactionMessageLifetime } from './lifetime';\nimport { BaseTransactionMessage } from './transaction-message';\nimport { ExcludeTransactionMessageWithinSizeLimit } from './transaction-message-size';\n\ntype DurableNonceConfig<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = Readonly<{\n    readonly nonce: Nonce<TNonceValue>;\n    readonly nonceAccountAddress: Address<TNonceAccountAddress>;\n    readonly nonceAuthorityAddress: Address<TNonceAuthorityAddress>;\n}>;\n\n/** Represents a string that is particularly known to be the base58-encoded value of a nonce. */\nexport type Nonce<TNonceValue extends string = string> = Brand<TNonceValue, 'Nonce'>;\n\n/**\n * A constraint which, when applied to a transaction message, makes that transaction message\n * eligible to land on the network.\n *\n * The transaction message will continue to be eligible to land until the network considers the\n * `nonce` to have advanced. This can happen when the nonce account in which this nonce is found is\n * destroyed, or the nonce value within changes.\n */\ntype NonceLifetimeConstraint<TNonceValue extends string = string> = Readonly<{\n    /**\n     * A value contained in the related nonce account at the time the transaction was prepared.\n     *\n     * The transaction will be considered eligible to land until the nonce account ceases to exist\n     * or contain this value.\n     */\n    nonce: Nonce<TNonceValue>;\n}>;\n\n/**\n * Represents a transaction message whose lifetime is defined by the value of a nonce it includes.\n *\n * Such a transaction can only be landed on the network if the nonce is known to the network and has\n * not already been used to land a different transaction.\n */\nexport interface TransactionMessageWithDurableNonceLifetime<\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> {\n    readonly instructions: readonly [\n        // The first instruction *must* be the system program's `AdvanceNonceAccount` instruction.\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...Instruction[],\n    ];\n    readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n}\n\n/**\n * A helper type to exclude the durable nonce lifetime constraint from a transaction message.\n */\nexport type ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage extends BaseTransactionMessage> =\n    TTransactionMessage extends TransactionMessageWithDurableNonceLifetime\n        ? ExcludeTransactionMessageLifetime<TTransactionMessage>\n        : TTransactionMessage;\n\n/**\n * A type guard that returns `true` if the transaction message conforms to the\n * {@link TransactionMessageWithDurableNonceLifetime} type, and refines its type for use in your\n * program.\n *\n * @example\n * ```ts\n * import { isTransactionMessageWithDurableNonceLifetime } from '@solana/transaction-messages';\n * import { fetchNonce } from \"@solana-program/system\";\n *\n * if (isTransactionMessageWithDurableNonceLifetime(message)) {\n *     // At this point, `message` has been refined to a\n *     // `TransactionMessageWithDurableNonceLifetime`.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n *     setNonceIsValid(nonce === actualNonce);\n * } else {\n *     setError(\n *         `${getSignatureFromTransaction(transaction)} does not have a nonce-based lifetime`,\n *     );\n * }\n * ```\n */\nexport function isTransactionMessageWithDurableNonceLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): transactionMessage is BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    return (\n        'lifetimeConstraint' in transactionMessage &&\n        typeof transactionMessage.lifetimeConstraint.nonce === 'string' &&\n        transactionMessage.instructions[0] != null &&\n        isAdvanceNonceAccountInstruction(transactionMessage.instructions[0])\n    );\n}\n\n/**\n * From time to time you might acquire a transaction message, that you expect to have a\n * nonce-based lifetime, from an untrusted network API or user input. Use this function to assert\n * that such a transaction message actually has a nonce-based lifetime.\n *\n * @example\n * ```ts\n * import { assertIsTransactionMessageWithDurableNonceLifetime } from '@solana/transaction-messages';\n *\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `message` to `TransactionMessageWithDurableNonceLifetime`.\n *     assertIsTransactionMessageWithDurableNonceLifetime(message);\n *     // At this point, `message` is a `TransactionMessageWithDurableNonceLifetime` that can be used\n *     // with the RPC.\n *     const { nonce, nonceAccountAddress } = message.lifetimeConstraint;\n *     const { data: { blockhash: actualNonce } } = await fetchNonce(nonceAccountAddress);\n * } catch (e) {\n *     // `message` turned out not to have a nonce-based lifetime\n * }\n * ```\n */\nexport function assertIsTransactionMessageWithDurableNonceLifetime(\n    transactionMessage: BaseTransactionMessage | (BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime),\n): asserts transactionMessage is BaseTransactionMessage & TransactionMessageWithDurableNonceLifetime {\n    if (!isTransactionMessageWithDurableNonceLifetime(transactionMessage)) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME);\n    }\n}\n\nfunction isAdvanceNonceAccountInstructionForNonce<\n    TNonceAccountAddress extends Address = Address,\n    TNonceAuthorityAddress extends Address = Address,\n>(\n    instruction: AdvanceNonceAccountInstruction,\n    nonceAccountAddress: TNonceAccountAddress,\n    nonceAuthorityAddress: TNonceAuthorityAddress,\n): instruction is AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress> {\n    return (\n        instruction.accounts[0].address === nonceAccountAddress &&\n        instruction.accounts[2].address === nonceAuthorityAddress\n    );\n}\n\n/**\n * Given a nonce, the account where the value of the nonce is stored, and the address of the account\n * authorized to consume that nonce, this method will return a new transaction having the same type\n * as the one supplied plus the {@link TransactionMessageWithDurableNonceLifetime} type.\n *\n * In particular, this method _prepends_ an instruction to the transaction message designed to\n * consume (or 'advance') the nonce in the same transaction whose lifetime is defined by it.\n *\n * @param config\n *\n * @example\n * ```ts\n * import { Nonce, setTransactionMessageLifetimeUsingDurableNonce } from '@solana/transaction-messages';\n * import { fetchNonce } from '@solana-program/system';\n *\n * const nonceAccountAddress = address('EGtMh4yvXswwHhwVhyPxGrVV2TkLTgUqGodbATEPvojZ');\n * const nonceAuthorityAddress = address('4KD1Rdrd89NG7XbzW3xsX9Aqnx2EExJvExiNme6g9iAT');\n *\n * const {\n *     data: { blockhash },\n * } = await fetchNonce(rpc, nonceAccountAddress);\n * const nonce = blockhash as string as Nonce;\n *\n * const durableNonceTransactionMessage = setTransactionMessageLifetimeUsingDurableNonce(\n *     { nonce, nonceAccountAddress, nonceAuthorityAddress },\n *     tx,\n * );\n * ```\n */\nexport function setTransactionMessageLifetimeUsingDurableNonce<\n    TTransactionMessage extends BaseTransactionMessage,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n>(\n    {\n        nonce,\n        nonceAccountAddress,\n        nonceAuthorityAddress,\n    }: DurableNonceConfig<TNonceAccountAddress, TNonceAuthorityAddress, TNonceValue>,\n    transactionMessage: TTransactionMessage,\n): SetTransactionMessageWithDurableNonceLifetime<\n    TTransactionMessage,\n    TNonceAccountAddress,\n    TNonceAuthorityAddress,\n    TNonceValue\n> {\n    type ReturnType = SetTransactionMessageWithDurableNonceLifetime<\n        TTransactionMessage,\n        TNonceAccountAddress,\n        TNonceAuthorityAddress,\n        TNonceValue\n    >;\n\n    let newInstructions: [\n        AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n        ...Instruction[],\n    ];\n\n    const firstInstruction = transactionMessage.instructions[0];\n    if (firstInstruction && isAdvanceNonceAccountInstruction(firstInstruction)) {\n        if (isAdvanceNonceAccountInstructionForNonce(firstInstruction, nonceAccountAddress, nonceAuthorityAddress)) {\n            if (\n                isTransactionMessageWithDurableNonceLifetime(transactionMessage) &&\n                transactionMessage.lifetimeConstraint.nonce === nonce\n            ) {\n                return transactionMessage as unknown as ReturnType;\n            } else {\n                // we already have the right first instruction, leave it as-is\n                newInstructions = [firstInstruction, ...transactionMessage.instructions.slice(1)];\n            }\n        } else {\n            // we have a different advance nonce instruction as the first instruction, replace it\n            newInstructions = [\n                Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n                ...transactionMessage.instructions.slice(1),\n            ];\n        }\n    } else {\n        // we don't have an existing advance nonce instruction as the first instruction, prepend one\n        newInstructions = [\n            Object.freeze(createAdvanceNonceAccountInstruction(nonceAccountAddress, nonceAuthorityAddress)),\n            ...transactionMessage.instructions,\n        ];\n    }\n\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze(newInstructions),\n        lifetimeConstraint: Object.freeze({ nonce }),\n    }) as unknown as ReturnType;\n}\n\n/**\n * Helper type that transforms a given transaction message type into a new one that has the\n * `AdvanceNonceAccount` instruction as the first instruction and a lifetime constraint\n * representing the nonce value.\n */\ntype SetTransactionMessageWithDurableNonceLifetime<\n    TTransactionMessage extends BaseTransactionMessage,\n    TNonceAccountAddress extends string = string,\n    TNonceAuthorityAddress extends string = string,\n    TNonceValue extends string = string,\n> = Omit<\n    // 1. The transaction message only grows in size if it currently has a different (or no) lifetime.\n    TTransactionMessage extends TransactionMessageWithDurableNonceLifetime\n        ? TTransactionMessage\n        : ExcludeTransactionMessageWithinSizeLimit<TTransactionMessage>,\n    // 2. Remove the instructions array as we are going to replace it with a new one.\n    'instructions'\n> & {\n    // 3. Replace or prepend the first instruction with the advance nonce account instruction.\n    readonly instructions: TTransactionMessage['instructions'] extends readonly [\n        AdvanceNonceAccountInstruction,\n        ...infer TTail extends readonly Instruction[],\n    ]\n        ? readonly [AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>, ...TTail]\n        : readonly [\n              AdvanceNonceAccountInstruction<TNonceAccountAddress, TNonceAuthorityAddress>,\n              ...TTransactionMessage['instructions'],\n          ];\n    // 4. Set the lifetime constraint to the nonce value.\n    readonly lifetimeConstraint: NonceLifetimeConstraint<TNonceValue>;\n};\n","import { Address } from '@solana/addresses';\n\nimport { BaseTransactionMessage } from './transaction-message';\n\n/**\n * Represents a transaction message for which a fee payer has been declared. A transaction must\n * conform to this type to be compiled and landed on the network.\n */\nexport interface TransactionMessageWithFeePayer<TAddress extends string = string> {\n    readonly feePayer: Readonly<{ address: Address<TAddress> }>;\n}\n\n/**\n * A helper type to exclude the fee payer from a transaction message.\n */\ntype ExcludeTransactionMessageFeePayer<TTransactionMessage extends BaseTransactionMessage> = Omit<\n    TTransactionMessage,\n    'feePayer'\n>;\n\n/**\n * Given a base58-encoded address of a system account, this method will return a new transaction\n * message having the same type as the one supplied plus the {@link TransactionMessageWithFeePayer}\n * type.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { setTransactionMessageFeePayer } from '@solana/transaction-messages';\n *\n * const myAddress = address('mpngsFd4tmbUfzDYJayjKZwZcaR7aWb2793J6grLsGu');\n * const txPaidByMe = setTransactionMessageFeePayer(myAddress, tx);\n * ```\n */\nexport function setTransactionMessageFeePayer<\n    TFeePayerAddress extends string,\n    TTransactionMessage extends BaseTransactionMessage & Partial<TransactionMessageWithFeePayer>,\n>(\n    feePayer: Address<TFeePayerAddress>,\n    transactionMessage: TTransactionMessage,\n): ExcludeTransactionMessageFeePayer<TTransactionMessage> & TransactionMessageWithFeePayer<TFeePayerAddress> {\n    if (\n        'feePayer' in transactionMessage &&\n        feePayer === transactionMessage.feePayer?.address &&\n        isAddressOnlyFeePayer(transactionMessage.feePayer)\n    ) {\n        return transactionMessage as unknown as Omit<TTransactionMessage, 'feePayer'> &\n            TransactionMessageWithFeePayer<TFeePayerAddress>;\n    }\n    const out = {\n        ...transactionMessage,\n        feePayer: Object.freeze({ address: feePayer }),\n    };\n    Object.freeze(out);\n    return out;\n}\n\nfunction isAddressOnlyFeePayer(\n    feePayer: Partial<TransactionMessageWithFeePayer>['feePayer'],\n): feePayer is { address: Address } {\n    return (\n        !!feePayer &&\n        'address' in feePayer &&\n        typeof feePayer.address === 'string' &&\n        Object.keys(feePayer).length === 1\n    );\n}\n","import { Instruction } from '@solana/instructions';\n\nimport { ExcludeTransactionMessageDurableNonceLifetime } from './durable-nonce';\nimport { BaseTransactionMessage } from './transaction-message';\nimport { ExcludeTransactionMessageWithinSizeLimit } from './transaction-message-size';\n\n/**\n * A helper type to append instructions to a transaction message\n * without losing type information about the current instructions.\n */\ntype AppendTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstructions extends readonly Instruction[],\n> = Omit<ExcludeTransactionMessageWithinSizeLimit<TTransactionMessage>, 'instructions'> & {\n    readonly instructions: readonly [...TTransactionMessage['instructions'], ...TInstructions];\n};\n\n/**\n * A helper type to prepend instructions to a transaction message\n * without losing type information about the current instructions.\n */\ntype PrependTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstructions extends readonly Instruction[],\n> = Omit<\n    ExcludeTransactionMessageWithinSizeLimit<ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage>>,\n    'instructions'\n> & {\n    readonly instructions: readonly [...TInstructions, ...TTransactionMessage['instructions']];\n};\n\n/**\n * Given an instruction, this method will return a new transaction message with that instruction\n * having been added to the end of the list of existing instructions.\n *\n * @see {@link appendTransactionInstructions} if you need to append multiple instructions to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { getUtf8Encoder } from '@solana/codecs-strings';\n * import { appendTransactionMessageInstruction } from '@solana/transaction-messages';\n *\n * const memoTransactionMessage = appendTransactionMessageInstruction(\n *     {\n *         data: getUtf8Encoder().encode('Hello world!'),\n *         programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *     },\n *     transactionMessage,\n * );\n * ```\n */\nexport function appendTransactionMessageInstruction<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstruction extends Instruction,\n>(\n    instruction: TInstruction,\n    transactionMessage: TTransactionMessage,\n): AppendTransactionMessageInstructions<TTransactionMessage, [TInstruction]> {\n    return appendTransactionMessageInstructions([instruction], transactionMessage);\n}\n\n/**\n * Given an array of instructions, this method will return a new transaction message with those\n * instructions having been added to the end of the list of existing instructions.\n *\n * @see {@link appendTransactionInstruction} if you only need to append one instruction to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { appendTransactionMessageInstructions } from '@solana/transaction-messages';\n *\n * const memoTransaction = appendTransactionMessageInstructions(\n *     [\n *         {\n *             data: new TextEncoder().encode('Hello world!'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *         {\n *             data: new TextEncoder().encode('How are you?'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *     ],\n *     tx,\n * );\n * ```\n */\nexport function appendTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    const TInstructions extends readonly Instruction[],\n>(\n    instructions: TInstructions,\n    transactionMessage: TTransactionMessage,\n): AppendTransactionMessageInstructions<TTransactionMessage, TInstructions> {\n    return Object.freeze({\n        ...transactionMessage,\n        instructions: Object.freeze([\n            ...(transactionMessage.instructions as TTransactionMessage['instructions']),\n            ...instructions,\n        ] as readonly [...TTransactionMessage['instructions'], ...TInstructions]),\n    });\n}\n\n/**\n * Given an instruction, this method will return a new transaction message with that instruction\n * having been added to the beginning of the list of existing instructions.\n *\n * @see {@link prependTransactionInstructions} if you need to prepend multiple instructions to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { prependTransactionMessageInstruction } from '@solana/transaction-messages';\n *\n * const memoTransaction = prependTransactionMessageInstruction(\n *     {\n *         data: new TextEncoder().encode('Hello world!'),\n *         programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *     },\n *     tx,\n * );\n * ```\n */\nexport function prependTransactionMessageInstruction<\n    TTransactionMessage extends BaseTransactionMessage,\n    TInstruction extends Instruction,\n>(\n    instruction: TInstruction,\n    transactionMessage: TTransactionMessage,\n): PrependTransactionMessageInstructions<TTransactionMessage, [TInstruction]> {\n    return prependTransactionMessageInstructions([instruction], transactionMessage);\n}\n\n/**\n * Given an array of instructions, this method will return a new transaction message with those\n * instructions having been added to the beginning of the list of existing instructions.\n *\n * @see {@link prependTransactionInstruction} if you only need to prepend one instruction to a\n * transaction message.\n *\n * @example\n * ```ts\n * import { address } from '@solana/addresses';\n * import { prependTransactionMessageInstructions } from '@solana/transaction-messages';\n *\n * const memoTransaction = prependTransactionMessageInstructions(\n *     [\n *         {\n *             data: new TextEncoder().encode('Hello world!'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *         {\n *             data: new TextEncoder().encode('How are you?'),\n *             programAddress: address('MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr'),\n *         },\n *     ],\n *     tx,\n * );\n * ```\n */\nexport function prependTransactionMessageInstructions<\n    TTransactionMessage extends BaseTransactionMessage,\n    const TInstructions extends readonly Instruction[],\n>(\n    instructions: TInstructions,\n    transactionMessage: TTransactionMessage,\n): PrependTransactionMessageInstructions<TTransactionMessage, TInstructions> {\n    return Object.freeze({\n        ...(transactionMessage as ExcludeTransactionMessageDurableNonceLifetime<TTransactionMessage>),\n        instructions: Object.freeze([\n            ...instructions,\n            ...(transactionMessage.instructions as TTransactionMessage['instructions']),\n        ] as readonly [...TInstructions, ...TTransactionMessage['instructions']]),\n    });\n}\n","import { Address, assertIsAddress } from '@solana/addresses';\nimport {\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING,\n    SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND,\n    SolanaError,\n} from '@solana/errors';\nimport { pipe } from '@solana/functional';\nimport { AccountLookupMeta, AccountMeta, AccountRole, Instruction } from '@solana/instructions';\nimport type { Blockhash } from '@solana/rpc-types';\n\nimport { AddressesByLookupTableAddress } from './addresses-by-lookup-table-address';\nimport { setTransactionMessageLifetimeUsingBlockhash } from './blockhash';\nimport { CompiledTransactionMessage, CompiledTransactionMessageWithLifetime } from './compile';\nimport type { getCompiledAddressTableLookups } from './compile/address-table-lookups';\nimport { createTransactionMessage } from './create-transaction-message';\nimport { Nonce, setTransactionMessageLifetimeUsingDurableNonce } from './durable-nonce';\nimport { isAdvanceNonceAccountInstruction } from './durable-nonce-instruction';\nimport { setTransactionMessageFeePayer, TransactionMessageWithFeePayer } from './fee-payer';\nimport { appendTransactionMessageInstruction } from './instructions';\nimport { TransactionMessageWithLifetime } from './lifetime';\nimport { BaseTransactionMessage, TransactionVersion } from './transaction-message';\n\nfunction getAccountMetas(message: CompiledTransactionMessage): AccountMeta[] {\n    const { header } = message;\n    const numWritableSignerAccounts = header.numSignerAccounts - header.numReadonlySignerAccounts;\n    const numWritableNonSignerAccounts =\n        message.staticAccounts.length - header.numSignerAccounts - header.numReadonlyNonSignerAccounts;\n\n    const accountMetas: AccountMeta[] = [];\n\n    let accountIndex = 0;\n    for (let i = 0; i < numWritableSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlySignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY_SIGNER,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < numWritableNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.WRITABLE,\n        });\n        accountIndex++;\n    }\n\n    for (let i = 0; i < header.numReadonlyNonSignerAccounts; i++) {\n        accountMetas.push({\n            address: message.staticAccounts[accountIndex],\n            role: AccountRole.READONLY,\n        });\n        accountIndex++;\n    }\n\n    return accountMetas;\n}\n\nfunction getAddressLookupMetas(\n    compiledAddressTableLookups: ReturnType<typeof getCompiledAddressTableLookups>,\n    addressesByLookupTableAddress: AddressesByLookupTableAddress,\n): AccountLookupMeta[] {\n    // check that all message lookups are known\n    const compiledAddressTableLookupAddresses = compiledAddressTableLookups.map(l => l.lookupTableAddress);\n    const missing = compiledAddressTableLookupAddresses.filter(a => addressesByLookupTableAddress[a] === undefined);\n    if (missing.length > 0) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING, {\n            lookupTableAddresses: missing,\n        });\n    }\n\n    const readOnlyMetas: AccountLookupMeta[] = [];\n    const writableMetas: AccountLookupMeta[] = [];\n\n    // we know that for each lookup, knownLookups[lookup.lookupTableAddress] is defined\n    for (const lookup of compiledAddressTableLookups) {\n        const addresses = addressesByLookupTableAddress[lookup.lookupTableAddress];\n        const readonlyIndexes = lookup.readonlyIndexes;\n        const writableIndexes = lookup.writableIndexes;\n\n        const highestIndex = Math.max(...readonlyIndexes, ...writableIndexes);\n        if (highestIndex >= addresses.length) {\n            throw new SolanaError(\n                SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE,\n                {\n                    highestKnownIndex: addresses.length - 1,\n                    highestRequestedIndex: highestIndex,\n                    lookupTableAddress: lookup.lookupTableAddress,\n                },\n            );\n        }\n\n        const readOnlyForLookup: AccountLookupMeta[] = readonlyIndexes.map(r => ({\n            address: addresses[r],\n            addressIndex: r,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.READONLY,\n        }));\n        readOnlyMetas.push(...readOnlyForLookup);\n\n        const writableForLookup: AccountLookupMeta[] = writableIndexes.map(w => ({\n            address: addresses[w],\n            addressIndex: w,\n            lookupTableAddress: lookup.lookupTableAddress,\n            role: AccountRole.WRITABLE,\n        }));\n        writableMetas.push(...writableForLookup);\n    }\n\n    return [...writableMetas, ...readOnlyMetas];\n}\n\nfunction convertInstruction(\n    instruction: CompiledTransactionMessage['instructions'][0],\n    accountMetas: AccountMeta[],\n): Instruction {\n    const programAddress = accountMetas[instruction.programAddressIndex]?.address;\n    if (!programAddress) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND, {\n            index: instruction.programAddressIndex,\n        });\n    }\n\n    const accounts = instruction.accountIndices?.map(accountIndex => accountMetas[accountIndex]);\n    const { data } = instruction;\n\n    return Object.freeze({\n        programAddress,\n        ...(accounts && accounts.length ? { accounts: Object.freeze(accounts) } : {}),\n        ...(data && data.length ? { data } : {}),\n    });\n}\n\ntype LifetimeConstraint =\n    | {\n          blockhash: Blockhash;\n          lastValidBlockHeight: bigint;\n      }\n    | {\n          nonce: Nonce;\n          nonceAccountAddress: Address;\n          nonceAuthorityAddress: Address;\n      };\n\nfunction getLifetimeConstraint(\n    messageLifetimeToken: string,\n    firstInstruction?: Instruction,\n    lastValidBlockHeight?: bigint,\n): LifetimeConstraint {\n    if (!firstInstruction || !isAdvanceNonceAccountInstruction(firstInstruction)) {\n        // first instruction is not advance durable nonce, so use blockhash lifetime constraint\n        return {\n            blockhash: messageLifetimeToken as Blockhash,\n            lastValidBlockHeight: lastValidBlockHeight ?? 2n ** 64n - 1n, // U64 MAX\n        };\n    } else {\n        // We know these accounts are defined because we checked `isAdvanceNonceAccountInstruction`\n        const nonceAccountAddress = firstInstruction.accounts[0].address;\n        assertIsAddress(nonceAccountAddress);\n\n        const nonceAuthorityAddress = firstInstruction.accounts[2].address;\n        assertIsAddress(nonceAuthorityAddress);\n\n        return {\n            nonce: messageLifetimeToken as Nonce,\n            nonceAccountAddress,\n            nonceAuthorityAddress,\n        };\n    }\n}\n\nexport type DecompileTransactionMessageConfig = {\n    /**\n     * If the compiled message loads addresses from one or more address lookup tables, you will have\n     * to supply a map of those tables to an array of the addresses they contained at the time that\n     * the transaction message was constructed.\n     *\n     * @see {@link decompileTransactionMessageFetchingLookupTables} if you do not already have this.\n     */\n    addressesByLookupTableAddress?: AddressesByLookupTableAddress;\n    /**\n     * If the compiled message has a blockhash-based lifetime constraint, you will have to supply\n     * the block height after which that blockhash is no longer valid for use as a lifetime\n     * constraint.\n     */\n    lastValidBlockHeight?: bigint;\n};\n\n/**\n * Converts the type of transaction message data structure appropriate for execution on the network\n * to the type of transaction message data structure designed for use in your application.\n *\n * Because compilation is a lossy process, you can not fully reconstruct a source message from a\n * compiled message without extra information. In order to faithfully reconstruct the original\n * source message you will need to supply supporting details about the lifetime constraint and the\n * concrete addresses of any accounts sourced from account lookup tables.\n *\n * @see {@link compileTransactionMessage}\n */\nexport function decompileTransactionMessage(\n    compiledTransactionMessage: CompiledTransactionMessage & CompiledTransactionMessageWithLifetime,\n    config?: DecompileTransactionMessageConfig,\n): BaseTransactionMessage & TransactionMessageWithFeePayer & TransactionMessageWithLifetime {\n    const feePayer = compiledTransactionMessage.staticAccounts[0];\n    if (!feePayer) {\n        throw new SolanaError(SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING);\n    }\n\n    const accountMetas = getAccountMetas(compiledTransactionMessage);\n    const accountLookupMetas =\n        'addressTableLookups' in compiledTransactionMessage &&\n        compiledTransactionMessage.addressTableLookups !== undefined &&\n        compiledTransactionMessage.addressTableLookups.length > 0\n            ? getAddressLookupMetas(\n                  compiledTransactionMessage.addressTableLookups,\n                  config?.addressesByLookupTableAddress ?? {},\n              )\n            : [];\n    const transactionMetas = [...accountMetas, ...accountLookupMetas];\n\n    const instructions: Instruction[] = compiledTransactionMessage.instructions.map(compiledInstruction =>\n        convertInstruction(compiledInstruction, transactionMetas),\n    );\n\n    const firstInstruction = instructions[0];\n    const lifetimeConstraint = getLifetimeConstraint(\n        compiledTransactionMessage.lifetimeToken,\n        firstInstruction,\n        config?.lastValidBlockHeight,\n    );\n\n    return pipe(\n        createTransactionMessage({ version: compiledTransactionMessage.version as TransactionVersion }),\n        m => setTransactionMessageFeePayer(feePayer, m),\n        m =>\n            instructions.reduce(\n                (acc, instruction) => appendTransactionMessageInstruction(instruction, acc),\n                m as BaseTransactionMessage & TransactionMessageWithFeePayer,\n            ),\n        m =>\n            'blockhash' in lifetimeConstraint\n                ? setTransactionMessageLifetimeUsingBlockhash(lifetimeConstraint, m)\n                : setTransactionMessageLifetimeUsingDurableNonce(lifetimeConstraint, m),\n    );\n}\n","import { isAddress, assertIsAddress, getAddressEncoder, getAddressDecoder } from '@solana/addresses';\nimport { createEncoder, combineCodec, transformDecoder } from '@solana/codecs-core';\nimport { isSolanaError, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE, SolanaError, SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH, SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH, SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE, SOLANA_ERROR__MALFORMED_BIGINT_STRING, SOLANA_ERROR__MALFORMED_NUMBER_STRING, SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE } from '@solana/errors';\nimport { getU64Encoder, getU64Decoder } from '@solana/codecs-numbers';\n\n// src/blockhash.ts\nfunction isBlockhash(putativeBlockhash) {\n  return isAddress(putativeBlockhash);\n}\nfunction assertIsBlockhash(putativeBlockhash) {\n  try {\n    assertIsAddress(putativeBlockhash);\n  } catch (error) {\n    if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE)) {\n      throw new SolanaError(SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE, error.context);\n    }\n    if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH)) {\n      throw new SolanaError(SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH, error.context);\n    }\n    throw error;\n  }\n}\nfunction blockhash(putativeBlockhash) {\n  assertIsBlockhash(putativeBlockhash);\n  return putativeBlockhash;\n}\nfunction getBlockhashEncoder() {\n  const addressEncoder = getAddressEncoder();\n  return createEncoder({\n    fixedSize: 32,\n    write: (value, bytes, offset) => {\n      assertIsBlockhash(value);\n      return addressEncoder.write(value, bytes, offset);\n    }\n  });\n}\nfunction getBlockhashDecoder() {\n  return getAddressDecoder();\n}\nfunction getBlockhashCodec() {\n  return combineCodec(getBlockhashEncoder(), getBlockhashDecoder());\n}\nfunction getBlockhashComparator() {\n  return new Intl.Collator(\"en\", {\n    caseFirst: \"lower\",\n    ignorePunctuation: false,\n    localeMatcher: \"best fit\",\n    numeric: false,\n    sensitivity: \"variant\",\n    usage: \"sort\"\n  }).compare;\n}\n\n// src/cluster-url.ts\nfunction mainnet(putativeString) {\n  return putativeString;\n}\nfunction devnet(putativeString) {\n  return putativeString;\n}\nfunction testnet(putativeString) {\n  return putativeString;\n}\nfunction getCommitmentScore(commitment) {\n  switch (commitment) {\n    case \"finalized\":\n      return 2;\n    case \"confirmed\":\n      return 1;\n    case \"processed\":\n      return 0;\n    default:\n      throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n        unexpectedValue: commitment\n      });\n  }\n}\nfunction commitmentComparator(a, b) {\n  if (a === b) {\n    return 0;\n  }\n  return getCommitmentScore(a) < getCommitmentScore(b) ? -1 : 1;\n}\nvar maxU64Value = 18446744073709551615n;\nvar memoizedU64Encoder;\nvar memoizedU64Decoder;\nfunction getMemoizedU64Encoder() {\n  if (!memoizedU64Encoder) memoizedU64Encoder = getU64Encoder();\n  return memoizedU64Encoder;\n}\nfunction getMemoizedU64Decoder() {\n  if (!memoizedU64Decoder) memoizedU64Decoder = getU64Decoder();\n  return memoizedU64Decoder;\n}\nfunction isLamports(putativeLamports) {\n  return putativeLamports >= 0 && putativeLamports <= maxU64Value;\n}\nfunction assertIsLamports(putativeLamports) {\n  if (putativeLamports < 0 || putativeLamports > maxU64Value) {\n    throw new SolanaError(SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE);\n  }\n}\nfunction lamports(putativeLamports) {\n  assertIsLamports(putativeLamports);\n  return putativeLamports;\n}\nfunction getDefaultLamportsEncoder() {\n  return getLamportsEncoder(getMemoizedU64Encoder());\n}\nfunction getLamportsEncoder(innerEncoder) {\n  return innerEncoder;\n}\nfunction getDefaultLamportsDecoder() {\n  return getLamportsDecoder(getMemoizedU64Decoder());\n}\nfunction getLamportsDecoder(innerDecoder) {\n  return transformDecoder(\n    innerDecoder,\n    (value) => lamports(typeof value === \"bigint\" ? value : BigInt(value))\n  );\n}\nfunction getDefaultLamportsCodec() {\n  return combineCodec(getDefaultLamportsEncoder(), getDefaultLamportsDecoder());\n}\nfunction getLamportsCodec(innerCodec) {\n  return combineCodec(getLamportsEncoder(innerCodec), getLamportsDecoder(innerCodec));\n}\nfunction isStringifiedBigInt(putativeBigInt) {\n  try {\n    BigInt(putativeBigInt);\n    return true;\n  } catch {\n    return false;\n  }\n}\nfunction assertIsStringifiedBigInt(putativeBigInt) {\n  try {\n    BigInt(putativeBigInt);\n  } catch {\n    throw new SolanaError(SOLANA_ERROR__MALFORMED_BIGINT_STRING, {\n      value: putativeBigInt\n    });\n  }\n}\nfunction stringifiedBigInt(putativeBigInt) {\n  assertIsStringifiedBigInt(putativeBigInt);\n  return putativeBigInt;\n}\nfunction isStringifiedNumber(putativeNumber) {\n  return !Number.isNaN(Number(putativeNumber));\n}\nfunction assertIsStringifiedNumber(putativeNumber) {\n  if (Number.isNaN(Number(putativeNumber))) {\n    throw new SolanaError(SOLANA_ERROR__MALFORMED_NUMBER_STRING, {\n      value: putativeNumber\n    });\n  }\n}\nfunction stringifiedNumber(putativeNumber) {\n  assertIsStringifiedNumber(putativeNumber);\n  return putativeNumber;\n}\nvar maxI64Value = 9223372036854775807n;\nvar minI64Value = -9223372036854775808n;\nfunction isUnixTimestamp(putativeTimestamp) {\n  return putativeTimestamp >= minI64Value && putativeTimestamp <= maxI64Value;\n}\nfunction assertIsUnixTimestamp(putativeTimestamp) {\n  if (putativeTimestamp < minI64Value || putativeTimestamp > maxI64Value) {\n    throw new SolanaError(SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, {\n      value: putativeTimestamp\n    });\n  }\n}\nfunction unixTimestamp(putativeTimestamp) {\n  assertIsUnixTimestamp(putativeTimestamp);\n  return putativeTimestamp;\n}\n\nexport { assertIsBlockhash, assertIsLamports, assertIsStringifiedBigInt, assertIsStringifiedNumber, assertIsUnixTimestamp, blockhash, commitmentComparator, devnet, getBlockhashCodec, getBlockhashComparator, getBlockhashDecoder, getBlockhashEncoder, getDefaultLamportsCodec, getDefaultLamportsDecoder, getDefaultLamportsEncoder, getLamportsCodec, getLamportsDecoder, getLamportsEncoder, isBlockhash, isLamports, isStringifiedBigInt, isStringifiedNumber, isUnixTimestamp, lamports, mainnet, stringifiedBigInt, stringifiedNumber, testnet, unixTimestamp };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","import { Address, assertIsAddress, getAddressDecoder, getAddressEncoder, isAddress } from '@solana/addresses';\nimport { combineCodec, createEncoder, FixedSizeCodec, FixedSizeDecoder, FixedSizeEncoder } from '@solana/codecs-core';\nimport {\n    isSolanaError,\n    SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE,\n    SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH,\n    SolanaError,\n} from '@solana/errors';\nimport { Brand, EncodedString } from '@solana/nominal-types';\n\nexport type Blockhash = Brand<EncodedString<string, 'base58'>, 'Blockhash'>;\n\n/**\n * A type guard that returns `true` if the input string conforms to the {@link Blockhash} type, and\n * refines its type for use in your program.\n *\n * @example\n * ```ts\n * import { isBlockhash } from '@solana/rpc-types';\n *\n * if (isBlockhash(blockhash)) {\n *     // At this point, `blockhash` has been refined to a\n *     // `Blockhash` that can be used with the RPC.\n *     const { value: isValid } = await rpc.isBlockhashValid(blockhash).send();\n *     setBlockhashIsFresh(isValid);\n * } else {\n *     setError(`${blockhash} is not a blockhash`);\n * }\n * ```\n */\nexport function isBlockhash(putativeBlockhash: string): putativeBlockhash is Blockhash {\n    return isAddress(putativeBlockhash);\n}\n\n/**\n * From time to time you might acquire a string, that you expect to validate as a blockhash, from an\n * untrusted network API or user input. Use this function to assert that such an arbitrary string is\n * a base58-encoded blockhash.\n *\n * @example\n * ```ts\n * import { assertIsBlockhash } from '@solana/rpc-types';\n *\n * // Imagine a function that determines whether a blockhash is fresh when a user submits a form.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `string` type.\n *     const blockhash: string = blockhashInput.value;\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `blockhash` to `Blockhash`.\n *         assertIsBlockhash(blockhash);\n *         // At this point, `blockhash` is a `Blockhash` that can be used with the RPC.\n *         const { value: isValid } = await rpc.isBlockhashValid(blockhash).send();\n *     } catch (e) {\n *         // `blockhash` turned out not to be a base58-encoded blockhash\n *     }\n * }\n * ```\n */\nexport function assertIsBlockhash(putativeBlockhash: string): asserts putativeBlockhash is Blockhash {\n    try {\n        assertIsAddress(putativeBlockhash);\n    } catch (error) {\n        if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE)) {\n            throw new SolanaError(SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE, error.context);\n        }\n        if (isSolanaError(error, SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH)) {\n            throw new SolanaError(SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH, error.context);\n        }\n        throw error;\n    }\n}\n\n/**\n * Combines _asserting_ that a string is a blockhash with _coercing_ it to the {@link Blockhash}\n * type. It's most useful with untrusted input.\n *\n * @example\n * ```ts\n * import { blockhash } from '@solana/rpc-types';\n *\n * const { value: isValid } = await rpc.isBlockhashValid(blockhash(blockhashFromUserInput)).send();\n * ```\n *\n * > [!TIP]\n * > When starting from a known-good blockhash as a string, it's more efficient to typecast it\n * rather than to use the {@link blockhash} helper, because the helper unconditionally performs\n * validation on its input.\n * >\n * > ```ts\n * > import { Blockhash } from '@solana/rpc-types';\n * >\n * > const blockhash = 'ABmPH5KDXX99u6woqFS5vfBGSNyKG42SzpvBMWWqAy48' as Blockhash;\n * > ```\n */\nexport function blockhash(putativeBlockhash: string): Blockhash {\n    assertIsBlockhash(putativeBlockhash);\n    return putativeBlockhash;\n}\n\n/**\n * Returns an encoder that you can use to encode a base58-encoded blockhash to a byte array.\n *\n * @example\n * ```ts\n * import { getBlockhashEncoder } from '@solana/rpc-types';\n *\n * const blockhash = 'ABmPH5KDXX99u6woqFS5vfBGSNyKG42SzpvBMWWqAy48' as Blockhash;\n * const blockhashEncoder = getBlockhashEncoder();\n * const blockhashBytes = blockhashEncoder.encode(blockhash);\n * // Uint8Array(32) [\n * //   136, 123,  44, 249,  43,  19,  60,  14,\n * //   144,  16, 168, 241, 121, 111,  70, 232,\n * //   186,  26, 140, 202, 213,  64, 231,  82,\n * //   179,  66, 103, 237,  52, 117, 217,  93\n * // ]\n * ```\n */\nexport function getBlockhashEncoder(): FixedSizeEncoder<Blockhash, 32> {\n    const addressEncoder = getAddressEncoder();\n    return createEncoder({\n        fixedSize: 32,\n        write: (value: string, bytes, offset) => {\n            assertIsBlockhash(value);\n            return addressEncoder.write(value as string as Address, bytes, offset);\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to convert an array of 32 bytes representing a blockhash to\n * the base58-encoded representation of that blockhash.\n *\n * @example\n * ```ts\n * import { getBlockhashDecoder } from '@solana/rpc-types';\n *\n * const blockhashBytes = new Uint8Array([\n *     136, 123,  44, 249,  43,  19,  60,  14,\n *     144,  16, 168, 241, 121, 111,  70, 232,\n *     186,  26, 140, 202, 213,  64, 231,  82,\n *     179,  66, 103, 237,  52, 117, 217,  93\n * ]);\n * const blockhashDecoder = getBlockhashDecoder();\n * const blockhash = blockhashDecoder.decode(blockhashBytes); // ABmPH5KDXX99u6woqFS5vfBGSNyKG42SzpvBMWWqAy48\n * ```\n */\nexport function getBlockhashDecoder(): FixedSizeDecoder<Blockhash, 32> {\n    return getAddressDecoder() as FixedSizeDecoder<string, 32> as FixedSizeDecoder<Blockhash, 32>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a base-58 encoded blockhash.\n *\n * @see {@link getBlockhashDecoder}\n * @see {@link getBlockhashEncoder}\n */\nexport function getBlockhashCodec(): FixedSizeCodec<Blockhash, Blockhash, 32> {\n    return combineCodec(getBlockhashEncoder(), getBlockhashDecoder());\n}\n\nexport function getBlockhashComparator(): (x: string, y: string) => number {\n    return new Intl.Collator('en', {\n        caseFirst: 'lower',\n        ignorePunctuation: false,\n        localeMatcher: 'best fit',\n        numeric: false,\n        sensitivity: 'variant',\n        usage: 'sort',\n    }).compare;\n}\n","export type MainnetUrl = string & { '~cluster': 'mainnet' };\nexport type DevnetUrl = string & { '~cluster': 'devnet' };\nexport type TestnetUrl = string & { '~cluster': 'testnet' };\nexport type ClusterUrl = DevnetUrl | MainnetUrl | TestnetUrl | string;\n\n/** Given a URL casts it to a type that is only accepted where mainnet URLs are expected. */\nexport function mainnet(putativeString: string): MainnetUrl {\n    return putativeString as MainnetUrl;\n}\n/** Given a URL casts it to a type that is only accepted where devnet URLs are expected. */\nexport function devnet(putativeString: string): DevnetUrl {\n    return putativeString as DevnetUrl;\n}\n/** Given a URL casts it to a type that is only accepted where testnet URLs are expected. */\nexport function testnet(putativeString: string): TestnetUrl {\n    return putativeString as TestnetUrl;\n}\n","import { SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, SolanaError } from '@solana/errors';\n\n/**\n * A union of all possible commitment statuses -- each a measure of the network confirmation and\n * stake levels on a particular block.\n *\n * Read more about the statuses themselves, [here](https://docs.solana.com/cluster/commitments).\n */\nexport type Commitment = 'confirmed' | 'finalized' | 'processed';\n\nfunction getCommitmentScore(commitment: Commitment): number {\n    switch (commitment) {\n        case 'finalized':\n            return 2;\n        case 'confirmed':\n            return 1;\n        case 'processed':\n            return 0;\n        default:\n            throw new SolanaError(SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE, {\n                unexpectedValue: commitment satisfies never,\n            });\n    }\n}\n\nexport function commitmentComparator(a: Commitment, b: Commitment): -1 | 0 | 1 {\n    if (a === b) {\n        return 0;\n    }\n    return getCommitmentScore(a) < getCommitmentScore(b) ? -1 : 1;\n}\n","import {\n    Codec,\n    combineCodec,\n    Decoder,\n    Encoder,\n    FixedSizeCodec,\n    FixedSizeDecoder,\n    FixedSizeEncoder,\n    transformDecoder,\n} from '@solana/codecs-core';\nimport { getU64Decoder, getU64Encoder, NumberCodec, NumberDecoder, NumberEncoder } from '@solana/codecs-numbers';\nimport { SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * Represents an integer value denominated in Lamports (ie. $1 \\times 10^{-9}$ ).\n *\n * It is represented as a `bigint` in client code and an `u64` in server code.\n */\nexport type Lamports = Brand<bigint, 'Lamports'>;\n\n// Largest possible value to be represented by a u64\nconst maxU64Value = 18446744073709551615n; // 2n ** 64n - 1n\n\nlet memoizedU64Encoder: FixedSizeEncoder<bigint | number, 8> | undefined;\nlet memoizedU64Decoder: FixedSizeDecoder<bigint, 8> | undefined;\n\nfunction getMemoizedU64Encoder(): FixedSizeEncoder<bigint | number, 8> {\n    if (!memoizedU64Encoder) memoizedU64Encoder = getU64Encoder();\n    return memoizedU64Encoder;\n}\n\nfunction getMemoizedU64Decoder(): FixedSizeDecoder<bigint, 8> {\n    if (!memoizedU64Decoder) memoizedU64Decoder = getU64Decoder();\n    return memoizedU64Decoder;\n}\n\n/**\n * This is a type guard that accepts a `bigint` as input. It will both return `true` if the integer\n * conforms to the {@link Lamports} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isLamports } from '@solana/rpc-types';\n *\n * if (isLamports(lamports)) {\n *     // At this point, `lamports` has been refined to a\n *     // `Lamports` that can be used anywhere Lamports are expected.\n *     await transfer(fromAddress, toAddress, lamports);\n * } else {\n *     setError(`${lamports} is not a quantity of Lamports`);\n * }\n * ```\n */\nexport function isLamports(putativeLamports: bigint): putativeLamports is Lamports {\n    return putativeLamports >= 0 && putativeLamports <= maxU64Value;\n}\n\n/**\n * Lamport values returned from the RPC API conform to the type {@link Lamports}. You can use a\n * value of that type wherever a quantity of Lamports is expected.\n *\n * @example\n * From time to time you might acquire a number that you expect to be a quantity of Lamports, from\n * an untrusted network API or user input. To assert that such an arbitrary number is usable as a\n * quantity of Lamports, use this function.\n *\n * ```ts\n * import { assertIsLamports } from '@solana/rpc-types';\n *\n * // Imagine a function that creates a transfer instruction when a user submits a form.\n * function handleSubmit() {\n *     // We know only that what the user typed conforms to the `number` type.\n *     const lamports: number = parseInt(quantityInput.value, 10);\n *     try {\n *         // If this type assertion function doesn't throw, then\n *         // Typescript will upcast `lamports` to `Lamports`.\n *         assertIsLamports(lamports);\n *         // At this point, `lamports` is a `Lamports` that can be used anywhere Lamports are expected.\n *         await transfer(fromAddress, toAddress, lamports);\n *     } catch (e) {\n *         // `lamports` turned out not to validate as a quantity of Lamports.\n *     }\n * }\n * ```\n */\nexport function assertIsLamports(putativeLamports: bigint): asserts putativeLamports is Lamports {\n    if (putativeLamports < 0 || putativeLamports > maxU64Value) {\n        throw new SolanaError(SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE);\n    }\n}\n\n/**\n * This helper combines _asserting_ that a number is a possible number of {@link Lamports} with\n * _coercing_ it to the {@link Lamports} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { lamports } from '@solana/rpc-types';\n *\n * await transfer(address(fromAddress), address(toAddress), lamports(100000n));\n * ```\n */\nexport function lamports(putativeLamports: bigint): Lamports {\n    assertIsLamports(putativeLamports);\n    return putativeLamports;\n}\n\ntype ExtractAdditionalProps<T, U> = Omit<T, keyof U>;\n\n/**\n * Returns an encoder that you can use to encode a 64-bit {@link Lamports} value to 8 bytes in\n * little endian order.\n */\nexport function getDefaultLamportsEncoder(): FixedSizeEncoder<Lamports, 8> {\n    return getLamportsEncoder(getMemoizedU64Encoder());\n}\n\n/**\n * Returns an encoder that you can use to encode a {@link Lamports} value to a byte array.\n *\n * You must supply a number decoder that will determine how encode the numeric value.\n *\n * @example\n * ```ts\n * import { getLamportsEncoder } from '@solana/rpc-types';\n * import { getU16Encoder } from '@solana/codecs-numbers';\n *\n * const lamports = lamports(256n);\n * const lamportsEncoder = getLamportsEncoder(getU16Encoder());\n * const lamportsBytes = lamportsEncoder.encode(lamports);\n * // Uint8Array(2) [ 0, 1 ]\n * ```\n */\nexport function getLamportsEncoder<TEncoder extends NumberEncoder>(\n    innerEncoder: TEncoder,\n): Encoder<Lamports> & ExtractAdditionalProps<TEncoder, NumberEncoder> {\n    return innerEncoder;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing a 64-bit little endian\n * number to a {@link Lamports} value.\n */\nexport function getDefaultLamportsDecoder(): FixedSizeDecoder<Lamports, 8> {\n    return getLamportsDecoder(getMemoizedU64Decoder());\n}\n\n/**\n * Returns a decoder that you can use to convert an array of bytes representing a number to a\n * {@link Lamports} value.\n *\n * You must supply a number decoder that will determine how many bits to use to decode the numeric\n * value.\n *\n * @example\n * ```ts\n * import { getLamportsDecoder } from '@solana/rpc-types';\n * import { getU16Decoder } from '@solana/codecs-numbers';\n *\n * const lamportsBytes = new Uint8Array([ 0, 1 ]);\n * const lamportsDecoder = getLamportsDecoder(getU16Decoder());\n * const lamports = lamportsDecoder.decode(lamportsBytes); // lamports(256n)\n * ```\n */\nexport function getLamportsDecoder<TDecoder extends NumberDecoder>(\n    innerDecoder: TDecoder,\n): Decoder<Lamports> & ExtractAdditionalProps<TDecoder, NumberDecoder> {\n    return transformDecoder<bigint | number, Lamports>(innerDecoder, value =>\n        lamports(typeof value === 'bigint' ? value : BigInt(value)),\n    ) as Decoder<Lamports> & ExtractAdditionalProps<TDecoder, NumberDecoder>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to a 64-bit {@link Lamports} value.\n *\n * @see {@link getDefaultLamportsDecoder}\n * @see {@link getDefaultLamportsEncoder}\n */\nexport function getDefaultLamportsCodec(): FixedSizeCodec<Lamports, Lamports, 8> {\n    return combineCodec(getDefaultLamportsEncoder(), getDefaultLamportsDecoder());\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link Lamports} value.\n *\n * @see {@link getLamportsDecoder}\n * @see {@link getLamportsEncoder}\n */\nexport function getLamportsCodec<TCodec extends NumberCodec>(\n    innerCodec: TCodec,\n): Codec<Lamports, Lamports> & ExtractAdditionalProps<TCodec, NumberCodec> {\n    return combineCodec(getLamportsEncoder(innerCodec), getLamportsDecoder(innerCodec)) as Codec<Lamports, Lamports> &\n        ExtractAdditionalProps<TCodec, NumberCodec>;\n}\n","import { SOLANA_ERROR__MALFORMED_BIGINT_STRING, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * This type represents a `bigint` which has been encoded as a string for transit over a transport\n * that does not support `bigint` values natively. The JSON-RPC is such a transport.\n */\nexport type StringifiedBigInt = Brand<string, 'StringifiedBigInt'>;\n\n/**\n * A type guard that returns `true` if the input string parses as a `BigInt`, and refines its type\n * for use in your program.\n *\n * @example\n * ```ts\n * import { isStringifiedBigInt } from '@solana/rpc-types';\n *\n * if (isStringifiedBigInt(bigintString)) {\n *     // At this point, `bigintString` has been refined to a `StringifiedBigInt`\n *     bigintString satisfies StringifiedBigInt; // OK\n * } else {\n *     setError(`${bigintString} does not represent a BigInt`);\n * }\n * ```\n */\nexport function isStringifiedBigInt(putativeBigInt: string): putativeBigInt is StringifiedBigInt {\n    try {\n        BigInt(putativeBigInt);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\n/**\n * From time to time you might acquire a string, that you expect to parse as a `BigInt`, from an\n * untrusted network API or user input. Use this function to assert that such an arbitrary string\n * will in fact parse as a `BigInt`.\n *\n * @example\n * ```ts\n * import { assertIsStringifiedBigInt } from '@solana/rpc-types';\n *\n * // Imagine having received a value that you presume represents the supply of some token.\n * // At this point we know only that it conforms to the `string` type.\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `supplyString` to `StringifiedBigInt`.\n *     assertIsStringifiedBigInt(supplyString);\n *     // At this point, `supplyString` is a `StringifiedBigInt`.\n *     supplyString satisfies StringifiedBigInt;\n * } catch (e) {\n *     // `supplyString` turned out not to parse as a `BigInt`\n * }\n * ```\n */\nexport function assertIsStringifiedBigInt(putativeBigInt: string): asserts putativeBigInt is StringifiedBigInt {\n    try {\n        BigInt(putativeBigInt);\n    } catch {\n        throw new SolanaError(SOLANA_ERROR__MALFORMED_BIGINT_STRING, {\n            value: putativeBigInt,\n        });\n    }\n}\n\n/**\n * This helper combines _asserting_ that a string will parse as a `BigInt` with _coercing_ it to the\n * {@link StringifiedBigInt} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { stringifiedBigInt } from '@solana/rpc-types';\n *\n * const supplyString = stringifiedBigInt('1000000000');\n * ```\n */\nexport function stringifiedBigInt(putativeBigInt: string): StringifiedBigInt {\n    assertIsStringifiedBigInt(putativeBigInt);\n    return putativeBigInt;\n}\n","import { SOLANA_ERROR__MALFORMED_NUMBER_STRING, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * This type represents a number which has been encoded as a string for transit over a transport\n * where loss of precision when using the native number type is a concern. The JSON-RPC is such a\n * transport.\n */\nexport type StringifiedNumber = Brand<string, 'StringifiedNumber'>;\n\n/**\n * A type guard that returns `true` if the input string parses as a `Number`, and refines its type\n * for use in your program.\n *\n * @example\n * ```ts\n * import { isStringifiedNumber } from '@solana/rpc-types';\n *\n * if (isStringifiedNumber(numericString)) {\n *     // At this point, `numericString` has been refined to a `StringifiedNumber`\n *     numericString satisfies StringifiedNumber; // OK\n * } else {\n *     setError(`${numericString} does not represent a number`);\n * }\n * ```\n */\nexport function isStringifiedNumber(putativeNumber: string): putativeNumber is StringifiedNumber {\n    return !Number.isNaN(Number(putativeNumber));\n}\n\n/**\n * From time to time you might acquire a string, that you expect to parse as a `Number`, from an\n * untrusted network API or user input. Use this function to assert that such an arbitrary string\n * will in fact parse as a `Number`.\n *\n * @example\n * ```ts\n * import { assertIsStringifiedNumber } from '@solana/rpc-types';\n *\n * // Imagine having received a value that you presume represents some decimal number.\n * // At this point we know only that it conforms to the `string` type.\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `decimalNumberString` to `StringifiedNumber`.\n *     assertIsStringifiedNumber(decimalNumberString);\n *     // At this point, `decimalNumberString` is a `StringifiedNumber`.\n *     decimalNumberString satisfies StringifiedNumber;\n * } catch (e) {\n *     // `decimalNumberString` turned out not to parse as a number.\n * }\n * ```\n */\nexport function assertIsStringifiedNumber(putativeNumber: string): asserts putativeNumber is StringifiedNumber {\n    if (Number.isNaN(Number(putativeNumber))) {\n        throw new SolanaError(SOLANA_ERROR__MALFORMED_NUMBER_STRING, {\n            value: putativeNumber,\n        });\n    }\n}\n\n/**\n * This helper combines _asserting_ that a string will parse as a `Number` with _coercing_ it to the\n * {@link StringifiedNumber} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { stringifiedNumber } from '@solana/rpc-types';\n *\n * const decimalNumberString = stringifiedNumber('-42.1');\n * ```\n */\nexport function stringifiedNumber(putativeNumber: string): StringifiedNumber {\n    assertIsStringifiedNumber(putativeNumber);\n    return putativeNumber;\n}\n","import { SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, SolanaError } from '@solana/errors';\nimport { Brand } from '@solana/nominal-types';\n\n/**\n * This type represents a Unix timestamp in _seconds_.\n *\n * It is represented as a `bigint` in client code and an `i64` in server code.\n */\nexport type UnixTimestamp = Brand<bigint, 'UnixTimestamp'>;\n\n// Largest possible value to be represented by an i64\nconst maxI64Value = 9223372036854775807n; // 2n ** 63n - 1n\nconst minI64Value = -9223372036854775808n; // -(2n ** 63n)\n\n/**\n * This is a type guard that accepts a `bigint` as input. It will both return `true` if the integer\n * conforms to the {@link UnixTimestamp} type and will refine the type for use in your program.\n *\n * @example\n * ```ts\n * import { isUnixTimestamp } from '@solana/rpc-types';\n *\n * if (isUnixTimestamp(timestamp)) {\n *     // At this point, `timestamp` has been refined to a\n *     // `UnixTimestamp` that can be used anywhere timestamps are expected.\n *     timestamp satisfies UnixTimestamp;\n * } else {\n *     setError(`${timestamp} is not a Unix timestamp`);\n * }\n * ```\n */\n\nexport function isUnixTimestamp(putativeTimestamp: bigint): putativeTimestamp is UnixTimestamp {\n    return putativeTimestamp >= minI64Value && putativeTimestamp <= maxI64Value;\n}\n\n/**\n * Timestamp values returned from the RPC API conform to the type {@link UnixTimestamp}. You can use\n * a value of that type wherever a timestamp is expected.\n *\n * @example\n * From time to time you might acquire a number that you expect to be a timestamp, from an untrusted\n * network API or user input. To assert that such an arbitrary number is usable as a Unix timestamp,\n * use this function.\n *\n * ```ts\n * import { assertIsUnixTimestamp } from '@solana/rpc-types';\n *\n * // Imagine having received a value that you presume represents a timestamp.\n * // At this point we know only that it conforms to the `bigint` type.\n * try {\n *     // If this type assertion function doesn't throw, then\n *     // Typescript will upcast `timestamp` to `UnixTimestamp`.\n *     assertIsUnixTimestamp(timestamp);\n *     // At this point, `timestamp` is a `UnixTimestamp`.\n *     timestamp satisfies UnixTimestamp;\n * } catch (e) {\n *     // `timestamp` turned out not to be a valid Unix timestamp\n * }\n * ```\n */\nexport function assertIsUnixTimestamp(putativeTimestamp: bigint): asserts putativeTimestamp is UnixTimestamp {\n    if (putativeTimestamp < minI64Value || putativeTimestamp > maxI64Value) {\n        throw new SolanaError(SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE, {\n            value: putativeTimestamp,\n        });\n    }\n}\n\n/**\n * This helper combines _asserting_ that a `bigint` represents a Unix timestamp with _coercing_ it\n * to the {@link UnixTimestamp} type. It's best used with untrusted input.\n *\n * @example\n * ```ts\n * import { unixTimestamp } from '@solana/rpc-types';\n *\n * const timestamp = unixTimestamp(-42n); // Wednesday, December 31, 1969 3:59:18 PM GMT-08:00\n * ```\n */\nexport function unixTimestamp(putativeTimestamp: bigint): UnixTimestamp {\n    assertIsUnixTimestamp(putativeTimestamp);\n    return putativeTimestamp;\n}\n","// src/pipe.ts\nfunction pipe(init, ...fns) {\n  return fns.reduce((acc, fn) => fn(acc), init);\n}\n\nexport { pipe };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","/**\n * A pipeline is a solution that allows you to perform successive transforms of a value using functions. This is useful when building up a transaction message.\n *\n * Until the [pipeline operator](https://github.com/tc39/proposal-pipeline-operator) becomes part of JavaScript you can use this utility to create pipelines.\n *\n * Following common implementations of pipe functions that use TypeScript, this function supports a maximum arity of 10 for type safety.\n *\n * Note you can use nested pipes to extend this limitation, like so:\n * ```ts\n * const myValue = pipe(\n *      pipe(\n *          1,\n *          (x) => x + 1,\n *          (x) => x * 2,\n *          (x) => x - 1,\n *      ),\n *      (y) => y / 3,\n *      (y) => y + 1,\n * );\n * ```\n *\n * @see https://github.com/ramda/ramda/blob/master/source/pipe.js\n * @see https://github.com/darky/rocket-pipes/blob/master/index.ts\n *\n * @example Basic\n * ```ts\n * const add = (a, b) => a + b;\n * const add10 = x => add(x, 10);\n * const add100 = x => add(x, 100);\n * const sum = pipe(1, add10, add100);\n * sum === 111; // true\n * ```\n *\n * @example Building a Solana transaction message\n * ```ts\n * const transferTransactionMessage = pipe(\n *     // The result of the first expression...\n *     createTransactionMessage({ version: 0 }),\n *     // ...gets passed as the sole argument to the next function in the pipeline.\n *     tx => setTransactionMessageFeePayer(myAddress, tx),\n *     // The return value of that function gets passed to the next...\n *     tx => setTransactionMessageLifetimeUsingBlockhash(latestBlockhash, tx),\n *     // ...and so on.\n *     tx => appendTransactionMessageInstruction(createTransferInstruction(myAddress, toAddress, amountInLamports), tx),\n * );\n * ```\n *\n * @returns The initial value\n */\nexport function pipe<TInitial>(\n    /** The initial value */\n    init: TInitial,\n): TInitial;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n): R1;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n): R2;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n): R3;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n): R4;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n): R5;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n): R6;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n    /** The function with which to transform the return value of the prior function */\n    r6_r7: (r6: R6) => R7,\n): R7;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n    /** The function with which to transform the return value of the prior function */\n    r6_r7: (r6: R6) => R7,\n    /** The function with which to transform the return value of the prior function */\n    r7_r8: (r7: R7) => R8,\n): R8;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8, R9>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n    /** The function with which to transform the return value of the prior function */\n    r6_r7: (r6: R6) => R7,\n    /** The function with which to transform the return value of the prior function */\n    r7_r8: (r7: R7) => R8,\n    /** The function with which to transform the return value of the prior function */\n    r8_r9: (r8: R8) => R9,\n): R9;\n/**\n * @returns The return value of the final transform function\n */\nexport function pipe<TInitial, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10>(\n    /** The initial value */\n    init: TInitial,\n    /** The function with which to transform the initial value */\n    init_r1: (init: TInitial) => R1,\n    /** The function with which to transform the return value of the prior function */\n    r1_r2: (r1: R1) => R2,\n    /** The function with which to transform the return value of the prior function */\n    r2_r3: (r2: R2) => R3,\n    /** The function with which to transform the return value of the prior function */\n    r3_r4: (r3: R3) => R4,\n    /** The function with which to transform the return value of the prior function */\n    r4_r5: (r4: R4) => R5,\n    /** The function with which to transform the return value of the prior function */\n    r5_r6: (r5: R5) => R6,\n    /** The function with which to transform the return value of the prior function */\n    r6_r7: (r6: R6) => R7,\n    /** The function with which to transform the return value of the prior function */\n    r7_r8: (r7: R7) => R8,\n    /** The function with which to transform the return value of the prior function */\n    r8_r9: (r8: R8) => R9,\n    /** The function with which to transform the return value of the prior function */\n    r9_r10: (r9: R9) => R10,\n): R10;\nexport function pipe<TInitial>(init: TInitial, ...fns: CallableFunction[]) {\n    return fns.reduce((acc, fn) => fn(acc), init);\n}\n","import { fetchEncodedAccount, fetchJsonParsedAccount, assertAccountExists, decodeAccount } from '@solana/accounts';\nimport { getStructEncoder, getU64Encoder, getI64Encoder, getStructDecoder, getU64Decoder, getI64Decoder, combineCodec, getU128Encoder, getBooleanEncoder, getU128Decoder, getBooleanDecoder, getArrayEncoder, getArrayDecoder, getF64Encoder, getU8Encoder, getF64Decoder, getU8Decoder, createEncoder, createDecoder, getArrayCodec, getU64Codec } from '@solana/codecs';\nimport { getBlockhashEncoder, getDefaultLamportsEncoder, getBlockhashDecoder, getDefaultLamportsDecoder } from '@solana/rpc-types';\nimport { SolanaError, SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS } from '@solana/errors';\n\n// src/clock.ts\nvar SYSVAR_CLOCK_ADDRESS = \"SysvarC1ock11111111111111111111111111111111\";\nvar SYSVAR_EPOCH_REWARDS_ADDRESS = \"SysvarEpochRewards1111111111111111111111111\";\nvar SYSVAR_EPOCH_SCHEDULE_ADDRESS = \"SysvarEpochSchedu1e111111111111111111111111\";\nvar SYSVAR_INSTRUCTIONS_ADDRESS = \"Sysvar1nstructions1111111111111111111111111\";\nvar SYSVAR_LAST_RESTART_SLOT_ADDRESS = \"SysvarLastRestartS1ot1111111111111111111111\";\nvar SYSVAR_RECENT_BLOCKHASHES_ADDRESS = \"SysvarRecentB1ockHashes11111111111111111111\";\nvar SYSVAR_RENT_ADDRESS = \"SysvarRent111111111111111111111111111111111\";\nvar SYSVAR_SLOT_HASHES_ADDRESS = \"SysvarS1otHashes111111111111111111111111111\";\nvar SYSVAR_SLOT_HISTORY_ADDRESS = \"SysvarS1otHistory11111111111111111111111111\";\nvar SYSVAR_STAKE_HISTORY_ADDRESS = \"SysvarStakeHistory1111111111111111111111111\";\nasync function fetchEncodedSysvarAccount(rpc, address, config) {\n  return await fetchEncodedAccount(rpc, address, config);\n}\nasync function fetchJsonParsedSysvarAccount(rpc, address, config) {\n  return await fetchJsonParsedAccount(rpc, address, config);\n}\n\n// src/clock.ts\nfunction getSysvarClockEncoder() {\n  return getStructEncoder([\n    [\"slot\", getU64Encoder()],\n    [\"epochStartTimestamp\", getI64Encoder()],\n    [\"epoch\", getU64Encoder()],\n    [\"leaderScheduleEpoch\", getU64Encoder()],\n    [\"unixTimestamp\", getI64Encoder()]\n  ]);\n}\nfunction getSysvarClockDecoder() {\n  return getStructDecoder([\n    [\"slot\", getU64Decoder()],\n    [\"epochStartTimestamp\", getI64Decoder()],\n    [\"epoch\", getU64Decoder()],\n    [\"leaderScheduleEpoch\", getU64Decoder()],\n    [\"unixTimestamp\", getI64Decoder()]\n  ]);\n}\nfunction getSysvarClockCodec() {\n  return combineCodec(getSysvarClockEncoder(), getSysvarClockDecoder());\n}\nasync function fetchSysvarClock(rpc, config) {\n  const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_CLOCK_ADDRESS, config);\n  assertAccountExists(account);\n  const decoded = decodeAccount(account, getSysvarClockDecoder());\n  return decoded.data;\n}\nfunction getSysvarEpochRewardsEncoder() {\n  return getStructEncoder([\n    [\"distributionStartingBlockHeight\", getU64Encoder()],\n    [\"numPartitions\", getU64Encoder()],\n    [\"parentBlockhash\", getBlockhashEncoder()],\n    [\"totalPoints\", getU128Encoder()],\n    [\"totalRewards\", getDefaultLamportsEncoder()],\n    [\"distributedRewards\", getDefaultLamportsEncoder()],\n    [\"active\", getBooleanEncoder()]\n  ]);\n}\nfunction getSysvarEpochRewardsDecoder() {\n  return getStructDecoder([\n    [\"distributionStartingBlockHeight\", getU64Decoder()],\n    [\"numPartitions\", getU64Decoder()],\n    [\"parentBlockhash\", getBlockhashDecoder()],\n    [\"totalPoints\", getU128Decoder()],\n    [\"totalRewards\", getDefaultLamportsDecoder()],\n    [\"distributedRewards\", getDefaultLamportsDecoder()],\n    [\"active\", getBooleanDecoder()]\n  ]);\n}\nfunction getSysvarEpochRewardsCodec() {\n  return combineCodec(getSysvarEpochRewardsEncoder(), getSysvarEpochRewardsDecoder());\n}\nasync function fetchSysvarEpochRewards(rpc, config) {\n  const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_EPOCH_REWARDS_ADDRESS, config);\n  assertAccountExists(account);\n  const decoded = decodeAccount(account, getSysvarEpochRewardsDecoder());\n  return decoded.data;\n}\nfunction getSysvarEpochScheduleEncoder() {\n  return getStructEncoder([\n    [\"slotsPerEpoch\", getU64Encoder()],\n    [\"leaderScheduleSlotOffset\", getU64Encoder()],\n    [\"warmup\", getBooleanEncoder()],\n    [\"firstNormalEpoch\", getU64Encoder()],\n    [\"firstNormalSlot\", getU64Encoder()]\n  ]);\n}\nfunction getSysvarEpochScheduleDecoder() {\n  return getStructDecoder([\n    [\"slotsPerEpoch\", getU64Decoder()],\n    [\"leaderScheduleSlotOffset\", getU64Decoder()],\n    [\"warmup\", getBooleanDecoder()],\n    [\"firstNormalEpoch\", getU64Decoder()],\n    [\"firstNormalSlot\", getU64Decoder()]\n  ]);\n}\nfunction getSysvarEpochScheduleCodec() {\n  return combineCodec(getSysvarEpochScheduleEncoder(), getSysvarEpochScheduleDecoder());\n}\nasync function fetchSysvarEpochSchedule(rpc, config) {\n  const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_EPOCH_SCHEDULE_ADDRESS, config);\n  assertAccountExists(account);\n  const decoded = decodeAccount(account, getSysvarEpochScheduleDecoder());\n  return decoded.data;\n}\nfunction getSysvarLastRestartSlotEncoder() {\n  return getStructEncoder([[\"lastRestartSlot\", getU64Encoder()]]);\n}\nfunction getSysvarLastRestartSlotDecoder() {\n  return getStructDecoder([[\"lastRestartSlot\", getU64Decoder()]]);\n}\nfunction getSysvarLastRestartSlotCodec() {\n  return combineCodec(getSysvarLastRestartSlotEncoder(), getSysvarLastRestartSlotDecoder());\n}\nasync function fetchSysvarLastRestartSlot(rpc, config) {\n  const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_LAST_RESTART_SLOT_ADDRESS, config);\n  assertAccountExists(account);\n  const decoded = decodeAccount(account, getSysvarLastRestartSlotDecoder());\n  return decoded.data;\n}\nfunction getSysvarRecentBlockhashesEncoder() {\n  return getArrayEncoder(\n    getStructEncoder([\n      [\"blockhash\", getBlockhashEncoder()],\n      [\"feeCalculator\", getStructEncoder([[\"lamportsPerSignature\", getDefaultLamportsEncoder()]])]\n    ])\n  );\n}\nfunction getSysvarRecentBlockhashesDecoder() {\n  return getArrayDecoder(\n    getStructDecoder([\n      [\"blockhash\", getBlockhashDecoder()],\n      [\"feeCalculator\", getStructDecoder([[\"lamportsPerSignature\", getDefaultLamportsDecoder()]])]\n    ])\n  );\n}\nfunction getSysvarRecentBlockhashesCodec() {\n  return combineCodec(getSysvarRecentBlockhashesEncoder(), getSysvarRecentBlockhashesDecoder());\n}\nasync function fetchSysvarRecentBlockhashes(rpc, config) {\n  const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_RECENT_BLOCKHASHES_ADDRESS, config);\n  assertAccountExists(account);\n  const decoded = decodeAccount(account, getSysvarRecentBlockhashesDecoder());\n  return decoded.data;\n}\nfunction getSysvarRentEncoder() {\n  return getStructEncoder([\n    [\"lamportsPerByteYear\", getDefaultLamportsEncoder()],\n    [\"exemptionThreshold\", getF64Encoder()],\n    [\"burnPercent\", getU8Encoder()]\n  ]);\n}\nfunction getSysvarRentDecoder() {\n  return getStructDecoder([\n    [\"lamportsPerByteYear\", getDefaultLamportsDecoder()],\n    [\"exemptionThreshold\", getF64Decoder()],\n    [\"burnPercent\", getU8Decoder()]\n  ]);\n}\nfunction getSysvarRentCodec() {\n  return combineCodec(getSysvarRentEncoder(), getSysvarRentDecoder());\n}\nasync function fetchSysvarRent(rpc, config) {\n  const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_RENT_ADDRESS, config);\n  assertAccountExists(account);\n  const decoded = decodeAccount(account, getSysvarRentDecoder());\n  return decoded.data;\n}\nfunction getSysvarSlotHashesEncoder() {\n  return getArrayEncoder(\n    getStructEncoder([\n      [\"slot\", getU64Encoder()],\n      [\"hash\", getBlockhashEncoder()]\n    ])\n  );\n}\nfunction getSysvarSlotHashesDecoder() {\n  return getArrayDecoder(\n    getStructDecoder([\n      [\"slot\", getU64Decoder()],\n      [\"hash\", getBlockhashDecoder()]\n    ])\n  );\n}\nfunction getSysvarSlotHashesCodec() {\n  return combineCodec(getSysvarSlotHashesEncoder(), getSysvarSlotHashesDecoder());\n}\nasync function fetchSysvarSlotHashes(rpc, config) {\n  const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_SLOT_HASHES_ADDRESS, config);\n  assertAccountExists(account);\n  const decoded = decodeAccount(account, getSysvarSlotHashesDecoder());\n  return decoded.data;\n}\nvar BITVEC_DISCRIMINATOR = 1;\nvar BITVEC_NUM_BITS = 1024 * 1024;\nvar BITVEC_LENGTH = BITVEC_NUM_BITS / 64;\nvar SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE = 1 + // Discriminator\n8 + // bitvector length (u64)\nBITVEC_LENGTH * 8 + 8 + // Number of bits (u64)\n8;\nvar memoizedU64Encoder;\nvar memoizedU64Decoder;\nvar memoizedU64ArrayEncoder;\nvar memoizedU64ArrayDecoder;\nfunction getMemoizedU64Encoder() {\n  if (!memoizedU64Encoder) memoizedU64Encoder = getU64Encoder();\n  return memoizedU64Encoder;\n}\nfunction getMemoizedU64Decoder() {\n  if (!memoizedU64Decoder) memoizedU64Decoder = getU64Decoder();\n  return memoizedU64Decoder;\n}\nfunction getMemoizedU64ArrayEncoder() {\n  if (!memoizedU64ArrayEncoder) memoizedU64ArrayEncoder = getArrayCodec(getU64Codec(), { size: BITVEC_LENGTH });\n  return memoizedU64ArrayEncoder;\n}\nfunction getMemoizedU64ArrayDecoder() {\n  if (!memoizedU64ArrayDecoder) memoizedU64ArrayDecoder = getArrayCodec(getU64Codec(), { size: BITVEC_LENGTH });\n  return memoizedU64ArrayDecoder;\n}\nfunction getSysvarSlotHistoryEncoder() {\n  return createEncoder({\n    fixedSize: SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE,\n    write: (value, bytes, offset) => {\n      bytes.set([BITVEC_DISCRIMINATOR], offset);\n      offset += 1;\n      getMemoizedU64Encoder().write(BigInt(BITVEC_LENGTH), bytes, offset);\n      offset += 8;\n      getMemoizedU64ArrayEncoder().write(value.bits, bytes, offset);\n      offset += BITVEC_LENGTH * 8;\n      getMemoizedU64Encoder().write(BigInt(BITVEC_NUM_BITS), bytes, offset);\n      offset += 8;\n      getMemoizedU64Encoder().write(value.nextSlot, bytes, offset);\n      offset += 8;\n      return offset;\n    }\n  });\n}\nfunction getSysvarSlotHistoryDecoder() {\n  return createDecoder({\n    fixedSize: SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE,\n    read: (bytes, offset) => {\n      if (bytes.length != SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n          actual: bytes.length,\n          expected: SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE\n        });\n      }\n      const discriminator = bytes[offset];\n      offset += 1;\n      if (discriminator !== BITVEC_DISCRIMINATOR) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n          actual: discriminator,\n          expected: BITVEC_DISCRIMINATOR\n        });\n      }\n      const bitVecLength = getMemoizedU64Decoder().read(bytes, offset)[0];\n      offset += 8;\n      if (bitVecLength !== BigInt(BITVEC_LENGTH)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n          actual: bitVecLength,\n          codecDescription: \"SysvarSlotHistoryCodec\",\n          expected: BITVEC_LENGTH\n        });\n      }\n      const bits = getMemoizedU64ArrayDecoder().read(bytes, offset)[0];\n      offset += BITVEC_LENGTH * 8;\n      const numBits = getMemoizedU64Decoder().read(bytes, offset)[0];\n      offset += 8;\n      if (numBits !== BigInt(BITVEC_NUM_BITS)) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n          actual: numBits,\n          codecDescription: \"SysvarSlotHistoryCodec\",\n          expected: BITVEC_NUM_BITS\n        });\n      }\n      const nextSlot = getMemoizedU64Decoder().read(bytes, offset)[0];\n      offset += 8;\n      return [\n        {\n          bits,\n          nextSlot\n        },\n        offset\n      ];\n    }\n  });\n}\nfunction getSysvarSlotHistoryCodec() {\n  return combineCodec(getSysvarSlotHistoryEncoder(), getSysvarSlotHistoryDecoder());\n}\nasync function fetchSysvarSlotHistory(rpc, config) {\n  const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_SLOT_HISTORY_ADDRESS, config);\n  assertAccountExists(account);\n  const decoded = decodeAccount(account, getSysvarSlotHistoryDecoder());\n  return decoded.data;\n}\nfunction getSysvarStakeHistoryEncoder() {\n  return getArrayEncoder(\n    getStructEncoder([\n      [\"epoch\", getU64Encoder()],\n      [\n        \"stakeHistory\",\n        getStructEncoder([\n          [\"effective\", getDefaultLamportsEncoder()],\n          [\"activating\", getDefaultLamportsEncoder()],\n          [\"deactivating\", getDefaultLamportsEncoder()]\n        ])\n      ]\n    ]),\n    { size: getU64Encoder() }\n  );\n}\nfunction getSysvarStakeHistoryDecoder() {\n  return getArrayDecoder(\n    getStructDecoder([\n      [\"epoch\", getU64Decoder()],\n      [\n        \"stakeHistory\",\n        getStructDecoder([\n          [\"effective\", getDefaultLamportsDecoder()],\n          [\"activating\", getDefaultLamportsDecoder()],\n          [\"deactivating\", getDefaultLamportsDecoder()]\n        ])\n      ]\n    ]),\n    { size: getU64Decoder() }\n  );\n}\nfunction getSysvarStakeHistoryCodec() {\n  return combineCodec(getSysvarStakeHistoryEncoder(), getSysvarStakeHistoryDecoder());\n}\nasync function fetchSysvarStakeHistory(rpc, config) {\n  const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_STAKE_HISTORY_ADDRESS, config);\n  assertAccountExists(account);\n  const decoded = decodeAccount(account, getSysvarStakeHistoryDecoder());\n  return decoded.data;\n}\n\nexport { SYSVAR_CLOCK_ADDRESS, SYSVAR_EPOCH_REWARDS_ADDRESS, SYSVAR_EPOCH_SCHEDULE_ADDRESS, SYSVAR_INSTRUCTIONS_ADDRESS, SYSVAR_LAST_RESTART_SLOT_ADDRESS, SYSVAR_RECENT_BLOCKHASHES_ADDRESS, SYSVAR_RENT_ADDRESS, SYSVAR_SLOT_HASHES_ADDRESS, SYSVAR_SLOT_HISTORY_ADDRESS, SYSVAR_STAKE_HISTORY_ADDRESS, fetchEncodedSysvarAccount, fetchJsonParsedSysvarAccount, fetchSysvarClock, fetchSysvarEpochRewards, fetchSysvarEpochSchedule, fetchSysvarLastRestartSlot, fetchSysvarRecentBlockhashes, fetchSysvarRent, fetchSysvarSlotHashes, fetchSysvarSlotHistory, fetchSysvarStakeHistory, getSysvarClockCodec, getSysvarClockDecoder, getSysvarClockEncoder, getSysvarEpochRewardsCodec, getSysvarEpochRewardsDecoder, getSysvarEpochRewardsEncoder, getSysvarEpochScheduleCodec, getSysvarEpochScheduleDecoder, getSysvarEpochScheduleEncoder, getSysvarLastRestartSlotCodec, getSysvarLastRestartSlotDecoder, getSysvarLastRestartSlotEncoder, getSysvarRecentBlockhashesCodec, getSysvarRecentBlockhashesDecoder, getSysvarRecentBlockhashesEncoder, getSysvarRentCodec, getSysvarRentDecoder, getSysvarRentEncoder, getSysvarSlotHashesCodec, getSysvarSlotHashesDecoder, getSysvarSlotHashesEncoder, getSysvarSlotHistoryCodec, getSysvarSlotHistoryDecoder, getSysvarSlotHistoryEncoder, getSysvarStakeHistoryCodec, getSysvarStakeHistoryDecoder, getSysvarStakeHistoryEncoder };\n//# sourceMappingURL=index.browser.mjs.map\n//# sourceMappingURL=index.browser.mjs.map","import {\n    type FetchAccountConfig,\n    fetchEncodedAccount,\n    fetchJsonParsedAccount,\n    type MaybeAccount,\n    type MaybeEncodedAccount,\n} from '@solana/accounts';\nimport type { Address } from '@solana/addresses';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { JsonParsedSysvarAccount } from '@solana/rpc-parsed-types';\nimport type { Rpc } from '@solana/rpc-spec';\n\nexport const SYSVAR_CLOCK_ADDRESS =\n    'SysvarC1ock11111111111111111111111111111111' as Address<'SysvarC1ock11111111111111111111111111111111'>;\nexport const SYSVAR_EPOCH_REWARDS_ADDRESS =\n    'SysvarEpochRewards1111111111111111111111111' as Address<'SysvarEpochRewards1111111111111111111111111'>;\nexport const SYSVAR_EPOCH_SCHEDULE_ADDRESS =\n    'SysvarEpochSchedu1e111111111111111111111111' as Address<'SysvarEpochSchedu1e111111111111111111111111'>;\nexport const SYSVAR_INSTRUCTIONS_ADDRESS =\n    'Sysvar1nstructions1111111111111111111111111' as Address<'Sysvar1nstructions1111111111111111111111111'>;\nexport const SYSVAR_LAST_RESTART_SLOT_ADDRESS =\n    'SysvarLastRestartS1ot1111111111111111111111' as Address<'SysvarLastRestartS1ot1111111111111111111111'>;\nexport const SYSVAR_RECENT_BLOCKHASHES_ADDRESS =\n    'SysvarRecentB1ockHashes11111111111111111111' as Address<'SysvarRecentB1ockHashes11111111111111111111'>;\nexport const SYSVAR_RENT_ADDRESS =\n    'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;\nexport const SYSVAR_SLOT_HASHES_ADDRESS =\n    'SysvarS1otHashes111111111111111111111111111' as Address<'SysvarS1otHashes111111111111111111111111111'>;\nexport const SYSVAR_SLOT_HISTORY_ADDRESS =\n    'SysvarS1otHistory11111111111111111111111111' as Address<'SysvarS1otHistory11111111111111111111111111'>;\nexport const SYSVAR_STAKE_HISTORY_ADDRESS =\n    'SysvarStakeHistory1111111111111111111111111' as Address<'SysvarStakeHistory1111111111111111111111111'>;\n\ntype SysvarAddress =\n    | typeof SYSVAR_CLOCK_ADDRESS\n    | typeof SYSVAR_EPOCH_REWARDS_ADDRESS\n    | typeof SYSVAR_EPOCH_SCHEDULE_ADDRESS\n    | typeof SYSVAR_INSTRUCTIONS_ADDRESS\n    | typeof SYSVAR_LAST_RESTART_SLOT_ADDRESS\n    | typeof SYSVAR_RECENT_BLOCKHASHES_ADDRESS\n    | typeof SYSVAR_RENT_ADDRESS\n    | typeof SYSVAR_SLOT_HASHES_ADDRESS\n    | typeof SYSVAR_SLOT_HISTORY_ADDRESS\n    | typeof SYSVAR_STAKE_HISTORY_ADDRESS;\n\n/**\n * Fetch an encoded sysvar account.\n *\n * Sysvars are special accounts that contain dynamically-updated data about the network cluster, the\n * blockchain history, and the executing transaction.\n */\nexport async function fetchEncodedSysvarAccount<TAddress extends SysvarAddress>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: TAddress,\n    config?: FetchAccountConfig,\n): Promise<MaybeEncodedAccount<TAddress>> {\n    return await fetchEncodedAccount<TAddress>(rpc, address, config);\n}\n\n/**\n * Fetch a JSON-parsed sysvar account.\n *\n * Sysvars are special accounts that contain dynamically-updated data about the network cluster, the\n * blockchain history, and the executing transaction.\n */\nexport async function fetchJsonParsedSysvarAccount<TAddress extends SysvarAddress>(\n    rpc: Rpc<GetAccountInfoApi>,\n    address: TAddress,\n    config?: FetchAccountConfig,\n): Promise<MaybeAccount<JsonParsedSysvarAccount, TAddress> | MaybeEncodedAccount<TAddress>> {\n    return await fetchJsonParsedAccount<JsonParsedSysvarAccount, TAddress>(rpc, address, config);\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getI64Decoder,\n    getI64Encoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Epoch, Slot, UnixTimestamp } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_CLOCK_ADDRESS } from './sysvar';\n\ntype SysvarClockSize = 40;\n\n/**\n * Contains data on cluster time, including the current slot, epoch, and estimated wall-clock Unix\n * timestamp. It is updated every slot.\n */\nexport type SysvarClock = Readonly<{\n    /** The current epoch */\n    epoch: Epoch;\n    /**\n     * The Unix timestamp of the first slot in this epoch.\n     *\n     * In the first slot of an epoch, this timestamp is identical to the `unixTimestamp`.\n     */\n    epochStartTimestamp: UnixTimestamp;\n    /** The most recent epoch for which the leader schedule has already been generated */\n    leaderScheduleEpoch: Epoch;\n    /** The current slot */\n    slot: Slot;\n    /** The Unix timestamp of this slot */\n    unixTimestamp: UnixTimestamp;\n}>;\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarClock} to a byte array representing\n * the `Clock` sysvar's account data.\n */\nexport function getSysvarClockEncoder(): FixedSizeEncoder<SysvarClock, SysvarClockSize> {\n    return getStructEncoder([\n        ['slot', getU64Encoder()],\n        ['epochStartTimestamp', getI64Encoder()],\n        ['epoch', getU64Encoder()],\n        ['leaderScheduleEpoch', getU64Encoder()],\n        ['unixTimestamp', getI64Encoder()],\n    ]) as FixedSizeEncoder<SysvarClock, SysvarClockSize>;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `Clock` sysvar's\n * account data to a {@link SysvarClock}.\n */\nexport function getSysvarClockDecoder(): FixedSizeDecoder<SysvarClock, SysvarClockSize> {\n    return getStructDecoder([\n        ['slot', getU64Decoder()],\n        ['epochStartTimestamp', getI64Decoder()],\n        ['epoch', getU64Decoder()],\n        ['leaderScheduleEpoch', getU64Decoder()],\n        ['unixTimestamp', getI64Decoder()],\n    ]) as FixedSizeDecoder<SysvarClock, SysvarClockSize>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarClock}\n *\n * @see {@link getSysvarClockDecoder}\n * @see {@link getSysvarClockEncoder}\n */\nexport function getSysvarClockCodec(): FixedSizeCodec<SysvarClock, SysvarClock, SysvarClockSize> {\n    return combineCodec(getSysvarClockEncoder(), getSysvarClockDecoder());\n}\n\n/**\n * Fetches the `Clock` sysvar account using any RPC that supports the {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarClock(rpc: Rpc<GetAccountInfoApi>, config?: FetchAccountConfig): Promise<SysvarClock> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_CLOCK_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarClockDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getBooleanDecoder,\n    getBooleanEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n    getU128Decoder,\n    getU128Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport {\n    Blockhash,\n    getBlockhashDecoder,\n    getBlockhashEncoder,\n    getDefaultLamportsDecoder,\n    getDefaultLamportsEncoder,\n    Lamports,\n} from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_EPOCH_REWARDS_ADDRESS } from './sysvar';\n\ntype SysvarEpochRewardsSize = 81;\n\n/**\n * Tracks whether the rewards period (including calculation and distribution) is in progress, as\n * well as the details needed to resume distribution when starting from a snapshot during the\n * rewards period.\n *\n * The sysvar is repopulated at the start of the first block of each epoch. Therefore, the sysvar\n * contains data about the current epoch until a new epoch begins.\n */\nexport type SysvarEpochRewards = Readonly<{\n    /** Whether the rewards period (including calculation and distribution) is active */\n    active: boolean;\n    /** The rewards currently distributed for the current epoch, in {@link Lamports} */\n    distributedRewards: Lamports;\n    /** The starting block height of the rewards distribution in the current epoch */\n    distributionStartingBlockHeight: bigint;\n    /**\n     * Number of partitions in the rewards distribution in the current epoch, used to generate an\n     * `EpochRewardsHasher`\n     */\n    numPartitions: bigint;\n    /**\n     * The {@link Blockhash} of the parent block of the first block in the epoch, used to seed an\n     * `EpochRewardsHasher`\n     */\n    parentBlockhash: Blockhash;\n    /**\n     * The total rewards points calculated for the current epoch, where points equals the sum of\n     * (delegated stake * credits observed) for all  delegations\n     */\n    totalPoints: bigint;\n    /** The total rewards for the current epoch, in {@link Lamports} */\n    totalRewards: Lamports;\n}>;\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarEpochRewards} to a byte array\n * representing the `EpochRewards` sysvar's account data.\n */\nexport function getSysvarEpochRewardsEncoder(): FixedSizeEncoder<SysvarEpochRewards, SysvarEpochRewardsSize> {\n    return getStructEncoder([\n        ['distributionStartingBlockHeight', getU64Encoder()],\n        ['numPartitions', getU64Encoder()],\n        ['parentBlockhash', getBlockhashEncoder()],\n        ['totalPoints', getU128Encoder()],\n        ['totalRewards', getDefaultLamportsEncoder()],\n        ['distributedRewards', getDefaultLamportsEncoder()],\n        ['active', getBooleanEncoder()],\n    ]) as FixedSizeEncoder<SysvarEpochRewards, SysvarEpochRewardsSize>;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `EpochRewards`\n * sysvar's account data to a {@link SysvarEpochRewards}.\n */\nexport function getSysvarEpochRewardsDecoder(): FixedSizeDecoder<SysvarEpochRewards, SysvarEpochRewardsSize> {\n    return getStructDecoder([\n        ['distributionStartingBlockHeight', getU64Decoder()],\n        ['numPartitions', getU64Decoder()],\n        ['parentBlockhash', getBlockhashDecoder()],\n        ['totalPoints', getU128Decoder()],\n        ['totalRewards', getDefaultLamportsDecoder()],\n        ['distributedRewards', getDefaultLamportsDecoder()],\n        ['active', getBooleanDecoder()],\n    ]) as FixedSizeDecoder<SysvarEpochRewards, SysvarEpochRewardsSize>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarEpochRewards}\n *\n * @see {@link getSysvarEpochRewardsDecoder}\n * @see {@link getSysvarEpochRewardsEncoder}\n */\nexport function getSysvarEpochRewardsCodec(): FixedSizeCodec<\n    SysvarEpochRewards,\n    SysvarEpochRewards,\n    SysvarEpochRewardsSize\n> {\n    return combineCodec(getSysvarEpochRewardsEncoder(), getSysvarEpochRewardsDecoder());\n}\n\n/**\n * Fetch the `EpochRewards` sysvar account using any RPC that supports the\n * {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarEpochRewards(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarEpochRewards> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_EPOCH_REWARDS_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarEpochRewardsDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getBooleanDecoder,\n    getBooleanEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Epoch, Slot } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_EPOCH_SCHEDULE_ADDRESS } from './sysvar';\n\ntype SysvarEpochScheduleSize = 33;\n\n/**\n * Includes the number of slots per epoch, timing of leader schedule selection, and information\n * about epoch warm-up time.\n */\nexport type SysvarEpochSchedule = Readonly<{\n    /**\n     * First normal-length epoch after the warmup period,\n     * log2(slotsPerEpoch) - log2(MINIMUM_SLOTS_PER_EPOCH)\n     */\n    firstNormalEpoch: Epoch;\n    /**\n     * The first slot after the warmup period, MINIMUM_SLOTS_PER_EPOCH * (2^(firstNormalEpoch) - 1)\n     */\n    firstNormalSlot: Slot;\n    /**\n     * A number of slots before beginning of an epoch to calculate a leader schedule for that\n     * epoch.\n     */\n    leaderScheduleSlotOffset: bigint;\n    /** The maximum number of slots in each epoch */\n    slotsPerEpoch: bigint;\n    /** Whether epochs start short and grow */\n    warmup: boolean;\n}>;\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarEpochSchedule} to a byte array\n * representing the `EpochSchedule` sysvar's account data.\n */\nexport function getSysvarEpochScheduleEncoder(): FixedSizeEncoder<SysvarEpochSchedule, SysvarEpochScheduleSize> {\n    return getStructEncoder([\n        ['slotsPerEpoch', getU64Encoder()],\n        ['leaderScheduleSlotOffset', getU64Encoder()],\n        ['warmup', getBooleanEncoder()],\n        ['firstNormalEpoch', getU64Encoder()],\n        ['firstNormalSlot', getU64Encoder()],\n    ]) as FixedSizeEncoder<SysvarEpochSchedule, SysvarEpochScheduleSize>;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `EpochSchedule`\n * sysvar's account data to a {@link SysvarEpochSchedule}.\n */\nexport function getSysvarEpochScheduleDecoder(): FixedSizeDecoder<SysvarEpochSchedule, SysvarEpochScheduleSize> {\n    return getStructDecoder([\n        ['slotsPerEpoch', getU64Decoder()],\n        ['leaderScheduleSlotOffset', getU64Decoder()],\n        ['warmup', getBooleanDecoder()],\n        ['firstNormalEpoch', getU64Decoder()],\n        ['firstNormalSlot', getU64Decoder()],\n    ]) as FixedSizeDecoder<SysvarEpochSchedule, SysvarEpochScheduleSize>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarEpochSchedule}\n *\n * @see {@link getSysvarEpochScheduleDecoder}\n * @see {@link getSysvarEpochScheduleEncoder}\n */\nexport function getSysvarEpochScheduleCodec(): FixedSizeCodec<\n    SysvarEpochSchedule,\n    SysvarEpochSchedule,\n    SysvarEpochScheduleSize\n> {\n    return combineCodec(getSysvarEpochScheduleEncoder(), getSysvarEpochScheduleDecoder());\n}\n\n/**\n * Fetches the `EpochSchedule` sysvar account using any RPC that supports the\n * {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarEpochSchedule(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarEpochSchedule> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_EPOCH_SCHEDULE_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarEpochScheduleDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Slot } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_LAST_RESTART_SLOT_ADDRESS } from './sysvar';\n\ntype SysvarLastRestartSlotSize = 8;\n\n/**\n * Information about the last restart slot (hard fork).\n *\n * The `LastRestartSlot` sysvar provides access to the last restart slot kept in the bank fork for\n * the slot on the fork that executes the current transaction. In case there was no fork it returns\n * `0`.\n */\nexport type SysvarLastRestartSlot = Readonly<{\n    /** The last restart {@link Slot} */\n    lastRestartSlot: Slot;\n}>;\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarLastRestartSlot} to a byte array\n * representing the `LastRestartSlot` sysvar's account data.\n */\nexport function getSysvarLastRestartSlotEncoder(): FixedSizeEncoder<SysvarLastRestartSlot, SysvarLastRestartSlotSize> {\n    return getStructEncoder([['lastRestartSlot', getU64Encoder()]]) as FixedSizeEncoder<\n        SysvarLastRestartSlot,\n        SysvarLastRestartSlotSize\n    >;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `LastRestartSlot`\n * sysvar's account data to a {@link SysvarLastRestartSlot}.\n */\nexport function getSysvarLastRestartSlotDecoder(): FixedSizeDecoder<SysvarLastRestartSlot, SysvarLastRestartSlotSize> {\n    return getStructDecoder([['lastRestartSlot', getU64Decoder()]]) as FixedSizeDecoder<\n        SysvarLastRestartSlot,\n        SysvarLastRestartSlotSize\n    >;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarLastRestartSlot}\n *\n * @see {@link getSysvarLastRestartSlotDecoder}\n * @see {@link getSysvarLastRestartSlotEncoder}\n */\nexport function getSysvarLastRestartSlotCodec(): FixedSizeCodec<\n    SysvarLastRestartSlot,\n    SysvarLastRestartSlot,\n    SysvarLastRestartSlotSize\n> {\n    return combineCodec(getSysvarLastRestartSlotEncoder(), getSysvarLastRestartSlotDecoder());\n}\n\n/**\n * Fetches the `LastRestartSlot` sysvar account using any RPC that supports the\n * {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarLastRestartSlot(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarLastRestartSlot> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_LAST_RESTART_SLOT_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarLastRestartSlotDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    getArrayDecoder,\n    getArrayEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport {\n    type Blockhash,\n    getBlockhashDecoder,\n    getBlockhashEncoder,\n    getDefaultLamportsDecoder,\n    getDefaultLamportsEncoder,\n    type Lamports,\n} from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_RECENT_BLOCKHASHES_ADDRESS } from './sysvar';\n\ntype FeeCalculator = Readonly<{\n    /**\n     * The current cost of a signature.\n     *\n     * This amount may increase/decrease over time based on cluster processing load\n     */\n    lamportsPerSignature: Lamports;\n}>;\ntype Entry = Readonly<{\n    blockhash: Blockhash;\n    feeCalculator: FeeCalculator;\n}>;\n\n/**\n * Information about recent blocks and their fee calculators.\n *\n * @deprecated Transaction fees should be determined with the\n * {@link GetFeeForMessageApi.getFeeForMessage} RPC method. For additional context see the\n * [Comprehensive Compute Fees proposal](https://docs.anza.xyz/proposals/comprehensive-compute-fees/).\n */\nexport type SysvarRecentBlockhashes = Entry[];\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarRecentBlockhashes} to a byte array\n * representing the `RecentBlockhashes` sysvar's account data.\n *\n * @deprecated Transaction fees should be determined with the\n * {@link GetFeeForMessageApi.getFeeForMessage} RPC method. For additional context see the\n * [Comprehensive Compute Fees proposal](https://docs.anza.xyz/proposals/comprehensive-compute-fees/).\n */\nexport function getSysvarRecentBlockhashesEncoder(): VariableSizeEncoder<SysvarRecentBlockhashes> {\n    return getArrayEncoder(\n        getStructEncoder([\n            ['blockhash', getBlockhashEncoder()],\n            ['feeCalculator', getStructEncoder([['lamportsPerSignature', getDefaultLamportsEncoder()]])],\n        ]),\n    );\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `RecentBlockhashes`\n * sysvar's account data to a {@link SysvarRecentBlockhashes}.\n *\n * @deprecated Transaction fees should be determined with the\n * {@link GetFeeForMessageApi.getFeeForMessage} RPC method. For additional context see the\n * [Comprehensive Compute Fees proposal](https://docs.anza.xyz/proposals/comprehensive-compute-fees/).\n */\nexport function getSysvarRecentBlockhashesDecoder(): VariableSizeDecoder<SysvarRecentBlockhashes> {\n    return getArrayDecoder(\n        getStructDecoder([\n            ['blockhash', getBlockhashDecoder()],\n            ['feeCalculator', getStructDecoder([['lamportsPerSignature', getDefaultLamportsDecoder()]])],\n        ]),\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarRecentBlockhashes}\n *\n * @deprecated Transaction fees should be determined with the\n * {@link GetFeeForMessageApi.getFeeForMessage} RPC method. For additional context see the\n * [Comprehensive Compute Fees proposal](https://docs.anza.xyz/proposals/comprehensive-compute-fees/).\n *\n * @see {@link getSysvarRecentBlockhashesDecoder}\n * @see {@link getSysvarRecentBlockhashesEncoder}\n */\nexport function getSysvarRecentBlockhashesCodec(): VariableSizeCodec<SysvarRecentBlockhashes> {\n    return combineCodec(getSysvarRecentBlockhashesEncoder(), getSysvarRecentBlockhashesDecoder());\n}\n\n/**\n * Fetches the `RecentBlockhashes` sysvar account using any RPC that supports the\n * {@link GetAccountInfoApi}.\n *\n * @deprecated Transaction fees should be determined with the\n * {@link GetFeeForMessageApi.getFeeForMessage} RPC method. For additional context see the\n * [Comprehensive Compute Fees proposal](https://docs.anza.xyz/proposals/comprehensive-compute-fees/).\n */\nexport async function fetchSysvarRecentBlockhashes(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarRecentBlockhashes> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_RECENT_BLOCKHASHES_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarRecentBlockhashesDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getF64Decoder,\n    getF64Encoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU8Decoder,\n    getU8Encoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport {\n    F64UnsafeSeeDocumentation,\n    getDefaultLamportsDecoder,\n    getDefaultLamportsEncoder,\n    type Lamports,\n} from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_RENT_ADDRESS } from './sysvar';\n\ntype SysvarRentSize = 17;\n\n/**\n * Configuration for network rent.\n */\nexport type SysvarRent = Readonly<{\n    /**\n     * The percentage of collected rent that is burned.\n     *\n     * Valid values are in the range [0, 100]. The remaining percentage is distributed to\n     * validators.\n     */\n    burnPercent: number;\n    /** Amount of time (in years) a balance must include rent for the account to be rent exempt */\n    exemptionThreshold: F64UnsafeSeeDocumentation;\n    /** Rental rate in {@link Lamports}/byte-year. */\n    lamportsPerByteYear: Lamports;\n}>;\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarRent} to a byte array representing\n * the `Rent` sysvar's account data.\n */\nexport function getSysvarRentEncoder(): FixedSizeEncoder<SysvarRent, SysvarRentSize> {\n    return getStructEncoder([\n        ['lamportsPerByteYear', getDefaultLamportsEncoder()],\n        ['exemptionThreshold', getF64Encoder()],\n        ['burnPercent', getU8Encoder()],\n    ]) as FixedSizeEncoder<SysvarRent, SysvarRentSize>;\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `Rent` sysvar's\n * account data to a {@link SysvarRent}.\n */\nexport function getSysvarRentDecoder(): FixedSizeDecoder<SysvarRent, SysvarRentSize> {\n    return getStructDecoder([\n        ['lamportsPerByteYear', getDefaultLamportsDecoder()],\n        ['exemptionThreshold', getF64Decoder()],\n        ['burnPercent', getU8Decoder()],\n    ]) as FixedSizeDecoder<SysvarRent, SysvarRentSize>;\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarRent}\n *\n * @see {@link getSysvarRentDecoder}\n * @see {@link getSysvarRentEncoder}\n */\nexport function getSysvarRentCodec(): FixedSizeCodec<SysvarRent, SysvarRent, SysvarRentSize> {\n    return combineCodec(getSysvarRentEncoder(), getSysvarRentDecoder());\n}\n\n/**\n * Fetches the `Rent` sysvar account using any RPC that supports the {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarRent(rpc: Rpc<GetAccountInfoApi>, config?: FetchAccountConfig): Promise<SysvarRent> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_RENT_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarRentDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    getArrayDecoder,\n    getArrayEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport { type Blockhash, getBlockhashDecoder, getBlockhashEncoder, type Slot } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_SLOT_HASHES_ADDRESS } from './sysvar';\n\ntype Entry = Readonly<{\n    hash: Blockhash;\n    slot: Slot;\n}>;\n\n/** The most recent hashes of a slot's parent banks. */\nexport type SysvarSlotHashes = Entry[];\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarSlotHashes} to a byte array\n * representing the `SlotHashes` sysvar's account data.\n */\nexport function getSysvarSlotHashesEncoder(): VariableSizeEncoder<SysvarSlotHashes> {\n    return getArrayEncoder(\n        getStructEncoder([\n            ['slot', getU64Encoder()],\n            ['hash', getBlockhashEncoder()],\n        ]),\n    );\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `SlotHashes` sysvar's\n * account data to a {@link SysvarSlotHashes}.\n */\nexport function getSysvarSlotHashesDecoder(): VariableSizeDecoder<SysvarSlotHashes> {\n    return getArrayDecoder(\n        getStructDecoder([\n            ['slot', getU64Decoder()],\n            ['hash', getBlockhashDecoder()],\n        ]),\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarSlotHashes}\n *\n * @see {@link getSysvarSlotHashesDecoder}\n * @see {@link getSysvarSlotHashesEncoder}\n */\nexport function getSysvarSlotHashesCodec(): VariableSizeCodec<SysvarSlotHashes> {\n    return combineCodec(getSysvarSlotHashesEncoder(), getSysvarSlotHashesDecoder());\n}\n\n/**\n * Fetches the `SlotHashes` sysvar account using any RPC that supports the {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarSlotHashes(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarSlotHashes> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_SLOT_HASHES_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarSlotHashesDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    createDecoder,\n    createEncoder,\n    type FixedSizeCodec,\n    type FixedSizeDecoder,\n    type FixedSizeEncoder,\n    getArrayCodec,\n    getU64Codec,\n    getU64Decoder,\n    getU64Encoder,\n    ReadonlyUint8Array,\n} from '@solana/codecs';\nimport {\n    SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE,\n    SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,\n    SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS,\n    SolanaError,\n} from '@solana/errors';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport type { Slot } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_SLOT_HISTORY_ADDRESS } from './sysvar';\n\nconst BITVEC_DISCRIMINATOR = 1;\n// Max number of bits in the bitvector.\n// The Solana SDK defines a constant `MAX_ENTRIES` representing the maximum\n// number of bits that can be represented by the bitvector in the `SlotHistory`\n// sysvar. This value is 1024 * 1024 = 1_048_576.\n// See https://github.com/anza-xyz/agave/blob/e0203f22dc83cb792fa97f91dbe6e924cbd08af1/sdk/program/src/slot_history.rs#L43\nconst BITVEC_NUM_BITS = 1024 * 1024;\n// The length of the bitvector in blocks.\n// At 64 bits per block, this is 1024 * 1024 / 64 = 16_384.\nconst BITVEC_LENGTH = BITVEC_NUM_BITS / 64;\n\nconst SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE =\n    1 + // Discriminator\n    8 + // bitvector length (u64)\n    BITVEC_LENGTH * 8 +\n    8 + // Number of bits (u64)\n    8; // Next slot (u64)\n\nlet memoizedU64Encoder: FixedSizeEncoder<bigint, 8> | undefined;\nlet memoizedU64Decoder: FixedSizeDecoder<bigint, 8> | undefined;\nlet memoizedU64ArrayEncoder: FixedSizeEncoder<bigint[]> | undefined;\nlet memoizedU64ArrayDecoder: FixedSizeDecoder<bigint[]> | undefined;\n\nfunction getMemoizedU64Encoder(): FixedSizeEncoder<bigint, 8> {\n    if (!memoizedU64Encoder) memoizedU64Encoder = getU64Encoder();\n    return memoizedU64Encoder;\n}\nfunction getMemoizedU64Decoder(): FixedSizeDecoder<bigint, 8> {\n    if (!memoizedU64Decoder) memoizedU64Decoder = getU64Decoder();\n    return memoizedU64Decoder;\n}\nfunction getMemoizedU64ArrayEncoder(): FixedSizeEncoder<bigint[], typeof BITVEC_LENGTH> {\n    if (!memoizedU64ArrayEncoder) memoizedU64ArrayEncoder = getArrayCodec(getU64Codec(), { size: BITVEC_LENGTH });\n    return memoizedU64ArrayEncoder;\n}\nfunction getMemoizedU64ArrayDecoder(): FixedSizeDecoder<bigint[], typeof BITVEC_LENGTH> {\n    if (!memoizedU64ArrayDecoder) memoizedU64ArrayDecoder = getArrayCodec(getU64Codec(), { size: BITVEC_LENGTH });\n    return memoizedU64ArrayDecoder;\n}\n\ntype SysvarSlotHistorySize = typeof SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE;\n\n/** A bitvector of slots present over the last epoch. */\nexport type SysvarSlotHistory = {\n    /**\n     * A vector of 64-bit numbers which, when their bits are strung together, represent a record of\n     * non-skipped slots.\n     *\n     * The bit in position (slot % MAX_ENTRIES) is 0 if the slot was skipped and 1 otherwise, valid\n     * only when the candidate slot is less than `nextSlot` and greater than or equal to\n     * `MAX_ENTRIES - nextSlot`.\n     */\n    bits: bigint[];\n    /** The number of the slot one newer than tracked by the bitvector */\n    nextSlot: Slot;\n};\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarSlotHistory} to a byte array\n * representing the `SlotHistory` sysvar's account data.\n */\nexport function getSysvarSlotHistoryEncoder(): FixedSizeEncoder<SysvarSlotHistory, SysvarSlotHistorySize> {\n    return createEncoder({\n        fixedSize: SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE,\n        write: (value: SysvarSlotHistory, bytes, offset) => {\n            // First byte is the bitvector discriminator.\n            bytes.set([BITVEC_DISCRIMINATOR], offset);\n            offset += 1;\n            // Next 8 bytes are the bitvector length.\n            getMemoizedU64Encoder().write(BigInt(BITVEC_LENGTH), bytes, offset);\n            offset += 8;\n            // Next `BITVEC_LENGTH` bytes are the bitvector.\n            // Any missing bits are assumed to be 0.\n            getMemoizedU64ArrayEncoder().write(value.bits, bytes, offset);\n            offset += BITVEC_LENGTH * 8;\n            // Next 8 bytes are the number of bits.\n            getMemoizedU64Encoder().write(BigInt(BITVEC_NUM_BITS), bytes, offset);\n            offset += 8;\n            // Next 8 bytes are the next slot.\n            getMemoizedU64Encoder().write(value.nextSlot, bytes, offset);\n            offset += 8;\n            return offset;\n        },\n    });\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `SlotHistory` sysvar's\n * account data to a {@link SysvarSlotHistory}.\n */\nexport function getSysvarSlotHistoryDecoder(): FixedSizeDecoder<SysvarSlotHistory, SysvarSlotHistorySize> {\n    return createDecoder({\n        fixedSize: SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE,\n        read: (bytes: ReadonlyUint8Array | Uint8Array, offset) => {\n            // Byte length should be exact.\n            if (bytes.length != SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n                    actual: bytes.length,\n                    expected: SLOT_HISTORY_ACCOUNT_DATA_STATIC_SIZE,\n                });\n            }\n            // First byte is the bitvector discriminator.\n            const discriminator = bytes[offset];\n            offset += 1;\n            if (discriminator !== BITVEC_DISCRIMINATOR) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE, {\n                    actual: discriminator,\n                    expected: BITVEC_DISCRIMINATOR,\n                });\n            }\n            // Next 8 bytes are the bitvector length.\n            const bitVecLength = getMemoizedU64Decoder().read(bytes, offset)[0];\n            offset += 8;\n            if (bitVecLength !== BigInt(BITVEC_LENGTH)) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n                    actual: bitVecLength,\n                    codecDescription: 'SysvarSlotHistoryCodec',\n                    expected: BITVEC_LENGTH,\n                });\n            }\n            // Next `BITVEC_LENGTH` bytes are the bitvector.\n            const bits = getMemoizedU64ArrayDecoder().read(bytes, offset)[0];\n            offset += BITVEC_LENGTH * 8;\n            // Next 8 bytes are the number of bits.\n            const numBits = getMemoizedU64Decoder().read(bytes, offset)[0];\n            offset += 8;\n            if (numBits !== BigInt(BITVEC_NUM_BITS)) {\n                throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS, {\n                    actual: numBits,\n                    codecDescription: 'SysvarSlotHistoryCodec',\n                    expected: BITVEC_NUM_BITS,\n                });\n            }\n            // Next 8 bytes are the next slot.\n            const nextSlot = getMemoizedU64Decoder().read(bytes, offset)[0];\n            offset += 8;\n            return [\n                {\n                    bits,\n                    nextSlot,\n                },\n                offset,\n            ];\n        },\n    });\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarSlotHistory}\n *\n * @see {@link getSysvarSlotHistoryDecoder}\n * @see {@link getSysvarSlotHistoryEncoder}\n */\nexport function getSysvarSlotHistoryCodec(): FixedSizeCodec<\n    SysvarSlotHistory,\n    SysvarSlotHistory,\n    SysvarSlotHistorySize\n> {\n    return combineCodec(getSysvarSlotHistoryEncoder(), getSysvarSlotHistoryDecoder());\n}\n\n/**\n * Fetches the `SlotHistory` sysvar account using any RPC that supports the\n * {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarSlotHistory(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarSlotHistory> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_SLOT_HISTORY_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarSlotHistoryDecoder());\n    return decoded.data;\n}\n","import { assertAccountExists, decodeAccount, type FetchAccountConfig } from '@solana/accounts';\nimport {\n    combineCodec,\n    getArrayDecoder,\n    getArrayEncoder,\n    getStructDecoder,\n    getStructEncoder,\n    getU64Decoder,\n    getU64Encoder,\n    type VariableSizeCodec,\n    type VariableSizeDecoder,\n    type VariableSizeEncoder,\n} from '@solana/codecs';\nimport type { GetAccountInfoApi } from '@solana/rpc-api';\nimport type { Rpc } from '@solana/rpc-spec';\nimport { Epoch, getDefaultLamportsDecoder, getDefaultLamportsEncoder, type Lamports } from '@solana/rpc-types';\n\nimport { fetchEncodedSysvarAccount, SYSVAR_STAKE_HISTORY_ADDRESS } from './sysvar';\n\ntype Entry = Readonly<{\n    /** The epoch to which this stake history entry pertains */\n    epoch: Epoch;\n    stakeHistory: Readonly<{\n        /**\n         * Sum of portion of stakes requested to be warmed up, but not fully activated yet, in\n         * {@link Lamports}\n         */\n        activating: Lamports;\n        /**\n         * Sum of portion of stakes requested to be cooled down, but not fully deactivated yet, in\n         * {@link Lamports}\n         */\n        deactivating: Lamports;\n        /** Effective stake at this epoch, in {@link Lamports} */\n        effective: Lamports;\n    }>;\n}>;\n\n/** History of stake activations and de-activations. */\nexport type SysvarStakeHistory = Entry[];\n\n/**\n * Returns an encoder that you can use to encode a {@link SysvarStakeHistory} to a byte array\n * representing the `StakeHistory` sysvar's account data.\n */\nexport function getSysvarStakeHistoryEncoder(): VariableSizeEncoder<SysvarStakeHistory> {\n    return getArrayEncoder(\n        getStructEncoder([\n            ['epoch', getU64Encoder()],\n            [\n                'stakeHistory',\n                getStructEncoder([\n                    ['effective', getDefaultLamportsEncoder()],\n                    ['activating', getDefaultLamportsEncoder()],\n                    ['deactivating', getDefaultLamportsEncoder()],\n                ]),\n            ],\n        ]),\n        { size: getU64Encoder() },\n    );\n}\n\n/**\n * Returns a decoder that you can use to decode a byte array representing the `StakeHistory`\n * sysvar's account data to a {@link SysvarStakeHistory}.\n */\nexport function getSysvarStakeHistoryDecoder(): VariableSizeDecoder<SysvarStakeHistory> {\n    return getArrayDecoder(\n        getStructDecoder([\n            ['epoch', getU64Decoder()],\n            [\n                'stakeHistory',\n                getStructDecoder([\n                    ['effective', getDefaultLamportsDecoder()],\n                    ['activating', getDefaultLamportsDecoder()],\n                    ['deactivating', getDefaultLamportsDecoder()],\n                ]),\n            ],\n        ]),\n        { size: getU64Decoder() },\n    );\n}\n\n/**\n * Returns a codec that you can use to encode from or decode to {@link SysvarStakeHistory}\n *\n * @see {@link getSysvarStakeHistoryDecoder}\n * @see {@link getSysvarStakeHistoryEncoder}\n */\nexport function getSysvarStakeHistoryCodec(): VariableSizeCodec<SysvarStakeHistory> {\n    return combineCodec(getSysvarStakeHistoryEncoder(), getSysvarStakeHistoryDecoder());\n}\n\n/**\n * Fetches the `StakeHistory` sysvar account using any RPC that supports the\n * {@link GetAccountInfoApi}.\n */\nexport async function fetchSysvarStakeHistory(\n    rpc: Rpc<GetAccountInfoApi>,\n    config?: FetchAccountConfig,\n): Promise<SysvarStakeHistory> {\n    const account = await fetchEncodedSysvarAccount(rpc, SYSVAR_STAKE_HISTORY_ADDRESS, config);\n    assertAccountExists(account);\n    const decoded = decodeAccount(account, getSysvarStakeHistoryDecoder());\n    return decoded.data;\n}\n"],"names":["$0bb11e8e9f3a1c4e$var$encodeObjectContextEntry","key","value","$0bb11e8e9f3a1c4e$var$encodeValue","Array","isArray","map","join","encodeURIComponent","String","Object","getPrototypeOf","$fadd3f4c7539d2fa$var$memoizedBase58Encoder","$fadd3f4c7539d2fa$var$memoizedBase58Decoder","Endian2","AccountRole2","AccountState2","AuthorityType2","ExtensionType2","AssociatedTokenInstruction2","Token2022Account2","Token2022Instruction2","$0bb11e8e9f3a1c4e$export$8349fd9adaaed269","Error","cause","context","code","contextAndErrorOptions","errorOptions","entries","getOwnPropertyDescriptors","forEach","name","descriptor","defineProperty","$0bb11e8e9f3a1c4e$var$getErrorMessage","decodingAdviceMessage","keys","length","btoa","__code","$b9bc3aaa401ff82b$export$4e76eeb6df88c889","encoder","freeze","encode","bytes","Uint8Array","fixedSize","getSizeFromValue","write","$b9bc3aaa401ff82b$export$f8c898e83b60faaa","decoder","decode","offset","read","$b9bc3aaa401ff82b$export$f9d60229c95384d4","codec","$b5f941eb9a28d328$export$54493dce0da47833","$278ae65923ee60f5$var$partitionLeadingZeroes","zeroCharacter","leadingZeros","tailChars","split","RegExp","$278ae65923ee60f5$var$getBigIntFromBaseX","alphabet4","base","BigInt","sum","char","indexOf","$278ae65923ee60f5$var$alphabet2","$fadd3f4c7539d2fa$var$getMemoizedBase58Encoder","leadingZeroes","base10Number","Math","ceil","toString","$278ae65923ee60f5$export$d81fb78fd5af226e","testValue","givenValue","match","alphabet","set","fill","tailBytes","unshift","Number","bytesToAdd","$fadd3f4c7539d2fa$export$f7d3c097ceca6c15","putativeAddress","actualLength","numBytes","base58Encoder","byteLength","$fadd3f4c7539d2fa$export$796121a945d5c29b","variableByteArray","fixedByteArray","slice","unmap","$b9bc3aaa401ff82b$export$d76fd0b6e42f051a","$fadd3f4c7539d2fa$var$mod","a","r","$fadd3f4c7539d2fa$var$P","$fadd3f4c7539d2fa$var$pow2","x","power","$fadd3f4c7539d2fa$var$PDA_MARKER_BYTES","$fadd3f4c7539d2fa$var$createProgramDerivedAddress","programAddress","seeds","textEncoder","globalThis","isSecureContext","crypto","subtle","digest","actual","maxSeeds","seedBytes","reduce","acc","seed","ii","TextEncoder","index","maxSeedLength","push","base58EncodedAddressCodec","$fadd3f4c7539d2fa$export$872beb68e6a83b96","rawBytes","trailIndex","findIndex","n","repeat","$278ae65923ee60f5$var$getBaseXFromBigInt","byte","$b9bc3aaa401ff82b$export$4a981e7c9ed0b6bf","codecDescription","expected","bytesLength","$b9bc3aaa401ff82b$export$4c6b868113605df3","paddedBytes","decoderFixedSize","encoderFixedSize","maxSize","decoderMaxSize","encoderMaxSize","programAddressBytes","addressBytesBuffer","addressBytes","$fadd3f4c7539d2fa$var$pointIsOnCurve","y","lastByte","y2","$fadd3f4c7539d2fa$var$uvRatio","u","v","v3","pow","$fadd3f4c7539d2fa$var$pow_2_252_3","b2","x2","b4","b5","b10","b20","b40","b80","b160","b240","b250","vx2","root1","root2","useRoot1","useRoot2","noRoot","$fadd3f4c7539d2fa$var$D","$fadd3f4c7539d2fa$var$decompressPointBytes","hexString","$fadd3f4c7539d2fa$var$byteToHex","$fadd3f4c7539d2fa$export$4e565ad19ba445b","bumpSeed","e","$bc6d449c2ea12356$export$ee58f0c89e8fce3b","Symbol","$c5679bb0a1fb1418$export$70504fba2ce56d52","$c5679bb0a1fb1418$export$cd82032b224a3839","$c5679bb0a1fb1418$export$4f037c6ec2da4eeb","$c5679bb0a1fb1418$export$694c519e7c5de7e7","$c5679bb0a1fb1418$export$b8ef38820c59ed7a","$c5679bb0a1fb1418$export$3559bd77d1c508e9","$c5679bb0a1fb1418$export$261fb6f487940719","config","owner","tokenProgram","mint","document","addEventListener","ownerAddressInput","getElementById","mintIdInput","resultsDiv","errorDiv","tokenAtaDiv","token2022AtaDiv","container","querySelector","console","log","updateResults","ownerAddress","trim","mintId","style","display","classList","add","result","$b4e14b6b8da86996$var$computeAllAta","associatedTokenAddress","status","textContent","reason","associatedTokenAddress2022","error","message","remove","Promise","allSettled","$b4e14b6b8da86996$var$TOKEN_PROGRAM_ID","$b4e14b6b8da86996$var$TOKEN_2022_PROGRAM_ID","AccountState","AuthorityType","getEnumEncoder","getEnumDecoder","combineCodec","fixEncoderSize","getBytesEncoder","fixDecoderSize","getBytesDecoder","ExtensionType","getU16Encoder","getU16Decoder","getDiscriminatedUnionEncoder","getUnitEncoder","getStructEncoder","addEncoderSizePrefix","getUtf8Encoder","getU32Encoder","getDiscriminatedUnionDecoder","getUnitDecoder","getStructDecoder","addDecoderSizePrefix","getUtf8Decoder","getU32Decoder","getU64Encoder","getU64Decoder","getOptionEncoder","getAddressEncoder","getBooleanEncoder","getOptionDecoder","getAddressDecoder","getBooleanDecoder","getU8Encoder","getArrayEncoder","getU8Decoder","getArrayDecoder","decodeAccount","assertAccountExists","fetchEncodedAccount","assertAccountsExist","fetchEncodedAccounts","getHiddenPrefixEncoder","getConstantEncoder","getHiddenPrefixDecoder","getConstantDecoder","AssociatedTokenInstruction","Token2022Account","Token2022Instruction","containsBytes","isProgramError","kitIsTransactionSigner","transformEncoder","AccountRole","getI8Encoder","getI8Decoder","getI16Encoder","getI16Decoder","none","getF64Encoder","getF64Decoder","extension","padLeftEncoder","newOffset","createEncoder","createDecoder","SolanaError","getEncodedSize","isFixedSize","transformDecoder","isSolanaError","ORDERED_ERROR_NAMES","Endian","address","SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE","TextDecoder","SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING","transaction","signature","privateKey","SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT","getShortU16Encoder","getShortU16Decoder","getAddressComparator","isWritableRole","isSignerRole","getBlockhashEncoder","getDefaultLamportsEncoder","getBlockhashDecoder","getDefaultLamportsDecoder"],"version":3,"file":"index.16e179e5.js.map"}